import { GraphQLClient, RequestOptions } from 'graphql-request';
import gql from 'graphql-tag';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
type GraphQLClientRequestHeaders = RequestOptions['requestHeaders'];
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  Date: { input: Date; output: Date; }
  DateTime: { input: Date; output: Date; }
  JsonNode: { input: unknown; output: unknown; }
  Time: { input: Date; output: Date; }
  URL: { input: string; output: string; }
  UUID: { input: string; output: string; }
};

export type AsapMessage = {
  __typename?: 'ASAPMessage';
  /** Тип объявления */
  adtType: AsapWidgetTypeEnum;
  /** Id виджета */
  adtWidgetId?: Maybe<Scalars['Int']['output']>;
  /** Дата завершения показа */
  finishDate: Scalars['DateTime']['output'];
  /** Url картинки объявления */
  fullImageUrl?: Maybe<Scalars['String']['output']>;
  /** Текст объявления */
  fullText?: Maybe<Scalars['String']['output']>;
  /** Полный заголовок объявления */
  fullTitle?: Maybe<Scalars['String']['output']>;
  /** Флаг закрепленного объявления */
  pinned: Scalars['Boolean']['output'];
  /** Флаг отображения даты на виджете */
  showFinishDate: Scalars['Boolean']['output'];
  /** Маленькое изображение */
  smallImageUrl?: Maybe<Scalars['String']['output']>;
  /** Короткое название объявления */
  smallTitle: Scalars['String']['output'];
  /** Ссылка на маленькое объявление */
  smallUrl?: Maybe<Scalars['String']['output']>;
  /** Дата начала показа */
  startDate: Scalars['DateTime']['output'];
};

export type AsapMutations = {
  __typename?: 'ASAPMutations';
  /** Создание виджета ASAP */
  createASAPWidget: AsapWidgetDetails;
  /** Редактирование виджета ASAP */
  deleteASAPWidget: Scalars['Boolean']['output'];
  /** Редактирование виджета ASAP */
  updateASAPWidget: AsapWidgetDetails;
};


export type AsapMutationsCreateAsapWidgetArgs = {
  input: AsapWidgetDetailsInput;
};


export type AsapMutationsDeleteAsapWidgetArgs = {
  widgetId?: InputMaybe<Scalars['ID']['input']>;
};


export type AsapMutationsUpdateAsapWidgetArgs = {
  input: AsapWidgetDetailsInput;
  widgetId?: InputMaybe<Scalars['ID']['input']>;
};

export type AsapQueries = {
  __typename?: 'ASAPQueries';
  /** Ш21. Поиск опубликованных виджетов ASAP по фильтру */
  findASAPWidgetsByFilter: Array<AsapWidgetDetails>;
  findASAPWidgetsByFilterCount: Scalars['Int']['output'];
  /** Ш21. Получение ASAP уведомлений, релевантных для пользователя */
  getASAPMessages: Array<AsapMessage>;
  /** Ш21. Получение виджета ASAP по ID */
  getASAPWidgetById: AsapWidgetDetails;
  /** Ш21. Фоновые изображения ASAP-виджетов */
  getASAPWidgetImages: Array<AsapWidgetImage>;
};


export type AsapQueriesFindAsapWidgetsByFilterArgs = {
  finishDate?: InputMaybe<Scalars['DateTime']['input']>;
  page: PagingInput;
  schoolIds?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  searchString?: InputMaybe<Scalars['String']['input']>;
  sorting?: InputMaybe<Array<InputMaybe<SortingField>>>;
  stageIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  stageSubjectGroupsIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  startDate?: InputMaybe<Scalars['DateTime']['input']>;
};


export type AsapQueriesFindAsapWidgetsByFilterCountArgs = {
  finishDate?: InputMaybe<Scalars['DateTime']['input']>;
  schoolIds?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  searchString?: InputMaybe<Scalars['String']['input']>;
  stageIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  stageSubjectGroupsIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  startDate?: InputMaybe<Scalars['DateTime']['input']>;
};


export type AsapQueriesGetAsapWidgetByIdArgs = {
  widgetId: Scalars['ID']['input'];
};


export type AsapQueriesGetAsapWidgetImagesArgs = {
  imageTypes?: InputMaybe<Array<InputMaybe<AsapWidgetImageTypeEnum>>>;
};

/** создание и редактирование Виджета ASAP */
export type AsapWidgetDetails = {
  __typename?: 'ASAPWidgetDetails';
  /** Тип объявления */
  adtType: AsapWidgetTypeEnum;
  /** Id виджета */
  adtWidgetId?: Maybe<Scalars['Int']['output']>;
  /** Автор объявления */
  createdBy?: Maybe<Scalars['String']['output']>;
  /** Дата создания объявления */
  createdTs?: Maybe<Scalars['DateTime']['output']>;
  /** Признак доступности для редактирования текущим пользователем */
  editable?: Maybe<Scalars['Boolean']['output']>;
  /** Дата завершения показа */
  finishDate: Scalars['DateTime']['output'];
  /** Url картинки объявления */
  fullImageId?: Maybe<Scalars['Int']['output']>;
  /** Текст объявления */
  fullText?: Maybe<Scalars['String']['output']>;
  /** Полный заголовок объявления */
  fullTitle?: Maybe<Scalars['String']['output']>;
  /** Флаг закрепленного объявления */
  pinned: Scalars['Boolean']['output'];
  /** Список связанных кампусов */
  schoolIds: Array<Scalars['UUID']['output']>;
  /** Список связанных кампусов */
  schools?: Maybe<Array<Maybe<School>>>;
  /** Флаг отображения даты на виджете */
  showFinishDate: Scalars['Boolean']['output'];
  /** Маленькое изображение */
  smallImageId?: Maybe<Scalars['Int']['output']>;
  /** Короткое название объявления */
  smallTitle: Scalars['String']['output'];
  /** Ссылка на маленькое объявление */
  smallUrl?: Maybe<Scalars['String']['output']>;
  /** Список связанных параллелей */
  stageIds: Array<Scalars['Int']['output']>;
  /** Список связанных групп по предмету */
  stageSubjectGroupIds: Array<Scalars['Int']['output']>;
  /** Список связанных групп по предмету */
  stageSubjectGroups?: Maybe<Array<Maybe<StageSubjectGroup>>>;
  /** Список связанных параллелей */
  stages?: Maybe<Array<Maybe<Stage>>>;
  /** Дата начала показа */
  startDate: Scalars['DateTime']['output'];
  /** Дата последнего изменения */
  tenantId: Scalars['UUID']['output'];
  /** Автор последнего изменения */
  updatedBy?: Maybe<Scalars['String']['output']>;
  /** Дата последнего изменения */
  updatedTs?: Maybe<Scalars['DateTime']['output']>;
  /** Изображение для виджета ASAP */
  widgetImages?: Maybe<Array<Maybe<AsapWidgetImage>>>;
};

/** создание и редактирование Виджета ASAP */
export type AsapWidgetDetailsInput = {
  /** Тип объявления */
  adtType: AsapWidgetTypeEnum;
  /** Дата завершения показа */
  finishDate: Scalars['DateTime']['input'];
  /** Url картинки объявления */
  fullImageId?: InputMaybe<Scalars['Int']['input']>;
  /** Текст объявления */
  fullText?: InputMaybe<Scalars['String']['input']>;
  /** Полный заголовок объявления */
  fullTitle?: InputMaybe<Scalars['String']['input']>;
  /** Флаг закрепленного объявления */
  pinned: Scalars['Boolean']['input'];
  /** Список связанных кампусов */
  schoolIds: Array<Scalars['UUID']['input']>;
  /** Флаг отображения даты на виджете */
  showFinishDate: Scalars['Boolean']['input'];
  /** Маленькое изображение */
  smallImageId?: InputMaybe<Scalars['Int']['input']>;
  /** Короткое название объявления */
  smallTitle: Scalars['String']['input'];
  /** Ссылка на маленькое объявление */
  smallUrl?: InputMaybe<Scalars['String']['input']>;
  /** Список связанных параллелей */
  stageIds: Array<Scalars['Int']['input']>;
  /** Список связанных групп по предмету */
  stageSubjectGroupIds: Array<Scalars['Int']['input']>;
  /** Дата начала показа */
  startDate: Scalars['DateTime']['input'];
};

export type AsapWidgetImage = {
  __typename?: 'ASAPWidgetImage';
  /** Id фонового изображения */
  adtWidgetImageId: Scalars['Int']['output'];
  /** Название */
  alias?: Maybe<Scalars['String']['output']>;
  /** Тип */
  imageType: AsapWidgetImageTypeEnum;
  /** URL */
  url: Scalars['String']['output'];
};

/** Типы изображений */
export enum AsapWidgetImageTypeEnum {
  Big = 'BIG',
  Small = 'SMALL'
}

/** Типы объявлений */
export enum AsapWidgetTypeEnum {
  /** Переход по ссылке */
  Link = 'LINK',
  /** Объявление с изображением */
  PopupImg = 'POPUP_IMG',
  /** Объявление без изображения */
  PopupTxt = 'POPUP_TXT'
}

/** Значение характеристик: Урон, Здоровье и т.д. */
export type AbilityPower = {
  __typename?: 'AbilityPower';
  /** user_ability_id || equipment_ability__id */
  id: Scalars['ID']['output'];
  /** Относительная ссылка на изображение в файловый сервис */
  imageUrl: Scalars['String']['output'];
  /** Наименование хар-ки */
  name: Scalars['String']['output'];
  /** Значение */
  power: Scalars['Int']['output'];
};

export type AcademicYear = {
  __typename?: 'AcademicYear';
  endDate: Scalars['Date']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  startDate: Scalars['Date']['output'];
};

/** Информация о Предметах на данный Учебный Год */
export type AcademicYearSubjects = {
  __typename?: 'AcademicYearSubjects';
  /** Учебный Год */
  academicYear: AcademicYear;
  /** Предметы на данный Учебный Год */
  subjects: Array<Subject>;
};

/** Сообщение GigaChat, отправленное пользователем или полученное в ответ */
export type AccGigaChatMessageInput = {
  /** текст сообщения */
  content: Scalars['String']['input'];
  role?: InputMaybe<GigaChatRoleEnum>;
};

/** Ответ GigaChat */
export type AccGigaChatResponse = {
  __typename?: 'AccGigaChatResponse';
  /** текст ответа */
  content: Scalars['String']['output'];
  /** приложенное изображение (если запрос содержал "нарисуй...") в формате jpeg, закодированное base64, необязательное поле */
  imgData?: Maybe<Scalars['String']['output']>;
};

export type AccNote = {
  __typename?: 'AccNote';
  /** Признак завершен ли пункт */
  completed: Scalars['Boolean']['output'];
  /** Время создания заметки */
  createTime: Scalars['DateTime']['output'];
  /** Идентификатор заметки */
  noteId: Scalars['ID']['output'];
  /** Время планирования заметки */
  scheduledTime: Scalars['DateTime']['output'];
  /** Текст заметки */
  text: Scalars['String']['output'];
  /** Время обновления заметки */
  updateTime: Scalars['DateTime']['output'];
  /** Идентификатор пользователя которому принадлежит заметка */
  userId: Scalars['UUID']['output'];
};

export type AccNoteInput = {
  /** Признак завершен ли пункт */
  completed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Идентификатор заметки */
  noteId?: InputMaybe<Scalars['ID']['input']>;
  /** Время планирования заметки */
  scheduledTime?: InputMaybe<Scalars['DateTime']['input']>;
  /** Текст заметки */
  text?: InputMaybe<Scalars['String']['input']>;
  /** Идентификатор пользователя которому принадлежит заметка */
  userId: Scalars['UUID']['input'];
};

export type AccOnlineCalendarEvent = {
  __typename?: 'AccOnlineCalendarEvent';
  /** ШЦП календарь ивент */
  onlineCalendarEvent: OnlineCalendarEvent;
  /** Проектный поток */
  projectFlowId?: Maybe<Scalars['UUID']['output']>;
};

export type AccOnlineCalendarEventInput = {
  /** ШЦП календарь ивент */
  calendarEventInput: CalendarEventInput;
  /** Признак необходимости выгрузить для пользовательского календаря событие */
  exportICalendar?: InputMaybe<Scalars['Boolean']['input']>;
  /** Идентификатор пользовательной группы организатора события */
  organizerGroupId?: InputMaybe<Scalars['UUID']['input']>;
  /** Проектный поток */
  projectFlowId?: InputMaybe<Scalars['UUID']['input']>;
};

export type AccUserInfoModel = {
  __typename?: 'AccUserInfoModel';
  isCapitan: Scalars['Boolean']['output'];
  isOldStageGroup: Scalars['Boolean']['output'];
  projectId?: Maybe<Scalars['UUID']['output']>;
  resumeId?: Maybe<Scalars['UUID']['output']>;
  stageGroupId: Scalars['Int']['output'];
  stageGroupName: Scalars['String']['output'];
  teamId?: Maybe<Scalars['UUID']['output']>;
  userType?: Maybe<Scalars['String']['output']>;
};

export type AcceleratorJoinCheckResult = {
  __typename?: 'AcceleratorJoinCheckResult';
  isJoined: Scalars['Boolean']['output'];
  userTypeId: AcceleratorUserType;
};

/** Статус участника акселератора */
export enum AcceleratorMemberStatus {
  Individual = 'INDIVIDUAL',
  Loser = 'LOSER',
  Winner = 'WINNER'
}

/** Метрика Акселератора */
export enum AcceleratorMetric {
  Csat = 'CSAT',
  Nps = 'NPS'
}

/** Этапы Акселератора */
export enum AcceleratorMilestone {
  First = 'FIRST',
  Fourth = 'FOURTH',
  Second = 'SECOND',
  Third = 'THIRD'
}

export type AcceleratorMutations = {
  __typename?: 'AcceleratorMutations';
  /** Принять приглашение пользователем */
  acceptTeamInvite: Scalars['String']['output'];
  /** добавление нотификацию в очеред для отправки */
  addNotificationItemToQueue: Scalars['String']['output'];
  addOrUpdateAccNotes?: Maybe<Scalars['Int']['output']>;
  addStudentToSecondAcceleratorSchool: Scalars['String']['output'];
  /**
   * Внутренняя регистрация
   * Добавление пользователя в студенческий акселератор с ролью 'Ученик акселератора'
   * @deprecated Неактуально, используйте joinToAccelerator
   */
  addUserToAcceleratorAsLearner: Scalars['Boolean']['output'];
  /** Утверждение заявки */
  approveRequests: Scalars['String']['output'];
  /**
   * Блокировка пользователей - студентов Акселератора - по итогам оценки проектов
   * @deprecated Использовать studentTransferToSecondStage
   */
  blockAcceleratorStudentsByProjectAssessment: Scalars['String']['output'];
  /**
   * Блокировка пользователя в одной из школ Акселератора
   * Не предназначен для вызова с фронта!
   */
  blockStudentInAcceleratorSchool: Scalars['String']['output'];
  /** Отмена рассылки Акселератора */
  cancelNotification: Scalars['String']['output'];
  /** Изменение статуса заявки */
  changeRequestStatus: Scalars['String']['output'];
  /** Смена статуса резюме */
  changeStatusResume: Scalars['String']['output'];
  /**
   * Резюме
   * Создание/обновление резюме
   */
  createOrUpdateResume: Scalars['String']['output'];
  /**
   * Работа с проектами
   * Создание проекта
   */
  createProject: Project;
  /** Создание заметок */
  deleteAccNotesByIds: Array<AccNote>;
  /** Удаление опроса */
  deleteAcceleratorSurvey: Scalars['String']['output'];
  /** Удаление проектного потока */
  deleteProjectFlowById: Scalars['String']['output'];
  /** Удаление вакансии проекта */
  deleteProjectRole: Scalars['String']['output'];
  /** Удаление резюме */
  deleteResume: Scalars['String']['output'];
  /** Изменение номера телефона */
  editAccMobile: Scalars['Boolean']['output'];
  /** Отклонение капитаном заявки на участие в проекте */
  failJoinToProject: JoinTeamRequest;
  generateRegLink: Scalars['String']['output'];
  /** Генерация реферальной ссылки */
  generateRegReferralLink: Scalars['String']['output'];
  /** Добавление пользователя в АУ 0 этапа или АС 0 этапа в зависимости от типа пользователя */
  joinToAccelerator: Scalars['String']['output'];
  /** Присоединение к событию */
  joinToCalendarEvent: CalendarEventParticipant;
  /**
   * Работа с заявками
   * Подача пользователем заявки на участие в проекте
   */
  joinToProject: JoinTeamRequest;
  /**
   * Помечание заявки, как "прочитанной"
   * @deprecated Под удаление. Использовать saveAcceleratorProfile
   */
  markRequestAsRead: JoinTeamRequest;
  /** Перевод проекта на следующий этап */
  projectTransferToNextStage: Scalars['String']['output'];
  /** Обновление баллов */
  refreshNtoScore: DefaultResponse;
  /** Отклонение события для участников, которые записались на него */
  rejectCalendarEvent: CalendarEventParticipant;
  /** Отзыв заявки пользователем */
  rejectRequestToProject: JoinTeamRequest;
  /** Отклонить приглашение пользователем */
  rejectTeamInvite: Scalars['String']['output'];
  /** Удаление события календаря */
  removeCalendarEvent: Scalars['String']['output'];
  /** Удаление файлов по id, приложенных к проекту */
  removeProjectFiles: Scalars['String']['output'];
  /** Отозвать приглашение */
  revokeTeamInvite: Scalars['String']['output'];
  /** Создание/изменение событий */
  saveAccCalendarEvent: AccOnlineCalendarEvent;
  /**
   * Изменение дополнительных данных
   * @deprecated Использовать saveAccCalendarEvent
   */
  saveAcceleratorProfile: Scalars['Boolean']['output'];
  /** Сохранение оценки по итоговому заданию проектной деятельности */
  saveAcceleratorProjectAssessment: Scalars['String']['output'];
  /**
   * Метрики
   * Сохранение (создание/обновление) опроса
   */
  saveAcceleratorSurvey: Scalars['String']['output'];
  /** Сохранение ответа на опрос */
  saveAcceleratorSurveyUserAnswer: Scalars['String']['output'];
  saveCalendarEvent: OnlineCalendarEvent;
  /**
   * Рассылки
   * Сохранение рассылки Акселератора и запуск email нотификации
   */
  saveNotification: Scalars['String']['output'];
  /**
   * Проектные потоки
   * Создание проектного потока
   */
  saveOrUpdateProjectFlow: Scalars['String']['output'];
  /** Сохранение вакансии проекта */
  saveOrUpdateProjectRole: Scalars['String']['output'];
  /** Отправка баллов */
  sendNtoScore: NtoSendScoreResponse;
  /** Приглашение в команду */
  sendTeamInvite: Scalars['UUID']['output'];
  setInfo?: Maybe<AcceleratorProfile>;
  /** Перевод пользователей - студентов Акселератора - на второй этап по итогам оценки проектов */
  studentTransferToSecondStage: Scalars['String']['output'];
  /** Одобрение капитаном заявки на участие в проекте */
  successJoinToProject: JoinTeamRequest;
  /**
   * Перевод студентов из школы в Акселератор Студента в школу Акселератора Ученика
   * Не предназначен для вызова с фронта!
   */
  transferAccStudentToAccLearnerSchool: Scalars['String']['output'];
  /** Перевод пользователя в класс "Акселератор" */
  transferUserToAcceleratorStageGroup: Scalars['String']['output'];
  /** Создание заметок */
  updateAccNoteCompleteness: Array<Maybe<AccNote>>;
  /** Повторная нотификация / нотификация при изменении email законного представителя */
  updateParentEmail: Scalars['String']['output'];
  /** Изменение проекта */
  updateProject: Project;
  updateProjectAvailableForRequests: Scalars['String']['output'];
  /**
   * Обновления файлов к проекту. Если не передано значение поля fileURL,
   * то удаляет текущий активный файл.
   */
  updateProjectFiles?: Maybe<Scalars['UUID']['output']>;
};


export type AcceleratorMutationsAcceptTeamInviteArgs = {
  inviteId: Scalars['UUID']['input'];
};


export type AcceleratorMutationsAddNotificationItemToQueueArgs = {
  notificationItem: AcceleratorNotificationItemInput;
};


export type AcceleratorMutationsAddOrUpdateAccNotesArgs = {
  noteInputModels: Array<AccNoteInput>;
};


export type AcceleratorMutationsApproveRequestsArgs = {
  agreementType: Scalars['String']['input'];
  requestIds: Array<InputMaybe<Scalars['UUID']['input']>>;
};


export type AcceleratorMutationsBlockStudentInAcceleratorSchoolArgs = {
  accSchoolId: Scalars['UUID']['input'];
  userEmail: Scalars['String']['input'];
};


export type AcceleratorMutationsCancelNotificationArgs = {
  notificationId: Scalars['UUID']['input'];
};


export type AcceleratorMutationsChangeRequestStatusArgs = {
  requestId: Scalars['UUID']['input'];
  status: Scalars['String']['input'];
};


export type AcceleratorMutationsChangeStatusResumeArgs = {
  status: Scalars['String']['input'];
};


export type AcceleratorMutationsCreateOrUpdateResumeArgs = {
  resumeInput: ResumeInput;
};


export type AcceleratorMutationsCreateProjectArgs = {
  project: ProjectInput;
};


export type AcceleratorMutationsDeleteAccNotesByIdsArgs = {
  noteIds: Array<Scalars['ID']['input']>;
};


export type AcceleratorMutationsDeleteAcceleratorSurveyArgs = {
  surveyId: Scalars['UUID']['input'];
};


export type AcceleratorMutationsDeleteProjectFlowByIdArgs = {
  projectFlowId: Scalars['UUID']['input'];
};


export type AcceleratorMutationsDeleteProjectRoleArgs = {
  vacancyId: Scalars['UUID']['input'];
};


export type AcceleratorMutationsEditAccMobileArgs = {
  newMobileNumber: Scalars['String']['input'];
};


export type AcceleratorMutationsFailJoinToProjectArgs = {
  reasonId?: InputMaybe<Scalars['UUID']['input']>;
  reasonText?: InputMaybe<Scalars['String']['input']>;
  requestId: Scalars['UUID']['input'];
};


export type AcceleratorMutationsGenerateRegLinkArgs = {
  stageGroupId: Scalars['Int']['input'];
};


export type AcceleratorMutationsGenerateRegReferralLinkArgs = {
  referralTypeId: Scalars['String']['input'];
};


export type AcceleratorMutationsJoinToAcceleratorArgs = {
  referralCode?: InputMaybe<Scalars['UUID']['input']>;
  referralType?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
  userTypeId: AcceleratorUserType;
};


export type AcceleratorMutationsJoinToCalendarEventArgs = {
  eventId: Scalars['UUID']['input'];
  participantGroupId: Scalars['UUID']['input'];
};


export type AcceleratorMutationsJoinToProjectArgs = {
  requestReason?: InputMaybe<Scalars['String']['input']>;
  teamId: Scalars['UUID']['input'];
  vacancyId?: InputMaybe<Scalars['UUID']['input']>;
};


export type AcceleratorMutationsMarkRequestAsReadArgs = {
  requestId: Scalars['UUID']['input'];
};


export type AcceleratorMutationsProjectTransferToNextStageArgs = {
  projectStageInput: ProjectStageInput;
};


export type AcceleratorMutationsRejectCalendarEventArgs = {
  eventId: Scalars['UUID']['input'];
  participantGroupId: Scalars['UUID']['input'];
};


export type AcceleratorMutationsRejectRequestToProjectArgs = {
  reasonId?: InputMaybe<Scalars['UUID']['input']>;
  reasonText?: InputMaybe<Scalars['String']['input']>;
  requestId: Scalars['UUID']['input'];
};


export type AcceleratorMutationsRejectTeamInviteArgs = {
  inviteId: Scalars['UUID']['input'];
};


export type AcceleratorMutationsRemoveCalendarEventArgs = {
  eventId: Scalars['UUID']['input'];
};


export type AcceleratorMutationsRemoveProjectFilesArgs = {
  id: Array<Scalars['UUID']['input']>;
};


export type AcceleratorMutationsRevokeTeamInviteArgs = {
  inviteId: Scalars['UUID']['input'];
};


export type AcceleratorMutationsSaveAccCalendarEventArgs = {
  accOnlineCalendarEventInput: AccOnlineCalendarEventInput;
};


export type AcceleratorMutationsSaveAcceleratorProfileArgs = {
  acceleratorProfileInput: AcceleratorProfileInput;
};


export type AcceleratorMutationsSaveAcceleratorProjectAssessmentArgs = {
  projectAssessmentInput: ProjectAssessmentInput;
};


export type AcceleratorMutationsSaveAcceleratorSurveyArgs = {
  acceleratorSurveyInput: AcceleratorSurveyInput;
};


export type AcceleratorMutationsSaveAcceleratorSurveyUserAnswerArgs = {
  userSurveyAnswerInput: UserSurveyAnswerInput;
};


export type AcceleratorMutationsSaveCalendarEventArgs = {
  onlineCalendarEventInput: OnlineCalendarEventInput;
};


export type AcceleratorMutationsSaveNotificationArgs = {
  acceleratorNotificationInput: AcceleratorNotificationInput;
};


export type AcceleratorMutationsSaveOrUpdateProjectFlowArgs = {
  projectFlowSaveOrUpdate: ProjectFlowSaveOrUpdate;
};


export type AcceleratorMutationsSaveOrUpdateProjectRoleArgs = {
  projectRoleInput?: InputMaybe<ProjectRoleInput>;
};


export type AcceleratorMutationsSendNtoScoreArgs = {
  activity: Scalars['String']['input'];
  userIds: Array<Scalars['UUID']['input']>;
};


export type AcceleratorMutationsSendTeamInviteArgs = {
  inviteRequestInput: InviteRequestInput;
};


export type AcceleratorMutationsSetInfoArgs = {
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  gender?: InputMaybe<Gender>;
  regionId?: InputMaybe<Scalars['UUID']['input']>;
  userAbout?: InputMaybe<Scalars['String']['input']>;
  userId: Scalars['UUID']['input'];
};


export type AcceleratorMutationsStudentTransferToSecondStageArgs = {
  projectFlowId?: InputMaybe<Scalars['UUID']['input']>;
  secondSchoolId: Scalars['UUID']['input'];
  secondStageId: Scalars['Int']['input'];
};


export type AcceleratorMutationsSuccessJoinToProjectArgs = {
  requestId: Scalars['UUID']['input'];
};


export type AcceleratorMutationsTransferAccStudentToAccLearnerSchoolArgs = {
  birthdate?: InputMaybe<Scalars['String']['input']>;
  userEmail: Scalars['String']['input'];
};


export type AcceleratorMutationsUpdateAccNoteCompletenessArgs = {
  isCompleted: Scalars['Boolean']['input'];
  noteId: Scalars['ID']['input'];
};


export type AcceleratorMutationsUpdateParentEmailArgs = {
  newParentEmail: Scalars['String']['input'];
};


export type AcceleratorMutationsUpdateProjectArgs = {
  id: Scalars['UUID']['input'];
  project: ProjectInput;
};


export type AcceleratorMutationsUpdateProjectAvailableForRequestsArgs = {
  availableForRequest: Scalars['Boolean']['input'];
  projectId: Scalars['UUID']['input'];
};


export type AcceleratorMutationsUpdateProjectFilesArgs = {
  projectFileInput?: InputMaybe<ProjectFileInput>;
};

/** Входная модель фильтра по рассылкам Акселератора */
export type AcceleratorNotificationFilter = {
  /** Paging */
  page?: InputMaybe<PagingInput>;
  /** Поиск по теме рассылки */
  searchText?: InputMaybe<Scalars['String']['input']>;
};

/** Входная модель для сохранения данных по рассылке Акселератора */
export type AcceleratorNotificationInput = {
  /** Тело рассылки */
  body: Scalars['String']['input'];
  /** Footer рассылки */
  footer?: InputMaybe<Scalars['String']['input']>;
  /** Header рассылки */
  header?: InputMaybe<Scalars['String']['input']>;
  /** Список ID групп получателей рассылки */
  receiversIds: Array<Scalars['String']['input']>;
  /** Тип группы получателей рассылки */
  receiversType: AcceleratorNotificationReceiverGroupType;
  /** Тема рассылки */
  subject: Scalars['String']['input'];
};

export type AcceleratorNotificationItemInput = {
  allOfOrgUnit: Scalars['Boolean']['input'];
  messageBody: Scalars['String']['input'];
  projectFlowId?: InputMaybe<Scalars['UUID']['input']>;
  projects: Array<Scalars['UUID']['input']>;
  subject: Scalars['String']['input'];
};

export type AcceleratorNotificationItemModel = {
  __typename?: 'AcceleratorNotificationItemModel';
  count: Scalars['Int']['output'];
  createDateTime: Scalars['DateTime']['output'];
  status: Scalars['String']['output'];
  subject: Scalars['String']['output'];
};

/** Модель рассылки Акселератора */
export type AcceleratorNotificationModel = {
  __typename?: 'AcceleratorNotificationModel';
  /** Тело рассылки */
  body: Scalars['String']['output'];
  /** Количество ошибок по рассылке */
  errorCount?: Maybe<Scalars['Int']['output']>;
  /** Идентификатор рассылки */
  id: Scalars['UUID']['output'];
  /** Список групп получателей рассылки */
  receivers: Array<AcceleratorNotificationReceiverGroup>;
  /** Общее кол-во email для отправки в рассылке */
  receiversCount?: Maybe<Scalars['Int']['output']>;
  /** Тип группы получателей рассылки */
  receiversType: AcceleratorNotificationReceiverGroupType;
  /** Количество отправленных нотификаций по рассылке */
  sentCount?: Maybe<Scalars['Int']['output']>;
  /** Статус рассылки */
  status: AcceleratorNotificationStatus;
  /** Тема рассылки */
  subject: Scalars['String']['output'];
};

/** Модель группы получателей рассылки Акселератора */
export type AcceleratorNotificationReceiverGroup = {
  __typename?: 'AcceleratorNotificationReceiverGroup';
  /** ID группы получателей */
  id: Scalars['String']['output'];
  /** Наименование группы получателей */
  name: Scalars['String']['output'];
};

/** Тип групп получателей рассылки Акселератора */
export enum AcceleratorNotificationReceiverGroupType {
  ProjectTeams = 'PROJECT_TEAMS',
  StageGroups = 'STAGE_GROUPS'
}

/** Сокращенная модель рассылки Акселератора */
export type AcceleratorNotificationShortModel = {
  __typename?: 'AcceleratorNotificationShortModel';
  /** Дата создания рассылки */
  createTs: Scalars['DateTime']['output'];
  /** Имя отправителя */
  creatorName: Scalars['String']['output'];
  /** Идентификатор рассылки */
  id: Scalars['UUID']['output'];
  /** Статус рассылки */
  status: AcceleratorNotificationStatus;
  /** Тема рассылки */
  subject: Scalars['String']['output'];
};

/** Тип статуса рассылки Акселератора */
export enum AcceleratorNotificationStatus {
  Cancelled = 'CANCELLED',
  Created = 'CREATED',
  Error = 'ERROR',
  Finished = 'FINISHED',
  Queued = 'QUEUED',
  Sending = 'SENDING'
}

export type AcceleratorProfile = {
  __typename?: 'AcceleratorProfile';
  active?: Maybe<Scalars['Boolean']['output']>;
  avatarUrl?: Maybe<Scalars['String']['output']>;
  birthdayDate?: Maybe<Scalars['DateTime']['output']>;
  block: Scalars['Boolean']['output'];
  country?: Maybe<Country>;
  email?: Maybe<Scalars['String']['output']>;
  emailConfirmed?: Maybe<Scalars['String']['output']>;
  favoriteArtists?: Maybe<Scalars['String']['output']>;
  favoriteBooks?: Maybe<Scalars['String']['output']>;
  favoriteFilms?: Maybe<Scalars['String']['output']>;
  favoriteSportKinds: Array<Scalars['String']['output']>;
  favoriteSubjects: Array<FavoriteSubject>;
  favoriteTaskFormats: Array<Scalars['String']['output']>;
  favoriteWorkForms: Array<Scalars['String']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  gender?: Maybe<Gender>;
  id: Scalars['UUID']['output'];
  interestsHobbies?: Maybe<Scalars['String']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  legalRepresentativeEmail?: Maybe<Scalars['String']['output']>;
  login?: Maybe<Scalars['String']['output']>;
  middleName?: Maybe<Scalars['String']['output']>;
  mobilePhone?: Maybe<Scalars['String']['output']>;
  region?: Maybe<Region>;
  userAbout?: Maybe<Scalars['String']['output']>;
  userClassName?: Maybe<Scalars['String']['output']>;
  userNameSchoolAcceleratorAccess?: Maybe<Scalars['String']['output']>;
  userPositionOrganizations: Array<UserPositionOrganization>;
  visibilityLevel?: Maybe<ProfileVisibilityLevel>;
  wantToBecome?: Maybe<Scalars['String']['output']>;
};

export type AcceleratorProfileInput = {
  accVocabularyEducationOrganization?: InputMaybe<Array<InputMaybe<UserPositionOrganizationInput>>>;
  active?: InputMaybe<Scalars['Boolean']['input']>;
  avatarUrl?: InputMaybe<Scalars['String']['input']>;
  birthdayDate?: InputMaybe<Scalars['DateTime']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  emailConfirmed?: InputMaybe<Scalars['String']['input']>;
  favoriteArtists?: InputMaybe<Scalars['String']['input']>;
  favoriteBooks?: InputMaybe<Scalars['String']['input']>;
  favoriteFilms?: InputMaybe<Scalars['String']['input']>;
  favoriteSportKinds: Array<Scalars['String']['input']>;
  favoriteSubjects: Array<Scalars['Int']['input']>;
  favoriteTaskFormats: Array<Scalars['String']['input']>;
  favoriteWorkForms: Array<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  gender?: InputMaybe<Gender>;
  id: Scalars['UUID']['input'];
  interestsHobbies?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  legalRepresentativeEmail?: InputMaybe<Scalars['String']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  middleName?: InputMaybe<Scalars['String']['input']>;
  mobilePhone?: InputMaybe<Scalars['String']['input']>;
  regionId?: InputMaybe<Scalars['UUID']['input']>;
  userAbout?: InputMaybe<Scalars['String']['input']>;
  userClassName?: InputMaybe<Scalars['String']['input']>;
  userNameSchoolAcceleratorAccess?: InputMaybe<Scalars['String']['input']>;
  userPositionOrganizations: Array<UserPositionOrganizationInput>;
  visibilityLevel?: InputMaybe<ProfileVisibilityLevel>;
  wantToBecome?: InputMaybe<Scalars['String']['input']>;
};

/** Статус прохождения проекта */
export enum AcceleratorProjectGrade {
  Fail = 'FAIL',
  Success = 'SUCCESS',
  Undefined = 'UNDEFINED'
}

export type AcceleratorQueries = {
  __typename?: 'AcceleratorQueries';
  /** Проверка заполненности профиля */
  checkProfile: Array<Scalars['String']['output']>;
  checkStatusModulesReport: StatusModulesReport;
  checkStatusUniversityModulesReport: StatusModulesReport;
  createModulesReportXls: DefaultResponse;
  createUniversityModulesReportXls: DefaultResponse;
  /** Выгрузка файла */
  downloadFile: Scalars['String']['output'];
  exportAsyncModulesReportToXLS: ReportExcelFile;
  exportAsyncUniversityModulesReportToXLS: ReportExcelFile;
  /** Получение списка опросов с данными по метрикам */
  exportMetricReportToXLS: ReportExcelFile;
  /** Получение файла Excel с отчетом в формате Base64 */
  exportMilestoneReportToXLS: ReportExcelFile;
  /** Отчет об успеваемости по модулям */
  exportModulesReportToXLS: ReportExcelFile;
  /** Получение отчета по рефералам */
  exportReferralReportToXLS: ReportExcelFile;
  /** Отчет о регистрации */
  exportRegistrationReportToXLS: ReportExcelFile;
  /** Возвращает отчет по успеваемости для */
  exportUniversityModulesReportToXLS: ReportExcelFile;
  /** Получение списка событий по фильтру */
  findAccCalendarEventsByFilter: Array<AccOnlineCalendarEvent>;
  findCalendarEventsByFilter: Array<OnlineCalendarEvent>;
  /** Получение ссылки на загрузку согласия */
  getAccAgreementLink: Scalars['String']['output'];
  /** Информация о пользователе Акселератора */
  getAccCurrentUserInfo: AccUserInfoModel;
  /** отправить запрос в GigaChat и получить ответ */
  getAccGigaChatResponse: Array<AccGigaChatResponse>;
  /** Модуль ученика */
  getAccModuleById?: Maybe<StudentModule>;
  /** Получение заметок за переданный день */
  getAccNotesByDate: Array<AccNote>;
  /** Получение даты блокировки возможности сменить проект Акселератора Ученика */
  getAcceleratorLearnerBlockChangingProjectDate?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Конфигурация
   * Получение ИД школы 'Акселератор Ученика'
   */
  getAcceleratorLearnerSchoolId?: Maybe<Scalars['UUID']['output']>;
  /** Получение даты начала второго этапа Акселератора Ученика */
  getAcceleratorLearnerSecondMilestoneStartDate?: Maybe<Scalars['DateTime']['output']>;
  /** Получение идентификатора школы Акселератора Ученика второго этапа */
  getAcceleratorLearnerSecondStageSchoolId?: Maybe<Scalars['UUID']['output']>;
  /** Получение идентификатора школы Акселератора Ученика нулевого этапа */
  getAcceleratorLearnerZeroStageSchoolId?: Maybe<Scalars['UUID']['output']>;
  /** получить статус участника акселератора */
  getAcceleratorMemberStatus: AcceleratorMemberStatus;
  /** Получение списка школ акселератора */
  getAcceleratorSchools: Array<AcceleratorSchool>;
  /** Получение даты блокировки возможности сменить проект Акселератора Студента */
  getAcceleratorStudentBlockChangingProjectDate?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Получение количества пользователей, которые могут ещё быть зарегистрированы
   * в Акселераторе Студента до достижения лимита (<=0 - лимит исчерпан)
   */
  getAcceleratorStudentLimitRemains: Scalars['Int']['output'];
  /** Получение ИД школы 'Акселератор Студента' */
  getAcceleratorStudentSchoolId?: Maybe<Scalars['UUID']['output']>;
  /** Получение даты начала второго этапа Акселератора Студента */
  getAcceleratorStudentSecondMilestoneStartDate?: Maybe<Scalars['DateTime']['output']>;
  /** Получение идентификатора школы Акселератора Студента второго этапа */
  getAcceleratorStudentSecondStageSchoolId?: Maybe<Scalars['UUID']['output']>;
  /** Получение идентификатора школы Акселератора Студента нулевого этапа */
  getAcceleratorStudentZeroStageSchoolId?: Maybe<Scalars['UUID']['output']>;
  /** Получение данных о соглашениях */
  getAgreementDataByRequestId: AgreementDataModel;
  /** Получение всех заказчиков */
  getAllBranches: Array<Branch>;
  /** Получение всех типов событий календаря */
  getAllCalendarEventTypes: Array<CalendarEventType>;
  /**
   * Справочники
   * Получение всех заказчиков
   */
  getAllCustomers: Array<Customer>;
  /**
   * Рассылки
   * Получение списка рассылок в школе
   */
  getAllNotifications: Array<AcceleratorNotificationShortModel>;
  /**
   * Проектные потоки
   * Получения списка проектных потоков
   */
  getAllProjectFlowsWithPaging: Array<ProjectFlow>;
  /** Получение всех ролей из справочника */
  getAllProjectRolesFromDirectory: Array<ProjectRoleFromDirectory>;
  /**
   * Проекты
   * Получение списка всех проектов в школе
   */
  getAllProjects: Array<ProjectCard>;
  /** Получение списка всех проектов в школе для email рассылки */
  getAllProjectsForEmailNotification: Array<ProjectCard>;
  /** зарегистрированных по реферальной ссылке */
  getAllReferralsForReferrerForConfigurator: Array<ReferralConfigurator>;
  /**
   * Реферальная программа
   * Получение списка зарегистрированных по реферальной ссылке для Участника
   */
  getAllReferralsForUser: Array<ReferralUser>;
  /** Получение списка реферреров для Конфигуратора */
  getAllReferrersForConfigurator: Array<ReferrerConfigurator>;
  /** Получение списка заявок */
  getAllRequestsByStatus: RequestDataModel;
  /** Получение списка резюме */
  getAllResumesByFilters: ResumesData;
  /** Получение списка классов в школе в текущем учебном году */
  getAllStageGroups: Array<StageGroup>;
  /** Получение списка классов в школе в текущем учебном году для email рассылки */
  getAllStageGroupsForEmailNotification: Array<StageGroup>;
  getAllStageGroupsForMoving: Array<StageGroupType>;
  /** Получение всех заказчиков */
  getAllTechnologies: Array<Technology>;
  /** Получение списка проектов, в командах которых хотя бы один ученик из вуза */
  getAllUniversityProjects: Array<Maybe<ProjectCard>>;
  /** Получение списка всех классoв вуза */
  getAllUniversityStageGroups: Array<Maybe<UniversityStageGroupModel>>;
  /** Получение типов событий, доступных для создания пользователем, в соответствии с его функциональными ролями */
  getAvailableEventTypesByUserId: Array<CalendarEventType>;
  /**
   * Получение типов пользовательских групп, для которых можно создавать события выранных типов
   * @deprecated Использовать findAccCalendarEventsByFilter
   */
  getAvailableGroupTypesByEventTypeIds: Array<GroupType>;
  /** Получение заказчика по id */
  getBranchById?: Maybe<Branch>;
  /** Получение событий по группе участника */
  getCalendarEventsByParticipantGroup: Array<OnlineCalendarEvent>;
  /** Получение списка событий по типу */
  getCalendarEventsByType: Array<OnlineCalendarEvent>;
  /** Получение событий по типу и группе участника */
  getCalendarEventsByTypeAndPartGroup: Array<OnlineCalendarEvent>;
  /** Получение событий по типу, группе и статусу участника */
  getCalendarEventsByTypeAndPartGroupAndStatus: Array<OnlineCalendarEvent>;
  /**
   * Календарь событий
   * Получение
   */
  getCalendersScheduleTasksByUserId: Array<ScheduledStudentTask>;
  /** Метод возвращает количество проектов и количества Участников Акселератора, переводимых на 2 этап */
  getCountsToSecondStageTransfer: StudentsManagement;
  /** Получение текщуего проекта текущего пользователя */
  getCurrentUserProject?: Maybe<Project>;
  /**
   * Резюме
   * Получение резюме пользователя
   */
  getCurrentUserResume: ResumeModel;
  /** Получение заказчика по id */
  getCustomerById?: Maybe<Customer>;
  /**
   * Работа с группами пользователей
   * Получение групп, в которые входит пользователь, в том числе транзитивно
   */
  getGroupsByUserId: Array<Group>;
  /** Получение всех групп, в которые входит пользователь, в том числе транзитивно */
  getGroupsByUserIdWithGroupTypes: Array<Group>;
  /** Метод возвращает дату последней активности капитана по проекту и команде проекта. */
  getLastCapitanActivity: Scalars['Date']['output'];
  /** Получение этапа по идентификатору образовательного учреждения */
  getMilestoneByOrgUnitId: AcceleratorMilestone;
  /** Получение кандидата в капитаны, при выходе из команды текущего капитана */
  getNextCaptainCandidate?: Maybe<TeamMember>;
  /** Получение подробной информации по рассылке */
  getNotificationById: AcceleratorNotificationModel;
  getNtoScore: NtoScoreResponse;
  /** Баллы НТО */
  getNtoWidgetData: NtoWidget;
  /** Получение групп участников события */
  getParticipantGroupsByEvent: Array<Group>;
  /**
   * Профиль УА
   * Получение данных профиля
   */
  getProfileById?: Maybe<AcceleratorProfile>;
  /** Получение проекта по ID */
  getProjectById: Project;
  /** Получение проектного потока */
  getProjectFlowById: ProjectFlowWithStageGroups;
  /** Получение проектного потока пользователя */
  getProjectFlowByUserId?: Maybe<ProjectFlow>;
  /** Получения списка классов проектного потока */
  getProjectFlowStageGroups: Array<ProjectFlowStageGroup>;
  /** Постраничное получение проектов */
  getProjectPageByFilter: ProjectPage;
  /** Постраничное получение проектов, которые пригласили пользователя */
  getProjectPageInvitedByFilter: ProjectPage;
  /** Получение проектов, к которым отправлены заявки */
  getProjectPageRequestByFilter: ProjectPage;
  /** Постраничное получение проектов, которые просматривали пользователя */
  getProjectPageViewedByFilter: ProjectPage;
  /**
   * Вакансии проекта
   * Получение вакансии по id вакансии
   */
  getProjectRoleByVacancyId: ProjectRole;
  /** Получение вакансий проекта по id проекта */
  getProjectRolesByProjectId: Array<ProjectRole>;
  /** Получение вакансий проекта по id проекта */
  getProjectVacanciesForCapitan: Array<ProjectRoleForCapitan>;
  /** Получение проектов по фильтрам */
  getProjectsByFilters: Array<ProjectCard>;
  /** Получение проектов по фильтрам */
  getProjectsByUserStageFilters: Array<ProjectCard>;
  /** Получение проектов с учетом просмотров приглашений */
  getProjectsInvitedUserByFilter: Array<Maybe<ProjectViewedModel>>;
  /** Получение проектов с учетом просмотров резюме */
  getProjectsViewedUserByFilter: Array<Maybe<ProjectViewedModel>>;
  getRefreshNtoScoreStatus: Scalars['String']['output'];
  /**
   * Работа с заявками
   * Получение заявки на участие в проекте по id
   */
  getRequestById?: Maybe<JoinTeamRequest>;
  /** Получение всех заявок в команду */
  getRequestsByTeam: Array<JoinTeamRequest>;
  /** Получение всех заявок пользователя */
  getRequestsByUser: Array<JoinTeamRequest>;
  /** Получение резюме для УА (капитана) */
  getResumeByIdForCapitan: ResumeForCapitan;
  /** Получение резюме для УА */
  getResumeByIdForStudent: ResumeForStudent;
  getStageGroupForMoving: StageGroupType;
  /**
   * Виджеты
   * Прогресс обучения
   */
  getStudentModulesWidgetData: StudentModuleWidgetData;
  /** Получение проектов с учетом приглашений */
  getTeamInviteByTeamId: InviteRequestModel;
  /** Получение списка резюме из приглашенных */
  getTeamInvitesByFilters: ResumesData;
  /** Получение количества приглашений команды */
  getTeamInvitesCounter: Scalars['Int']['output'];
  /** Получение заказчика по id */
  getTechnologyById?: Maybe<Technology>;
  /** Получение спиcка всех ТБ и регионов по ТБ */
  getTerbanksWithRegions: Array<Maybe<TerbanksModel>>;
  /** Получение активных учеников  вуза из числа зарегистрированных вуза */
  getUniversityActiveStudentsCount: UniversityActiveStudentsCount;
  /** Получение количество учеников вуза по этапам проектной деятельности */
  getUniversityNumberOfStudentsOnStage: UniversityNumberOfStudentsOnStage;
  /** Получение количества приглашений УА */
  getUserInvitesCounter: Scalars['Int']['output'];
  /** Получение флага, что набор в 'Акселератор Ученика' открыт */
  isAcceleratorLearnerSchoolEnrollmentEnabled: Scalars['Boolean']['output'];
  /** Получение флага, что набор в 'Акселератор Студента' открыт */
  isAcceleratorStudentSchoolEnrollmentEnabled: Scalars['Boolean']['output'];
  /** Метод возвращает должна ли отображаться только главная страница */
  isJuniorLanding: Scalars['Boolean']['output'];
  /** Получение значения фиче-флага проектной деятельности */
  isProjectActivityEnabled: Scalars['Boolean']['output'];
  /** Получение статуса разрешения отправки запросов на вступление в группу проекта. */
  isProjectAvailableForRequest: Scalars['Boolean']['output'];
  /** Получения софт-флага управления включением функционала проектной деятельности на фронте. */
  isProjectFlowActive: Scalars['Boolean']['output'];
  /**
   * Внутренняя регистрация
   * Проверка находится ли пользователь в текущем потоке Акселератора
   */
  isUserAlreadyJoinedAccelerator: AcceleratorJoinCheckResult;
  /**
   * Получение справочных данных из acc-report сервиса Акселератора
   * Получение списка образовательных организаций
   */
  loadEducationalOrganizations: Array<ShortOrganizationModel>;
  /** получить список нотификаций в очереди */
  loadListNotificationItems: Array<AcceleratorNotificationItemModel>;
  /**
   * Метрики
   * Получение списка опросов с данными по метрикам
   */
  loadMetrics: Array<Survey>;
  /**
   * Закрытие первого этапа
   * Получение данных для построения интерфейса с отчетами с фильтрами
   */
  loadMilestoneReport: Array<MilestoneReport>;
  /** Получение списка организаций для заполнения профиля */
  loadOrganizations: Array<ShortOrganizationModel>;
  /** Получение списка должностей */
  loadPositions: Array<Position>;
  /** Получение списка регионов */
  loadRegions: Array<Region>;
  /** Получение списка активных опросов пользователя без ответов */
  loadRunningSurveysWithoutAnswer: Array<ActiveSurveyWithoutAnswer>;
  /** Получение количества получателей email-рассылки для данных групп пользоватлей */
  notificationReceiversCount: Scalars['Int']['output'];
};


export type AcceleratorQueriesCheckProfileArgs = {
  userId: Scalars['UUID']['input'];
};


export type AcceleratorQueriesCreateModulesReportXlsArgs = {
  filter: ModulesReportFilter;
};


export type AcceleratorQueriesCreateUniversityModulesReportXlsArgs = {
  filter: UniversityModulesReportFilter;
};


export type AcceleratorQueriesDownloadFileArgs = {
  fileId: Scalars['UUID']['input'];
};


export type AcceleratorQueriesExportMetricReportToXlsArgs = {
  endDate: Scalars['DateTime']['input'];
  metricId: AcceleratorMetric;
};


export type AcceleratorQueriesExportMilestoneReportToXlsArgs = {
  filter: MilestoneReportFilter;
};


export type AcceleratorQueriesExportModulesReportToXlsArgs = {
  filter: ModulesReportFilter;
};


export type AcceleratorQueriesExportRegistrationReportToXlsArgs = {
  beginDate: Scalars['String']['input'];
  endDate?: InputMaybe<Scalars['String']['input']>;
};


export type AcceleratorQueriesExportUniversityModulesReportToXlsArgs = {
  filter: UniversityModulesReportFilter;
};


export type AcceleratorQueriesFindAccCalendarEventsByFilterArgs = {
  filter: CalendarEventFilterInput;
  page?: InputMaybe<PagingInput>;
};


export type AcceleratorQueriesFindCalendarEventsByFilterArgs = {
  filter: CalendarEventFilterInput;
  page?: InputMaybe<PagingInput>;
};


export type AcceleratorQueriesGetAccGigaChatResponseArgs = {
  conversationId?: InputMaybe<Scalars['UUID']['input']>;
  messages: Array<AccGigaChatMessageInput>;
};


export type AcceleratorQueriesGetAccModuleByIdArgs = {
  goalId: Scalars['ID']['input'];
};


export type AcceleratorQueriesGetAccNotesByDateArgs = {
  atDate: Scalars['Date']['input'];
};


export type AcceleratorQueriesGetAcceleratorMemberStatusArgs = {
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
};


export type AcceleratorQueriesGetAgreementDataByRequestIdArgs = {
  requestId: Scalars['UUID']['input'];
};


export type AcceleratorQueriesGetAllNotificationsArgs = {
  filter?: InputMaybe<AcceleratorNotificationFilter>;
  orgUnitId?: InputMaybe<Scalars['UUID']['input']>;
};


export type AcceleratorQueriesGetAllProjectFlowsWithPagingArgs = {
  page: PagingInput;
};


export type AcceleratorQueriesGetAllProjectsArgs = {
  orgUnitId?: InputMaybe<Scalars['UUID']['input']>;
};


export type AcceleratorQueriesGetAllProjectsForEmailNotificationArgs = {
  orgUnitId?: InputMaybe<Scalars['UUID']['input']>;
};


export type AcceleratorQueriesGetAllReferralsForReferrerForConfiguratorArgs = {
  page: PagingInput;
  referralType?: InputMaybe<Scalars['String']['input']>;
  referrerUserId: Scalars['UUID']['input'];
};


export type AcceleratorQueriesGetAllReferralsForUserArgs = {
  referralType?: InputMaybe<Scalars['String']['input']>;
};


export type AcceleratorQueriesGetAllReferrersForConfiguratorArgs = {
  page: PagingInput;
  referralType?: InputMaybe<Scalars['String']['input']>;
};


export type AcceleratorQueriesGetAllRequestsByStatusArgs = {
  paging: PagingInput;
  searchShortFio: Scalars['String']['input'];
  status: Scalars['String']['input'];
};


export type AcceleratorQueriesGetAllResumesByFiltersArgs = {
  paging: PagingInput;
  resumeFilter: ResumeFilterInput;
};


export type AcceleratorQueriesGetAllStageGroupsArgs = {
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
};


export type AcceleratorQueriesGetAllStageGroupsForEmailNotificationArgs = {
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
};


export type AcceleratorQueriesGetAvailableEventTypesByUserIdArgs = {
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  userId: Scalars['UUID']['input'];
};


export type AcceleratorQueriesGetAvailableGroupTypesByEventTypeIdsArgs = {
  eventTypeIds: Array<Scalars['Int']['input']>;
};


export type AcceleratorQueriesGetBranchByIdArgs = {
  id: Scalars['UUID']['input'];
};


export type AcceleratorQueriesGetCalendarEventsByParticipantGroupArgs = {
  groupId: Scalars['UUID']['input'];
};


export type AcceleratorQueriesGetCalendarEventsByTypeArgs = {
  eventTypeId: Scalars['Int']['input'];
};


export type AcceleratorQueriesGetCalendarEventsByTypeAndPartGroupArgs = {
  eventTypeId: Scalars['Int']['input'];
  groupId: Scalars['UUID']['input'];
};


export type AcceleratorQueriesGetCalendarEventsByTypeAndPartGroupAndStatusArgs = {
  eventTypeId: Scalars['Int']['input'];
  groupId: Scalars['UUID']['input'];
  status?: InputMaybe<Scalars['String']['input']>;
};


export type AcceleratorQueriesGetCalendersScheduleTasksByUserIdArgs = {
  endTime?: InputMaybe<Scalars['DateTime']['input']>;
  startTime?: InputMaybe<Scalars['DateTime']['input']>;
  userId: Scalars['UUID']['input'];
};


export type AcceleratorQueriesGetCountsToSecondStageTransferArgs = {
  projectFlowId?: InputMaybe<Scalars['UUID']['input']>;
  secondSchoolId: Scalars['UUID']['input'];
  secondStageId: Scalars['Int']['input'];
};


export type AcceleratorQueriesGetCustomerByIdArgs = {
  id: Scalars['UUID']['input'];
};


export type AcceleratorQueriesGetGroupsByUserIdArgs = {
  groupTypeId?: InputMaybe<Scalars['Int']['input']>;
  userId: Scalars['UUID']['input'];
};


export type AcceleratorQueriesGetGroupsByUserIdWithGroupTypesArgs = {
  groupTypeIds: Array<Scalars['Int']['input']>;
  userId: Scalars['UUID']['input'];
};


export type AcceleratorQueriesGetLastCapitanActivityArgs = {
  projectId: Scalars['UUID']['input'];
};


export type AcceleratorQueriesGetMilestoneByOrgUnitIdArgs = {
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
};


export type AcceleratorQueriesGetNextCaptainCandidateArgs = {
  teamId: Scalars['UUID']['input'];
};


export type AcceleratorQueriesGetNotificationByIdArgs = {
  id: Scalars['UUID']['input'];
};


export type AcceleratorQueriesGetNtoScoreArgs = {
  filterAvailable?: InputMaybe<Scalars['Boolean']['input']>;
  paging: PagingInput;
};


export type AcceleratorQueriesGetParticipantGroupsByEventArgs = {
  eventId: Scalars['UUID']['input'];
};


export type AcceleratorQueriesGetProfileByIdArgs = {
  userId: Scalars['UUID']['input'];
};


export type AcceleratorQueriesGetProjectByIdArgs = {
  id: Scalars['UUID']['input'];
};


export type AcceleratorQueriesGetProjectFlowByIdArgs = {
  projectFlowId: Scalars['UUID']['input'];
};


export type AcceleratorQueriesGetProjectFlowByUserIdArgs = {
  userId?: InputMaybe<Scalars['UUID']['input']>;
};


export type AcceleratorQueriesGetProjectFlowStageGroupsArgs = {
  projectFlowId?: InputMaybe<Scalars['UUID']['input']>;
};


export type AcceleratorQueriesGetProjectPageByFilterArgs = {
  paging: PagingInput;
  projectFilter: ProjectFilterInput;
};


export type AcceleratorQueriesGetProjectPageInvitedByFilterArgs = {
  paging: PagingInput;
  projectFilter: ProjectFilterInput;
};


export type AcceleratorQueriesGetProjectPageRequestByFilterArgs = {
  paging: PagingInput;
  projectFilter: ProjectFilterInput;
};


export type AcceleratorQueriesGetProjectPageViewedByFilterArgs = {
  paging: PagingInput;
  projectFilter: ProjectFilterInput;
};


export type AcceleratorQueriesGetProjectRoleByVacancyIdArgs = {
  vacancyId: Scalars['UUID']['input'];
};


export type AcceleratorQueriesGetProjectRolesByProjectIdArgs = {
  isOpen?: InputMaybe<Scalars['Boolean']['input']>;
  projectId: Scalars['UUID']['input'];
};


export type AcceleratorQueriesGetProjectVacanciesForCapitanArgs = {
  projectId: Scalars['UUID']['input'];
};


export type AcceleratorQueriesGetProjectsByFiltersArgs = {
  page?: InputMaybe<PagingInput>;
  projectFilter: ProjectFilterInput;
};


export type AcceleratorQueriesGetProjectsByUserStageFiltersArgs = {
  page?: InputMaybe<PagingInput>;
  projectFilter: ProjectFilterInput;
};


export type AcceleratorQueriesGetProjectsInvitedUserByFilterArgs = {
  paging: PagingInput;
  projectFilter: ProjectFilterInput;
};


export type AcceleratorQueriesGetProjectsViewedUserByFilterArgs = {
  paging: PagingInput;
  projectFilter: ProjectFilterInput;
};


export type AcceleratorQueriesGetRequestByIdArgs = {
  requestId: Scalars['UUID']['input'];
};


export type AcceleratorQueriesGetRequestsByTeamArgs = {
  teamId: Scalars['UUID']['input'];
};


export type AcceleratorQueriesGetRequestsByUserArgs = {
  userId: Scalars['UUID']['input'];
};


export type AcceleratorQueriesGetResumeByIdForCapitanArgs = {
  resumeId: Scalars['UUID']['input'];
};


export type AcceleratorQueriesGetResumeByIdForStudentArgs = {
  resumeId: Scalars['UUID']['input'];
};


export type AcceleratorQueriesGetTeamInviteByTeamIdArgs = {
  teamId: Scalars['UUID']['input'];
};


export type AcceleratorQueriesGetTeamInvitesByFiltersArgs = {
  paging: PagingInput;
  resumeFilter: ResumeFilterInput;
};


export type AcceleratorQueriesGetTechnologyByIdArgs = {
  id: Scalars['UUID']['input'];
};


export type AcceleratorQueriesIsProjectAvailableForRequestArgs = {
  projectId: Scalars['UUID']['input'];
};


export type AcceleratorQueriesIsUserAlreadyJoinedAcceleratorArgs = {
  userId?: InputMaybe<Scalars['UUID']['input']>;
};


export type AcceleratorQueriesLoadEducationalOrganizationsArgs = {
  filter: EducationalOrganizationFilter;
};


export type AcceleratorQueriesLoadMetricsArgs = {
  endDate: Scalars['DateTime']['input'];
  metricId: AcceleratorMetric;
  page?: InputMaybe<PagingInput>;
  sort?: InputMaybe<Array<SortingField>>;
};


export type AcceleratorQueriesLoadMilestoneReportArgs = {
  filter: MilestoneReportFilter;
  page?: InputMaybe<PagingInput>;
  sort?: InputMaybe<SortingField>;
};


export type AcceleratorQueriesLoadOrganizationsArgs = {
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type AcceleratorQueriesLoadRegionsArgs = {
  searchText?: InputMaybe<Scalars['String']['input']>;
};


export type AcceleratorQueriesNotificationReceiversCountArgs = {
  receiversIds: Array<Scalars['String']['input']>;
  receiversType: AcceleratorNotificationReceiverGroupType;
};

export type AcceleratorSchool = {
  __typename?: 'AcceleratorSchool';
  fullName: Scalars['String']['output'];
  schoolId: Scalars['UUID']['output'];
  shortName: Scalars['String']['output'];
};

/** Входная модель опроса */
export type AcceleratorSurveyInput = {
  /** Дата начала опроса */
  beginDate: Scalars['DateTime']['input'];
  /** Окончание опроса */
  endDate: Scalars['DateTime']['input'];
  /** Идентификатор опроса */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Наименование метрики */
  metricId: AcceleratorMetric;
  /** Название опроса */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Статус */
  status: SurveyStatus;
};

/** Тип пользователя Акселератора */
export enum AcceleratorUserType {
  AccSchoolStage_0 = 'ACC_SCHOOL_STAGE_0',
  AccUniversityStage_0 = 'ACC_UNIVERSITY_STAGE_0',
  School = 'SCHOOL',
  University = 'UNIVERSITY'
}

/** Информация о выполненной мутации */
export type AcceptAnswerResponse = {
  __typename?: 'AcceptAnswerResponse';
  /** Информация о текущем состоянии Домашней Работы, с которой связан данный ответ на Задание (если ответ был отправлен в рамках некоторой Домашней Работы) */
  homeworkProgressInfo?: Maybe<AnswerRelatedHomeworkProgressInfo>;
  /** Информация о текущем состоянии связанной с Заданием Персональной Цели (если есть) */
  personalObjectiveProgressInfo?: Maybe<PersonalObjectiveProgressInfo>;
  /** Полная информация по Заданию в контексте Студента */
  studentTaskInfo: StudentTaskInfo;
};

/** Информация о следующем "учебном дне" (день на который назначены уроки) */
export type ActiveLearningDayLessonsInfo = {
  __typename?: 'ActiveLearningDayLessonsInfo';
  /** Планы уроков на сегодня и следующий "учебный день" (если есть) */
  lessonPlans: Array<LessonPlan>;
  /** Дата следующего "учебного дня" */
  nextLearningDayDate?: Maybe<Scalars['DateTime']['output']>;
  /** Список уроков на следующий после сегодня "учебный день" */
  nextLearningDayLessons: Array<StudentLesson>;
  /** Задания Ученика, запланированные на уроки на сегодня и следующий "учебный день" */
  plannedStudentTasks: Array<StudentTask>;
  /** Список уроков на сегодня */
  todayLessons: Array<StudentLesson>;
};

export type ActiveSurveyWithoutAnswer = {
  __typename?: 'ActiveSurveyWithoutAnswer';
  /** Наименование метрики */
  metricId: AcceleratorMetric;
  /** Идентификатор запроса */
  surveyId: Scalars['UUID']['output'];
};

/** Мероприятие */
export type ActivityEvent = {
  __typename?: 'ActivityEvent';
  /** Идентификатор мероприятия */
  activityEventId: Scalars['ID']['output'];
  /** Тип мероприятия */
  activityType: Scalars['String']['output'];
  /** Средняя оценка мероприятия по отзывам */
  averageFeedbackRating: Scalars['Float']['output'];
  /** Дата начала */
  beginDate: Scalars['DateTime']['output'];
  /** Комментарии к событию */
  comments?: Maybe<Array<ParticipantEventComment>>;
  /** Дата создания мероприятия */
  createDate: Scalars['DateTime']['output'];
  /** Текущее число зарегистрированных студентов на мероприятие */
  currentStudentsCount: Scalars['Int']['output'];
  /** Текущее число студентов в списке ожидания */
  currentWaitListStudentsCount: Scalars['Int']['output'];
  /** Описание */
  description?: Maybe<Scalars['String']['output']>;
  /** Дата окончания */
  endDate: Scalars['DateTime']['output'];
  /** Создатель мероприятия (события) */
  eventCreator?: Maybe<User>;
  /** Идентификатор события */
  eventId: Scalars['ID']['output'];
  /** Тип события */
  eventType: Scalars['String']['output'];
  /** Последний редактировавший пользователь */
  eventUpdater?: Maybe<User>;
  /** Количество оставленых отзывов */
  feedbackCount: Scalars['Int']['output'];
  /** Мероприятие с работодателем */
  isEmployerMeeting: Scalars['Boolean']['output'];
  /** Находится ли студент в листе ожидания */
  isInWaitList?: Maybe<Scalars['Boolean']['output']>;
  /** Внутренне/ внешнее мероприятие */
  isInternal?: Maybe<Scalars['Boolean']['output']>;
  /** Обязательное ли мероприятие */
  isMandatory: Scalars['Boolean']['output'];
  /** Потенциальный работодатель? */
  isPotentialEmployer?: Maybe<Scalars['Boolean']['output']>;
  /** Зарегистрирован студент на событие или нет */
  isRegistered?: Maybe<Scalars['Boolean']['output']>;
  /** Работодатель ПАО Сбербанк/другой */
  isSberEmployer?: Maybe<Scalars['Boolean']['output']>;
  /** Видно ли мероприятие студентам */
  isVisible: Scalars['Boolean']['output'];
  /** Активен ли лист ожидания */
  isWaitListActive: Scalars['Boolean']['output'];
  /** Ключевые спикеры */
  keySpeakers?: Maybe<Scalars['String']['output']>;
  /** Место проведения */
  location: Scalars['String']['output'];
  /** Максимальное количество участников */
  maxStudentCount?: Maybe<Scalars['Int']['output']>;
  /** Название */
  name: Scalars['String']['output'];
  /** Организаторы */
  organizers?: Maybe<Array<User>>;
  /** Индентификатор школы */
  schoolId: Scalars['ID']['output'];
  /** Дата начала регистрации */
  startRegisterDate?: Maybe<Scalars['DateTime']['output']>;
  /** Статус заявкм */
  status?: Maybe<ParticipantEventStatus>;
  /** Дата завершения регистрации */
  stopRegisterDate?: Maybe<Scalars['DateTime']['output']>;
  /** Оценка текущего студента */
  studentFeedback?: Maybe<StudentEventFeedback>;
  /** Дата обновления мероприятия */
  updateDate: Scalars['DateTime']['output'];
};

/** Мероприятие */
export type ActivityEventByStudentInputModel = {
  /** Инпут типа мероприятия */
  activityType: ActivityTypeInput;
  /** Дата начала */
  beginDate: Scalars['DateTime']['input'];
  /** Комментарий */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** Описание */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Дата окончания */
  endDate: Scalars['DateTime']['input'];
  /** Активен ли лист ожидания */
  isWaitListActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Место проведения */
  location: Scalars['String']['input'];
  /** Максимальное количество участников */
  maxStudentCount: Scalars['Int']['input'];
  /** Название */
  name: Scalars['String']['input'];
  /** Организаторы */
  organizers?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  /** Кампус для мероприятия */
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  /** Список параллелей для мероприятия */
  stages: Array<InputMaybe<Scalars['ID']['input']>>;
  /** Дата начала регистрации */
  startRegisterDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Дата завершения регистрации */
  stopRegisterDate?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Мероприятие */
export type ActivityEventInput = {
  /** Инпут типа мероприятия */
  activityType: ActivityTypeInput;
  /** Дата начала */
  beginDate: Scalars['DateTime']['input'];
  /** Список коалиций для мероприятия */
  coalitions: Array<InputMaybe<Scalars['ID']['input']>>;
  /** Комментарий */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** Описание */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Дата окончания */
  endDate: Scalars['DateTime']['input'];
  /** Является ли типом "Мероприятие с работодателем" */
  isEmployerMeeting?: InputMaybe<Scalars['Boolean']['input']>;
  /** Внутреннее/внешнее мероприятие */
  isInternal?: InputMaybe<Scalars['Boolean']['input']>;
  /** Обязательное ли мероприятие */
  isMandatory: Scalars['Boolean']['input'];
  /** Является ли встречей с потенциальным работодателем */
  isPotentialEmployer?: InputMaybe<Scalars['Boolean']['input']>;
  /** Потенциальный работодатель */
  isSberEmployer?: InputMaybe<Scalars['Boolean']['input']>;
  /** Видимость */
  isVisible: Scalars['Boolean']['input'];
  /** Активен ли лист ожидания */
  isWaitListActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Ключевые спикеры */
  keySpeakers?: InputMaybe<Scalars['String']['input']>;
  /** Список уровней студентов для мероприятия */
  levels: Array<InputMaybe<Scalars['ID']['input']>>;
  /** Место проведения */
  location: Scalars['String']['input'];
  /** Максимальное количество участников */
  maxStudentCount: Scalars['Int']['input'];
  /** Название */
  name: Scalars['String']['input'];
  /** Организаторы */
  organizers?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  /** Кампус для мероприятия */
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  /** Список классов по предмету для мероприятия */
  stageSubjectGroups: Array<InputMaybe<Scalars['ID']['input']>>;
  /** Список параллелей для мероприятия */
  stages: Array<InputMaybe<Scalars['ID']['input']>>;
  /** Дата начала регистрации */
  startRegisterDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Дата завершения регистрации */
  stopRegisterDate?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Тип мероприятия */
export type ActivityType = {
  __typename?: 'ActivityType';
  /** Категория */
  category: Scalars['String']['output'];
  /** Название */
  description: Scalars['String']['output'];
  /** Идентификатор типа */
  id: Scalars['ID']['output'];
};

export type ActivityTypeInput = {
  /** Категория */
  category?: InputMaybe<Scalars['String']['input']>;
  /** Название */
  description: Scalars['String']['input'];
  /** Идентификатор типа */
  id: Scalars['ID']['input'];
};

/** Для добавления урока */
export type AddLessonInput = {
  /** Идентификатор классной комнаты */
  classRoomId?: InputMaybe<Scalars['ID']['input']>;
  /** Дата проведения урока */
  date: Scalars['DateTime']['input'];
  /** Идентификатор интервала времени, в который проводится урок */
  lessonTimeslotId: Scalars['ID']['input'];
  /** Дата окончания создания повторов урока. Обязательно если repeatType не NONE */
  repeatLessonEndDate?: InputMaybe<Scalars['Date']['input']>;
  /** Тип повтора создания урока */
  repeatType: CreateLessonRepeat;
  /** Идентфикатор группы класса по предмету */
  stageSubjectGroupId: Scalars['ID']['input'];
  /** Идентификатор предмета */
  subjectId: Scalars['ID']['input'];
  /** Идентификатор учителя */
  teacherId: Scalars['UUID']['input'];
};

/** Результат выполнения запроса addStudyStepSubjectLearningActivitiesResult */
export type AddStudyStepSubjectLearningActivitiesResult = {
  __typename?: 'AddStudyStepSubjectLearningActivitiesResult';
  /** Результаты привязки элемента набора к предмету и уровню образования */
  studyStepSubjectLearningActivitiesAdditionResults: Array<StudyStepSubjectLearningActivitiesAdditionResult>;
  /** Список всех форм контроля */
  subjectLearningActivities: Array<StudyStepSubjectLearningActivities>;
};

export type AdditionalAttributes = {
  __typename?: 'AdditionalAttributes';
  /** Стоимость проверки (Code Review Points) */
  codeReviewCost?: Maybe<Scalars['Int']['output']>;
  /** Длительность проверки (код-ревью, в минутах) */
  codeReviewDuration?: Maybe<Scalars['Int']['output']>;
  codeReviewSkillPercentage: Array<SoftSkillPercentage>;
  cookiesCount: Scalars['Int']['output'];
  /** Включение/выключение ci/cd */
  enableCiCd?: Maybe<GitlabCiCdType>;
  /** Включение/выключение возможности возвращаться к предыдущим вопросам и изменять ответы */
  enableStepBack?: Maybe<Scalars['Boolean']['output']>;
  firstMistakeAuto: Scalars['Boolean']['output'];
  firstMistakeP2p: Scalars['Boolean']['output'];
  gitDockerImageName?: Maybe<Scalars['String']['output']>;
  groupSoftSkillPercentage: Array<SoftSkillPercentage>;
  /** Максимальное количество проверяющих (код-ревью) */
  maxCodeReviewCount?: Maybe<Scalars['Int']['output']>;
  p2pFormula: P2pFormulasType;
  percentageOfBonusAuto: Scalars['Int']['output'];
  percentageOfBonusP2p: Scalars['Int']['output'];
  percentageOfCompletion: Scalars['Int']['output'];
  percentageOfCompletionMentorCheck?: Maybe<Array<MentorFeedBacksPercentage>>;
  periodOfVerification: Scalars['Int']['output'];
  pointTask: Scalars['Int']['output'];
  /**
   * Количество требуемых проверок (код-ревью)
   * @deprecated Will be deleted. Use maxCodeReviewCount
   */
  requiredCodeReviewCount?: Maybe<Scalars['Int']['output']>;
  reviewUserCount: Scalars['Int']['output'];
  softSkillPercentage: Array<SoftSkillPercentage>;
  staffCheck: Scalars['Boolean']['output'];
  taskId: Scalars['ID']['output'];
};

/** Под удаление. Использовать AdditionalAttributesForTaskInput */
export type AdditionalAttributesInput = {
  /** Стоимость проверки (Code Review Points) */
  codeReviewCost?: InputMaybe<Scalars['Int']['input']>;
  /** Длительность проверки (код-ревью, в минутах) */
  codeReviewDuration?: InputMaybe<Scalars['Int']['input']>;
  codeReviewSkillPercentage?: InputMaybe<Array<SoftSkillPercentageInput>>;
  cookiesCount: Scalars['Int']['input'];
  /** Включение/выключение ci/cd */
  enableCiCd?: InputMaybe<GitlabCiCdType>;
  /** Включение/выключение возможности возвращаться к предыдущим вопросам и изменять ответы */
  enableStepBack?: InputMaybe<Scalars['Boolean']['input']>;
  firstMistakeAuto?: InputMaybe<Scalars['Boolean']['input']>;
  firstMistakeP2p?: InputMaybe<Scalars['Boolean']['input']>;
  groupSoftSkillPercentage: Array<SoftSkillPercentageInput>;
  /** Максимальное количество проверяющих (код-ревью) */
  maxCodeReviewCount?: InputMaybe<Scalars['Int']['input']>;
  p2pFormula: P2pFormulasType;
  percentageOfBonusAuto?: InputMaybe<Scalars['Int']['input']>;
  percentageOfBonusP2p?: InputMaybe<Scalars['Int']['input']>;
  percentageOfCompletion: Scalars['Int']['input'];
  percentageOfCompletionMentorCheck?: InputMaybe<Array<MentorCheckInput>>;
  periodOfVerification: Scalars['Int']['input'];
  pointTask: Scalars['Int']['input'];
  /** Количество требуемых проверок (код-ревью) */
  requiredCodeReviewCount?: InputMaybe<Scalars['Int']['input']>;
  reviewUserCount: Scalars['Int']['input'];
  softSkillPercentage: Array<SoftSkillPercentageInput>;
  staffCheck?: InputMaybe<Scalars['Boolean']['input']>;
  taskId: Scalars['ID']['input'];
};

/** Сущность с информацией о возможности назначения доп проверки по ответу студента */
export type AdditionalCheckButtonStateModel = {
  __typename?: 'AdditionalCheckButtonStateModel';
  /** Флаг с информацией о доступности кнопки */
  isButtonAvailable: Scalars['Boolean']['output'];
  /** Причина, по которой проверка не может быть назначена (null, если проверку назначить возможно) */
  message?: Maybe<Scalars['String']['output']>;
};

/** Модель, где название кампуса со списком логинов проверяющих */
export type AdditionalCheckCampus = {
  __typename?: 'AdditionalCheckCampus';
  /** Логины пользователей, которые могут быть назначены проверяющими (студенты + БА) */
  availableVerifiersLogins: Array<Scalars['String']['output']>;
  /** Название кампуса */
  campusName: Scalars['String']['output'];
  /** ID кампуса */
  schoolId: Scalars['UUID']['output'];
};

/** Модель с первоначальной информацией для назначения дополнительной проверки */
export type AdditionalCheckInitialData = {
  __typename?: 'AdditionalCheckInitialData';
  /** Сущность с информацией о возможности назначения доп проверки по ответу студента. NonNull но не ставим ! для обратной совместимости */
  additionalCheckButtonState?: Maybe<AdditionalCheckButtonStateModel>;
  /** Список кампусов с логинами проверяющих */
  additionalCheckCampuses: Array<AdditionalCheckCampus>;
  /**
   * Флаг для алерта, что дополнительная проверка не повлияет на рез-тат попытки, т.к одна из проверок (кроме P2P) завершена провалом
   * true - если проверка не повлияет на финальный результат
   * false - во всех остальных случаях (включая ситуацию, когда проект находится на стадии проверок)
   */
  additionalCheckWillNotAffectTheOverallAttemptResult: Scalars['Boolean']['output'];
  /** Кол-во минут, необходимых для проведения проверки */
  checkDurationMinutes: Scalars['Int']['output'];
  /** Идентификатор ответа студента */
  studentAnswerId: Scalars['ID']['output'];
};

/** Сущность инициации дополнительно проверки по ответу студента */
export type AdditionalCheckInitiationInputModel = {
  /** Дата окончания проверки */
  checkEnd: Scalars['DateTime']['input'];
  /** Дата начала проверки */
  checkStart: Scalars['DateTime']['input'];
  /** Тип дополнительной проверки */
  checkType: AdditionalCheckType;
  /** ID школы */
  schoolId: Scalars['UUID']['input'];
  /** Идентификатор ответа студента, для которого инициируется доп. проверка */
  studentAnswerId: Scalars['ID']['input'];
  /** Логин проверяющего */
  verifierLogin: Scalars['String']['input'];
};

/** Типы дополнительных проверок */
export enum AdditionalCheckType {
  /**
   * Экстра проверка
   * По смыслу не отличается от обычной проверки,
   * за исключением отсутствия ограничения по кол-ву проверок в конструкторе задания
   */
  Extra = 'EXTRA',
  /** Приоритетная проверка */
  Priority = 'PRIORITY'
}

/** Дополнительная информация про чек-лист */
export type AdditionalChecklist = {
  __typename?: 'AdditionalChecklist';
  /** Id заполненного чек-листа */
  filledChecklistId?: Maybe<Scalars['ID']['output']>;
  /** Этап заполненного чек-листа с отзывом */
  filledChecklistStageEnum?: Maybe<FilledChecklistStageEnum>;
  /** Id записи онлайн проверки */
  filledChecklistStatusRecordingEnum?: Maybe<FilledChecklistStatusRecordingEnum>;
};

export enum AdditionalContentFormat {
  Offline = 'OFFLINE',
  Online = 'ONLINE'
}

/** Учебные параллели для дополнительных материалов */
export enum AdditionalContentStage {
  /** 8-я параллель */
  Eighth = 'EIGHTH',
  /** 11-я параллель */
  Eleventh = 'ELEVENTH',
  /** 5-я параллель */
  Fifth = 'FIFTH',
  /** 1-я параллель */
  First = 'FIRST',
  /** Материал для всех параллелей */
  ForAll = 'FOR_ALL',
  /** 4-я параллель */
  Fourth = 'FOURTH',
  /** 9-я параллель */
  Ninth = 'NINTH',
  /** 2-я параллель */
  Second = 'SECOND',
  /** 7-я параллель */
  Seventh = 'SEVENTH',
  /** 6-я параллель */
  Sixth = 'SIXTH',
  /** 10-я параллель */
  Tenth = 'TENTH',
  /** 3-я параллель */
  Third = 'THIRD'
}

/** Типы дополнительного материала */
export enum AdditionalContentType {
  /** Аудио */
  Audio = 'AUDIO',
  /** Книга */
  Book = 'BOOK',
  /** Челлендж */
  Challenge = 'CHALLENGE',
  /** Кружок */
  Club = 'CLUB',
  /** Конкурс. */
  Contest = 'CONTEST',
  /** Курс */
  Course = 'COURSE',
  /** Документ (например, MS Word) */
  Document = 'DOCUMENT',
  /** Учебные материалы */
  EducationalMaterials = 'EDUCATIONAL_MATERIALS',
  /** Учебное задание-опросник */
  ExternalSurvey = 'EXTERNAL_SURVEY',
  /** Глобальный план */
  GlobalPlan = 'GLOBAL_PLAN',
  /** Изображение */
  Image = 'IMAGE',
  /** Ссылка на другой источник */
  Link = 'LINK',
  /** Учебный модуль */
  Module = 'MODULE',
  /** Олимпиада. */
  Olympiad = 'OLYMPIAD',
  /** Статья */
  Paper = 'PAPER',
  /** Учебное задание издательства Физикон */
  Physicon = 'PHYSICON',
  /** Плейлист */
  Playlist = 'PLAYLIST',
  /** Презентация */
  Presentation = 'PRESENTATION',
  /** Учебное задание издательства РосУчебник */
  RosUchebnik = 'ROS_UCHEBNIK',
  /** SCORM пакет */
  Scorm = 'SCORM',
  /** Учебное задание */
  Task = 'TASK',
  /** Учебное задание-тренажер */
  TrainingIntegration = 'TRAINING_INTEGRATION',
  /** Видео */
  Video = 'VIDEO'
}

/** Публичный профиль конфигуратора */
export type AdminBusinessPublicProfile = {
  __typename?: 'AdminBusinessPublicProfile';
  avatarUrl?: Maybe<Scalars['String']['output']>;
  contacts: Array<ContactData>;
  firstName: Scalars['String']['output'];
  functionalRoles: Array<FunctionalRoleData>;
  lastName: Scalars['String']['output'];
  middleName?: Maybe<Scalars['String']['output']>;
};

/** Дополнительная информация для агенды */
export type AgendaAdditionalInfo = {
  __typename?: 'AgendaAdditionalInfo';
  key?: Maybe<Scalars['String']['output']>;
  value?: Maybe<Scalars['String']['output']>;
};

export enum AgendaEntityType {
  Booking = 'BOOKING',
  Event = 'EVENT',
  StudentGoal = 'STUDENT_GOAL'
}

/** События для агенды s21 */
export type AgendaEvent = {
  __typename?: 'AgendaEvent';
  /** Дополнительная информация для агенды */
  additionalInfo?: Maybe<Array<AgendaAdditionalInfo>>;
  /** Тип мероприятия для отображения */
  agendaEventType: AgendaEventType;
  /** Сущность, по которой определяется какое это событие */
  agendaItemContext: AgendaItemContext;
  /** Описание события */
  description: Scalars['String']['output'];
  /** Дата и время завершения события */
  end: Scalars['DateTime']['output'];
  /** Заголовок события */
  label: Scalars['String']['output'];
  /** Дата и время начала события */
  start: Scalars['DateTime']['output'];
};

export enum AgendaEventType {
  Activity = 'ACTIVITY',
  CheckForVerifiable = 'CHECK_FOR_VERIFIABLE',
  CheckForVerifier = 'CHECK_FOR_VERIFIER',
  CodeReview = 'CODE_REVIEW',
  EmployerMeeting = 'EMPLOYER_MEETING',
  Exam = 'EXAM',
  ExtraAdditionalCheck = 'EXTRA_ADDITIONAL_CHECK',
  ExtraForVerifiable = 'EXTRA_FOR_VERIFIABLE',
  ExtraForVerifier = 'EXTRA_FOR_VERIFIER',
  ParticipantEvent = 'PARTICIPANT_EVENT',
  Penalty = 'PENALTY',
  PriorityAdditionalCheck = 'PRIORITY_ADDITIONAL_CHECK',
  PriorityForVerifiable = 'PRIORITY_FOR_VERIFIABLE',
  PriorityForVerifier = 'PRIORITY_FOR_VERIFIER',
  StaffCheckForVerifiable = 'STAFF_CHECK_FOR_VERIFIABLE',
  StaffExtraForVerifiable = 'STAFF_EXTRA_FOR_VERIFIABLE',
  StaffPriorityForVerifiable = 'STAFF_PRIORITY_FOR_VERIFIABLE',
  TeamCheckForVerifier = 'TEAM_CHECK_FOR_VERIFIER'
}

/** Сущность, по которой определяется какое это событие */
export type AgendaItemContext = {
  __typename?: 'AgendaItemContext';
  /** Идентификатор сущности (зависит от AgendaEntityType) */
  entityId: Scalars['ID']['output'];
  /** Тип идентификатора сущности */
  entityType: AgendaEntityType;
};

/** Агрегированные данные для диаграммы Радар (Паутинка) */
export type AggregatedSkillStudentRadarChart = {
  __typename?: 'AggregatedSkillStudentRadarChart';
  /** Агрегированные данные по цифровым навыкам */
  digitalSkillData: Array<StudentRadarChartBySkill>;
  /** Агрегированные данные по мягким навыкам */
  softSkillData: Array<StudentRadarChartBySkill>;
  stageGroupId: Scalars['ID']['output'];
  testCompleteResults: Array<Maybe<IsSelfAssessmentTestComplete>>;
  testFactComplete: Scalars['Boolean']['output'];
};

/** Агрегированные данные для диаграммы Радар (Паутинка) */
export type AggregatedStudentRadarChart = {
  __typename?: 'AggregatedStudentRadarChart';
  /** Агрегированные данные по предметам */
  subjectData: Array<StudentRadarChartBySubject>;
};

export type AgreementDataModel = {
  __typename?: 'AgreementDataModel';
  agreements: Array<Maybe<AgreementModel>>;
  isMarketAgreement: Scalars['Boolean']['output'];
  isPdnAgreement: Scalars['Boolean']['output'];
};

export type AgreementModel = {
  __typename?: 'AgreementModel';
  fileId: Scalars['UUID']['output'];
  fileName: Scalars['String']['output'];
  uploadDt: Scalars['DateTime']['output'];
};

export enum AmountTasksInStatusesEnum {
  /** Задание зачтено */
  Accepted = 'ACCEPTED',
  /** Все задания */
  AllStatuses = 'ALL_STATUSES',
  /** Назначено */
  Assigned = 'ASSIGNED',
  /** Количество карточек "Добавлен комментарий" */
  ByMessageTask = 'BY_MESSAGE_TASK',
  /** Задание провалено */
  Failed = 'FAILED',
  /** Задание в работе (прохождение тренажера) */
  InProgress = 'IN_PROGRESS',
  /** Требуется проверка учителем */
  NeedCheck = 'NEED_CHECK',
  /** Задачи на проверку с просроченным временем проверки */
  NeedCheckOverdue = 'NEED_CHECK_OVERDUE',
  /** Просроченные задания */
  OverdueTasks = 'OVERDUE_TASKS',
  /** Задание провалено, но у пользователя есть еще попытки его пройти */
  TryAgain = 'TRY_AGAIN'
}

export type AnalyticsDataAcademicPerformance = {
  __typename?: 'AnalyticsDataAcademicPerformance';
  /** Список рекомендованных профилей */
  recommendedProfiles?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Список рекомендованных предметов */
  recommendedSubjects?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Список успешно сданных предметов */
  successfulSubjects?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Список неуспешно сданных предметов */
  warningSubjects?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

export type AnswerBodyInput = {
  /** новое body для Кода */
  codeAnswerBody?: InputMaybe<CodeAnswerBodyInput>;
  /** Заполнение пропусков */
  fillingGapAnswerBody?: InputMaybe<FillingGapAnswerBodyInput>;
  /** Развернутый ответ */
  fullAnswerBody?: InputMaybe<FullAnswerBodyInput>;
  /** Соединение линиями */
  lineConnectorAnswerBody?: InputMaybe<LineConnectorAnswerBodyInput>;
  /** Отправляемый ответ на виджет "Таблица (выбор одного)" */
  matrixAnswerBody?: InputMaybe<MatrixAnswerBodyInput>;
  /** Отправляемый ответ на виджет "Таблица (множественный выбор)" */
  matrixDropdownAnswerBody?: InputMaybe<MatrixDropdownAnswerBodyInput>;
  /** Отправляемый ответ на виджет "Множественный выбор текста" */
  multipleTextAnswerBody?: InputMaybe<MultipleTextAnswerBodyInput>;
  /** ответ на scorm-задание */
  scormAnswerBody?: InputMaybe<ScormAnswerBodyInput>;
  /** Простой ответ */
  simpleAnswerBody?: InputMaybe<SimpleAnswerBodyInput>;
  /** Сортировка */
  sortableAnswerBody?: InputMaybe<SortableAnswerBodyInput>;
  /** Ответ на тест */
  testAnswerBody?: InputMaybe<TestAnswerBodyInput>;
};

export type AnswerFile = {
  __typename?: 'AnswerFile';
  /** Ссылка на файл ответа */
  link: Scalars['String']['output'];
  /** Имя файла ответа */
  name: Scalars['String']['output'];
};

/** Информация о состоянии закрывающего теста после сохранения ответа на задание из теста */
export type AnswerRelatedGoalLevelTestProgressInfo = {
  __typename?: 'AnswerRelatedGoalLevelTestProgressInfo';
  /** Закрывающий тест в контексте студента */
  studentGoalLevelTest: StudentGoalLevelTest;
};

/** Информация о текущем состоянии Домашней Работы, с которой связан данный ответ на Задание */
export type AnswerRelatedHomeworkProgressInfo = {
  __typename?: 'AnswerRelatedHomeworkProgressInfo';
  /** Признак выполненности Домашней Работы */
  isComplete: Scalars['Boolean']['output'];
};

/** статус ответа ученика */
export enum AnswerStatusEnum {
  /** принято */
  Accepted = 'ACCEPTED',
  /** на проверке */
  CheckInProgress = 'CHECK_IN_PROGRESS',
  /** не принято, пробуй другое */
  RejectedFinal = 'REJECTED_FINAL',
  /** не принято, пробуй еще */
  RejectedTryAgain = 'REJECTED_TRY_AGAIN',
  /** Ожидает назначения проверяющих */
  WaitingForReviewers = 'WAITING_FOR_REVIEWERS',
  /** отозван */
  Withdrawn = 'WITHDRAWN'
}

export type AnswerToWidgetInput = {
  /** Композиционный тип для тела ответа на виджет */
  answerBody?: InputMaybe<AnswerBodyInput>;
  /** Файлы, прикрепленные к ответу на виджет */
  files?: InputMaybe<Array<FileInput>>;
  /** Идентификатор варианта вопроса тренажера */
  variantId?: InputMaybe<Scalars['String']['input']>;
  /** Тип группы виджетов */
  widgetGroupType: WidgetGroupTypeEnum;
  /** Идентификатор виджета */
  widgetId: Scalars['UUID']['input'];
  /** Тип виджета */
  widgetType: WidgetTypeEnum;
};

export type ApiMigrationMutations = {
  __typename?: 'ApiMigrationMutations';
  /** Массовое объявление заданий выполненными */
  acceptTaskBatch: Scalars['Boolean']['output'];
  assignGlobalContentForSystemAdmins: SystemAdminMigrationResult;
  /**
   * мигрировать книги из Контент-сервиса в сервис Каталога (создается описание в каталоге, сами книги остаются в контенте)
   * @deprecated Использовать initQueue/migrateUsingQueue/deleteQueue
   */
  bookToCatalogItem: MigrationToCatalogResult;
  /** Массовое изменение статусов заданий и последних статусов ответов по этим заданиям */
  changeTaskStatusAndAnswerStatusBatch: Scalars['Boolean']['output'];
  /** Массовое создание read facts */
  createTaskMessageReadFacts: Scalars['Boolean']['output'];
  /** удалить очередь на миграцию */
  deleteQueue: Scalars['Int']['output'];
  /**
   * Закрыть модуль
   * SM-8499
   */
  directAchieveBatch: Scalars['Boolean']['output'];
  /**
   * мигрировать внешние задания из Контент-сервиса в сервис Каталога (создается описание в каталоге)
   * @deprecated Использовать initQueue/migrateUsingQueue/deleteQueue
   */
  externalTaskToCatalogItem: MigrationToCatalogResult;
  /** корректировка EDUCATION_SUBJECT/SUBJECT_NAME, EDUCATION_STAGE/STAGE_NAME */
  fixCatalogSubject: CatalogFixResult;
  globalModuleCatalogItemTenantFix: MigrationToCatalogResult;
  /** Исправление тенантов глобальных заданий в каталоге */
  globalTaskCatalogItemTenantFix: MigrationToCatalogResult;
  /** инициализация очереди на миграцию */
  initQueue: Scalars['Int']['output'];
  migrateGameTasks: Scalars['Int']['output'];
  /** Миграция заметок к модулю, возвращает количество модулей, для которых заметки еще не были смигрированы */
  migrateGoalNotesFromMongoToPG: Scalars['Int']['output'];
  /** Миграция тенантов модуля в контент сервисе, возвращает количество несмигрированных модулей. */
  migrateGoalTenant: Scalars['Int']['output'];
  /** Миграция отсутствующих модулей в каталог */
  migrateGoalsToCatalog: Scalars['Int']['output'];
  /** Миграция python-заданий в WidgetCode(MIXED) */
  migratePythonTasks: Scalars['Int']['output'];
  /** Миграция scorm-заданий в generic */
  migrateScormTasks: Scalars['Int']['output'];
  /** Тестирование миграции запускаемой из batch сервиса */
  migrateStartBatch: Scalars['Int']['output'];
  /**
   * Выполнение миграции ответов ученика
   * SM-8348
   */
  migrateStudentAnswerContentsFromPGToMongo: Scalars['Boolean']['output'];
  /**
   * Миграция по дублированию ответов на ЗТ в витрину student_answers_showcase,
   * возвращает оставшееся количество несмигрированных записей в edu_power_shard.xref_student_goal_level_test_attempt_2_task
   * @deprecated Мутация создана для разового выполнения миграции; EDU-66327
   */
  migrateStudentTaskAttemptToStudentAnswersShowcase: Scalars['Int']['output'];
  /** Миграция HTML-контента из survey в generic */
  migrateSurveyHTMLContentToGeneric: Scalars['Int']['output'];
  /** Миграция JSON-контента из survey в generic */
  migrateSurveyJSONContentToGeneric: Scalars['Int']['output'];
  /** Миграция контента заданий из mongo в postgres, возвращает количество несмигрированных заданий. */
  migrateTaskContentToPostgres: Scalars['Int']['output'];
  /** Миграция заметок к заданию, возвращает количество заданий, для которых заметки еще не были смигрированы */
  migrateTaskNotesFromMongoToPG: Scalars['Int']['output'];
  /** Миграция тенантов задания в контент сервисе, возвращает количество несмигрированных заданий. */
  migrateTaskTenant: Scalars['Int']['output'];
  /** Миграция отсутствующих заданий в каталог */
  migrateTasksToCatalog: Scalars['Int']['output'];
  /** миграция контента в каталог */
  migrateUsingQueue: MigrationToCatalogResultV2;
  /**
   * мигрировать учебные модули из Контент-сервиса в сервис Каталога (создается описание в каталоге, сами модули остаются в контенте)
   * @deprecated Использовать initQueue/migrateUsingQueue/deleteQueue
   */
  moduleToCatalogItem: MigrationToCatalogResult;
  /** Ручной запрос обработки событий связанных с Персональными Целями (в случае если основной механизм по какой-то причине его не обработал) */
  processPersonalObjectiveRelatedEventsManually: Scalars['Boolean']['output'];
  /** Пересчет количества попыток ответить на задание */
  retryCountRecalculation: Scalars['Boolean']['output'];
  /**
   *     public void syncGoals(final List<Long> goalIds, final boolean syncTasks) {
   * Миграция тенантов задания в контент сервисе, возвращает количество несмигрированных заданий.
   */
  syncGoals: Scalars['Boolean']['output'];
  /**
   * мигрировать задания из Контент-сервиса в сервис Каталога (создается описание в каталоге, сами задания остаются в контенте)
   * @deprecated Использовать initQueue/migrateUsingQueue/deleteQueue
   */
  taskToCatalogItem: MigrationToCatalogResult;
};


export type ApiMigrationMutationsAcceptTaskBatchArgs = {
  migrationCallName: Scalars['String']['input'];
  pairs: Array<Student2TaskPairForAcceptInput>;
};


export type ApiMigrationMutationsBookToCatalogItemArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type ApiMigrationMutationsChangeTaskStatusAndAnswerStatusBatchArgs = {
  migrationCallName: Scalars['String']['input'];
  taskStatusAndAnswerStatusList: Array<InputMaybe<TaskStatusAndAnswerStatusForChangeInput>>;
};


export type ApiMigrationMutationsCreateTaskMessageReadFactsArgs = {
  dateUntil: Scalars['Date']['input'];
  messageCount: Scalars['Int']['input'];
};


export type ApiMigrationMutationsDeleteQueueArgs = {
  entityType: ContentMigrationEntityType;
};


export type ApiMigrationMutationsDirectAchieveBatchArgs = {
  goalId: Scalars['ID']['input'];
  students: Array<Scalars['UUID']['input']>;
};


export type ApiMigrationMutationsExternalTaskToCatalogItemArgs = {
  dateFrom?: InputMaybe<Scalars['Date']['input']>;
  dateTo?: InputMaybe<Scalars['Date']['input']>;
  externalTaskId?: InputMaybe<Scalars['ID']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type ApiMigrationMutationsFixCatalogSubjectArgs = {
  contentId?: InputMaybe<Scalars['Int']['input']>;
  dateFrom?: InputMaybe<Scalars['Date']['input']>;
  dateTimeFrom?: InputMaybe<Scalars['DateTime']['input']>;
  dateTimeTo?: InputMaybe<Scalars['DateTime']['input']>;
  dateTo?: InputMaybe<Scalars['Date']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type ApiMigrationMutationsGlobalTaskCatalogItemTenantFixArgs = {
  end?: InputMaybe<Scalars['Date']['input']>;
  start?: InputMaybe<Scalars['Date']['input']>;
};


export type ApiMigrationMutationsInitQueueArgs = {
  dateFrom?: InputMaybe<Scalars['Date']['input']>;
  dateTo?: InputMaybe<Scalars['Date']['input']>;
  entityType: ContentMigrationEntityType;
};


export type ApiMigrationMutationsMigrateGameTasksArgs = {
  batchSize: Scalars['Int']['input'];
  migrationCallName: Scalars['String']['input'];
};


export type ApiMigrationMutationsMigrateGoalNotesFromMongoToPgArgs = {
  batchSize: Scalars['Int']['input'];
  migrationCallName: Scalars['String']['input'];
};


export type ApiMigrationMutationsMigrateGoalTenantArgs = {
  batchSize: Scalars['Int']['input'];
  catalogPageSize?: InputMaybe<Scalars['Int']['input']>;
  migrationCallName: Scalars['String']['input'];
};


export type ApiMigrationMutationsMigrateGoalsToCatalogArgs = {
  batchSize: Scalars['Int']['input'];
  catalogPageSize?: InputMaybe<Scalars['Int']['input']>;
  migrationCallName: Scalars['String']['input'];
};


export type ApiMigrationMutationsMigratePythonTasksArgs = {
  batchSize: Scalars['Int']['input'];
  goalIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  migrationCallName: Scalars['String']['input'];
  taskIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  tenantIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
};


export type ApiMigrationMutationsMigrateScormTasksArgs = {
  batchSize: Scalars['Int']['input'];
  goalIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  migrationCallName: Scalars['String']['input'];
  taskIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  tenantIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
};


export type ApiMigrationMutationsMigrateStartBatchArgs = {
  migrationCallName: Scalars['String']['input'];
};


export type ApiMigrationMutationsMigrateStudentAnswerContentsFromPgToMongoArgs = {
  amount: Scalars['Int']['input'];
};


export type ApiMigrationMutationsMigrateStudentTaskAttemptToStudentAnswersShowcaseArgs = {
  batchSize: Scalars['Int']['input'];
  migrationCallName: Scalars['String']['input'];
};


export type ApiMigrationMutationsMigrateSurveyHtmlContentToGenericArgs = {
  batchSize: Scalars['Int']['input'];
  goalIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  migrationCallName: Scalars['String']['input'];
  taskIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  tenantIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
};


export type ApiMigrationMutationsMigrateSurveyJsonContentToGenericArgs = {
  batchSize: Scalars['Int']['input'];
  goalIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  migrationCallName: Scalars['String']['input'];
  taskIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  tenantIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
};


export type ApiMigrationMutationsMigrateTaskContentToPostgresArgs = {
  batchSize: Scalars['Int']['input'];
  migrationCallName: Scalars['String']['input'];
};


export type ApiMigrationMutationsMigrateTaskNotesFromMongoToPgArgs = {
  batchSize: Scalars['Int']['input'];
  migrationCallName: Scalars['String']['input'];
};


export type ApiMigrationMutationsMigrateTaskTenantArgs = {
  batchSize: Scalars['Int']['input'];
  catalogPageSize?: InputMaybe<Scalars['Int']['input']>;
  migrationCallName: Scalars['String']['input'];
};


export type ApiMigrationMutationsMigrateTasksToCatalogArgs = {
  batchSize: Scalars['Int']['input'];
  catalogPageSize?: InputMaybe<Scalars['Int']['input']>;
  migrationCallName: Scalars['String']['input'];
};


export type ApiMigrationMutationsMigrateUsingQueueArgs = {
  entityType: ContentMigrationEntityType;
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type ApiMigrationMutationsModuleToCatalogItemArgs = {
  dateFrom?: InputMaybe<Scalars['Date']['input']>;
  dateTimeFrom?: InputMaybe<Scalars['DateTime']['input']>;
  dateTimeTo?: InputMaybe<Scalars['DateTime']['input']>;
  dateTo?: InputMaybe<Scalars['Date']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  moduleId?: InputMaybe<Scalars['ID']['input']>;
  periodAsDateModify?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ApiMigrationMutationsProcessPersonalObjectiveRelatedEventsManuallyArgs = {
  eventIds: Array<Scalars['UUID']['input']>;
};


export type ApiMigrationMutationsRetryCountRecalculationArgs = {
  migrationCallName: Scalars['String']['input'];
  studentTaskIds: Array<Scalars['ID']['input']>;
};


export type ApiMigrationMutationsSyncGoalsArgs = {
  goalIds: Array<Scalars['Int']['input']>;
  syncTasks: Scalars['Boolean']['input'];
};


export type ApiMigrationMutationsTaskToCatalogItemArgs = {
  dateFrom?: InputMaybe<Scalars['Date']['input']>;
  dateTimeFrom?: InputMaybe<Scalars['DateTime']['input']>;
  dateTimeTo?: InputMaybe<Scalars['DateTime']['input']>;
  dateTo?: InputMaybe<Scalars['Date']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  taskId?: InputMaybe<Scalars['ID']['input']>;
};

export type ApiMigrationQueries = {
  __typename?: 'ApiMigrationQueries';
  /** Возвращает количество книг, не синхронизированных с сервисом каталога */
  countBooksNotSyncedWithCatalog: Scalars['Int']['output'];
  /** Возвращает количество модулей, не синхронизированных с сервисом каталога */
  countModulesNotSyncedWithCatalog: Scalars['Int']['output'];
  /**
   * Возвращает количество ответов, которые необходимо мигрировать
   * SM-8348
   */
  countStudentAnswersWithContentInPG: Scalars['Int']['output'];
  /** Возвращает количество сообщений, по которым еще не созданы read facts */
  countTaskMessagesForCreationReadFact: Scalars['Int']['output'];
  /** Возвращает количество заданий, не синхронизированных с сервисом каталога */
  countTasksNotSyncedWithCatalog: Scalars['Int']['output'];
};


export type ApiMigrationQueriesCountModulesNotSyncedWithCatalogArgs = {
  dateTimeFrom?: InputMaybe<Scalars['DateTime']['input']>;
  dateTimeTo?: InputMaybe<Scalars['DateTime']['input']>;
  periodAsDateModify?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ApiMigrationQueriesCountTaskMessagesForCreationReadFactArgs = {
  dateUntil: Scalars['Date']['input'];
};


export type ApiMigrationQueriesCountTasksNotSyncedWithCatalogArgs = {
  dateTimeFrom?: InputMaybe<Scalars['DateTime']['input']>;
  dateTimeTo?: InputMaybe<Scalars['DateTime']['input']>;
};

export type ApplicationBuildInfo = {
  __typename?: 'ApplicationBuildInfo';
  /** ArtifactId приложения */
  artifactId?: Maybe<Scalars['String']['output']>;
  /** Branch в гите, из которого была запущена сборка */
  branch?: Maybe<Scalars['String']['output']>;
  /** Дата сборки */
  buildDate?: Maybe<Scalars['DateTime']['output']>;
  /** Номер сборки из jenkins */
  buildNumber?: Maybe<Scalars['String']['output']>;
  /** Id последнего коммита в ветке, из которой собиралось приложение */
  commitId?: Maybe<Scalars['String']['output']>;
  /** Автор последнего коммита в ветке, из которой собиралось приложение */
  commitUserName?: Maybe<Scalars['String']['output']>;
  /** Версия миграции flyway */
  flywayMigrationVersions?: Maybe<Array<FlywayMigrationVersion>>;
  /** Теги, с которыми запускалась сборка */
  tags?: Maybe<Scalars['String']['output']>;
};

/** Build info приложения, микросервиса или модуля, в котором хранится информация о сборке, версии, миграции flyway и т.п. */
export type ApplicationInfo = {
  __typename?: 'ApplicationInfo';
  /** Информация о сборке приложения */
  applicationBuildInfo?: Maybe<ApplicationBuildInfo>;
  /** Название приложения */
  applicationName: Scalars['String']['output'];
  /** В случае если при вызове данного сервиса упала ошибка, то она передается в это поле, applicationBuildInfo при этом приходит пустой */
  error?: Maybe<Scalars['String']['output']>;
};

export type AreaPolygon = {
  __typename?: 'AreaPolygon';
  areaFiasId: Scalars['UUID']['output'];
  areaName: Scalars['String']['output'];
  areaPolygonId?: Maybe<Scalars['UUID']['output']>;
  areaShortName: Scalars['String']['output'];
  centerPoint?: Maybe<Scalars['String']['output']>;
  isCity: Scalars['Boolean']['output'];
  mapMetrics: MapMetrics;
  polygon?: Maybe<Scalars['String']['output']>;
};

export type AssignTaskSetToStudentRequest = {
  /** флаг - проверять аффектит ли учебный процесс студента изменение плейлиста */
  isNeedToCheckAffecting: Scalars['Boolean']['input'];
  /** идентификатор Учебного Модуля (goals.goal_id) */
  moduleId: Scalars['ID']['input'];
  /** идентмфикатор Студента (students.student_id) */
  studentId: Scalars['UUID']['input'];
  /** идентифкатор Набора Заданий (base_playlists.base_playlist_id) или (teacher_playlists.teacher_playlist_id) */
  taskSetId: Scalars['ID']['input'];
  /** тип Набора Заданий */
  taskSetType: PlaylistType;
};

export type AssignTaskSetToStudentResponse = {
  __typename?: 'AssignTaskSetToStudentResponse';
  /** успешно ли выполнение запроса (пройдены ли все проверки) */
  isSuccess: Scalars['Boolean']['output'];
  /** Персонализированный Учебный Модуль */
  module?: Maybe<StudentModule>;
  /** Все Плейлисты доступные Учителю по этому Учебному Модулю, как Учительские так и Базовые */
  taskSets?: Maybe<Array<TaskSet>>;
};

/** Запрос на назначение Студенту в Подгруппе Варианта Контрольной Работы на Группу по Предмету */
export type AssignVariantToStudentRequest = {
  /** идентификатор Варианта Контрольной Работы, который назначен ученику (stage_subject_group_control_work_variants.stage_subect_group_control_work_variant_id) */
  classSubjectControlWorkVariantId: Scalars['ID']['input'];
  /** идентификатор Студента в Подгруппе (stage_subject_subgroup_students.stage_subject_subgroup_student_id) */
  studentInSubgroupId: Scalars['ID']['input'];
};

/** Механика назначения (учитель/ученик, система/ученик, etc.) */
export type AssignmentType = {
  __typename?: 'AssignmentType';
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
};

export type AssistantDisplayType = {
  __typename?: 'AssistantDisplayType';
  /** Позиция картинки Ассистента */
  assistantPosition: AssistantPosition;
  /** Тип отображения Ассистента */
  assistantType: AssistantType;
};

export type AssistantDisplayType3D = {
  __typename?: 'AssistantDisplayType3D';
  /** Состояние ассистента (для выбора текста) */
  assistantState3D: AssistantState;
  /** Тип анимации Ассистента */
  assistantType3D: AssistantType3D;
};

export enum AssistantPosition {
  Right = 'RIGHT',
  Up = 'UP'
}

export enum AssistantState {
  GeCompletedThreeInRow = 'GE_COMPLETED_THREE_IN_ROW',
  /** уже неактуален */
  GeError = 'GE_ERROR',
  GeFailedThreeInRow = 'GE_FAILED_THREE_IN_ROW',
  GeFinishedGoNext = 'GE_FINISHED_GO_NEXT',
  GeFinishedLevelComplete = 'GE_FINISHED_LEVEL_COMPLETE',
  /** уже неактуален */
  GeFinishedLevelCompleteGoNext = 'GE_FINISHED_LEVEL_COMPLETE_GO_NEXT',
  GeFinishedLevelCompleteModuleFinished = 'GE_FINISHED_LEVEL_COMPLETE_MODULE_FINISHED',
  GeFinishIsSoon = 'GE_FINISH_IS_SOON',
  /** уже неактуален */
  GeNotFinishedLevelComplete = 'GE_NOT_FINISHED_LEVEL_COMPLETE',
  /** уже неактуален */
  GeStartWithEssential = 'GE_START_WITH_ESSENTIAL',
  GeStartWithEssentialAndAdditional = 'GE_START_WITH_ESSENTIAL_AND_ADDITIONAL',
  GeStartWithEssentialNoAdditional = 'GE_START_WITH_ESSENTIAL_NO_ADDITIONAL',
  LevelError = 'LEVEL_ERROR',
  LevelFirstChoiceWithoutMt = 'LEVEL_FIRST_CHOICE_WITHOUT_MT',
  LevelFirstChoiceWithMt = 'LEVEL_FIRST_CHOICE_WITH_MT',
  LevelNewChoice = 'LEVEL_NEW_CHOICE',
  ModuleError = 'MODULE_ERROR',
  ModuleFinishedAuto = 'MODULE_FINISHED_AUTO',
  ModuleFinishedAutoWithoutReflection = 'MODULE_FINISHED_AUTO_WITHOUT_REFLECTION',
  ModuleFinishedAutoWithoutReport = 'MODULE_FINISHED_AUTO_WITHOUT_REPORT',
  ModuleFinishedAutoWithoutReportWithoutReflection = 'MODULE_FINISHED_AUTO_WITHOUT_REPORT_WITHOUT_REFLECTION',
  ModuleFinishedByTeacher = 'MODULE_FINISHED_BY_TEACHER',
  ModuleFinishedByTeacherWithoutReport = 'MODULE_FINISHED_BY_TEACHER_WITHOUT_REPORT',
  ModuleFinishedByTeacherWithComment = 'MODULE_FINISHED_BY_TEACHER_WITH_COMMENT',
  ModuleFinishedByTeacherWithCommentWithoutReport = 'MODULE_FINISHED_BY_TEACHER_WITH_COMMENT_WITHOUT_REPORT',
  ModuleFinishedByTest = 'MODULE_FINISHED_BY_TEST',
  ModuleFinishedByTestWithoutReflection = 'MODULE_FINISHED_BY_TEST_WITHOUT_REFLECTION',
  ModuleFinishedByTestWithoutReport = 'MODULE_FINISHED_BY_TEST_WITHOUT_REPORT',
  ModuleFinishedByTestWithoutReportWithoutReflection = 'MODULE_FINISHED_BY_TEST_WITHOUT_REPORT_WITHOUT_REFLECTION',
  ModuleHardNoTime = 'MODULE_HARD_NO_TIME',
  ModuleInProgress = 'MODULE_IN_PROGRESS',
  ModuleLandingHardDeadlineWithoutMt = 'MODULE_LANDING_HARD_DEADLINE_WITHOUT_MT',
  ModuleLandingHardDeadlineWithMt = 'MODULE_LANDING_HARD_DEADLINE_WITH_MT',
  ModuleLandingNotMuchTimeLeft = 'MODULE_LANDING_NOT_MUCH_TIME_LEFT',
  ModuleLandingNotMuchTimeLeftWithoutMt = 'MODULE_LANDING_NOT_MUCH_TIME_LEFT_WITHOUT_MT',
  /** уже неактуален */
  ModuleLandingNotMuchTimeLeftWithMt = 'MODULE_LANDING_NOT_MUCH_TIME_LEFT_WITH_MT',
  ModuleLandingOffPlanWithoutMt = 'MODULE_LANDING_OFF_PLAN_WITHOUT_MT',
  ModuleLandingOffPlanWithMt = 'MODULE_LANDING_OFF_PLAN_WITH_MT',
  ModuleLandingSoftNoTime = 'MODULE_LANDING_SOFT_NO_TIME',
  ModuleLandingWithoutMt = 'MODULE_LANDING_WITHOUT_MT',
  ModuleLandingWithMt = 'MODULE_LANDING_WITH_MT',
  ModuleLevelFinished = 'MODULE_LEVEL_FINISHED',
  /** уже неактуален */
  ModuleNoTasksNoMail = 'MODULE_NO_TASKS_NO_MAIL',
  ModuleNoTasksWithMail = 'MODULE_NO_TASKS_WITH_MAIL',
  ModuleWithTrajectoryNotMuchTimeLeft = 'MODULE_WITH_TRAJECTORY_NOT_MUCH_TIME_LEFT',
  ModuleWithTrajectorySoftNoTime = 'MODULE_WITH_TRAJECTORY_SOFT_NO_TIME'
}

/** GE - goal element - Элемент Цели */
export enum AssistantType {
  CoolProgress = 'COOL_PROGRESS',
  EasyToFinish = 'EASY_TO_FINISH',
  FinishAdvancedGe = 'FINISH_ADVANCED_GE',
  FirstBaseGe = 'FIRST_BASE_GE',
  FirstConfidentGe = 'FIRST_CONFIDENT_GE',
  FirstRecommendedConfidentGe = 'FIRST_RECOMMENDED_CONFIDENT_GE',
  GoingByPlan = 'GOING_BY_PLAN',
  GoingCool = 'GOING_COOL',
  KeepItUp = 'KEEP_IT_UP',
  LastBaseGe = 'LAST_BASE_GE',
  LastConfidentGe = 'LAST_CONFIDENT_GE',
  LevelIsAlmostDone = 'LEVEL_IS_ALMOST_DONE',
  NextEasyGoal = 'NEXT_EASY_GOAL',
  NextGoal = 'NEXT_GOAL',
  NotMuchLeft = 'NOT_MUCH_LEFT',
  YouAreSmart = 'YOU_ARE_SMART',
  YouAreSmartAndNotMuchLeft = 'YOU_ARE_SMART_AND_NOT_MUCH_LEFT'
}

export enum AssistantType3D {
  AssistantApplause = 'ASSISTANT_APPLAUSE',
  AssistantCool = 'ASSISTANT_COOL',
  AssistantCry = 'ASSISTANT_CRY',
  AssistantFacepalm = 'ASSISTANT_FACEPALM',
  AssistantHappyJump = 'ASSISTANT_HAPPY_JUMP',
  AssistantHeart = 'ASSISTANT_HEART',
  AssistantHighFive = 'ASSISTANT_HIGH_FIVE',
  AssistantKissing = 'ASSISTANT_KISSING',
  AssistantNervous = 'ASSISTANT_NERVOUS',
  AssistantOk = 'ASSISTANT_OK',
  AssistantShrekEyes = 'ASSISTANT_SHREK_EYES',
  AssistantThinking = 'ASSISTANT_THINKING'
}

/** Информация о группе асинхронных задач публикации программы/направления */
export type AsyncExecutionData = {
  __typename?: 'AsyncExecutionData';
  /** Процент завершенных асинхронных задач по группе задач */
  percent: Scalars['Float']['output'];
  /** Статистическая информация о задачах группы */
  taskByStatuses: Array<AsyncTasksStatusCount>;
  /** Идентификатор группы асинхронных задач на публикацию */
  taskGroupId: Scalars['ID']['output'];
};

export type AsyncReport = {
  __typename?: 'AsyncReport';
  columns: Array<AsyncReportColumn>;
  reportId: Scalars['Int']['output'];
  rows: Array<Scalars['JsonNode']['output']>;
};

export type AsyncReportColumn = {
  __typename?: 'AsyncReportColumn';
  childColumnNames?: Maybe<Array<Scalars['String']['output']>>;
  description: Scalars['String']['output'];
  name: Scalars['String']['output'];
  type?: Maybe<AsyncReportParamType>;
};

export enum AsyncReportGroup {
  Content = 'CONTENT',
  DiscoverUnknown_2021 = 'DISCOVER_UNKNOWN_2021',
  UsersActivity = 'USERS_ACTIVITY'
}

export type AsyncReportInputParamModel = {
  name: Scalars['String']['input'];
  val?: InputMaybe<Scalars['String']['input']>;
  value: Scalars['String']['input'];
};

/** Элемент списка отчетов */
export type AsyncReportItem = {
  __typename?: 'AsyncReportItem';
  batchJobId?: Maybe<Scalars['String']['output']>;
  created: Scalars['DateTime']['output'];
  description: Scalars['String']['output'];
  excelFile?: Maybe<Scalars['String']['output']>;
  /** @deprecated Use scheduleId */
  mailingId?: Maybe<Scalars['Int']['output']>;
  modified?: Maybe<Scalars['DateTime']['output']>;
  parameters: Array<ParamValue>;
  reportId: Scalars['Int']['output'];
  scheduleId?: Maybe<Scalars['Int']['output']>;
  scheduleStatus: AsyncReportMailingStatus;
  status: AsyncReportStatus;
  type: AsyncReportName;
  userName: Scalars['String']['output'];
};

export type AsyncReportMailingStatus = {
  __typename?: 'AsyncReportMailingStatus';
  status: Scalars['String']['output'];
  statusCode: AsyncReportScheduleStatusEnum;
  statusTime: Scalars['DateTime']['output'];
};

export type AsyncReportMailingStatusByUsers = {
  __typename?: 'AsyncReportMailingStatusByUsers';
  status: Scalars['String']['output'];
  statusTime: Scalars['DateTime']['output'];
  userToId: Scalars['UUID']['output'];
};

/** Мутаторы асинхронных отчетов */
export type AsyncReportMutations = {
  __typename?: 'AsyncReportMutations';
  /** Отправить список событий */
  createAsyncReport: AsyncReportResponse;
  /** Создать рассылку асинхронных отчетов */
  createReportSchedule: Scalars['Int']['output'];
  /** false если отчет уже удален. */
  deleteAsyncReport?: Maybe<Scalars['Boolean']['output']>;
  /** Удаление рассылки */
  deleteSchedule: Scalars['Boolean']['output'];
  /** Приостановка рассылки */
  pauseSchedule: Scalars['Boolean']['output'];
  /** Повторная отправка отчета пользователю */
  sendReportToUser: Scalars['Int']['output'];
  /** Рассылка отчета пользователям */
  sendReportToUsers: Scalars['Int']['output'];
  /** Запуск рассылки */
  startSchedule: Scalars['Boolean']['output'];
  /** Обновить рассылку асинхронных отчетов */
  updateReportSchedule: Scalars['Boolean']['output'];
  /** Обновить список получателей рассылки асинхронных отчетов */
  updateReportScheduleRecipients: Scalars['Boolean']['output'];
};


/** Мутаторы асинхронных отчетов */
export type AsyncReportMutationsCreateAsyncReportArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  params: Array<AsyncReportInputParamModel>;
  report?: InputMaybe<AsyncReportName>;
};


/** Мутаторы асинхронных отчетов */
export type AsyncReportMutationsCreateReportScheduleArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  firstRun: Scalars['DateTime']['input'];
  lastRun: Scalars['DateTime']['input'];
  name: Scalars['String']['input'];
  params: Array<AsyncReportInputParamModel>;
  recipients: Array<Scalars['UUID']['input']>;
  reportType: AsyncReportName;
  scheduleCron: ScheduleCron;
};


/** Мутаторы асинхронных отчетов */
export type AsyncReportMutationsDeleteAsyncReportArgs = {
  reportId: Scalars['Int']['input'];
};


/** Мутаторы асинхронных отчетов */
export type AsyncReportMutationsDeleteScheduleArgs = {
  reportScheduleId: Scalars['Int']['input'];
};


/** Мутаторы асинхронных отчетов */
export type AsyncReportMutationsPauseScheduleArgs = {
  reportScheduleId: Scalars['Int']['input'];
};


/** Мутаторы асинхронных отчетов */
export type AsyncReportMutationsSendReportToUserArgs = {
  asyncReportId: Scalars['Int']['input'];
  userId: Scalars['UUID']['input'];
};


/** Мутаторы асинхронных отчетов */
export type AsyncReportMutationsSendReportToUsersArgs = {
  asyncReportId: Scalars['Int']['input'];
  userIds: Array<Scalars['UUID']['input']>;
};


/** Мутаторы асинхронных отчетов */
export type AsyncReportMutationsStartScheduleArgs = {
  reportScheduleId: Scalars['Int']['input'];
};


/** Мутаторы асинхронных отчетов */
export type AsyncReportMutationsUpdateReportScheduleArgs = {
  firstRun: Scalars['DateTime']['input'];
  lastRun: Scalars['DateTime']['input'];
  name: Scalars['String']['input'];
  params: Array<AsyncReportInputParamModel>;
  recipientsToAdd?: InputMaybe<Array<Scalars['UUID']['input']>>;
  recipientsToRemove?: InputMaybe<Array<Scalars['UUID']['input']>>;
  reportScheduleId: Scalars['Int']['input'];
  reportType: AsyncReportName;
};


/** Мутаторы асинхронных отчетов */
export type AsyncReportMutationsUpdateReportScheduleRecipientsArgs = {
  recipientsToAdd?: InputMaybe<Array<Scalars['UUID']['input']>>;
  recipientsToRemove?: InputMaybe<Array<Scalars['UUID']['input']>>;
  reportScheduleId: Scalars['Int']['input'];
};

export enum AsyncReportName {
  ClassesAndSubjectsStatistics = 'CLASSES_AND_SUBJECTS_STATISTICS',
  DiscoverUnknown_2021Schools = 'DISCOVER_UNKNOWN_2021_SCHOOLS',
  DiscoverUnknown_2021Students = 'DISCOVER_UNKNOWN_2021_STUDENTS',
  DiscoverUnknown_2021Tasks = 'DISCOVER_UNKNOWN_2021_TASKS',
  DiscoverUnknown_2021Teachers = 'DISCOVER_UNKNOWN_2021_TEACHERS',
  ModulesUsages = 'MODULES_USAGES',
  ProsveshcheniyeContentCreationStatistics = 'PROSVESHCHENIYE_CONTENT_CREATION_STATISTICS',
  SchoolsActivity = 'SCHOOLS_ACTIVITY',
  SchoolsActivityByRegions = 'SCHOOLS_ACTIVITY_BY_REGIONS',
  SchoolsActivitySummaryStatistics = 'SCHOOLS_ACTIVITY_SUMMARY_STATISTICS',
  SchoolUsersActivity = 'SCHOOL_USERS_ACTIVITY',
  SchoolUsersMonitoringByRegions = 'SCHOOL_USERS_MONITORING_BY_REGIONS',
  TaskSkills = 'TASK_SKILLS'
}

export type AsyncReportNameModel = {
  __typename?: 'AsyncReportNameModel';
  asyncReportGroup: AsyncReportGroup;
  asyncReportName: AsyncReportName;
  description: Scalars['String']['output'];
  groupDescription: Scalars['String']['output'];
};

export type AsyncReportParamModel = {
  __typename?: 'AsyncReportParamModel';
  defaultValue?: Maybe<Scalars['String']['output']>;
  description: Scalars['String']['output'];
  paramName: Scalars['String']['output'];
  required?: Maybe<Scalars['Boolean']['output']>;
  typeName: AsyncReportParamType;
};

export enum AsyncReportParamType {
  Books = 'BOOKS',
  Bool = 'BOOL',
  LearningProgramCompetitions = 'LEARNING_PROGRAM_COMPETITIONS',
  Number = 'NUMBER',
  Regions = 'REGIONS',
  Schools = 'SCHOOLS',
  SchoolsRegion = 'SCHOOLS_REGION',
  SchoolTags = 'SCHOOL_TAGS',
  SchoolTagsRegion = 'SCHOOL_TAGS_REGION',
  Stages = 'STAGES',
  String = 'STRING',
  Subjects = 'SUBJECTS',
  Timestamp = 'TIMESTAMP'
}

/** Резолверы асинхронных отчетов */
export type AsyncReportQueries = {
  __typename?: 'AsyncReportQueries';
  /** Асихронные отчеты */
  getAsyncReport: AsyncReport;
  /** Асихронные отчеты */
  getAsyncReportItem: AsyncReportItem;
  /**
   * Получить консолидированный статус рассылки отчета
   * @deprecated Field no longer supported
   */
  getAsyncReportMailingStatus?: Maybe<AsyncReportMailingStatus>;
  /**
   * Получить статусы рассылок отчета в разрезе адресатов
   * @deprecated Field no longer supported
   */
  getAsyncReportMailingStatuses: Array<AsyncReportMailingStatusByUsers>;
  /** Получение списка описаний отчетов */
  getAsyncReportNames: Array<AsyncReportNameModel>;
  /** Получение параметров отчета */
  getAsyncReportParams: Array<AsyncReportParamModel>;
  /** Получить существующее расписание */
  getAsyncReportSchedule: AsyncReportSchedule;
  /** Получить историю формирований отчетов по расписанию */
  getAsyncReportScheduleHistory: Array<AsyncReportItem>;
  /** Получить консолидированный статус рассылки отчета */
  getAsyncReportScheduleStatus?: Maybe<AsyncReportMailingStatus>;
  /** Получить статусы рассылок отчета в разрезе адресатов */
  getAsyncReportScheduleStatuses: Array<AsyncReportScheduleStatusByUser>;
  /** Получить расписания рассылок */
  getAsyncReportSchedules: Array<AsyncReportSchedule>;
  /** Асихронные отчеты */
  getAsyncReports: Array<AsyncReportItem>;
  /** Получить новое расписание */
  getNewAsyncReportSchedule: AsyncReportSchedule;
};


/** Резолверы асинхронных отчетов */
export type AsyncReportQueriesGetAsyncReportArgs = {
  reportId: Scalars['Int']['input'];
};


/** Резолверы асинхронных отчетов */
export type AsyncReportQueriesGetAsyncReportItemArgs = {
  reportId: Scalars['Int']['input'];
};


/** Резолверы асинхронных отчетов */
export type AsyncReportQueriesGetAsyncReportMailingStatusArgs = {
  reportId: Scalars['Int']['input'];
};


/** Резолверы асинхронных отчетов */
export type AsyncReportQueriesGetAsyncReportMailingStatusesArgs = {
  reportId: Scalars['Int']['input'];
};


/** Резолверы асинхронных отчетов */
export type AsyncReportQueriesGetAsyncReportNamesArgs = {
  asyncReportGroup?: InputMaybe<AsyncReportGroup>;
};


/** Резолверы асинхронных отчетов */
export type AsyncReportQueriesGetAsyncReportParamsArgs = {
  reportName: AsyncReportName;
};


/** Резолверы асинхронных отчетов */
export type AsyncReportQueriesGetAsyncReportScheduleArgs = {
  reportScheduleId: Scalars['Int']['input'];
};


/** Резолверы асинхронных отчетов */
export type AsyncReportQueriesGetAsyncReportScheduleHistoryArgs = {
  reportScheduleId: Scalars['Int']['input'];
};


/** Резолверы асинхронных отчетов */
export type AsyncReportQueriesGetAsyncReportScheduleStatusArgs = {
  reportId: Scalars['Int']['input'];
};


/** Резолверы асинхронных отчетов */
export type AsyncReportQueriesGetAsyncReportScheduleStatusesArgs = {
  reportId: Scalars['Int']['input'];
};


/** Резолверы асинхронных отчетов */
export type AsyncReportQueriesGetAsyncReportSchedulesArgs = {
  reportType?: InputMaybe<AsyncReportName>;
};


/** Резолверы асинхронных отчетов */
export type AsyncReportQueriesGetAsyncReportsArgs = {
  asyncReportGroup?: InputMaybe<AsyncReportGroup>;
  currentRole?: InputMaybe<Scalars['String']['input']>;
  reportType?: InputMaybe<AsyncReportName>;
};


/** Резолверы асинхронных отчетов */
export type AsyncReportQueriesGetNewAsyncReportScheduleArgs = {
  reportName: AsyncReportName;
};

export type AsyncReportRecipient = {
  __typename?: 'AsyncReportRecipient';
  email?: Maybe<Scalars['String']['output']>;
  fio: Scalars['String']['output'];
  userId: Scalars['UUID']['output'];
};

export type AsyncReportResponse = {
  __typename?: 'AsyncReportResponse';
  errors: Array<Scalars['String']['output']>;
  report?: Maybe<AsyncReportItem>;
};

export type AsyncReportSchedule = {
  __typename?: 'AsyncReportSchedule';
  batchJobId?: Maybe<Scalars['String']['output']>;
  created?: Maybe<Scalars['DateTime']['output']>;
  firstRun: Scalars['DateTime']['output'];
  lastRun?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  nextRun?: Maybe<Scalars['DateTime']['output']>;
  nextRunParams: Array<ParamValue>;
  paramModels?: Maybe<Array<AsyncReportParamModel>>;
  recipients: Array<AsyncReportRecipient>;
  reportType: Scalars['String']['output'];
  scheduleId?: Maybe<Scalars['Int']['output']>;
  state?: Maybe<AsyncReportScheduleState>;
};

export enum AsyncReportScheduleState {
  /** Активно */
  Active = 'ACTIVE',
  /** В архиве */
  Archived = 'ARCHIVED',
  /** Закрыто */
  Closed = 'CLOSED',
  /** Приостановлено */
  Paused = 'PAUSED'
}

export type AsyncReportScheduleStatusByUser = {
  __typename?: 'AsyncReportScheduleStatusByUser';
  status: AsyncReportScheduleStatusByUserEnum;
  statusTime: Scalars['DateTime']['output'];
  userTo: AsyncReportRecipient;
};

export enum AsyncReportScheduleStatusByUserEnum {
  /** Ошибка рассылки */
  Error = 'ERROR',
  /** Создано */
  New = 'NEW',
  /** Успешно выполнено */
  Sent = 'SENT',
  /** Статус отправки писем не отслеживается */
  StatusMonitoringDisabled = 'STATUS_MONITORING_DISABLED',
  /** Email-сервис не вернул информацию по пользователю, письмо не отправлялось */
  Warning = 'WARNING'
}

export enum AsyncReportScheduleStatusEnum {
  /** Ошибка рассылки */
  Error = 'ERROR',
  /** В процессе рассылки */
  InProgress = 'IN_PROGRESS',
  /** Рассылка еще не проводилась */
  New = 'NEW',
  /** Статус отправки писем не отслеживается */
  StatusMonitoringDisabled = 'STATUS_MONITORING_DISABLED',
  /** Успешно выполнено */
  Success = 'SUCCESS',
  /** Рассылка была инициирована, но статус от email-service пуст, например выключен канал email */
  Warning = 'WARNING'
}

export enum AsyncReportStatus {
  /** В архиве */
  Archived = 'ARCHIVED',
  /** Готов */
  Complete = 'COMPLETE',
  /** Ошибка */
  Error = 'ERROR',
  /** Ожидает */
  Waiting = 'WAITING',
  /** В работе */
  Working = 'WORKING'
}

/** Модель асинхронной задачи */
export type AsyncTask = {
  __typename?: 'AsyncTask';
  /** Уникальный UUID асинхронной задачи */
  asyncTaskId: Scalars['UUID']['output'];
  /** дата и время создания асинхронной задачи */
  createTs: Scalars['DateTime']['output'];
  /** ИД связаной сущности */
  entityId?: Maybe<Scalars['ID']['output']>;
  /** UUID связаной сущности */
  entityUuid?: Maybe<Scalars['UUID']['output']>;
  /** Сообщение ошибки, если задание завершилось не успешно */
  errorMessage?: Maybe<Scalars['String']['output']>;
  /** Тип асинхронной задачи */
  payloadType: Scalars['String']['output'];
  /** UUID школы по которой создали асинхронную задачу */
  schoolId?: Maybe<Scalars['UUID']['output']>;
  /** Текущий статус */
  status: AsyncTaskStatus;
  /** ID группы задач */
  taskGroupId?: Maybe<Scalars['UUID']['output']>;
  /** дата и время последнего обновления асинхронной задачи */
  updateTs: Scalars['DateTime']['output'];
  /** Пользователь, создавший задачу */
  user: User;
};

export enum AsyncTaskStatus {
  /** Ошибка */
  Error = 'ERROR',
  /** Выполняется */
  Processing = 'PROCESSING',
  /** В очереди */
  Queued = 'QUEUED',
  /** Успешно */
  Success = 'SUCCESS'
}

/** Элемент группировки асинхронных задач по статусу на количество задач в этом статусе */
export type AsyncTasksStatusCount = {
  __typename?: 'AsyncTasksStatusCount';
  /** Количество задач в данном статусе */
  count: Scalars['Int']['output'];
  /** Статус асинхронной задачи */
  status: AsyncTaskStatus;
};

/** Протокол по попытке */
export type AttemptCheckDetailInfo = {
  __typename?: 'AttemptCheckDetailInfo';
  /** Протокол подсчета оценки за авто (json) */
  assessmentProtocolMeta?: Maybe<Scalars['String']['output']>;
  /** Версия протокола подсчета оценки за авто */
  assessmentProtocolVersion?: Maybe<Scalars['Int']['output']>;
  /** Номер попытки */
  attemptNumber: Scalars['Int']['output'];
  /** Идентификатор проекта */
  goalId: Scalars['ID']['output'];
  /** Название проекта */
  projectName: Scalars['String']['output'];
  /** Дата и время попытки */
  resultDate?: Maybe<Scalars['DateTime']['output']>;
  /** Информация об ответе студента (gitlab/platform) */
  solutionInfo?: Maybe<SolutionInfo>;
  /** Список ответов по вопросам обратной связи студента */
  studentFeedbackResults?: Maybe<Array<StudentFeedbackResult>>;
  /** Статус студенческого ответа */
  studentFeedbackStatus?: Maybe<StudentFeedbackStatusEnum>;
  /** Идентификатор отчета о попытке */
  studentGoalAttemptId: Scalars['ID']['output'];
  /** Логин студента */
  studentLogin: Scalars['String']['output'];
  /** Информация о проверяемых */
  verifiableUsers: VerifiableUsers;
};

/** Справочник формул подсчета оценки при повторном прохождение проекта */
export enum AttemptCountingFormulaEnum {
  /** Средняя */
  Average = 'AVERAGE',
  /** Последняя */
  Last = 'LAST',
  /** Максимальная */
  Max = 'MAX',
  /** Минимальная */
  Min = 'MIN'
}

/** Модель, содержащая информацию о попытке прохождения проекта вместе с проверками */
export type AttemptWithChecks = {
  __typename?: 'AttemptWithChecks';
  /**
   * Формула подсчета итогового балла за все проверки.
   * Null в случае, когда формула на момент завершения проверки не сохранялась
   */
  attemptCalculationFormula?: Maybe<CountingFormulaType>;
  /** Информация за авто-блок проверки. Null если авто-проверка не настроен */
  autoCheckInfo?: Maybe<AutoCheckInfo>;
  /** Информация за блок проверки код-ревью. Null если код-ревью не настроен */
  codeReviewInfo?: Maybe<CodeReviewInfo>;
  /** Информация за p2p-блок проверки. Null если p2p не настроен */
  p2pCheckInfo?: Maybe<P2pCheckInfo>;
  /**
   * Процент, который необходимо набрать чтобы задание считалось выполненным
   * Null в случае, когда процент на момент завершения проверки не сохранялся
   */
  percentageOfCompletion?: Maybe<Scalars['Int']['output']>;
  /** Оценка в пересчете на опыт. Null в случае, если оценка еще не посчитана */
  resultExperience?: Maybe<Scalars['Int']['output']>;
  /** Процент за прохождение попытки. Null в случае, если оценка еще не посчитана */
  resultPercentage?: Maybe<Scalars['Int']['output']>;
  /** Информация по решению при типе загрузки Platf. Null если тип загрузки Gitlab или если проект зафейлен до старта */
  solutionInfo: SolutionInfo;
  /** Идентификатор ответа. Null в случае, если проект зафейлен до старта проекта */
  studentAnswerId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор попытки выполнения проекта */
  studentGoalAttemptId: Scalars['ID']['output'];
  /** Информация о проверяемых */
  verifiableUsers: VerifiableUsers;
};

export type AttendanceAndAchievementQueries = {
  __typename?: 'AttendanceAndAchievementQueries';
  getScheduleEventsVisitJournalInfo: ScheduleEventsVisitJournalInfoResponse;
};


export type AttendanceAndAchievementQueriesGetScheduleEventsVisitJournalInfoArgs = {
  childUserId?: InputMaybe<Scalars['ID']['input']>;
  excludeVisitJournalValues?: InputMaybe<Array<VisitJournalCellValueEnum>>;
  lessonsFromDate: Scalars['Date']['input'];
  lessonsToDate: Scalars['Date']['input'];
  subjectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Количество уроков для соответствующего статуса посещения */
export type AttendanceStateStatistics = {
  __typename?: 'AttendanceStateStatistics';
  /** Количество уроков для состояния */
  numberOfLessons: Scalars['Int']['output'];
  /** Состояние (статус) посещения урока */
  state: VisitJournalCellValueEnum;
};

/** Модель аттестационного периода */
export type AttestationPeriod = {
  __typename?: 'AttestationPeriod';
  /** Дата окончания */
  endDate: Scalars['Date']['output'];
  /** Идентификатор периода */
  periodId: Scalars['ID']['output'];
  /** Наименование периода */
  periodName: Scalars['String']['output'];
  /** Тип периода (АП или УП) */
  periodType: FinalPeriodType;
  /** Идентификатор типа периода (АП или УП) */
  periodTypeId: Scalars['ID']['output'];
  /** Дата начала */
  startDate: Scalars['Date']['output'];
};

/** Даты аттестационного периода */
export type AttestationPeriodDatesResponse = {
  __typename?: 'AttestationPeriodDatesResponse';
  /** Данные */
  data?: Maybe<VisitLessonPeriod>;
  /** Ошибки */
  error?: Maybe<VisitLessonStatError>;
  /** Успешность операции */
  isSuccess: Scalars['Boolean']['output'];
};

/** Итоговая оценка за АП */
export type AttestationPeriodFinalMark = {
  __typename?: 'AttestationPeriodFinalMark';
  /** Значение оценки GovernmentMark#customMarkName */
  mark?: Maybe<Scalars['String']['output']>;
  /** СРВ */
  midWeightMark?: Maybe<Scalars['String']['output']>;
  /** Идентификатор аттестационного периода */
  periodId: Scalars['ID']['output'];
  /** прогнозируемая итоговая */
  predictedFinalMark?: Maybe<Scalars['String']['output']>;
};

export type AttestationPeriodInputModel = {
  /** дата закрытия модулей */
  closeModuleDate: Scalars['Date']['input'];
  /** дата начала */
  endDate: Scalars['Date']['input'];
  /** id аттестационного периода */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** название */
  name: Scalars['String']['input'];
  /** дата начала */
  startDate: Scalars['Date']['input'];
};

export type AttestationPeriodMarkMutations = {
  __typename?: 'AttestationPeriodMarkMutations';
  /** Добавить файл во внешнюю работу */
  attachExternalWorkFile: ExternalWork;
  /** Переименовать внешнюю работу */
  changeExternalWorkName: ExternalWork;
  /** Создать внешнюю работу */
  createExternalWork: StudentInSubgroup;
  /** Создать и тиражировать внешнюю работу на всех учеников в классе */
  createExternalWorkForClassSubject: Array<Maybe<StudentStageSubjectStudyPeriod>>;
  /** Создать внешнюю работу (вариант c полем periodTypeId: ID ) */
  createExternalWorkV2: StudentInSubgroup;
  /** Производит пересчет показателей успеваемости для текущих учеников ГКпП за переданный аттестационный период. */
  recalculateAndUpdateAcademicPerformanceOfStageSubjectGroupStudents: Scalars['Boolean']['output'];
  /** Производит перерасчет показателей успеваемости для ученика по предмету за аттестационный период */
  recalculateAndUpdateAcademicPerformanceOfStudentBySubject: Scalars['Boolean']['output'];
  /** Удалить внешнюю работу */
  removeExternalWork: StudentInSubgroup;
  /** Удалить файл из внешней работы */
  removeExternalWorkFile: Scalars['ID']['output'];
  /**
   * Установить оценку за модуль
   * setStudentModuleMark(studentId: ID!, moduleId: ID!, markId: ID) : StudentModule!
   * Установить оценку за внешнюю работу
   */
  setExternalWorkMark: StudentInSubgroup;
  /** Установить оценку */
  setStudentStageSubjectStudyPeriodMark: StudentInSubgroup;
};


export type AttestationPeriodMarkMutationsAttachExternalWorkFileArgs = {
  externalWorkId: Scalars['ID']['input'];
  fileInput: FileInput;
};


export type AttestationPeriodMarkMutationsChangeExternalWorkNameArgs = {
  externalWorkId: Scalars['ID']['input'];
  externalWorkName: Scalars['String']['input'];
};


export type AttestationPeriodMarkMutationsCreateExternalWorkArgs = {
  externalWorkInput: ExternalWorkInput;
};


export type AttestationPeriodMarkMutationsCreateExternalWorkForClassSubjectArgs = {
  attestationPeriodId: Scalars['ID']['input'];
  attestationPeriodTypeId?: InputMaybe<Scalars['ID']['input']>;
  classSubjectId: Scalars['ID']['input'];
  name: Scalars['String']['input'];
};


export type AttestationPeriodMarkMutationsCreateExternalWorkV2Args = {
  externalWorkV2Input: ExternalWorkV2Input;
};


export type AttestationPeriodMarkMutationsRecalculateAndUpdateAcademicPerformanceOfStageSubjectGroupStudentsArgs = {
  attestationPeriodId: Scalars['ID']['input'];
  stageSubjectGroupId: Scalars['ID']['input'];
};


export type AttestationPeriodMarkMutationsRecalculateAndUpdateAcademicPerformanceOfStudentBySubjectArgs = {
  attestationPeriodId: Scalars['ID']['input'];
  stageSubjectGroupId: Scalars['ID']['input'];
  studentId: Scalars['ID']['input'];
};


export type AttestationPeriodMarkMutationsRemoveExternalWorkArgs = {
  externalWorkId: Scalars['ID']['input'];
};


export type AttestationPeriodMarkMutationsRemoveExternalWorkFileArgs = {
  fileId: Scalars['ID']['input'];
};


export type AttestationPeriodMarkMutationsSetExternalWorkMarkArgs = {
  externalWorkId: Scalars['ID']['input'];
  markId?: InputMaybe<Scalars['ID']['input']>;
  percentageMark?: InputMaybe<Scalars['Float']['input']>;
};


export type AttestationPeriodMarkMutationsSetStudentStageSubjectStudyPeriodMarkArgs = {
  attestationPeriodId: Scalars['ID']['input'];
  attestationPeriodTypeId?: InputMaybe<Scalars['ID']['input']>;
  markId?: InputMaybe<Scalars['ID']['input']>;
  stageSubjectId: Scalars['ID']['input'];
  studentId: Scalars['ID']['input'];
};

export type AttestationPeriodMarkQueries = {
  __typename?: 'AttestationPeriodMarkQueries';
  /** Получение данных о прогрессе и оценках по ГКпП */
  getAttestationPeriodMarks: ClassSubject;
  /** Получение данных о прогрессе и оценках по студенту */
  getAttestationPeriodStudentMarks: ClassSubject;
  /** набор оценок, принятых в школе */
  getSchoolMarks: Array<SchoolMark>;
  /** Получение данных по гкпп */
  getStageSubjectGroupInfo: StageSubjectGroupInfoForMarks;
};


export type AttestationPeriodMarkQueriesGetAttestationPeriodMarksArgs = {
  attestationPeriodMarksRequestInput?: InputMaybe<AttestationPeriodMarksRequestInput>;
};


export type AttestationPeriodMarkQueriesGetAttestationPeriodStudentMarksArgs = {
  attestationPeriodMarksRequestInput?: InputMaybe<AttestationPeriodMarksRequestInput>;
};


export type AttestationPeriodMarkQueriesGetStageSubjectGroupInfoArgs = {
  stageSubjectGroupId: Scalars['ID']['input'];
};

export type AttestationPeriodMarksRequestInput = {
  periodId?: InputMaybe<Scalars['ID']['input']>;
  stageSubjectGroupId: Scalars['ID']['input'];
  studentId?: InputMaybe<Scalars['ID']['input']>;
};

/** Аттестационный период */
export type AttestationPeriodModel = {
  __typename?: 'AttestationPeriodModel';
  /** дата закрытия модулей */
  closeModuleDate: Scalars['Date']['output'];
  /** дата окончания */
  endDate: Scalars['Date']['output'];
  /** id аттестационного периода */
  id: Scalars['ID']['output'];
  /** название */
  name: Scalars['String']['output'];
  /** дата начала */
  startDate: Scalars['Date']['output'];
};

export type AttestationPeriodMutations = {
  __typename?: 'AttestationPeriodMutations';
  /** Изменение графика аттестационных периодов */
  changeAttestationPeriodSet: AttestationPeriodSetModel;
  /** Создание/изменение ячейки таблицы аттестационных периодов */
  changeStageSubjectGroupAttestation: Array<StageSubjectGroupAttestationEntryModel>;
  /** Создание графика аттестационных периодов */
  createAttestationPeriodSet: AttestationPeriodSetModel;
  /** Удаление графика аттестационных периодов */
  deleteAttestationPeriodSet?: Maybe<Scalars['Boolean']['output']>;
};


export type AttestationPeriodMutationsChangeAttestationPeriodSetArgs = {
  attestationPeriodSet: AttestationPeriodSetInputModel;
};


export type AttestationPeriodMutationsChangeStageSubjectGroupAttestationArgs = {
  stageSubjectGroupAttestation: Array<StageSubjectGroupAttestationInputModel>;
};


export type AttestationPeriodMutationsCreateAttestationPeriodSetArgs = {
  attestationPeriodSet: AttestationPeriodSetInputModel;
};


export type AttestationPeriodMutationsDeleteAttestationPeriodSetArgs = {
  attestationPeriodSetId: Scalars['ID']['input'];
};

export type AttestationPeriodQueries = {
  __typename?: 'AttestationPeriodQueries';
  /** Получение графиков аттестационных периодов */
  getAttestationPeriodSets: Array<AttestationPeriodSetModel>;
  /** Получение Атестационных Периодов по предметам для Ученика */
  getCurrentAcademicYearAttestation: AttestationPeriodSetResponse;
  /** Получение ячеек таблицы аттестационных периодов */
  getStageSubjectGroupAttestations: Array<StageSubjectGroupAttestationEntryModel>;
  /** Кастомная кверя получения актуальных предметов для параллели */
  getSubjectsByStage: Array<Subject>;
};


export type AttestationPeriodQueriesGetAttestationPeriodSetsArgs = {
  academicYearId: Scalars['ID']['input'];
};


export type AttestationPeriodQueriesGetCurrentAcademicYearAttestationArgs = {
  childUserId?: InputMaybe<Scalars['ID']['input']>;
};


export type AttestationPeriodQueriesGetStageSubjectGroupAttestationsArgs = {
  academicYearId: Scalars['ID']['input'];
  stageId: Scalars['ID']['input'];
};


export type AttestationPeriodQueriesGetSubjectsByStageArgs = {
  academicYearId: Scalars['ID']['input'];
  stageId: Scalars['ID']['input'];
};

export enum AttestationPeriodResponseCode {
  /** Не найдены активные ГПП ученика */
  ActiveStageSubjectGroupNotFound = 'ACTIVE_STAGE_SUBJECT_GROUP_NOT_FOUND',
  /** статус обозначающий общую ошибку. Заведен для использования в responseCode */
  Error = 'ERROR',
  Ok = 'OK',
  /** Не найден Класс ученика */
  StageGroupNotFound = 'STAGE_GROUP_NOT_FOUND',
  /** Не найдены Учебные периоды ученика */
  StudyPeriodsNotFound = 'STUDY_PERIODS_NOT_FOUND'
}

/** Итоговые оценки по графикам аттестационных периодов */
export type AttestationPeriodSetFinalMarks = {
  __typename?: 'AttestationPeriodSetFinalMarks';
  /** Аттестационные периоды в наборе */
  attestationPeriods: Array<EJournalFinalPeriod>;
  /** Итоговые оценки по предмету параллели */
  stageSubjectMarks: Array<StageSubjectFinalMarks>;
};

export type AttestationPeriodSetInputModel = {
  /** идентификатор учебного года для которого определен график. */
  academicYearId: Scalars['ID']['input'];
  /** аттестационные периоды */
  attestationPeriods: Array<AttestationPeriodInputModel>;
  /** id графика */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** название */
  name: Scalars['String']['input'];
  /** аббревиатура */
  shortName?: InputMaybe<Scalars['String']['input']>;
};

/** График аттестационных периодов */
export type AttestationPeriodSetModel = {
  __typename?: 'AttestationPeriodSetModel';
  /** идентификатор учебного года для которого определен график. */
  academicYearId?: Maybe<Scalars['ID']['output']>;
  /** проверка назначен ли график */
  assigned: Scalars['Boolean']['output'];
  /** аттестационные периоды */
  attestationPeriods: Array<AttestationPeriodModel>;
  /** id графика */
  id: Scalars['ID']['output'];
  /** название */
  name: Scalars['String']['output'];
  /** аббревиатура */
  shortName?: Maybe<Scalars['String']['output']>;
};

export type AttestationPeriodSetResponse = {
  __typename?: 'AttestationPeriodSetResponse';
  /** @deprecated Использовать responseCodes  */
  attestationPeriodSetWithStageSubjectGroups: Array<AttestationPeriodSetWithStageSubjectGroups>;
  responseCode: AttestationPeriodResponseCode;
  responseCodes: Array<AttestationPeriodResponseCode>;
};

/** Итоговые оценки по графикам аттестационных периодов */
export type AttestationPeriodSetStatisticsMarks = {
  __typename?: 'AttestationPeriodSetStatisticsMarks';
  /** Аттестационные периоды в наборе */
  attestationPeriods: Array<EJournalFinalPeriod>;
  /** Итоговые оценки по предмету параллели */
  stageSubjectMarks: Array<StageSubjectStatisticsMarks>;
};

export type AttestationPeriodSetWithStageSubjectGroups = {
  __typename?: 'AttestationPeriodSetWithStageSubjectGroups';
  attestationPeriodSet: AttestationPeriodSetModel;
  attestationType: AttestationTypeModel;
  stageSubjectGroupAttestationPeriods: Array<StageSubjectGroupAttestationModel>;
};

/** Итоговая оценка за АП */
export type AttestationPeriodStatisticsMark = {
  __typename?: 'AttestationPeriodStatisticsMark';
  /** Значение оценки GovernmentMark#customMarkName */
  mark?: Maybe<Scalars['String']['output']>;
  /** СРВ */
  midWeightMark?: Maybe<Scalars['String']['output']>;
  /** Идентификатор аттестационного периода */
  periodId: Scalars['ID']['output'];
  /** прогнозируемая итоговая */
  predictedFinalMark?: Maybe<Scalars['String']['output']>;
};

/** Типы аттестации */
export enum AttestationTypeModel {
  /** По аттестационным периодам */
  ByAttestationPeriods = 'BY_ATTESTATION_PERIODS',
  /** По модулям КТП */
  ByModules = 'BY_MODULES',
  /** По учебным периодам */
  ByStudyPeriods = 'BY_STUDY_PERIODS'
}

export type AuditMessage = {
  __typename?: 'AuditMessage';
  /** Классификация действий пользователя */
  action: AuditOperationAction;
  /** Идентификатор записи журнала аудита */
  auditMessageId: Scalars['ID']['output'];
  /** Идентификатор клиентского запроса */
  clientRequestId: Scalars['String']['output'];
  createTs: Scalars['DateTime']['output'];
  /** идентификатор аудируемой сущности */
  entityId?: Maybe<Scalars['String']['output']>;
  /** тип аудируемой сущности */
  entityTypeCode?: Maybe<Scalars['String']['output']>;
  /** Идентификатор имперсонатора в Keycloak */
  impersonatorUserId?: Maybe<Scalars['String']['output']>;
  /** Логин имперсонатора в Keycloak */
  impersonatorUserLogin?: Maybe<Scalars['String']['output']>;
  /** Признак успешно выполненного действия пользователя */
  isSuccess: Scalars['Boolean']['output'];
  message: Scalars['String']['output'];
  /** Уникальный код события журнала аудита */
  operationCode: Scalars['String']['output'];
  /** Человекопонятное описание события журнала аудита */
  operationDescription: Scalars['String']['output'];
  schoolId?: Maybe<Scalars['ID']['output']>;
  userFullName: Scalars['String']['output'];
  userId: Scalars['ID']['output'];
  userLogin: Scalars['String']['output'];
  /** Ид рабочего места пользователя, взято из куки */
  workplaceId: Scalars['String']['output'];
};

/** Тип действий для аудита */
export enum AuditOperationAction {
  Create = 'CREATE',
  Delete = 'DELETE',
  Read = 'READ',
  Update = 'UPDATE'
}

export type AuditOperationType = {
  __typename?: 'AuditOperationType';
  /** Классификация действий пользователя */
  action: AuditOperationAction;
  /** Уникальный код события журнала аудита */
  code: Scalars['String']['output'];
  /** Человекопонятное описание события журнала аудита */
  description: Scalars['String']['output'];
};

export type AuditRecordsResponse = {
  __typename?: 'AuditRecordsResponse';
  /** количество записей */
  count: Scalars['Int']['output'];
  records: Array<AuditMessage>;
};

export type AuditableEntityType = {
  __typename?: 'AuditableEntityType';
  /** Уникальный код сущности */
  code: Scalars['String']['output'];
  /** Имя сущности, которое можно отобразить пользователю */
  name: Scalars['String']['output'];
};

/** Автор учебного контента */
export type Author = {
  __typename?: 'Author';
  /** Имя */
  firstName?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** Фамилия */
  lastName?: Maybe<Scalars['String']['output']>;
  /** Отчетство */
  middleName?: Maybe<Scalars['String']['output']>;
};

/** Информация о блоке за авто-проверку */
export type AutoCheckInfo = {
  __typename?: 'AutoCheckInfo';
  /** Идентификатор авто-проверки */
  autoCheckReportId: Scalars['ID']['output'];
  /** Содержит время завершения авто-проверки */
  endTimeCheck: Scalars['DateTime']['output'];
  /** Фактический процент выполнения авто-проверки */
  receivedPercentage: Scalars['Int']['output'];
};

/** Протокол по авто проверке */
export type AutoCheckReportDetailInfo = {
  __typename?: 'AutoCheckReportDetailInfo';
  /** Протокол подсчета оценки за авто (json) */
  assessmentProtocolMeta?: Maybe<Scalars['String']['output']>;
  /** Версия протокола подсчета оценки за авто */
  assessmentProtocolVersion?: Maybe<Scalars['Int']['output']>;
  /** Идентификатор отчета об авто проверке */
  autoCheckReportId: Scalars['ID']['output'];
  /** Текстовый результат автоматической проверки */
  resultInfo?: Maybe<Scalars['String']['output']>;
};

/** Информация об auto проверке по проекту */
export type AutoEvaluationInfo = {
  __typename?: 'AutoEvaluationInfo';
  /** Фактическое время окончания автопроверки, если она была проведена */
  endTimeCheck?: Maybe<Scalars['DateTime']['output']>;
  /** Процент выполнения автопроверки */
  receivedPercentage: Scalars['Int']['output'];
  /** результат автопроверки */
  resultInfo?: Maybe<Scalars['String']['output']>;
  /** Статус проверки */
  status: ProjectEvaluationStatus;
};

/** Информация о весах автотестов */
export type AutotestInfo = {
  __typename?: 'AutotestInfo';
  /** Автотест и его вес */
  autotests: Array<AutotestWithWeight>;
  /** Категория секции */
  kindQuestion: KindQuestion;
};

/** Автотест и его вес */
export type AutotestWithWeight = {
  __typename?: 'AutotestWithWeight';
  /** Идентификатор автотеста */
  id: Scalars['ID']['output'];
  /** Наименование теста */
  name?: Maybe<Scalars['String']['output']>;
  /** Вес автотеста */
  weight: Scalars['Int']['output'];
};

/** Автотест и его вес */
export type AutotestWithWeightInput = {
  /** Идентификатор автотеста */
  id: Scalars['ID']['input'];
  /** Вес автотеста */
  weight: Scalars['Int']['input'];
};

/** Класс, на который можно назначить курс */
export type AvailableClassForAssignmentCourse = {
  __typename?: 'AvailableClassForAssignmentCourse';
  /** Название класса, на который можно назначить курс */
  className: Scalars['String']['output'];
  /** Флаг, назначен ли курс уже на группу класса по предмету */
  isAssigned?: Maybe<Scalars['Boolean']['output']>;
  /** Идентификатор параллели, к которой привязан класс */
  stageId: Scalars['ID']['output'];
  /** Название параллели, к которой привязан класс */
  stageName: Scalars['String']['output'];
  /** Идентификатор группы класса по предмету */
  stageSubjectGroupId: Scalars['ID']['output'];
};

export type AvailableCodeReviews = {
  __typename?: 'AvailableCodeReviews';
  codeReviews: Array<CodeReview>;
  limitInfo: CodeReviewLimitInfo;
};

export type AvailablePublicationActions = {
  __typename?: 'AvailablePublicationActions';
  isPublishAvailable: Scalars['Boolean']['output'];
  isUnPublishAvailable: Scalars['Boolean']['output'];
};

/** Доступные области видимости и пресеты */
export type AvailableScopes = {
  __typename?: 'AvailableScopes';
  /** @deprecated Не используется в бизнес-логике */
  scopePresets: Array<ScopePresetEnum>;
  scopes: Array<ScopeEnum>;
};

export type AvailableTimeZone = {
  __typename?: 'AvailableTimeZone';
  zoneId: Scalars['String']['output'];
  zoneName: Scalars['String']['output'];
};

/** Аватар */
export type Avatar = {
  __typename?: 'Avatar';
  /** Категория аватара (Великие люди, Великие изобретения, Великие открытия) */
  avatarGroup: AvatarGroup;
  /** Размер аватара (Low-grade,Middle-grade,High-grade) */
  avatarKind: AvatarKind;
  /** Id аватара */
  id: Scalars['ID']['output'];
  /** Название аватара */
  name: Scalars['String']['output'];
  /** Цена аватара, 0 если бесплатный */
  price: Scalars['Int']['output'];
  /** Школа в которой заведен этот аватар или null, если аватар глобальный */
  schoolId?: Maybe<Scalars['UUID']['output']>;
  /** Ссылка на аватар */
  url: Scalars['String']['output'];
  /** признак того, что этот аватар у юзера уже есть */
  userGotIt: Scalars['Boolean']['output'];
};

/** Категория аватара (Великие люди, Великие изобретения, Великие открытия) */
export type AvatarGroup = {
  __typename?: 'AvatarGroup';
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

/** Создание/изменений стикеров */
export type AvatarInput = {
  /** Категория стикера (Великие люди, Великие изобретения, Великие открытия) */
  avatarGroupId: Scalars['Int']['input'];
  /** Размер стикера */
  avatarKindId: Scalars['Int']['input'];
  /** Наименование бейджа */
  name: Scalars['String']['input'];
  /** Ссылка на изображение стикера */
  url: Scalars['String']['input'];
};

/** Размер аватара (Аватар маленьких/средних/больших размеров) */
export type AvatarKind = {
  __typename?: 'AvatarKind';
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

/** Информация о средней посещаемости за неделю/месяц */
export type AverageLogtime = {
  __typename?: 'AverageLogtime';
  /** Средняя посещаемость за месяц (в секундах) */
  month: Scalars['Int']['output'];
  /** Средняя посещаемость за неделю (в секундах) */
  week: Scalars['Int']['output'];
  /** Средняя посещаемость в неделю за месяц (в секундах) */
  weekPerMonth: Scalars['Int']['output'];
};

/** Награда (Ачивка) */
export type Award = {
  __typename?: 'Award';
  /** Механика назначения (учитель/ученик, система/ученик, etc.) */
  assignments: Array<AwardAssignmentType>;
  /** Вознаграждение за награду */
  awardBounties: Array<AwardBounty>;
  /** Условие получения награды */
  awardCondition: AwardCondition;
  /** Тип награды */
  awardType: AwardTypeEnum;
  /**
   * Бейдж
   * не {null} если {awardType=BADGE}
   */
  badge?: Maybe<Badge>;
  /**
   * Сколько игровой валюты начисляется за получение награды
   * @deprecated Use awardBounties. Will be deleted in r/24.0.0
   */
  coins: Scalars['Int']['output'];
  /**
   * Сколько печенек начисляется за получение награды
   * @deprecated Use awardBounties. Will be deleted in r/24.0.0
   */
  cookies: Scalars['Int']['output'];
  /** Дата создания награды */
  createdTs: Scalars['DateTime']['output'];
  /**
   * Экипировка
   * не {null} если {awardType=EQUIPMENT}
   */
  equipment?: Maybe<Equipment>;
  /**
   * Сколько очков опыта начисляется за получение награды
   * @deprecated Use awardBounties. Will be deleted in r/24.0.0
   */
  experienceValue: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  /** Награда активна */
  isActive: Scalars['Boolean']['output'];
  /** Сколько очков добавляется при апдейте */
  pointsToAdd: Scalars['Int']['output'];
  /** Кол-во выданных наград в рамках кампуса(или продукта). Доступно только при запросе getAwards из-под ba, sa */
  rewardCount?: Maybe<Scalars['Int']['output']>;
  /** Школа, в которой заведена награда. {null} если награда глобальная */
  school?: Maybe<SafeSchool>;
  /** Школа в которой заведена награда */
  schoolId?: Maybe<Scalars['ID']['output']>;
  /** Дата редактирования награды */
  updatedTs?: Maybe<Scalars['DateTime']['output']>;
};

/** Способ назначения конкретной награды */
export type AwardAssignmentType = {
  __typename?: 'AwardAssignmentType';
  /** включен ли способ выдачи для награды */
  enabled: Scalars['Boolean']['output'];
  /** ID способа */
  id: Scalars['Int']['output'];
  /** наименование */
  name: Scalars['String']['output'];
};

/** Вознаграждение за получение награды в разрезе уровней */
export type AwardBounty = {
  __typename?: 'AwardBounty';
  /** Идентификатор вознаграждения */
  awardBountyId: Scalars['ID']['output'];
  /** Уровень при котором выдается вознаграждение. NULL если выдается за все уровни */
  awardLevelId?: Maybe<Scalars['Int']['output']>;
  /** метрики для достижения уровня награды */
  awardMetricConditions: Array<AwardMetricCondition>;
  /** Баллы коалиции */
  coalitionPoints: Scalars['Int']['output'];
  /** Wallets */
  coins: Scalars['Int']['output'];
  /** Печеньки/Evaluation Points */
  cookies: Scalars['Int']['output'];
  /** Code Review Points */
  crpValue: Scalars['Int']['output'];
  /** Описание уровня награды (ранга) */
  description?: Maybe<Scalars['String']['output']>;
  /** Очки опыта / XP */
  experienceValue: Scalars['Int']['output'];
  /** Прокачка навыков */
  softSkillPowers: Array<AwardBountySoftSkillPower>;
};

/** Вознаграждение за получение награды в разрезе уровней */
export type AwardBountyInput = {
  /** Уровень при котором выдается вознаграждение. NULL если выдается за все уровни */
  awardLevelId?: InputMaybe<Scalars['Int']['input']>;
  /** Баллы коалиции */
  coalitionPoints?: InputMaybe<Scalars['Int']['input']>;
  /** Печеньки/Evaluation Points */
  coins: Scalars['Int']['input'];
  /** Wallets */
  cookies: Scalars['Int']['input'];
  /** Code Review Points */
  crpValue?: InputMaybe<Scalars['Int']['input']>;
  /** Описание уровня награды (ранга) */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Очки опыта */
  experienceValue: Scalars['Int']['input'];
  /** Прокачка навыков */
  softSkillPowers: Array<AwardBountySoftSkillPowerInput>;
};

/** Сколько мягких навыков выдается при получении вознаграждения */
export type AwardBountySoftSkillPower = {
  __typename?: 'AwardBountySoftSkillPower';
  /** Выдаваемое кол-во софт скилла */
  power: Scalars['Int']['output'];
  /** Софт скилл */
  softSkill: SoftSkillType;
  /** ID софт скилла */
  softSkillId: Scalars['Int']['output'];
};

/** Сколько мягких навыков выдается при получении вознаграждения */
export type AwardBountySoftSkillPowerInput = {
  /** Выдаваемое кол-во софт скилла */
  power: Scalars['Int']['input'];
  /** ID софт скилла */
  softSkillId: Scalars['Int']['input'];
};

/** Условия получения награды */
export type AwardCondition = {
  __typename?: 'AwardCondition';
  /** Человек-читаемое описание условия */
  description: Scalars['String']['output'];
  id: Scalars['Int']['output'];
};

/** Справочник уровней наград */
export type AwardLevel = {
  __typename?: 'AwardLevel';
  /** Число уровня */
  awardLevelId: Scalars['Int']['output'];
  /** Название уровня */
  awardLevelName: Scalars['String']['output'];
};

export type AwardMetricCondition = {
  __typename?: 'AwardMetricCondition';
  /** ID награды */
  awardId: Scalars['ID']['output'];
  /** Требуемое значение метрики для выдачи награды */
  awardLevel: Scalars['Int']['output'];
  /** Уникальный ID */
  awardMetricConditionId: Scalars['ID']['output'];
  /** Метрика */
  metricId: Scalars['Int']['output'];
  /** Требуемое значение метрики для выдачи награды */
  requiredPower: Scalars['Int']['output'];
};

export type AwardMutations = {
  __typename?: 'AwardMutations';
  /** Сделать бэйдж неактивным */
  archiveAward: Award;
  /** Скопировать бэйдж из существующего бейджа */
  copyBadgeAward: Award;
  /** Создать бэйдж */
  createBadgeAward: Award;
  /** Редактировать бэйдж */
  editBadgeAward: Award;
};


export type AwardMutationsArchiveAwardArgs = {
  awardId: Scalars['ID']['input'];
};


export type AwardMutationsCopyBadgeAwardArgs = {
  awardId: Scalars['ID']['input'];
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
};


export type AwardMutationsCreateBadgeAwardArgs = {
  badgeAwardInputModel: BadgeAwardInput;
  schoolId: Scalars['UUID']['input'];
};


export type AwardMutationsEditBadgeAwardArgs = {
  awardId: Scalars['ID']['input'];
  badgeAwardInputModel: BadgeAwardInput;
  schoolId: Scalars['UUID']['input'];
};

export type AwardQueries = {
  __typename?: 'AwardQueries';
  /** Получение награды по идентификатору */
  getAwardById: Award;
  /** Доступные награды для выдачи */
  getAwards: Array<Award>;
  /** количество доступных наград для выдачи */
  getAwardsCount: Scalars['Int']['output'];
  /** Доступные награды для выдачи в приложении методолога */
  getAwardsV2: Array<AwardV2>;
  /** Механики назначения наград */
  getS21AwardAssignmentTypes: Array<AssignmentType>;
  /** Запрос истории получения ачивки c возможностью сортировать по awardDate */
  getUserAwardHistoryByAwardId: Array<UserAwardHistory>;
  /** Кол-во записей в истории получения ачивки */
  getUserAwardHistoryByAwardIdCount: Scalars['Int']['output'];
};


export type AwardQueriesGetAwardByIdArgs = {
  awardId: Scalars['ID']['input'];
};


export type AwardQueriesGetAwardsArgs = {
  assignmentTypeId?: InputMaybe<Scalars['Int']['input']>;
  awardName?: InputMaybe<Scalars['String']['input']>;
  badgeKindTypeId?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<PagingInput>;
  schoolId?: InputMaybe<Scalars['ID']['input']>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
};


export type AwardQueriesGetAwardsCountArgs = {
  assignmentTypeId?: InputMaybe<Scalars['Int']['input']>;
  awardName?: InputMaybe<Scalars['String']['input']>;
  badgeKindTypeId?: InputMaybe<Scalars['Int']['input']>;
  schoolId?: InputMaybe<Scalars['ID']['input']>;
};


export type AwardQueriesGetAwardsV2Args = {
  assignmentTypeId?: InputMaybe<Scalars['Int']['input']>;
  awardName?: InputMaybe<Scalars['String']['input']>;
  badgeKindTypeId?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<PagingInput>;
  schoolId?: InputMaybe<Scalars['ID']['input']>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
};


export type AwardQueriesGetUserAwardHistoryByAwardIdArgs = {
  awardId: Scalars['ID']['input'];
  login?: InputMaybe<Scalars['String']['input']>;
  paging: PagingInput;
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  sortingFields: Array<SortingField>;
};


export type AwardQueriesGetUserAwardHistoryByAwardIdCountArgs = {
  awardId: Scalars['ID']['input'];
  login?: InputMaybe<Scalars['String']['input']>;
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
};

/** Тип награды */
export enum AwardTypeEnum {
  /** Бейдж */
  Badge = 'BADGE',
  /** Экипировка */
  Equipment = 'EQUIPMENT'
}

/** Награда (Ачивка) */
export type AwardV2 = {
  __typename?: 'AwardV2';
  /** Формат выдачи */
  assignmentType: Scalars['Int']['output'];
  /** Вознаграждение за награду */
  awardBounties: Array<AwardBounty>;
  /** Условие получения награды */
  awardCondition: AwardCondition;
  /** Тип награды */
  awardType: AwardTypeEnum;
  /**
   * Бейдж
   * не {null} если {awardType=BADGE}
   */
  badge?: Maybe<BadgeV2>;
  /** Дата создания награды */
  createdTs: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  /** Награда активна */
  isActive: Scalars['Boolean']['output'];
  /** Сколько очков добавляется при апдейте */
  pointsToAdd: Scalars['Int']['output'];
  /** Кол-во выданных наград в рамках кампуса(или продукта). Доступно только при запросе getAwards из-под ba, sa */
  rewardCount?: Maybe<Scalars['Int']['output']>;
  /** Школа, в которой заведена награда. {null} если награда глобальная */
  school?: Maybe<SafeSchool>;
  /** Школа в которой заведена награда */
  schoolId: Scalars['ID']['output'];
  /** Дата редактирования награды */
  updatedTs?: Maybe<Scalars['DateTime']['output']>;
};

/** Информация об ученике Bootcamp-а для сохранения */
export type BtcStudentsInfoInputModel = {
  /** Идентификатор Буткемп-мастера */
  bmUserId?: InputMaybe<Scalars['UUID']['input']>;
  /** Город ученика */
  city?: InputMaybe<Scalars['String']['input']>;
  /** Флаг, указывающий, что Буткемп-мастер не определен для ученика */
  isBmMasterUndefined?: InputMaybe<Scalars['Boolean']['input']>;
  /** Формат обучения - очно/дистанционно */
  isStudyOnline?: InputMaybe<Scalars['Boolean']['input']>;
  /** Идентификатор ученика */
  studentId: Scalars['UUID']['input'];
};

/** Информация об ученике Bootcamp-а */
export type BtcStudentsInfoModel = {
  __typename?: 'BTCStudentsInfoModel';
  /** Идентификатор Буткемп-мастера */
  bmUserId?: Maybe<Scalars['UUID']['output']>;
  /** Город ученика */
  city?: Maybe<Scalars['String']['output']>;
  /** Флаг, указывающий, что Буткемп-мастер не определен для ученика */
  isBmMasterUndefined?: Maybe<Scalars['Boolean']['output']>;
  /** Формат обучения - очно/дистанционно */
  isStudyOnline?: Maybe<Scalars['Boolean']['output']>;
  /** Идентификатор ученика */
  studentId: Scalars['UUID']['output'];
  /** Идентификатор записи об ученике в Моем классе */
  studentInfoId: Scalars['ID']['output'];
};

export type Badge = {
  __typename?: 'Badge';
  /** Ссылка на изображение бэйджа */
  avatarUrl: Scalars['String']['output'];
  /** Ссылка на крупное изображение бэйджа */
  bigAvatarUrl: Scalars['String']['output'];
  /** Описание бэйджа */
  description: Scalars['String']['output'];
  /** Код бэйджа */
  id: Scalars['ID']['output'];
  /** Вид бэйджа (Награды за гибкие навыки, награды за модули, награды за достижения уровней) */
  kind: BadgeKind;
  /** Название бэйджа */
  name: Scalars['String']['output'];
};

/** Создание/изменений бейджей */
export type BadgeAwardInput = {
  /** Механика назначения (учитель/ученик, система/ученик, etc.) */
  assignmentIds: Array<Scalars['Int']['input']>;
  /** Ссылка на изображение бэйджа */
  avatarUrl: Scalars['String']['input'];
  /** Вознаграждение за получение бейджа */
  awardBounties?: InputMaybe<Array<AwardBountyInput>>;
  /**
   * Условия получения награды
   * 1 если награда выдается в ручную
   */
  awardConditionId: Scalars['Int']['input'];
  /** Вид бейджа (командная работа, наставничество, etc.) */
  badgeKindId: Scalars['Int']['input'];
  /** Сколько игровой валюты начисляется за получение бейджа */
  coins?: InputMaybe<Scalars['Int']['input']>;
  /** Сколько печенек начисляется за получение бейджа */
  cookies?: InputMaybe<Scalars['Int']['input']>;
  /** Описание бейджа */
  description: Scalars['String']['input'];
  /** Сколько очков опыта начисляется за получение бейджа */
  experienceValue?: InputMaybe<Scalars['Int']['input']>;
  /** Название получения бейджа */
  name: Scalars['String']['input'];
  /** Сколько очков начисляется за бейдж */
  pointsToAdd: Scalars['Int']['input'];
  /** Включена ли системная выдача для награды */
  systemAssignmentEnabled?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Вид бэйджа (командная работа, наставничество, etc.) */
export type BadgeKind = {
  __typename?: 'BadgeKind';
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  /**
   * Порядок в котором отображаются группы бейджей(сгруппированные по BadgeKind) на фронте.
   * Используется только на фронте, и только в Ш21. В БД не хранится. Вычисляется на лету.
   * С бэка на фронт улетает всегда, с фронта на бэк никогда не передаётся поэтому необязательное поле
   */
  order?: Maybe<Scalars['Int']['output']>;
};

export type BadgeKindV2 = {
  __typename?: 'BadgeKindV2';
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
};

export type BadgeV2 = {
  __typename?: 'BadgeV2';
  /** Ссылка на изображение бэйджа */
  avatarUrl: Scalars['String']['output'];
  /** Вид бэйджа (Награды за гибкие навыки, награды за модули, награды за достижения уровней) */
  badgeKind: BadgeKindV2;
  /** Ссылка на крупное изображение бэйджа */
  bigAvatarUrl: Scalars['String']['output'];
  /** Описание бэйджа */
  description?: Maybe<Scalars['String']['output']>;
  /** Код бэйджа */
  id: Scalars['ID']['output'];
  /** Название бэйджа */
  name: Scalars['String']['output'];
};

/** Содержимое баннера */
export type BannerContent = {
  __typename?: 'BannerContent';
  /** Пресет фонового цвета */
  backgroundColorCode?: Maybe<Scalars['String']['output']>;
  /** Наименование фонового цвета */
  backgroundColorName?: Maybe<Scalars['String']['output']>;
  /** Ссылка на обложку баннера */
  bannerImageLink?: Maybe<Scalars['String']['output']>;
  /** Ссылка баннера */
  bannerLink: Scalars['String']['output'];
  /** Ссылка кнопки банера */
  buttonLink?: Maybe<Scalars['String']['output']>;
  /** Текст кнопки банера */
  buttonText?: Maybe<Scalars['String']['output']>;
  /** Идентификатор кастомного баннера */
  customBannerId?: Maybe<Scalars['String']['output']>;
  /** Дата окончания действия баннера */
  endDate?: Maybe<Scalars['Date']['output']>;
  /** Пресет градиента */
  gradientId?: Maybe<Scalars['String']['output']>;
  /** Заголовок */
  heading: Scalars['String']['output'];
  /** Лого у партнерского баннера */
  logo?: Maybe<Scalars['String']['output']>;
  /** Идентификатор позиции в области */
  positionId: Scalars['String']['output'];
  /** Пресет картинки */
  presetImageId?: Maybe<Scalars['String']['output']>;
  /** Роли */
  roles?: Maybe<BannerContentRolesEnum>;
  /** Дата начала действия баннера */
  startDate?: Maybe<Scalars['Date']['output']>;
  /** Стори */
  stories?: Maybe<Array<Maybe<BannerContentStory>>>;
  /** Подзаголовок */
  subHeading?: Maybe<Scalars['String']['output']>;
};

/** Содержимое баннера */
export type BannerContentInput = {
  /** Пресет фонового цвета */
  backgroundColorCode?: InputMaybe<Scalars['String']['input']>;
  /** Наименование фонового цвета */
  backgroundColorName?: InputMaybe<Scalars['String']['input']>;
  /** Ссылка на обложку баннера */
  bannerImageLink?: InputMaybe<Scalars['String']['input']>;
  /** Ссылка баннера */
  bannerLink: Scalars['String']['input'];
  /** Ссылка кнопки банера */
  buttonLink?: InputMaybe<Scalars['String']['input']>;
  /** Текст кнопки банера */
  buttonText?: InputMaybe<Scalars['String']['input']>;
  /** Идентификатор кастомного баннера */
  customBannerId?: InputMaybe<Scalars['String']['input']>;
  /** Дата окончания действия баннера */
  endDate?: InputMaybe<Scalars['Date']['input']>;
  /** Пресет градиента */
  gradientId?: InputMaybe<Scalars['String']['input']>;
  /** Заголовок */
  heading: Scalars['String']['input'];
  /** Лого у партнерского баннера */
  logo?: InputMaybe<Scalars['String']['input']>;
  /** Идентификатор позиции в области */
  positionId: Scalars['String']['input'];
  /** Пресет картинки */
  presetImageId?: InputMaybe<Scalars['String']['input']>;
  /** Роли */
  roles?: InputMaybe<BannerContentRolesEnum>;
  /** Дата начала действия баннера */
  startDate?: InputMaybe<Scalars['Date']['input']>;
  /** Стори */
  stories?: InputMaybe<Array<InputMaybe<BannerContentStoryInput>>>;
  /** Подзаголовок */
  subHeading?: InputMaybe<Scalars['String']['input']>;
};

/** Роли пользователей для содержимого баннеров */
export enum BannerContentRolesEnum {
  /** Все */
  All = 'ALL',
  /** Только родители */
  Parent = 'PARENT',
  /** Только ученики */
  Student = 'STUDENT'
}

/** Стори */
export type BannerContentStory = {
  __typename?: 'BannerContentStory';
  /** Пресет фонового цвета */
  backgroundColorCode?: Maybe<Scalars['String']['output']>;
  /** Наименование фонового цвета */
  backgroundColorName?: Maybe<Scalars['String']['output']>;
  /** Ссылка на обложку баннера */
  bannerImageLink?: Maybe<Scalars['String']['output']>;
  /** Ссылка кнопки стори */
  buttonLinkStory?: Maybe<Scalars['String']['output']>;
  /** Текст кнопки для стори */
  buttonTextStory?: Maybe<Scalars['String']['output']>;
  /** Описание */
  description?: Maybe<Scalars['String']['output']>;
  /** Дата окончания показа стори */
  endDate?: Maybe<Scalars['Date']['output']>;
  /** Пресет градиента */
  gradientId?: Maybe<Scalars['String']['output']>;
  /** Заголовок */
  heading?: Maybe<Scalars['String']['output']>;
  /** Идентификатор позиции в области */
  positionId: Scalars['Int']['output'];
  /** Пресет картинки */
  presetImageId?: Maybe<Scalars['String']['output']>;
  /** Роли */
  roles?: Maybe<BannerContentRolesEnum>;
  /** Дата начала показа стори */
  startDate?: Maybe<Scalars['Date']['output']>;
};

/** Стори */
export type BannerContentStoryInput = {
  /** Пресет фонового цвета */
  backgroundColorCode?: InputMaybe<Scalars['String']['input']>;
  /** Наименование фонового цвета */
  backgroundColorName?: InputMaybe<Scalars['String']['input']>;
  /** Ссылка на обложку баннера */
  bannerImageLink?: InputMaybe<Scalars['String']['input']>;
  /** Ссылка кнопки стори */
  buttonLinkStory?: InputMaybe<Scalars['String']['input']>;
  /** Текст кнопки для стори */
  buttonTextStory?: InputMaybe<Scalars['String']['input']>;
  /** Описание */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Дата окончания показа стори */
  endDate?: InputMaybe<Scalars['Date']['input']>;
  /** Пресет градиента */
  gradientId?: InputMaybe<Scalars['String']['input']>;
  /** Заголовок */
  heading?: InputMaybe<Scalars['String']['input']>;
  /** Идентификатор позиции в области */
  positionId: Scalars['Int']['input'];
  /** Пресет картинки */
  presetImageId?: InputMaybe<Scalars['String']['input']>;
  /** Роли */
  roles?: InputMaybe<BannerContentRolesEnum>;
  /** Дата начала показа стори */
  startDate?: InputMaybe<Scalars['Date']['input']>;
};

/** Секция баннеров */
export type BannerSection = {
  __typename?: 'BannerSection';
  /** Id секции баннеров */
  id?: Maybe<Scalars['ID']['output']>;
  /** Максимальное количество позиций */
  maxSectionContentCount?: Maybe<Scalars['Int']['output']>;
  /** ID школы, если не задано, то показываем всем */
  schoolId?: Maybe<Scalars['ID']['output']>;
  /** Наименование школы */
  schoolName?: Maybe<Scalars['String']['output']>;
  /** Код секции */
  sectionCode: Scalars['String']['output'];
  /** Содержимое секции (информация о баннерах) в JSON-формате. */
  sectionContent: Array<BannerContent>;
  /** Описание секции */
  sectionDescription?: Maybe<Scalars['String']['output']>;
  /** Имя секции */
  sectionName: Scalars['String']['output'];
  /** ID параллели, если не задано, то показываем всем */
  stageId?: Maybe<Scalars['ID']['output']>;
  /** Наименование параллели */
  stageName?: Maybe<Scalars['String']['output']>;
};

/** Справочная информация по секции баннеров */
export type BannerSectionInfo = {
  __typename?: 'BannerSectionInfo';
  /** Максимальное количество позиций */
  maxSectionContentCount?: Maybe<Scalars['Int']['output']>;
  /** Код секции */
  sectionCode?: Maybe<Scalars['String']['output']>;
  /** Описание секции */
  sectionDescription?: Maybe<Scalars['String']['output']>;
  /** Имя секции */
  sectionName?: Maybe<Scalars['String']['output']>;
};

/** Секция баннеров */
export type BannerSectionInput = {
  /** Id секции баннеров */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** ID школы, если не задано, то показываем всем */
  schoolId?: InputMaybe<Scalars['ID']['input']>;
  /** Имя секции */
  sectionCode: Scalars['String']['input'];
  /** Содержимое секции (информация о баннерах) в JSON-формате. */
  sectionContent: Array<BannerContentInput>;
  /** ID параллели, если не задано, то показываем всем */
  stageId?: InputMaybe<Scalars['ID']['input']>;
};

/** Публичный профиль пользователя */
export type BasePublicProfile = {
  __typename?: 'BasePublicProfile';
  /** Ссылка на аватар пользователя edu_power_global.users.avatar_url */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Имя пользователя edu_power_global.users.first_name */
  firstName: Scalars['String']['output'];
  /** Фамилия пользователя edu_power_global.users.last_name */
  lastName: Scalars['String']['output'];
  /** Отчество пользователя edu_power_global.users.middle_name */
  middleName?: Maybe<Scalars['String']['output']>;
};

/** обычная сущность части стикер-фона */
export type BgStickerPart = {
  __typename?: 'BgStickerPart';
  /** Id главного стикера */
  bgStickerId: Scalars['ID']['output'];
  /** Описание части */
  description: Scalars['String']['output'];
  /** Id части стикер-фона */
  id: Scalars['ID']['output'];
  /** Уровень за который выдается этот стикер-фон */
  level: ExperienceLevel;
  /** Название части стикер-фона */
  name: Scalars['String']['output'];
  /** Ссылка на стикер-аватар */
  url?: Maybe<Scalars['String']['output']>;
};

export type BigChallengeMutations = {
  __typename?: 'BigChallengeMutations';
  acceptBigChallengeTrialV2?: Maybe<Scalars['ID']['output']>;
  acceptBigChallengeV2?: Maybe<Scalars['ID']['output']>;
  declineBigChallengeTrialV2?: Maybe<Scalars['ID']['output']>;
};


export type BigChallengeMutationsAcceptBigChallengeTrialV2Args = {
  bigChallengeId: Scalars['ID']['input'];
  stageId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type BigChallengeMutationsAcceptBigChallengeV2Args = {
  bigChallengeId: Scalars['ID']['input'];
  stageId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type BigChallengeMutationsDeclineBigChallengeTrialV2Args = {
  bigChallengeId: Scalars['ID']['input'];
  stageId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};

/** enums */
export enum BigChallengePeriod {
  AcademicYear = 'ACADEMIC_YEAR',
  Summer = 'SUMMER',
  SummerEve = 'SUMMER_EVE',
  Trial = 'TRIAL',
  WinterChange = 'WINTER_CHANGE'
}

export type BigChallengeQuery = {
  __typename?: 'BigChallengeQuery';
  bigChallengesV2: Array<BigChallengeV2>;
  isEligibleToChangeBigChallenge: Scalars['Boolean']['output'];
  recommendedBigChallenges?: Maybe<Array<Maybe<BigChallengeV3>>>;
};


export type BigChallengeQueryBigChallengesV2Args = {
  stageId: Scalars['ID']['input'];
};


export type BigChallengeQueryIsEligibleToChangeBigChallengeArgs = {
  studentId: Scalars['UUID']['input'];
};


export type BigChallengeQueryRecommendedBigChallengesArgs = {
  maxCount?: InputMaybe<Scalars['Int']['input']>;
  studentId?: InputMaybe<Scalars['UUID']['input']>;
};

export type BigChallengeV2 = {
  __typename?: 'BigChallengeV2';
  /** идентификатор большого вызова */
  bigChallengeId: Scalars['ID']['output'];
  /** полное описание большого вызова */
  description: Scalars['String']['output'];
  /** название большого вызова */
  name: Scalars['String']['output'];
  /** краткое описание большого вызова */
  shortDescription: Scalars['String']['output'];
  /** идентификатор параллели */
  stageId: Scalars['ID']['output'];
  /** список категорий предметов большого вызова */
  subjects: Array<ChallengeSubjectCategory>;
  /** тип большого вызова */
  type: Scalars['String']['output'];
};

export type BigChallengeV3 = {
  __typename?: 'BigChallengeV3';
  /** идентификатор большого вызова */
  bigChallengeId: Scalars['ID']['output'];
  /** полное описание большого вызова */
  description: Scalars['String']['output'];
  /** название большого вызова */
  name: Scalars['String']['output'];
  /** Целевое значение баллов по Большому Вызову */
  pointsRequired: Scalars['Int']['output'];
  /** краткое описание большого вызова */
  shortDescription: Scalars['String']['output'];
  /** идентификатор параллели */
  stageId: Scalars['ID']['output'];
  /** список категорий предметов большого вызова */
  subjects: Array<ChallengeSubjectCategory>;
  /** тип большого вызова */
  type: Scalars['String']['output'];
};

export type BigChallengeWithStudentProgressQueryV3 = {
  __typename?: 'BigChallengeWithStudentProgressQueryV3';
  activeBigChallengeInfoWithProgressV3?: Maybe<BigChallengeWithStudentProgressV3>;
  bigChallengeInfoWithProgressV3?: Maybe<BigChallengeWithStudentProgressV3>;
  currentBigChallengeProgressForStudent?: Maybe<CurrentProgress>;
  currentBigChallengeStateForStudent?: Maybe<BigChallengeWithStudentProgressV3>;
  lastActiveBigChallengeInfoWithProgressV2?: Maybe<BigChallengeWithStudentProgressV3>;
};


export type BigChallengeWithStudentProgressQueryV3ActiveBigChallengeInfoWithProgressV3Args = {
  stageId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type BigChallengeWithStudentProgressQueryV3BigChallengeInfoWithProgressV3Args = {
  bigChallengeId: Scalars['ID']['input'];
  stageId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type BigChallengeWithStudentProgressQueryV3CurrentBigChallengeProgressForStudentArgs = {
  bigChallengeId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type BigChallengeWithStudentProgressQueryV3CurrentBigChallengeStateForStudentArgs = {
  studentId: Scalars['UUID']['input'];
};


export type BigChallengeWithStudentProgressQueryV3LastActiveBigChallengeInfoWithProgressV2Args = {
  studentId: Scalars['UUID']['input'];
};

export type BigChallengeWithStudentProgressV3 = {
  __typename?: 'BigChallengeWithStudentProgressV3';
  bigChallenge: BigChallengeV3;
  progressBarData: ProgressBarDataV2;
  studentId: Scalars['UUID']['output'];
  studentToBigChallenge?: Maybe<StudentToBigChallengeV2>;
};

/** Книга */
export type Book = {
  __typename?: 'Book';
  /** Авторы книги */
  authors: Array<Author>;
  /** Идентфикатор УМК */
  bookUmkId?: Maybe<Scalars['ID']['output']>;
  /** Url обложки */
  coverUrl?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** Название книги */
  name: Scalars['String']['output'];
  /** Вид литературы */
  type: BookTypeEnum;
  /**
   * Идентфикатор УМК
   * @deprecated Will be deleted. Use instead bookUmkId
   */
  umkId: Scalars['ID']['output'];
};

/** Обложки для книг */
export type BookAvatar = {
  __typename?: 'BookAvatar';
  /** URL обложки */
  avatarUrl: Scalars['String']['output'];
  /** Идентификатор обложки */
  bookId: Scalars['ID']['output'];
};

/** Вид литературы */
export enum BookTypeEnum {
  /** Атлас */
  Atlas = 'ATLAS',
  /** Контурная_карта */
  ContourMap = 'CONTOUR_MAP',
  /** Пособие_по_диагностике_и_аттестации */
  DiagnosticCertificationGuide = 'DIAGNOSTIC_CERTIFICATION_GUIDE',
  /** Дидактический материал */
  DidacticMaterial = 'DIDACTIC_MATERIAL',
  /** ЭФУ */
  Efu = 'EFU',
  /** ЭФУ_ЭФУП */
  EfuEfup = 'EFU_EFUP',
  /** Методическое_пособие */
  MethodologicalGuide = 'METHODOLOGICAL_GUIDE',
  /** Программа */
  Program = 'PROGRAM',
  /** Учебник */
  Textbook = 'TEXTBOOK',
  /** Рабочая_тетрадь */
  Workbook = 'WORKBOOK'
}

/** Статистика по алгоритму выбора проверяющего */
export type BookingAttemptStatistic = {
  __typename?: 'BookingAttemptStatistic';
  /** Средний процент отбора участника */
  averagePercent: Scalars['Int']['output'];
  /** Список попыток записей проверяемых */
  bookingVerifiableList: Array<BookingAttemptVerifiable>;
  /** Кол-во попыток по конкретному этапу */
  countAttempts: Scalars['Int']['output'];
  /** Этап, на котором выбыл или был выбран таймслот */
  selectionStageEnum: SelectionStageEnum;
};

/** Попытка записи проверяемого */
export type BookingAttemptVerifiable = {
  __typename?: 'BookingAttemptVerifiable';
  /** Идентификатор попытки */
  bookingAttemptId: Scalars['Int']['output'];
  /** Идентификатор записи */
  bookingId: Scalars['Int']['output'];
  /** Длительность проверки */
  duration: Scalars['Int']['output'];
  /** Логин проверяемого */
  loginVerifiable: Scalars['String']['output'];
  /** Время проверки */
  timeCheck: Scalars['DateTime']['output'];
};

/** Попытка записи проверяющего */
export type BookingAttemptVerifier = {
  __typename?: 'BookingAttemptVerifier';
  /** Идентификатор попытки */
  bookingAttemptId: Scalars['Int']['output'];
  /** Идентификатор записи */
  bookingId: Scalars['Int']['output'];
  /**
   * Названия кампуса, в которой был создан слот
   * {null}, когда еще не было этапа Выбор кампуса
   */
  campusName?: Maybe<Scalars['String']['output']>;
  /** Значение баланса PRP на момент записи на проверку */
  currentPrpAmount: Scalars['Int']['output'];
  /** Дата последней встречи с проверяемым (null - если не было встреч) */
  lastMeetingDate?: Maybe<Scalars['Date']['output']>;
  /** Логин проверяющего */
  loginVerifier: Scalars['String']['output'];
  /** Общее количество встреч с проверяемым (по P2P) */
  meetingsFrequency: Scalars['Int']['output'];
  /** Этап, на котором выбыл или был выбран таймслот */
  selectionStageEnum: SelectionStageEnum;
};

/** Протокол проверки P2P в школе 21 */
export enum BookingStatusEnum {
  /** Проверка отменена из-за окончания интенсива проверяющего */
  CancelledByCompletionIntensiveVerifier = 'CANCELLED_BY_COMPLETION_INTENSIVE_VERIFIER',
  /** Проверка отменена из-за отчисления проверяемого */
  CancelledByExpelledVerifiable = 'CANCELLED_BY_EXPELLED_VERIFIABLE',
  /** Проверка отменена из-за отчисления проверяющего */
  CancelledByExpelledVerifier = 'CANCELLED_BY_EXPELLED_VERIFIER',
  /** Проверка отменена из-за заморозки проверяемого */
  CancelledByFrozenVerifiable = 'CANCELLED_BY_FROZEN_VERIFIABLE',
  /** Проверка отменена из-за заморозки проверяющего */
  CancelledByFrozenVerifier = 'CANCELLED_BY_FROZEN_VERIFIER',
  /** Задание проверено учителем */
  TaskCheckedByStaff = 'TASK_CHECKED_BY_STAFF',
  /** Задание проверено другим студентом */
  TaskCheckedByStudent = 'TASK_CHECKED_BY_STUDENT',
  /** Задание провеверно на экстра проверке сотрудником */
  TaskCheckedWithExtraTypeByStaff = 'TASK_CHECKED_WITH_EXTRA_TYPE_BY_STAFF',
  /** Задание провеверно на экстра проверке студентом */
  TaskCheckedWithExtraTypeByStudent = 'TASK_CHECKED_WITH_EXTRA_TYPE_BY_STUDENT',
  /** Задание провеверно на приоритетной проверке сотрудником */
  TaskCheckedWithPriorityTypeByStaff = 'TASK_CHECKED_WITH_PRIORITY_TYPE_BY_STAFF',
  /** Задание провеверно на приоритетной проверке студентом */
  TaskCheckedWithPriorityTypeByStudent = 'TASK_CHECKED_WITH_PRIORITY_TYPE_BY_STUDENT',
  /** Задание на проверке код ревью */
  TaskInCodeReview = 'TASK_IN_CODE_REVIEW',
  /** Задание сдано на проверку сотруднику */
  TaskSendForCheckToStaff = 'TASK_SEND_FOR_CHECK_TO_STAFF',
  /** Заданиче отправлено на проверку */
  TaskSendForCheckToStudent = 'TASK_SEND_FOR_CHECK_TO_STUDENT',
  /** Задание отправлено на экстра проверку сотруднику */
  TaskSendForExtraCheckToStaff = 'TASK_SEND_FOR_EXTRA_CHECK_TO_STAFF',
  /** Задание отправлено на экстра проверку студенту */
  TaskSendForExtraCheckToStudent = 'TASK_SEND_FOR_EXTRA_CHECK_TO_STUDENT',
  /** Задание отправлено на принудительную проверку сотруднику */
  TaskSendForForcedCheckToStaff = 'TASK_SEND_FOR_FORCED_CHECK_TO_STAFF',
  /** Задание отправлено на принудительную проверку студенту */
  TaskSendForForcedCheckToStudent = 'TASK_SEND_FOR_FORCED_CHECK_TO_STUDENT',
  /** Задание отправлено на приоритетную проверку сотруднику */
  TaskSendForPriorityCheckToStaff = 'TASK_SEND_FOR_PRIORITY_CHECK_TO_STAFF',
  /** Задание отправлено на приоритетную проверку студенту */
  TaskSendForPriorityCheckToStudent = 'TASK_SEND_FOR_PRIORITY_CHECK_TO_STUDENT',
  /** Проверяемый отменил проверку */
  VerifiableCancelledBooking = 'VERIFIABLE_CANCELLED_BOOKING',
  /** Проверяемый не явился */
  VerifiableWasAbsent = 'VERIFIABLE_WAS_ABSENT',
  /** Проверяющий отменил проверку */
  VerifierCancelledBooking = 'VERIFIER_CANCELLED_BOOKING',
  /** Проверяющий не явился */
  VerifierWasAbsent = 'VERIFIER_WAS_ABSENT'
}

/** Статистика пользователя по его избранному */
export type BookmarkStatistics = {
  __typename?: 'BookmarkStatistics';
  /** Количество материалов в списке избранного пользователя */
  totalItems: Scalars['Int']['output'];
};

/** Информация о Bootcamp-мастере */
export type BootcampMasterModel = {
  __typename?: 'BootcampMasterModel';
  /** Ссылка на аватар профиля */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Идентификатор Буткемп-мастера */
  bmId: Scalars['UUID']['output'];
  /** Имя Буткемп-мастера */
  firstName?: Maybe<Scalars['String']['output']>;
  /** Фамилия Буткемп-мастера */
  lastName?: Maybe<Scalars['String']['output']>;
  /** Отчество Буткемп-мастера */
  middleName?: Maybe<Scalars['String']['output']>;
  /** Идентификатор пользователя */
  userId: Scalars['UUID']['output'];
};

export type Branch = {
  __typename?: 'Branch';
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
};

export type BreadCrumbsPlanItem = {
  __typename?: 'BreadCrumbsPlanItem';
  /** Идентификатор курса */
  courseId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор сущности в курсе */
  courseItemId?: Maybe<Scalars['ID']['output']>;
  /** Название сущности в курсе */
  courseItemName?: Maybe<Scalars['String']['output']>;
  /** Название курса */
  courseName?: Maybe<Scalars['String']['output']>;
  /** Тип выполнения */
  executionType?: Maybe<ModuleExecutionType>;
  /** Идентификатор плана */
  planId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор сущности в плане */
  planItemId?: Maybe<Scalars['ID']['output']>;
  /** Название сущности в плане */
  planItemName?: Maybe<Scalars['String']['output']>;
  /** Название плана */
  planName?: Maybe<Scalars['String']['output']>;
  /** Идентификатор группы студентов */
  studentGroupId?: Maybe<Scalars['ID']['output']>;
};

export type BtcStudentCityModel = {
  __typename?: 'BtcStudentCityModel';
  /** Название города */
  cityName: Scalars['String']['output'];
  /** Формат обучения учеников в Bootcamp в этом городе (очно/дистанционно) */
  isStudyOnline?: Maybe<Scalars['Boolean']['output']>;
  /** Идентификатор города */
  studentCityId: Scalars['ID']['output'];
};

export type Building = {
  __typename?: 'Building';
  address: Scalars['String']['output'];
  classrooms: Array<ClassRoom>;
  id: Scalars['ID']['output'];
  isActive: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  roomsNumber: Scalars['Int']['output'];
  safeSchool: SafeSchool;
};

/** Типы жалоб на буллинг */
export enum BullyingComplaintTypeEnum {
  ClassmatesProblems = 'CLASSMATES_PROBLEMS',
  JustTalk = 'JUST_TALK',
  Other = 'OTHER',
  ParentsProblems = 'PARENTS_PROBLEMS',
  ProfessionChoice = 'PROFESSION_CHOICE',
  StudiesProblems = 'STUDIES_PROBLEMS'
}

export type BusinessAdminMutations = {
  __typename?: 'BusinessAdminMutations';
  /**
   * Массовая выдача игровых монет
   * @deprecated Используйте S21CoinsGroupTransactionV2, возвращающий результат операции
   */
  S21CoinsGroupTransaction: Scalars['Boolean']['output'];
  /**
   * Массовая выдача монет ученикам по фильтру
   * @deprecated Используйте S21CoinsGroupTransactionByFilterV2, возвращающий результат операции
   */
  S21CoinsGroupTransactionByFilter: Scalars['Boolean']['output'];
  /** Массовая выдача монет ученикам по фильтру */
  S21CoinsGroupTransactionByFilterV2: GroupCoinsTransactionResponseModel;
  /** Массовая выдача игровых монет */
  S21CoinsGroupTransactionV2: GroupCoinsTransactionResponseModel;
  /** Массовая выдача награды ученикам */
  S21MassAddAwardToUsers: S21MassAddAwardToUsersResponse;
  /** Массовая выдача награды ученикам по фильтру */
  S21MassAddAwardToUsersByFilter: S21MassAddAwardToUsersResponse;
  activateBusinessAdminRole?: Maybe<Scalars['Boolean']['output']>;
  activateParentRole?: Maybe<Scalars['Boolean']['output']>;
  activateSchool: School;
  activateStudentRole?: Maybe<Scalars['Boolean']['output']>;
  activateTeacherRole?: Maybe<Scalars['Boolean']['output']>;
  /** Добавление урока с возможностью повтора до определенной даты */
  addLesson: Scalars['Int']['output'];
  /** Добавление коллекции уроков с возможностью повтора до определенной даты */
  addLessons: Scalars['Int']['output'];
  /** Добавить емейл психолога (для оказания помощи при издевательствах) с привязкой к классам */
  addStageGroupPsychologistEmail: Scalars['String']['output'];
  /** Мутация пытается добавить каждую форму контроля для переданных массивов */
  addStudyStepSubjectLearningActivities?: Maybe<AddStudyStepSubjectLearningActivitiesResult>;
  addSubjectLearningActivity: Array<LearningActivity>;
  /** Добавить пользователей в группы */
  addUsersToUserGroups: Array<UserGroup>;
  /** Перенести дедлайн Ш21 */
  approveDeadlineShiftRequest: DeadlineShiftRequest;
  archiveAward: Award;
  /** Кидает ивенты о необходимости блокировки студентов определенного класса и отмену их штрафов */
  blockUsersOfStageGroup: Scalars['Boolean']['output'];
  /**
   * Кидает ивенты о необходимости блокировки студентов определенной группы по предмету и отмену их штрафов
   * @deprecated use school21 mutation
   */
  blockUsersOfStageSubjectGroup: Scalars['Boolean']['output'];
  /**
   * Изменение Плана на Класс по Предмету по идентификатору (stage_subject_group_plan_id)
   * @deprecated Field no longer supported
   */
  changeClassPlan: ClassPlan;
  changeClassPlanWithChecking: ClassPlanChangeResponse;
  /**
   * Метод для модификации номера кабинетов в еще не прошедших уроках
   * Можно в newClassroomId передать null, если кабинет необязателен
   */
  changeClassroomInFutureLessons: Scalars['Boolean']['output'];
  /** Вкл\выкл кластера в Ш21 */
  changeClusterState: Scalars['Int']['output'];
  /** Изменение баллов участников коалиции в текущем активном турнире */
  changeCoalitionMemberPoints: Scalars['Boolean']['output'];
  /** Выдача очков коалиции по логинам */
  changeCoalitionMemberPointsByFilter: ChangeCoalitionMemberPointsResponse;
  /** Выдача очков коалиции по логинам */
  changeCoalitionMemberPointsByLogins: ChangeCoalitionMemberPointsResponse;
  /** Изменение баллов коалиций в рамках турнира */
  changeCoalitionPoints: Scalars['Boolean']['output'];
  /** Редактирование урока */
  changeLesson: Lesson;
  /**
   * Изменяет существующий План на Параллель по ID (stage_subject_plans.stage_subject_plan_id)
   * @deprecated use sc21BaTaskCheck#savePrivateFeedback
   */
  changeStagePlan: StagePlan;
  checkAutoAwards: Scalars['Boolean']['output'];
  /** Завершаем турнир по ID */
  closeTournament: GameTournament;
  /** Создание персональных планов на основе существующих */
  copyAndActivatePersonalPlans: Array<Maybe<Scalars['ID']['output']>>;
  /** Копирование награды по идентификатору */
  copyBadgeAward: Award;
  /** Стиражировать Базовый Плейлист */
  copyBasePlaylist: TaskSet;
  /** Скопировать групповой План на Группы по Предмету или на Студентов как персональный */
  copyClassPlan: ClassPlan;
  /**
   * Копирование модуля, возвращает скопированный модуль
   * @deprecated Под удаление. Использовать новую схему content.graphqls, метод copyModule
   */
  copyModule: StudyModule;
  /**
   * перенос структуры классов из года в год
   * @deprecated Не используется. Перешли на massTransferAsync
   */
  copyStructureToNewYear: Array<Scalars['String']['output']>;
  createAvatar: Scalars['ID']['output'];
  createBadgeAward: Award;
  /** @deprecated Classroom has new mandatory field, use saveBuilding method */
  createBuilding: Building;
  /** Создание Плана на Класс по Предмету с назначением плану определенного статуса(stage_subject_group_plans) TODO: до написания метода */
  createClassPlan: ClassPlan;
  createClassRoom: ClassRoom;
  /** создание нескольких групп по предмету */
  createClassSubjectGroups: Array<ClassSubject>;
  /** Создание дедлайна Ш21 */
  createDeadline: Deadline;
  /** Создание экзамена в школе */
  createExam: Exam;
  /** Создание драфта ручного расписания */
  createManualTimeTableDraft: TimetableDraftV2;
  /** Создать кластер в Ш21 */
  createOrUpdateS21Cluster: Scalars['Int']['output'];
  /** Создание дистанционных периодов */
  createPeriodLessonPlans?: Maybe<Scalars['Boolean']['output']>;
  /** Создание конфигурации оценивания */
  createRatingConfiguration: RatingConfiguration;
  /** Сохраняет данные о новой школьной группе системы оценивания */
  createSchoolMarkTypeGroup: SchoolMarkTypeGroup;
  /** Создаёт новую конфигурацию оценивания */
  createSchoolMarkTypeGroupConfiguration: SchoolMarkTypeGroupConfiguration;
  /** Сохранение классов с получением и добавлением предметов для учителя Иннополис */
  createStageGroupWithAllStageSubjectGroups: Array<ClassSubject>;
  /** Создает План на Параллель по Предмету */
  createStagePlan: StagePlan;
  /** Добавление уроков в существующий драфт расписания */
  createTimetableDraftLessons: Array<ExtendedLessonDraft>;
  /** Сохранение нового университета с доменами */
  createUniversitiesWithDomains: Scalars['ID']['output'];
  createUserInvites: Array<UserDraftOperationsResult>;
  deactivateClassRoom: Scalars['Boolean']['output'];
  /** Деактивация драфта бизнес-пользователя с ролями (Ученик, Родитель) и только в текущей школе */
  deactivateUserDraft: UserDraftOperationsResult;
  /** Удаление здания, привязанного к школе */
  deleteBuilding?: Maybe<Scalars['Boolean']['output']>;
  /** Удаление/деактивация роли Конфигуратор системы у пользователя в текущей школе */
  deleteBusinessAdminRole: Scalars['Boolean']['output'];
  /** Удалить черновик кластера в Ш21 */
  deleteClusterDraft: Scalars['Int']['output'];
  /** Удаление дедлайна */
  deleteDeadline: Deadline;
  /** Удаляем коалицию и всю инфу об участниках */
  deleteGameCoalition: Scalars['Boolean']['output'];
  /** Удаляем турнир и всю инфу об участниках */
  deleteGameTournament: Scalars['Boolean']['output'];
  /** @deprecated Не поддерживается. Используйте deleteGitlabProjectsV3 */
  deleteGitlabProjects: DeleteGitlabProjectsResponse;
  /** удаление гитлаб-проектов по идентификаторам */
  deleteGitlabProjectsByExternalSystemProjectIds: DeleteGitlabProjectsResponse;
  deleteGitlabProjectsV2: DeleteGitlabProjectsResponse;
  /** удаление гитлаб-проектов по параметрам */
  deleteGitlabProjectsV3: DeleteGitlabProjectsResponse;
  /** Удаляет все элементы для переданного набора, а затем и сам переданный набор форм контроля */
  deleteLearningActivitySet: Scalars['Boolean']['output'];
  /** Удаляет переданную форму контроля из набора */
  deleteLearningActivitySetElement: Scalars['Boolean']['output'];
  /**
   * Удаление урока.
   * Если стоит флаг deleteAllRepeatAtSameDayOfWeek - то удаляются все повторы этого урока,
   * которые приходятся на тот же день недели
   */
  deleteLesson: Scalars['Int']['output'];
  /** Удаление/деактивация роли Родитель у пользователя в текущей школе */
  deleteParentRole: Scalars['Boolean']['output'];
  /** Удаление дистанционного периода */
  deletePeriodLessonPlan?: Maybe<Scalars['Boolean']['output']>;
  /** S21. Удаление файлов из проектов с платформенным типом решения */
  deletePlatfProjectSolutions: DeletePlatfProjectSolutionsResponse;
  /** Удаляет данные о школьной группе системы оценивания */
  deleteSchoolMarkTypeGroup: Array<SchoolMarkTypeGroup>;
  /** Удаляет данные о конфигурации оценивания и возвращает актуальный список конфигураций оценивания для школы */
  deleteSchoolMarkTypeGroupConfiguration: Array<SchoolMarkTypeGroupConfiguration>;
  /** Удаление записи в student_whiteList */
  deleteStudentByMobilePhoneOrEmailOrUtmSource?: Maybe<Scalars['Boolean']['output']>;
  /** Кидает ивенты о необходимости удаления студенческих проектов из гитлаба при переводе их в основу */
  deleteStudentGitlabIntensiveProjects: Scalars['Boolean']['output'];
  /** Удаление/деактивация роли Ученик у пользователя в текущей школе */
  deleteStudentRole: Scalars['Boolean']['output'];
  /** Мутация удаляет переданную форму контроля по идентификатору */
  deleteStudyStepSubjectLearningActivity: Scalars['Boolean']['output'];
  deleteSubjectLearningActivity: Array<LearningActivity>;
  /** Удаление сгенерированного расписания, true - если успешно удалено */
  deleteTimetableDraft: Scalars['Boolean']['output'];
  /** Удаление уроков из существующего драфта расписания по идентификаторам драфтов уроков */
  deleteTimetableDraftLessons: Scalars['Boolean']['output'];
  deleteUserInvite: UserDraftOperationsResult;
  /** Скидывает конструкторы локального курса до глобального */
  dropLocalCourseGoalConditionsToGlobal: Scalars['Boolean']['output'];
  editAvatar: Scalars['Boolean']['output'];
  editBadgeAward: Award;
  /** @deprecated Classroom has new mandatory field, use updateBuilding method */
  editBuilding: Building;
  editExperienceLevelRange: Scalars['Boolean']['output'];
  /** @deprecated use school21 mutation */
  expelStudent: ExpelResult;
  /**
   * Отчислить студентов с основы Ш21
   * @deprecated use school21 mutation
   */
  expelStudents?: Maybe<ExpelResult>;
  /** Формирование команд из модуля в локальном курсе (группе проектов) */
  formTeamsForLocalCourseGoal: Array<ProjectTeamMembers>;
  /** Формирование команд из модуля в плане на класс */
  formTeamsForStageSubjectGroupPlanGoal: Array<ProjectTeamMembers>;
  /** @deprecated use school21 mutation */
  freezeStudent: ExpelResult;
  /**
   * Заморозить студентов в ш21
   * @deprecated use school21 mutation
   */
  freezeStudents?: Maybe<ExpelResult>;
  /** Выполнить асинхронный запрос на автоматическую генерацию расписания */
  generateSchedule: Scalars['Boolean']['output'];
  /** выпуск учеников */
  graduateStudents: StageGroup;
  /** Обработка всех дедлайнов */
  handleAllProjectDeadlines?: Maybe<Scalars['Boolean']['output']>;
  /** Создание новой записи в student_whiteList */
  insertNewStudent?: Maybe<Scalars['Boolean']['output']>;
  /** Запись факта выдачи Welcome Pack */
  issuedWelcomePack: WelcomePackModel;
  /** Ручное завершение экзамена для всех студентов подписанных на экзамен */
  manualExamFinish: Scalars['Boolean']['output'];
  /** Отметить версию черновика расписания как просмотренную */
  markTimeTableDraftAsViewed: Scalars['Boolean']['output'];
  /**
   * Мутация создает асинхронную задачу на перевод классов из одного учебного года в другой.
   * Возвращает ID созданной задачи
   */
  massTransferAsync: Scalars['ID']['output'];
  /** Метод для модификации уроков в результате редактирования цепочки уроков */
  modifyLessons: Scalars['Boolean']['output'];
  /** Перевести студента в новую коалицию */
  moveToAnotherCoalition: CoalitionMember;
  readAllNotifications: Scalars['Boolean']['output'];
  readByObject: Scalars['Boolean']['output'];
  readNotification: Scalars['ID']['output'];
  /** @deprecated use school21 mutation */
  reinstateStudent: ExpelResult;
  /**
   * Восстановить студентов в Ш21
   * @deprecated use school21 mutation
   */
  reinstateStudents?: Maybe<ExpelResult>;
  /** Удаление заявки на перенос дедлайна */
  rejectDeadlineShiftRequest: DeadlineShiftRequest;
  /**
   * удалениие групп по предмету
   * @deprecated Использовать saveStudyPeriodSet. Под удаление
   */
  removeClassSubjectGroups: StageGroup;
  /** Удалить емейл психолога (для оказания помощи при издевательствах) с привязкой к классам */
  removeStageGroupPsychologistEmail: Scalars['String']['output'];
  /** Удалить пользователей из групп */
  removeUsersFromUserGroups: Array<UserGroup>;
  /** Переименование кластера в Ш21 */
  renameS21Cluster: Scalars['Int']['output'];
  /** Сброс факта выдачи Welcome Pack */
  resetIssuedStatusForWelcomePack: WelcomePackModel;
  /**
   * Перезапуск сохранения текущей версии плана для студентов с ошибкой
   * @deprecated Функция работает не стабильно и временно отключена. Доработки будут реализованы в рамках S21-19562
   */
  retryS21ClassPlanSavingWithCurrentVersion: Scalars['Boolean']['output'];
  revertS21ClassPlanToLastSuccessVersion: Scalars['Boolean']['output'];
  /** создание здания */
  saveBuilding: Building;
  /** Изменение проектов в плане на класс */
  saveClassPlanProjects: S21ClassPlan;
  /** создание/редактирование группы по предмету */
  saveClassSubjectGroup: ClassSubject;
  /** создание/редактирование групп по предмету (опционально распределение студентов по гкпп в случае создания новых с исключениями) */
  saveClassSubjectGroups: Array<ClassSubject>;
  /** @deprecated Использовать saveGameCoalitionV3, удалить после переезда в новую админку ш21 */
  saveGameCoalition: GameCoalition;
  saveGameCoalitionV2: GameCoalition;
  saveGameCoalitionV3: GameCoalition;
  /** Создаем или изменяем турнир в школе пользователя */
  saveGameTournament: GameTournament;
  /** Мутация создает или изменяет уже существующий набор форм контроля */
  saveLearningActivitySet?: Maybe<LearningActivitySet>;
  /** Сохранение настройки повторного прохождения проекта */
  saveModuleAttemptsSettings: ModuleAttemptsSettings;
  /** Сохранение приватного фидбэка на команду */
  savePrivateFeedback: Scalars['Boolean']['output'];
  /** создание/редактирование группы по предмету для Школы 21 */
  saveS21ClassSubjectGroup: ClassSubject;
  /** Сохранение настроек праздничных тем */
  saveS21GlobalSchoolViews: Array<S21SchoolViewSettings>;
  /** Сохранение настроек праздничных тем */
  saveS21SchoolViews: Array<S21SchoolViewSettings>;
  /** сохранение текущей школы */
  saveSchool: ValidatedSchool;
  saveSchoolLearningActivityWeights?: Maybe<Scalars['Boolean']['output']>;
  /** Сохраняет данные о школьной группе системы оценивания */
  saveSchoolMarkTypeGroup: SchoolMarkTypeGroup;
  /** Сохраняет измененные данные о конфигурации оценивания */
  saveSchoolMarkTypeGroupConfiguration: SchoolMarkTypeGroupConfiguration;
  /** редактирование/наполнение класcа и групп, если необходимо */
  saveStageGroup: StageGroup;
  /** редактирование/наполнение клаcса и групп для Bootcamp, если необходимо */
  saveStageGroupBTC: StageGroup;
  /** Сохранение email на класс для помощи студентам Bootcamp */
  saveStageGroupHelpEmail: StageGroupHelpEmailModel;
  saveStageGroups: Array<StageGroup>;
  /** сохранение набора учебных периодов */
  saveStudyPeriodSet: Scalars['UUID']['output'];
  saveStudyPeriodSets: Array<StudyPeriodSet>;
  /** сохранение учебной программы за год */
  saveStudyProgram: StudyProgram;
  /** Новый метод сохранения предмета(-ов) для данного образовательного учреждения с 2-мя параметрами "subjects" и "orgUnitId" */
  saveSubjectsForOrganization: Array<Subject>;
  /** Сохранение параметров расчета навыков за проверку задания */
  saveTaskAdditionalAttributes: Scalars['Boolean']['output'];
  saveTimeSlotSets: Array<TimeSlotSet>;
  /** Сохранение драфта расписания */
  saveTimetableDraftV2: Scalars['Boolean']['output'];
  /** сохранение/изменение бизнес-пользователя с ролями (учитель, ученик, БА) и только в текущей школе */
  saveUser: User;
  /** сохранение/изменение драфта бизнес-пользователя с ролями (Ученик, Родитель) и только в текущей школе */
  saveUserDraft: UserDraftOperationsResult;
  /** сохранение бизнес-пользователя с ролью ученик (только в текущей школе) */
  saveUserWithUserDraftBusinessCode: User;
  /** повторная отправка приглашения на основе существующего драфт-пользователя */
  sendInviteAgainAndUpdateUserDraft: UserDraftOperationsResult;
  /** Изменение статуса Плана на Класс По Предмету */
  setClassPlanStatus: ClassPlan;
  /** @deprecated Достаточно старая реализация. Не не использовать! */
  setExpTaskTypePower: Scalars['Boolean']['output'];
  /** Проставление школе флага, что все обязательные данные заполнены */
  setMandatoryDataFilled?: Maybe<Scalars['Boolean']['output']>;
  /** Установка локали пользователя */
  setUserLocale: Scalars['String']['output'];
  /** сдвиг дедлайнов для студента */
  shiftDeadlines: Array<Maybe<DeadlineStudentInfo>>;
  /** сдвиг дедлайна для студента */
  shiftSingleDeadline: DeadlineStudentInfo;
  /**
   * Восстановление класса из архива Bootcamp
   * @deprecated Не поддерживается. Используйте deleteGitlabProjectsV2
   */
  stageGroupFromArchive: Scalars['Boolean']['output'];
  /** Перевод класса в архив Bootcamp */
  stageGroupToArchive: Scalars['Boolean']['output'];
  /** Удаление/деактивация роли Учитель у пользователя в текущей школе. В т.ч. удаление роли Ученик, если она относится к внешнему обучению */
  substituteAndDeleteTeacherRole: Scalars['Boolean']['output'];
  /** @deprecated use school21 mutation */
  unfreezeStudents?: Maybe<ExpelResult>;
  /** Изменение признака разрешения для студента в student_whiteList */
  updateAllowedStatusByMobilePhoneOrEmailOrUtmSource?: Maybe<Scalars['Boolean']['output']>;
  updateBuilding: Building;
  /** Обновление выданного сертификата ученику */
  updateCertificateTemplateForStudent: IssuedCertificateModel;
  updateClassRoom: ClassRoom;
  /** Обновление разбалловки */
  updateCountInfo: Scalars['Boolean']['output'];
  /** Редактирование дедлайна Ш21 */
  updateDeadline: Deadline;
  /**
   * Обновление экзамена в школе
   * @deprecated Использовать saveGameCoalitionV2, удалить после переезда в новую админку ш21
   */
  updateExam: Exam;
  /** Запись баллов в таблицу глобальных заданий */
  updateGlobalPlanGoalPoints?: Maybe<Scalars['Boolean']['output']>;
  /** Редактирование дистанционного периода */
  updatePeriodLessonPlan: PeriodLessonPlanExtended;
  /** Обновление дистанционного периода (перегенерация планов) */
  updatePeriodLessonPlanById: PeriodLessonPlanExtended;
  /** Обновление дистанционных периодов (перегенерация планов) */
  updatePeriodLessonPlansByIds: Array<PeriodLessonPlanExtended>;
  updateStageGroupsForTimeSlotSet?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Обновление драфта расписания
   * @deprecated Use createTimetableDraftLessons/updateTimetableDraftLessons/deleteTimetableDraftLessons instead
   */
  updateTimetableDraft: Scalars['Boolean']['output'];
  /** Обновление уроков в существующем драфте расписания */
  updateTimetableDraftLessons: Array<ExtendedLessonDraft>;
  /** Обновление информации по университету */
  updateUniversityWithDomains: UniversityInfoModel;
  updateUserInvite: UserDraftOperationsResult;
  /** Устанавливаем второй фактор при аутентификации пользователя. */
  updateUserSecondFactorAuth: Scalars['Boolean']['output'];
};


export type BusinessAdminMutationsS21CoinsGroupTransactionArgs = {
  comment?: InputMaybe<Scalars['String']['input']>;
  logins: Array<Scalars['String']['input']>;
  transactionAmount: Scalars['Int']['input'];
};


export type BusinessAdminMutationsS21CoinsGroupTransactionByFilterArgs = {
  coalitionId?: InputMaybe<Scalars['ID']['input']>;
  comment?: InputMaybe<Scalars['String']['input']>;
  experienceLevelId?: InputMaybe<Scalars['ID']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  stageGroupId?: InputMaybe<Scalars['ID']['input']>;
  stageId?: InputMaybe<Scalars['ID']['input']>;
  transactionAmount: Scalars['Int']['input'];
};


export type BusinessAdminMutationsS21CoinsGroupTransactionByFilterV2Args = {
  coalitionId?: InputMaybe<Scalars['ID']['input']>;
  comment?: InputMaybe<Scalars['String']['input']>;
  experienceLevelId?: InputMaybe<Scalars['ID']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  stageGroupId?: InputMaybe<Scalars['ID']['input']>;
  stageId?: InputMaybe<Scalars['ID']['input']>;
  transactionAmount: Scalars['Int']['input'];
};


export type BusinessAdminMutationsS21CoinsGroupTransactionV2Args = {
  comment?: InputMaybe<Scalars['String']['input']>;
  logins: Array<Scalars['String']['input']>;
  transactionAmount: Scalars['Int']['input'];
};


export type BusinessAdminMutationsS21MassAddAwardToUsersArgs = {
  awardId: Scalars['ID']['input'];
  comment?: InputMaybe<Scalars['String']['input']>;
  logins: Array<Scalars['String']['input']>;
};


export type BusinessAdminMutationsS21MassAddAwardToUsersByFilterArgs = {
  awardId: Scalars['ID']['input'];
  coalitionId?: InputMaybe<Scalars['ID']['input']>;
  comment?: InputMaybe<Scalars['String']['input']>;
  experienceLevelId?: InputMaybe<Scalars['ID']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  stageGroupId?: InputMaybe<Scalars['ID']['input']>;
  stageId?: InputMaybe<Scalars['ID']['input']>;
};


export type BusinessAdminMutationsActivateBusinessAdminRoleArgs = {
  schoolId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsActivateParentRoleArgs = {
  childrenIds: Array<Scalars['UUID']['input']>;
  schoolId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsActivateStudentRoleArgs = {
  schoolId: Scalars['ID']['input'];
  stageGroupId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsActivateTeacherRoleArgs = {
  schoolId: Scalars['ID']['input'];
  subjectIds: Array<Scalars['ID']['input']>;
  userId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsAddLessonArgs = {
  lessonInput: AddLessonInput;
};


export type BusinessAdminMutationsAddLessonsArgs = {
  lessonInput: Array<AddLessonInput>;
};


export type BusinessAdminMutationsAddStageGroupPsychologistEmailArgs = {
  email: Scalars['String']['input'];
  stageGroupIds: Array<Scalars['ID']['input']>;
};


export type BusinessAdminMutationsAddStudyStepSubjectLearningActivitiesArgs = {
  learningActivitySetElementIds: Array<Scalars['ID']['input']>;
  studyStepId: Scalars['ID']['input'];
  subjectIds: Array<Scalars['ID']['input']>;
};


export type BusinessAdminMutationsAddSubjectLearningActivityArgs = {
  learningActivityId: Scalars['ID']['input'];
  schoolId: Scalars['UUID']['input'];
  subjectId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsAddUsersToUserGroupsArgs = {
  request: ManageUserGroupsInput;
};


export type BusinessAdminMutationsApproveDeadlineShiftRequestArgs = {
  daysToShift: Scalars['Int']['input'];
  deadlineShiftRequestId: Scalars['UUID']['input'];
  shiftTs?: InputMaybe<Scalars['DateTime']['input']>;
};


export type BusinessAdminMutationsArchiveAwardArgs = {
  awardId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsBlockUsersOfStageGroupArgs = {
  stageGroupId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsBlockUsersOfStageSubjectGroupArgs = {
  stageSubjectGroupId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsChangeClassPlanArgs = {
  frames: Array<ClassPlanFrameInput>;
  planId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsChangeClassPlanWithCheckingArgs = {
  frames: Array<ClassPlanFrameInput>;
  isNeedToCheckAffecting: Scalars['Boolean']['input'];
  planId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsChangeClassroomInFutureLessonsArgs = {
  newClassroomId?: InputMaybe<Scalars['ID']['input']>;
  oldClassroomId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsChangeClusterStateArgs = {
  clusterId: Scalars['Int']['input'];
  isActive: Scalars['Boolean']['input'];
};


export type BusinessAdminMutationsChangeCoalitionMemberPointsArgs = {
  changeCoalitionMemberPoints: Array<ChangeCoalitionMemberPointsInput>;
  coalitionId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsChangeCoalitionMemberPointsByFilterArgs = {
  amount: Scalars['Int']['input'];
  coalitionId?: InputMaybe<Scalars['ID']['input']>;
  comment?: InputMaybe<Scalars['String']['input']>;
  experienceLevelId?: InputMaybe<Scalars['ID']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  stageGroupId?: InputMaybe<Scalars['ID']['input']>;
  stageId?: InputMaybe<Scalars['ID']['input']>;
};


export type BusinessAdminMutationsChangeCoalitionMemberPointsByLoginsArgs = {
  amount: Scalars['Int']['input'];
  comment?: InputMaybe<Scalars['String']['input']>;
  logins: Array<Scalars['String']['input']>;
};


export type BusinessAdminMutationsChangeCoalitionPointsArgs = {
  changeCoalitionPoints: Array<ChangeCoalitionPointsInput>;
  tournamentId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsChangeLessonArgs = {
  lessonId: Scalars['ID']['input'];
  lessonInput: LessonInput;
};


export type BusinessAdminMutationsChangeStagePlanArgs = {
  frames: Array<StagePlanFrameInput>;
  stagePlanId: Scalars['ID']['input'];
  status: PlanStatusEnum;
};


export type BusinessAdminMutationsCheckAutoAwardsArgs = {
  inputs: Array<CheckAutoAwardsEventInput>;
};


export type BusinessAdminMutationsCloseTournamentArgs = {
  tournamentId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsCopyAndActivatePersonalPlansArgs = {
  studentId: Scalars['String']['input'];
  trajectorySlug: Scalars['String']['input'];
};


export type BusinessAdminMutationsCopyBadgeAwardArgs = {
  awardId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsCopyBasePlaylistArgs = {
  basePlaylistId: Scalars['ID']['input'];
  classSubjectIds: Array<Scalars['ID']['input']>;
  excludePersonalPlansFromChangingClassPlan?: InputMaybe<Scalars['Boolean']['input']>;
  studentInSubgroupIds: Array<Scalars['ID']['input']>;
};


export type BusinessAdminMutationsCopyClassPlanArgs = {
  classPlanId: Scalars['ID']['input'];
  classSubjectIds: Array<Scalars['ID']['input']>;
  status: PlanStatusEnum;
  studentInSubgroupIds: Array<Scalars['ID']['input']>;
};


export type BusinessAdminMutationsCopyModuleArgs = {
  moduleId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsCopyStructureToNewYearArgs = {
  allStageGroups: Scalars['Boolean']['input'];
  allStageSubjectGroups: Scalars['Boolean']['input'];
  allStudyPeriods: Scalars['Boolean']['input'];
  allStudyPrograms: Scalars['Boolean']['input'];
  destinationAcademicYearId: Scalars['ID']['input'];
  sourceAcademicYearId: Scalars['ID']['input'];
  stageGroupList?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type BusinessAdminMutationsCreateAvatarArgs = {
  avatarInput: AvatarInput;
};


export type BusinessAdminMutationsCreateBadgeAwardArgs = {
  badgeInput: BadgeAwardInput;
};


export type BusinessAdminMutationsCreateBuildingArgs = {
  address: Scalars['String']['input'];
  classrooms: Array<ClassRoomInput>;
  name: Scalars['String']['input'];
};


export type BusinessAdminMutationsCreateClassPlanArgs = {
  classSubjectId: Scalars['ID']['input'];
  frames: Array<ClassPlanFrameInput>;
  status?: InputMaybe<PlanStatusEnum>;
};


export type BusinessAdminMutationsCreateClassRoomArgs = {
  buildingID: Scalars['ID']['input'];
  classRoom: ClassRoomInputModel;
};


export type BusinessAdminMutationsCreateClassSubjectGroupsArgs = {
  inputModels: Array<ClassSubjectBaseInput>;
};


export type BusinessAdminMutationsCreateDeadlineArgs = {
  deadline: DeadlineInput;
  deadlineInfo?: InputMaybe<DeadlineS21Input>;
  evaluationRules: Array<EvaluationRuleGroupInput>;
};


export type BusinessAdminMutationsCreateExamArgs = {
  exam: ExamInput;
};


export type BusinessAdminMutationsCreateManualTimeTableDraftArgs = {
  academicYearId: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  schoolDaysCountPerWeek: Scalars['Int']['input'];
  stageGroupIds: Array<Scalars['ID']['input']>;
};


export type BusinessAdminMutationsCreateOrUpdateS21ClusterArgs = {
  classroomInputModel: ClassRoomInputModel;
  planMeta: Scalars['String']['input'];
};


export type BusinessAdminMutationsCreatePeriodLessonPlansArgs = {
  periodInput: PeriodLessonPlanInput;
};


export type BusinessAdminMutationsCreateRatingConfigurationArgs = {
  ratingConfiguration: RatingConfigurationInput;
};


export type BusinessAdminMutationsCreateSchoolMarkTypeGroupArgs = {
  schoolMarkTypeGroup: SchoolMarkTypeGroupInput;
};


export type BusinessAdminMutationsCreateSchoolMarkTypeGroupConfigurationArgs = {
  schoolMarkTypeGroupConfiguration: SchoolMarkTypeGroupConfigurationInput;
};


export type BusinessAdminMutationsCreateStageGroupWithAllStageSubjectGroupsArgs = {
  academicYearId: Scalars['ID']['input'];
  stageGroup: StageGroupInput;
  teacherId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsCreateStagePlanArgs = {
  frames: Array<StagePlanFrameInput>;
  globalPlanId?: InputMaybe<Scalars['ID']['input']>;
  stageId: Scalars['ID']['input'];
  status: PlanStatusEnum;
  subjectId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsCreateTimetableDraftLessonsArgs = {
  lessonDrafts: Array<StageGroupTimetableDraftInput>;
  timetableDraftId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsCreateUniversitiesWithDomainsArgs = {
  universityInfoInputModel: UniversityInfoInputModel;
};


export type BusinessAdminMutationsCreateUserInvitesArgs = {
  userDraftInvites: Array<UserDraftInvite>;
};


export type BusinessAdminMutationsDeactivateClassRoomArgs = {
  classRoomId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsDeactivateUserDraftArgs = {
  email: Scalars['String']['input'];
  userDraftId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsDeleteBuildingArgs = {
  buildingID: Scalars['ID']['input'];
};


export type BusinessAdminMutationsDeleteBusinessAdminRoleArgs = {
  schoolId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsDeleteClusterDraftArgs = {
  clusterId: Scalars['Int']['input'];
};


export type BusinessAdminMutationsDeleteDeadlineArgs = {
  deadlineId: Scalars['UUID']['input'];
};


export type BusinessAdminMutationsDeleteGameCoalitionArgs = {
  gameCoalitionId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsDeleteGameTournamentArgs = {
  gameTournamentId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsDeleteGitlabProjectsArgs = {
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  stageGroupId?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  studentState?: InputMaybe<StudentStateEnum>;
  taskId?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAdminMutationsDeleteGitlabProjectsByExternalSystemProjectIdsArgs = {
  projectIds: Array<Scalars['Int']['input']>;
};


export type BusinessAdminMutationsDeleteGitlabProjectsV2Args = {
  schoolId: Scalars['UUID']['input'];
  stageGroupId: Scalars['ID']['input'];
  stageId: Scalars['ID']['input'];
  studentState?: InputMaybe<StudentStateEnum>;
  taskId?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAdminMutationsDeleteGitlabProjectsV3Args = {
  goalId?: InputMaybe<Scalars['Int']['input']>;
  schoolId: Scalars['UUID']['input'];
  stageGroupId: Scalars['ID']['input'];
  stageId: Scalars['ID']['input'];
  studentState?: InputMaybe<StudentStateEnum>;
};


export type BusinessAdminMutationsDeleteLearningActivitySetArgs = {
  learningActivitySetId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsDeleteLearningActivitySetElementArgs = {
  learningActivitySetElementId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsDeleteLessonArgs = {
  deleteAllRepeatAtSameDayOfWeek: Scalars['Boolean']['input'];
  lessonId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsDeleteParentRoleArgs = {
  schoolId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsDeletePeriodLessonPlanArgs = {
  periodLessonPlanId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsDeletePlatfProjectSolutionsArgs = {
  studentAnswerIds: Array<Scalars['Int']['input']>;
};


export type BusinessAdminMutationsDeleteSchoolMarkTypeGroupArgs = {
  schoolId: Scalars['UUID']['input'];
  schoolMarkTypeGroupId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsDeleteSchoolMarkTypeGroupConfigurationArgs = {
  schoolId: Scalars['UUID']['input'];
  schoolMarkTypeGroupConfigurationId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsDeleteStudentByMobilePhoneOrEmailOrUtmSourceArgs = {
  email?: InputMaybe<Scalars['String']['input']>;
  mobilePhone?: InputMaybe<Scalars['String']['input']>;
  utmSource?: InputMaybe<Scalars['String']['input']>;
};


export type BusinessAdminMutationsDeleteStudentGitlabIntensiveProjectsArgs = {
  stageGroupId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsDeleteStudentRoleArgs = {
  schoolId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsDeleteStudyStepSubjectLearningActivityArgs = {
  studyStepSubjectLearningActivityId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsDeleteSubjectLearningActivityArgs = {
  learningActivityId: Scalars['ID']['input'];
  schoolId: Scalars['UUID']['input'];
  subjectId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsDeleteTimetableDraftArgs = {
  timetableDraftId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsDeleteTimetableDraftLessonsArgs = {
  lessonDraftIds: Array<Scalars['ID']['input']>;
  timetableDraftId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsDeleteUserInviteArgs = {
  userDraftId: Scalars['UUID']['input'];
};


export type BusinessAdminMutationsDropLocalCourseGoalConditionsToGlobalArgs = {
  localCourseId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsEditAvatarArgs = {
  avatarId: Scalars['ID']['input'];
  avatarInput: AvatarInput;
};


export type BusinessAdminMutationsEditBadgeAwardArgs = {
  awardId: Scalars['ID']['input'];
  badgeAwardInput: BadgeAwardInput;
};


export type BusinessAdminMutationsEditBuildingArgs = {
  address: Scalars['String']['input'];
  buildingID: Scalars['ID']['input'];
  editedClassrooms: Array<ClassRoomInput>;
  name: Scalars['String']['input'];
  newClassrooms: Array<ClassRoomInput>;
};


export type BusinessAdminMutationsEditExperienceLevelRangeArgs = {
  expLevelId: Scalars['ID']['input'];
  rangeInputModel?: InputMaybe<ExperienceLevelRangeInput>;
};


export type BusinessAdminMutationsExpelStudentArgs = {
  student: Scalars['UUID']['input'];
};


export type BusinessAdminMutationsExpelStudentsArgs = {
  students: Array<Scalars['UUID']['input']>;
};


export type BusinessAdminMutationsFormTeamsForLocalCourseGoalArgs = {
  localCourseGoalId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsFormTeamsForStageSubjectGroupPlanGoalArgs = {
  stageSubjectGroupPlanGoalId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsFreezeStudentArgs = {
  student: Scalars['UUID']['input'];
};


export type BusinessAdminMutationsFreezeStudentsArgs = {
  students: Array<Scalars['UUID']['input']>;
};


export type BusinessAdminMutationsGenerateScheduleArgs = {
  academicYearId: Scalars['ID']['input'];
  buildingIds: Array<Scalars['ID']['input']>;
  isNoWritingWorkSubjectsAfterPhysicalExercise: Scalars['Boolean']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  scheduleConstraints?: InputMaybe<Array<ScheduleConstraintInput>>;
  schoolDaysCountPerWeek: Scalars['Int']['input'];
  stageGroupIds: Array<Scalars['ID']['input']>;
};


export type BusinessAdminMutationsGraduateStudentsArgs = {
  graduateStudents: Array<Scalars['ID']['input']>;
  stageGroupId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsInsertNewStudentArgs = {
  studentWhiteListInputModel: StudentWhiteListInputModel;
};


export type BusinessAdminMutationsIssuedWelcomePackArgs = {
  organisationName: Scalars['String']['input'];
  personnelNumber: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type BusinessAdminMutationsManualExamFinishArgs = {
  examEventId: Scalars['ID']['input'];
  goalId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsMarkTimeTableDraftAsViewedArgs = {
  timetableDraftId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsMassTransferAsyncArgs = {
  copyStageSubjectGroups: Scalars['Boolean']['input'];
  copyStudyPeriods: Scalars['Boolean']['input'];
  destinationAcademicYearId: Scalars['ID']['input'];
  sourceAcademicYearId: Scalars['ID']['input'];
  stageGroupIdsToGraduate: Array<Scalars['ID']['input']>;
  stageGroupsToTransfer: Array<TransferInput>;
};


export type BusinessAdminMutationsModifyLessonsArgs = {
  deletedLessons?: InputMaybe<Array<Scalars['ID']['input']>>;
  editedLessons?: InputMaybe<Array<LessonInput>>;
  newLessons?: InputMaybe<Array<LessonInput>>;
};


export type BusinessAdminMutationsMoveToAnotherCoalitionArgs = {
  newCoalitionId: Scalars['Int']['input'];
  userId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsReadByObjectArgs = {
  objectId: Scalars['String']['input'];
  objectType: Scalars['String']['input'];
  typeIds: Array<Scalars['ID']['input']>;
};


export type BusinessAdminMutationsReadNotificationArgs = {
  notificationId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsReinstateStudentArgs = {
  reinstateStudent: ReinstateStudentInput;
};


export type BusinessAdminMutationsReinstateStudentsArgs = {
  reinstateStudents: Array<ReinstateStudentInput>;
};


export type BusinessAdminMutationsRejectDeadlineShiftRequestArgs = {
  deadlineShiftRequestId: Scalars['UUID']['input'];
};


export type BusinessAdminMutationsRemoveClassSubjectGroupsArgs = {
  classSubjectIds: Array<Scalars['ID']['input']>;
};


export type BusinessAdminMutationsRemoveStageGroupPsychologistEmailArgs = {
  email: Scalars['String']['input'];
};


export type BusinessAdminMutationsRemoveUsersFromUserGroupsArgs = {
  request: ManageUserGroupsInput;
};


export type BusinessAdminMutationsRenameS21ClusterArgs = {
  clusterId: Scalars['Int']['input'];
  name: Scalars['String']['input'];
  shortName: Scalars['String']['input'];
};


export type BusinessAdminMutationsResetIssuedStatusForWelcomePackArgs = {
  comment: Scalars['String']['input'];
  welcomePackId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsRetryS21ClassPlanSavingWithCurrentVersionArgs = {
  stageSubjectGroupPlanId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsRevertS21ClassPlanToLastSuccessVersionArgs = {
  stageSubjectGroupPlanId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsSaveBuildingArgs = {
  address: Scalars['String']['input'];
  classrooms: Array<ClassRoomInputModel>;
  name: Scalars['String']['input'];
};


export type BusinessAdminMutationsSaveClassPlanProjectsArgs = {
  classPlan: S21ClassPlanInput;
};


export type BusinessAdminMutationsSaveClassSubjectGroupArgs = {
  classSubject: ClassSubjectInput;
};


export type BusinessAdminMutationsSaveClassSubjectGroupsArgs = {
  classSubject: Array<ClassSubjectInput>;
  distributeStudentsToNewStageSubjectGroups?: InputMaybe<Scalars['Boolean']['input']>;
  notDistributedStudents?: InputMaybe<Array<Scalars['UUID']['input']>>;
};


export type BusinessAdminMutationsSaveGameCoalitionArgs = {
  gameCoalition: GameCoalitionInput;
};


export type BusinessAdminMutationsSaveGameCoalitionV2Args = {
  gameCoalition: GameCoalitionInputV2;
};


export type BusinessAdminMutationsSaveGameCoalitionV3Args = {
  gameCoalition: GameCoalitionInputV3;
};


export type BusinessAdminMutationsSaveGameTournamentArgs = {
  gameTournament: GameTournamentInput;
};


export type BusinessAdminMutationsSaveLearningActivitySetArgs = {
  learningActivitySetInput: LearningActivitySetInput;
};


export type BusinessAdminMutationsSaveModuleAttemptsSettingsArgs = {
  goalId: Scalars['ID']['input'];
  moduleAttemptSettings: ModuleAttemptsSettingsInput;
};


export type BusinessAdminMutationsSavePrivateFeedbackArgs = {
  feedbacks: Array<PrivateFeedbackInput>;
  filledChecklistId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsSaveS21ClassSubjectGroupArgs = {
  classSubject: ClassSubjectInput;
  startDate: Scalars['DateTime']['input'];
};


export type BusinessAdminMutationsSaveS21GlobalSchoolViewsArgs = {
  s21SchoolViews: Array<S21SchoolViewSettingsInput>;
};


export type BusinessAdminMutationsSaveS21SchoolViewsArgs = {
  s21SchoolViews: Array<S21SchoolViewSettingsInput>;
};


export type BusinessAdminMutationsSaveSchoolArgs = {
  schoolUpdate: SchoolUpdateInput;
};


export type BusinessAdminMutationsSaveSchoolLearningActivityWeightsArgs = {
  learningActivities: Array<LearningActivityInput>;
  schoolId: Scalars['UUID']['input'];
};


export type BusinessAdminMutationsSaveSchoolMarkTypeGroupArgs = {
  schoolMarkTypeGroup: SchoolMarkTypeGroupInput;
};


export type BusinessAdminMutationsSaveSchoolMarkTypeGroupConfigurationArgs = {
  schoolMarkTypeGroupConfiguration: SchoolMarkTypeGroupConfigurationInput;
};


export type BusinessAdminMutationsSaveStageGroupArgs = {
  formMaster?: InputMaybe<Scalars['ID']['input']>;
  learningType?: InputMaybe<LearningTypeEnum>;
  newStudents?: InputMaybe<Array<Scalars['ID']['input']>>;
  removedStudents?: InputMaybe<Array<Scalars['ID']['input']>>;
  stageGroupId: Scalars['ID']['input'];
  stageSubjectGroupIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type BusinessAdminMutationsSaveStageGroupBtcArgs = {
  formMaster?: InputMaybe<Scalars['ID']['input']>;
  learningType?: InputMaybe<LearningTypeEnum>;
  removedStudents?: InputMaybe<Array<Scalars['ID']['input']>>;
  stageGroupId: Scalars['ID']['input'];
  stageSubjectGroupIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  studentsInfo?: InputMaybe<Array<BtcStudentsInfoInputModel>>;
};


export type BusinessAdminMutationsSaveStageGroupHelpEmailArgs = {
  email?: InputMaybe<Scalars['String']['input']>;
  enabled: Scalars['Boolean']['input'];
  stageGroupId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsSaveStageGroupsArgs = {
  academicYearId: Scalars['ID']['input'];
  stageGroups: Array<StageGroupInput>;
};


export type BusinessAdminMutationsSaveStudyPeriodSetArgs = {
  academicYearId: Scalars['ID']['input'];
  updatedStudyPeriodSet: StudyPeriodSetInput;
};


export type BusinessAdminMutationsSaveStudyPeriodSetsArgs = {
  academicYearId: Scalars['ID']['input'];
  updatedStudyPeriodSets?: InputMaybe<Array<StudyPeriodSetInput>>;
};


export type BusinessAdminMutationsSaveStudyProgramArgs = {
  studyProgram: StudyProgramInput;
};


export type BusinessAdminMutationsSaveSubjectsForOrganizationArgs = {
  orgUnitId: Scalars['String']['input'];
  subjects: Array<SubjectInput>;
};


export type BusinessAdminMutationsSaveTaskAdditionalAttributesArgs = {
  additionalAttributes: AdditionalAttributesInput;
};


export type BusinessAdminMutationsSaveTimeSlotSetsArgs = {
  deletedTimeSlotSets?: InputMaybe<Array<TimeSlotSetInput>>;
  editedTimeSlotSets?: InputMaybe<Array<TimeSlotSetInput>>;
  newTimeSlotSets?: InputMaybe<Array<TimeSlotSetInput>>;
};


export type BusinessAdminMutationsSaveTimetableDraftV2Args = {
  lessonDraftVersion: LessonDraftVersion;
  timetableDraftChanges: Array<TimetableDraftChangeInput>;
  timetableDraftId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsSaveUserArgs = {
  user: UserInput;
};


export type BusinessAdminMutationsSaveUserDraftArgs = {
  userDraftInvite: UserDraftInvite;
};


export type BusinessAdminMutationsSaveUserWithUserDraftBusinessCodeArgs = {
  businessCode: Scalars['String']['input'];
};


export type BusinessAdminMutationsSendInviteAgainAndUpdateUserDraftArgs = {
  email: Scalars['String']['input'];
};


export type BusinessAdminMutationsSetClassPlanStatusArgs = {
  planId: Scalars['ID']['input'];
  status: PlanStatusEnum;
};


export type BusinessAdminMutationsSetExpTaskTypePowerArgs = {
  expTaskTypeId: Scalars['ID']['input'];
  power: Scalars['Int']['input'];
};


export type BusinessAdminMutationsSetMandatoryDataFilledArgs = {
  schoolId: Scalars['UUID']['input'];
};


export type BusinessAdminMutationsSetUserLocaleArgs = {
  locale: Scalars['String']['input'];
  userId: Scalars['UUID']['input'];
};


export type BusinessAdminMutationsShiftDeadlinesArgs = {
  shiftDeadlines: Array<ShiftDeadline>;
};


export type BusinessAdminMutationsShiftSingleDeadlineArgs = {
  shiftDeadline: ShiftDeadline;
};


export type BusinessAdminMutationsStageGroupFromArchiveArgs = {
  stageGroupId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsStageGroupToArchiveArgs = {
  stageGroupId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsSubstituteAndDeleteTeacherRoleArgs = {
  schoolId: Scalars['ID']['input'];
  substituteTeachersInput?: InputMaybe<SubstituteTeachersInput>;
  userId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsUnfreezeStudentsArgs = {
  students: Array<Scalars['UUID']['input']>;
};


export type BusinessAdminMutationsUpdateAllowedStatusByMobilePhoneOrEmailOrUtmSourceArgs = {
  allowed: Scalars['Boolean']['input'];
  email?: InputMaybe<Scalars['String']['input']>;
  mobilePhone?: InputMaybe<Scalars['String']['input']>;
  utmSource?: InputMaybe<Scalars['String']['input']>;
};


export type BusinessAdminMutationsUpdateBuildingArgs = {
  address: Scalars['String']['input'];
  buildingID: Scalars['ID']['input'];
  editedClassrooms: Array<ClassRoomInputModel>;
  name: Scalars['String']['input'];
  newClassrooms: Array<ClassRoomInputModel>;
};


export type BusinessAdminMutationsUpdateCertificateTemplateForStudentArgs = {
  issuedId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type BusinessAdminMutationsUpdateClassRoomArgs = {
  buildingID: Scalars['ID']['input'];
  classRoom: ClassRoomInputModel;
};


export type BusinessAdminMutationsUpdateCountInfoArgs = {
  countInfo: CountInfoInput;
  taskId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsUpdateDeadlineArgs = {
  deadline: DeadlineInput;
  deadlineId: Scalars['UUID']['input'];
  deadlineInfo?: InputMaybe<DeadlineS21Input>;
  evaluationRules: Array<EvaluationRuleGroupInput>;
};


export type BusinessAdminMutationsUpdateExamArgs = {
  exam: ExamInput;
  examId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsUpdateGlobalPlanGoalPointsArgs = {
  goalPoints: Array<GoalPointInput>;
};


export type BusinessAdminMutationsUpdatePeriodLessonPlanArgs = {
  periodInput: PeriodLessonPlanInput;
};


export type BusinessAdminMutationsUpdatePeriodLessonPlanByIdArgs = {
  periodLessonPlanId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsUpdatePeriodLessonPlansByIdsArgs = {
  periodLessonPlanIds: Array<Scalars['ID']['input']>;
};


export type BusinessAdminMutationsUpdateStageGroupsForTimeSlotSetArgs = {
  academicYearId: Scalars['ID']['input'];
  stageGroupIds: Array<Scalars['ID']['input']>;
  timeSlotSetId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsUpdateTimetableDraftArgs = {
  lessonDrafts: Array<LessonDraft>;
  timetableDraftId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsUpdateTimetableDraftLessonsArgs = {
  lessonDrafts: Array<StageGroupTimetableDraftInput>;
  timetableDraftId: Scalars['ID']['input'];
};


export type BusinessAdminMutationsUpdateUniversityWithDomainsArgs = {
  universityInfoInputModel: UniversityInfoInputModel;
};


export type BusinessAdminMutationsUpdateUserInviteArgs = {
  userDraftInvite: UserDraftInvite;
};


export type BusinessAdminMutationsUpdateUserSecondFactorAuthArgs = {
  smsAction?: InputMaybe<UserSecondFactorAuthSmsAction>;
  totpAction?: InputMaybe<UserSecondFactorAuthTotpAction>;
  userId: Scalars['ID']['input'];
};

export type BusinessAdminQueries = {
  __typename?: 'BusinessAdminQueries';
  /** проверить externalSystemProjectIds на наличие в бд */
  checkGitlabProjectIdsExistence: GitlabProjectIdsExistenceResponse;
  /** Проверка наличия привязанных заданий к модулям */
  checkGoalsContainTasks: Scalars['Boolean']['output'];
  /** Проверка возможности удаления кабинета в зависимости от связанных объектов */
  checkHowToDeleteClassroom: ClassroomDeletionCode;
  checkIfCanDeleteClassroom: Scalars['Boolean']['output'];
  checkIfCanDeleteStage: Scalars['Boolean']['output'];
  /**
   * Проверка возможности удаления класса
   * @deprecated Проверка проводится при сохранении набора учебных периодов saveStudyPeriodSet. Под удаление
   */
  checkIfCanDeleteStageGroup: Scalars['Boolean']['output'];
  /** @deprecated Проверка проводится при сохранении набора учебных периодов saveStudyPeriodSet. Под удаление */
  checkIfCanDeleteStudyPeriods: Scalars['Boolean']['output'];
  /** Проверка возможности удаления таймслота */
  checkIfCanDeleteTimeSlot: Scalars['Boolean']['output'];
  /** Проверка возможности удаления набора таймслотов */
  checkIfCanDeleteTimeSlotSet: Scalars['Boolean']['output'];
  /** Проверка корректности периодов плана (не переместились ли даты из будущего в прошлое) */
  checkS21ClassPlanPeriodsRelocatedToPast: Array<Scalars['String']['output']>;
  /** Получение количества университетов */
  countAllUniversities: Scalars['ID']['output'];
  /** Получение количества записей в отчете welcome pack */
  countWelcomePackReports: Scalars['ID']['output'];
  /** Предметы. Выгрузка в Excel. */
  downloadModulesProgressBySubjectAndStageExcel: ReportExcelFile;
  /** Отчет "Успеваемость по эл.журналу" выгрузка в Excel */
  downloadStudentJournalPerformanceExcel: ReportExcelFile;
  /**
   * Статистика. Успеваемость учеников расширенная по аттестационным периодам. Выгрузка в Excel.
   * @deprecated Под удаление. EDU-48885
   */
  downloadStudentsAcademicPerformanceByAttestationPeriodExpandedExcel: ReportExcelFile;
  /** Статистика. Успеваемость учеников. Выгрузка в Excel. */
  downloadStudentsAcademicPerformanceExcel: ReportExcelFile;
  /** Статистика. Успеваемость учеников расширенная. Выгрузка в Excel. */
  downloadStudentsAcademicPerformanceExpandedExcel: ReportExcelFile;
  /** Отчет "Итоговые оценки. Детальный" с датами Выгрузка в Excel */
  downloadStudentsMarksResultDetailedExcel: ReportExcelFile;
  /** Итоговые оценки. Выгрузка в Excel */
  downloadStudyPeriodMarksExcel: ReportExcelFile;
  /** Задания на проверке. Выгрузка в Excel. */
  downloadTasksOnCheckExcel: ReportExcelFile;
  /** Задания на проверке более 7 дней по ученикам. Выгрузка в Excel */
  downloadTasksOnCheckForMoreThan7DaysDetailedExcel: ReportExcelFile;
  /** Выгрузка сертификата ученика */
  exportCertificateForStudent: IssuedCertificatePdf;
  /** Отчет по выгрузке вузовской почты учеников в Bootcamp */
  exportStudentUniversityEmails: ReportExcelFile;
  /** Отчет по Welcome Pack'ах в Bootcamp */
  exportWelcomePackReports: ReportExcelFile;
  /** Запрос всех групп класса по предмету для школы */
  findAllStageSubjectGroupsOfSchool: Array<StageSubjectGroup>;
  /** @deprecated Не поддерживается. Используйте findGitlabProjectsV3 */
  findGitlabProjects: FindGitlabProjectsResponse;
  findGitlabProjectsV2: FindGitlabProjectsResponse;
  /**
   * поиск гитлаб-проектов по параметрам
   * @deprecated Не поддерживается. Используйте loadGitlabProjectsAsExcelFileV2
   */
  findGitlabProjectsV3: FindGitlabProjectsResponse;
  /** S21. Поиск файлов проектов по параметрам */
  findPlatfProjectSolutions: PlatfProjectSolutions;
  /** Получение списка школ по региону текущей школы пользователя */
  findSchoolsByCurrentRegion: Array<School>;
  /** Получение списка школ по регионам */
  findSchoolsByRegions: Array<School>;
  /** Поиск классов, в которых есть планы на класс с указанными модулями. Используется в Bootcamp */
  findStageGroupsByGoalIdsFromStageSubjectGroupPlan: Array<StageGroupInfo>;
  /** Возвращает Классы по Предмету по массиву идентификаторов goalids */
  findStageSubjectGroupPlanByGoalIds: Array<ClassSubject>;
  /**
   * выдает список академических лет школы. Если не передать schoolId, выдаст по текущей
   * @deprecated Рекомендуется использовать оптимизированный запрос getStageGroupsV2
   */
  getAcademicYears: Array<AcademicYear>;
  /**
   * Получение списка отзывов по идентификатору мероприятия
   * @deprecated use event.getActivityEventFeedback
   */
  getActivityEventFeedback: Array<Maybe<StudentEventFeedback>>;
  /**
   * Получение количества отзывов по идентификатору мероприятия
   * @deprecated use event.getActivityEventFeedbackCount
   */
  getActivityEventFeedbackCount: Scalars['Int']['output'];
  /**
   * Получение списка типов мероприятий
   * @deprecated use School21:getActivityTypes
   */
  getActivityTypes: Array<ActivityType>;
  /** Получение всех уровней опыта */
  getAllExperienceLevels: Array<Maybe<ExperienceLevel>>;
  /** Получения списка студентов из student_whiteList */
  getAllInStudentWhiteList: Array<StudentWhiteListModel>;
  /**
   * Возвращает список регионов России
   * @deprecated Запрос для получения всех регионов в UserQueries
   */
  getAllRegions: Array<Region>;
  getAllSafeSchool: Array<SafeSchool>;
  /** получения стандартных параллелей 1-11 классов из */
  getAllStages: Array<Stage>;
  /** Получение списка всех университетов для Bootcamp */
  getAllUniversities: Array<UniversityModel>;
  /** Получение всех доменов университетов */
  getAllUniversitiesDomains: Array<Scalars['String']['output']>;
  /** Получение списка университетов и их почтовых доменов */
  getAllUniversitiesInfo: Array<UniversityInfoModel>;
  /** Получение списка классов, переведенных в архив Bootcamp */
  getArchiveStageGroups: Array<Scalars['ID']['output']>;
  /** список доступных пермишенов */
  getAvailablePermissions: Array<Scalars['String']['output']>;
  /**
   * S21. Публичный профиль студента. Получение ссылки на автар по UserId
   * @deprecated use school21 query
   */
  getAvatarByUserId?: Maybe<Scalars['String']['output']>;
  getAvatars: Array<Avatar>;
  /** Получение награды по идентификатору */
  getAwardById: Award;
  /** Доступные награды для выдачи */
  getAwards: Array<Award>;
  /** количество доступных наград для выдачи */
  getAwardsCount: Scalars['Int']['output'];
  /**
   * Получение списка всех городов учеников
   * @deprecated Использовать getBTCStudentCitiesV2 с возвратом доплнительной информации по городу
   */
  getBTCStudentCities: Array<Scalars['String']['output']>;
  /** Получение списка учеников Bootcamp по student id */
  getBTCStudentsInfoForMyClasses: Array<BtcStudentsInfoModel>;
  getBadges: Array<Badge>;
  /**
   * S21. Публичный профиль студента. Получение достижений для публиличного профиля
   * @deprecated use school21 query
   */
  getBadgesPublicProfile: Array<UserBadgeAward>;
  /** Получение списка всех Буткемп-мастеров */
  getBootcampMastersList: Array<BootcampMasterModel>;
  /** Получение списка всех городов учеников с дополнительной информацией по городу */
  getBtcStudentCitiesV2: Array<BtcStudentCityModel>;
  /** Возращает здания кабинетами */
  getBuildings: Array<Building>;
  /** Метод возвращает количество событий по идентификатору школы вызывающего и по списку типов событий */
  getCalendarEventsCount: Scalars['Int']['output'];
  /** Получение студентов с полученными сертификатами по их траектории для определенного класса */
  getCertificateForStudentsStageGroups?: Maybe<Array<IssuedCertificateModel>>;
  /**
   * S21. Публичный профиль студента. Получение класса в котором авторизован студент по его логину
   * @deprecated use school21 query
   */
  getClassRoomByLogin?: Maybe<ClassRoom>;
  /** Получить Планы на все Группы Класса по Предмету в текущей школе */
  getClassSubjectPlansByAcademicYearId: Array<ClassSubject>;
  /** Возвращает все Классы по Предмету в текущей Школе */
  getClassSubjects: Array<ClassSubject>;
  /** Возвращает все Группы по Предмету БА (stage_subject_groups) по идентификатору академического года (academic_years.academic_year_id) */
  getClassSubjectsByAcademicYearId: Array<ClassSubject>;
  /** Возвращает все Классы по Предмету в текущей Школе c поиском по н азванию */
  getClassSubjectsByClassName: Array<ClassSubject>;
  /** Возвращает Классы по Предмету по массиву идентификаторов (stage_subject_groups.stage_subject_group_id) */
  getClassSubjectsByIds: Array<ClassSubject>;
  /**
   * Возвращает текущие Группы по Предмету Учителя (stage_subject_groups)
   * по идентификатору Предмета (subjects.subject_id) и идентифкатору параллели (stages.stage_id)
   */
  getClassSubjectsBySubjectIdAndStageId: Array<ClassSubject>;
  /**
   * Возвращает развернутую информацию о предмете класса, его модулях и количестве заданий в их плейлистах
   * (в методе getClassSubjectsByIds считается общее количество заданий, не по плейлисту)
   */
  getClassSubjectsExtendedInfo: Array<ClassSubject>;
  getClassroomById: ClassRoom;
  /**
   * Информация о студентах на плане кластера
   * @deprecated do not use. Will be deleted in 29.0
   */
  getClusterPlanStudents: ClusterPlanStudents;
  /** Информация о студентах на плане кластера по идентификатору кластера (кабинета) */
  getClusterPlanStudentsByClusterId: ClusterPlanStudents;
  getClustersSummary: Array<ClusterSummaryModel>;
  /** Список бекграундов(подложек) для коалиций */
  getCoalitionBackgrounds: Array<CoalitionBackground>;
  /** Список аватаров для мастера трайба */
  getCoalitionMasterAvatars: Array<CoalitionMasterAvatar>;
  /**
   * Получить сводную информация об участнике коалиции
   * @deprecated Используйте getLastGivingsV2
   */
  getCoalitionMemberInfoModels: Array<CoalitionMemberInfoModel>;
  /** Получение коалиций мероприятия */
  getCoalitionsByActivityId: Array<GameCoalition>;
  /** Получение коалиций для параллели */
  getCoalitionsBySchoolIdAndStageId: Array<GameCoalition>;
  /** Получение фильтров для отчета БМ (Буткэмп Мастер) */
  getContentFilterData: Array<ContentFilterData>;
  /** Получение списка модулей в рамках школы, у которых заведена контрольная работа */
  getControlWorksModules: Array<ClassSubjectControlWork>;
  /** Получение курсов с учетом фильтров */
  getCourses: CourseSearchResult;
  /** Получение общего количества студентов, зарегистрированных на экзамен */
  getCurrentStudentCountByExamID: Scalars['Int']['output'];
  /** Получение дедлайна по айди */
  getDeadline: Deadline;
  /** Получение запроса на отсрочку по айди */
  getDeadlineShiftRequest: DeadlineShiftRequestInfo;
  /** Получение списка запросов на отсрочку дедлайна */
  getDeadlineShiftRequests: Array<Maybe<DeadlineShiftRequest>>;
  /** Возвращает классы Ш21, на которые можно назначить дедлайны */
  getDeadlineStageGroups: Array<StageGroup>;
  /** Получение списка дедлайнов по фильтрам */
  getDeadlines: Array<Maybe<Deadline>>;
  /** Получение количество дедлайнов по фильтрам */
  getDeadlinesCount: Scalars['Int']['output'];
  /** @deprecated Use school21 query */
  getDeadlinesForStudents: Array<Maybe<DeadlineStudentInfo>>;
  /**
   * Получение количество дедлайнов по фильтрам
   * @deprecated Use school21 query
   */
  getDeadlinesForStudentsCount: Scalars['Int']['output'];
  /**
   * S21. Публичный профиль студента. Получение email по UserId
   * @deprecated use school21 query
   */
  getEmailbyUserId?: Maybe<Scalars['String']['output']>;
  /**
   * S21. Получение отчета по проведенным мероприятиям
   * @deprecated use school21 query
   */
  getEventsReport: ReportExcelFile;
  /** Получение экзамена по идентификатору */
  getExam: Exam;
  /** Получение количестова экзаменов по идентификатору школы */
  getExamCount: Scalars['Int']['output'];
  /** Получение списка экзаминационных модулей в рамках школы */
  getExamModules: Array<Maybe<StudyModule>>;
  /**
   * Получение списка студентов, зарегистрированных на экзамен
   * @deprecated Следует использовать общую реализацию businessAdmin.getEventStudents
   */
  getExamStudents: Array<StudentEvent>;
  /** Получение списка событий "Экзамен" по идентификатору школу */
  getExams: Array<Exam>;
  /** Получение списка событий "Экзамен" по параметрам */
  getExamsByFilter: Array<Exam>;
  /** Получение количества записей для запроса getExamsByFilter */
  getExamsByFilterCount: Scalars['Int']['output'];
  /** Получение истории изменения опыта */
  getExperienceHistoryDate: UserExperienceHistoryDate;
  /**
   * S21. Публичный профиль студента. Получение опыта по UserId
   * @deprecated use school21 query
   */
  getExperiencePublicProfile?: Maybe<UserExperience>;
  /** Получение данных о количестве P2P проверок и средней оценке пользователя как ревьюера */
  getFeedbackStatisticsAverageScore: FeedbackStatisticsAverageScore;
  /** Получение списка классов, в которых учитель является классным руководителем */
  getFormMasterStageGroups: Array<Maybe<StageGroupInfo>>;
  /** список функциоальных ролей по ролям и школам */
  getFunctionalRoles: Array<FunctionalRole>;
  /** модули по периоду и группе по предметам */
  getGoalsByDatePeriodAndStageSubjectGroup: Array<Goal>;
  /** Возвращает перечень проектов доступных для регистрации для заданных параллели и классов по предмету */
  getGoalsByStageAndStageSubjectGroupIds: Array<S21Goal>;
  /** Возвращает список систем оценивания */
  getGovernmentMarkTypes: Array<GovernmentMarkType>;
  /** @deprecated Используйте getLastGivingsV3 */
  getLastGivings: Array<UserLastGiving>;
  getLastGivingsV2: Array<UserLastGiving>;
  /**
   * Получить краткую информацию о пользователе + информация о последних награждениях(любых) этого пользователя
   * Ищет только активных студентов
   */
  getLastGivingsV3: UserLastGivingsResponse;
  /** Запрос возвращает последнюю задачу по массовому переводу из учебного года. */
  getLastMassTransferTask?: Maybe<MassTransferTask>;
  getLearningActivitiesBySchool: Array<LearningActivity>;
  /** @deprecated Use getStudyStepSubjectLearningActivities */
  getLearningActivitiesBySchoolSubjects: Array<SubjectLearningActivities>;
  /** Возвращает все наборы форм контроля для школы текущего пользователя */
  getLearningActivitySets: Array<LearningActivitySet>;
  /** Получение урока по ID */
  getLesson: Lesson;
  /**
   * Возвращает план урока по идентификатору.
   * Не бросает исключения, как getLessonPlanById, а возвращает описание ошибки и статус
   */
  getLessonPlanByIdV2: LessonPlanV4Response;
  /** Получение результата редактирования цепочки уроков для дальнейшей модификации уроков */
  getLessonsTransferResult: Array<LessonTransferValidationResult>;
  /**
   * Получение локальных настроек мультикампусности, опционально можно задать idForFilter и isStage для фильтрации
   * @deprecated Не поддерживается. Используйте findGitlabProjectsV2
   */
  getLocalMulticampusSettingAndAllStagesAndStageSubjectGroups: LocalMulticampusSettingAndAllStagesAndStageSubjectGroups;
  getMarkTypes: Array<Scalars['String']['output']>;
  /** Запрос настроек повторного прохождения модуля */
  getModuleAttemptsSettings?: Maybe<ModuleAttemptsSettings>;
  /**
   * Метод возвращает список групповых модулей, имеющих p2p проверки, по идентификатору школы вызывающего
   * @deprecated Следует использовать sc21BaCalendar.getModulesForFreeSlot
   */
  getModulesForFreeSlot: Array<Goal>;
  /** Предметы */
  getModulesProgressBySubjectAndStageReport: Array<ModulesProgressBySubjectAndStage>;
  /**
   * Возвращает "соседние" Группы по Предмету (stage_subject_groups) по идентификатору группы
   * соседние по предмету(subjects.subject_id), идентификатору параллели (stages.stage_id) и году (academic_years)
   */
  getNestedClassSubjectsByStageSubjectGroupId: Array<ClassSubject>;
  getNotifications: Array<Notification>;
  getNotificationsByTypes: Array<Notification>;
  getNotificationsCount: Scalars['Int']['output'];
  /** Получение списка периодов планирования уроков в учебном году с их вычисляемыми статусами */
  getPeriodLessonPlansWithStatuses: Array<PeriodLessonPlanExtended>;
  /** S21. Получение списка модулей плана для дашборда, в зависимости от id плана и и типа плана */
  getPlanModulesForDashboard: DashboardPlanModules;
  /** Получение информации о команде в групповом задании по ид проверяемого ответа */
  getProjectTeamMembersByAnswerId?: Maybe<ProjectTeamMembers>;
  /**
   * (periodInput: PeriodLessonPlanInput!)
   *  Получение рекомендуемого кол-ва дней на учебный модуь в соотношении (Идентификатор цели, кол-во дне на  учебный модуь)
   */
  getRecommendedDurationForModules: Array<GoalDurationMap>;
  /** Возвращает план на класс по идентификатору группы по предмету */
  getS21ClassPlanByStageSubjectGroupId: S21ClassPlan;
  /** Получение настроек праздничных тем */
  getS21GlobalSchoolViewSettings: Array<S21SchoolViewSettings>;
  /** Получение настроек праздничных тем */
  getS21SchoolViewSettings: Array<S21SchoolViewSettings>;
  /** Возвращает план на параллель по идентификатору c групповыми проектами */
  getS21StageGroupPlan: S21StagePlan;
  getSafeSchoolsByIds: Array<SafeSchool>;
  /** Получение асинхронной задачи сохранения набора учебных периодов по идентификатору асинхронной задачи */
  getSaveStudyPeriodSetAsyncTaskByAsyncTaskId: AsyncTask;
  /** Получение асинхронной задачи сохранения набора учебных периодов по идентификатору набора учебных периодов */
  getSaveStudyPeriodSetAsyncTaskByStudyPeriodSetId?: Maybe<AsyncTask>;
  /** Получение списка правил из Конструктора расписаний */
  getScheduleConstraints: Array<ScheduleConstraint>;
  getSchool: School;
  /** Коалиция по ID */
  getSchoolGameCoalition: GameCoalition;
  /** Список пользователей участников коалиции */
  getSchoolGameCoalitionMembers: Array<User>;
  /** Ранги участников коалиции в турнире */
  getSchoolGameCoalitionTournamentMembers: Array<CoalitionMemberPowerRank>;
  /** Cписок коалиций */
  getSchoolGameCoalitions: Array<GameCoalition>;
  /** Общее кол-во коалиций в школе */
  getSchoolGameCoalitionsCount: Scalars['Int']['output'];
  /** Общее кол-во коалиций в школе с учетом фильтра */
  getSchoolGameCoalitionsCountV2: Scalars['Int']['output'];
  /**
   * Коалиции не учавствующие в турнире
   * @deprecated EDU-44085б. Will be deleted in 29.0
   */
  getSchoolGameCoalitionsNotInTournament: Array<GameCoalition>;
  getSchoolGameCoalitionsV2: Array<GameCoalitionV2>;
  /** Турнир по ID */
  getSchoolGameTournament: GameTournament;
  /** Список турниров */
  getSchoolGameTournaments: Array<GameTournament>;
  /** Общее кол-во турниров в школе */
  getSchoolGameTournamentsCount: Scalars['Int']['output'];
  getSchoolGameTournamentsCountV2: Scalars['Int']['output'];
  /** Турниры за период */
  getSchoolGameTournamentsForTimes: Array<GameTournament>;
  getSchoolGameTournamentsV2: Array<GameTournament>;
  /**
   * S21. Публичный профиль студента. Получение SchoolId по Login пользователя, если нет schoolId - EMPTY_UUID
   * @deprecated использовать getStudentByLogin
   */
  getSchoolIdByLogin?: Maybe<Scalars['UUID']['output']>;
  /** Возвращает учебные активности с весами, настроенными для переданной школы */
  getSchoolLearningActivityWeights: Array<LearningActivity>;
  /** Получение статуса заполнения обязательных данных для школы для начала учебного процесса (здания, кабинеты, звонки, ученики, учителя, классы) */
  getSchoolMandatoryFilledData: SchoolMandatoryData;
  /** Возвращает список конфигураций оценивания для переданной школы */
  getSchoolMarkTypeGroupConfigurations: Array<SchoolMarkTypeGroupConfiguration>;
  /** Возвращает список школьных группы систем оценивания */
  getSchoolMarkTypeGroupsBySchool: Array<SchoolMarkTypeGroup>;
  /** @deprecated Field no longer supported */
  getSchoolMarks: SchoolMarkSet;
  /** Возвращает список отметок для переданной системы оценивания */
  getSchoolMarksByGovernmentMarkType: Array<SchoolMark>;
  /** Обзор работы пользователей платформы. */
  getSchoolMonitoring: Array<SchoolMonitoring>;
  getSchools: Array<School>;
  getSchoolsCount: Scalars['Int']['output'];
  getSchoolsTags: Array<SchoolTag>;
  /** Возвращает все школы (безопасные, без доп.инфы) */
  getSchoolsTagsByCurrentRegion: Array<SchoolTag>;
  getSchoolsTagsByRegions: Array<SchoolTag>;
  /** Получение количества запросов на отсрочку дедлайна по фильтрам */
  getShiftRequestsCount: Scalars['Int']['output'];
  /** Список мягких навыков */
  getSoftSkillTypes: Array<SoftSkillType>;
  /**
   * S21. Публичный профиль студента. Получение навыков для публиличного профиля
   * @deprecated use school21 query
   */
  getSoftSkillsByStudentId: Array<SoftSkillPower>;
  getStageById: Stage;
  getStageConfigurations: Array<StageConfiguration>;
  /**
   * Выдает расширенную информацию по классу. В список ГКпП попадают только с типом обучения из filterStageSubjectGroupLearningTypes
   * Если filterStageSubjectGroupLearningTypes == null, то возвращаются ГКпП с типом обучения BASE_LEARNING, EXTERNAL_LEARNING
   */
  getStageGroup: StageGroupExtended;
  /** Получение списка адресов психологов с перечнем класов привязанных к адресу психолога */
  getStageGroupPsychologistEmails: Array<StageGroupPsychologistEmail>;
  /**
   * S21. Публичный профиль студента. Получение волны (аналог stage_group_name) и формы обучения (аналог stage_name) по StudentId
   * @deprecated use school21 query
   */
  getStageGroupS21PublicProfile?: Maybe<StageGroupS21>;
  getStageGroups: Array<StageGroupAggregated>;
  /** выдает список классов школы в заданном году и заданной параллели */
  getStageGroupsByFilter: Array<StageGroup>;
  /** список классов (для завуча все классы, для учителя его классы, возможны фильтры по параллели и учебному году) */
  getStageGroupsBySchoolAndTeacher: Array<StageGroupInfo>;
  /**
   * Агрегация списка классов школы по учителю в заданном академическом году.
   * Содержит только те ГКпП, в которых преподает учитель.
   */
  getStageGroupsByTeacher: Array<StageGroupAggregated>;
  /**
   * S21. Публичный профиль студента. Получение всех волн (аналог stage_group_name) и форм обучения (аналог stage_name) по StudentId
   * @deprecated use school21 query
   */
  getStageGroupsS21PublicProfile?: Maybe<Array<Maybe<StageGroupS21>>>;
  /** Возвращает список классов в академическом году в контексте БА */
  getStageGroupsV2: Array<StageGroupV2>;
  getStageGroupsWithTimeslotSetIds: Array<StageGroupWithTimeslotSetId>;
  /** получение планов на параллель */
  getStagePlansByIds: Array<StagePlan>;
  /** список гкпп по кампусу и параллели */
  getStageSubjectGroupsBySchoolIdAndStageId: Array<StageSubjectGroup>;
  /** список гкпп по классу и предмету параллели */
  getStageSubjectGroupsByStageGroupAndStageSubjects: Array<StageSubjectGroup>;
  /** список групп по предмету по классу и предмету (для учителя только его предметы, для классного руководителя его предмет и предметы его класса) */
  getStageSubjectGroupsByStageGroupAndSubject: Array<StageSubjectGroup>;
  /** получить список гкпп по идентификатору класса и строке поиска */
  getStageSubjectGroupsByStageGroupIdAndFilter: Array<StageSubjectGroupExtended>;
  getStages?: Maybe<Array<Scalars['Int']['output']>>;
  /** Возвращает список параллелей для переданной группы систем оценивания */
  getStagesBySchoolMarkTypeGroup: Array<Stage>;
  getStagesWithNames: Array<Stage>;
  /** Отчет "Успеваемость" по Аттестационным периодам */
  getStudentAcademicPerformanceByAttestationPeriod: Array<StudentAcademicPerformance>;
  /** Отчет "Успеваемость" по Аттестационным периодам расширенный */
  getStudentAcademicPerformanceByAttestationPeriodExpanded: Array<StudentAcademicPerformanceExpandedV2>;
  /**
   * Получение списка Учеников в контекстной школе по фильтрам
   * Не возвращает учеников классов внешнего обучения
   */
  getStudentAccounts: StudentAccountList;
  /**
   * S21. Публичный профиль студента. Получение StudentId по Login пользователя, если нет studetnId - EMPTY_UUID
   * @deprecated использовать getStudentByLogin
   */
  getStudentIdByLogin?: Maybe<Scalars['UUID']['output']>;
  /** Отчет "Успеваемость по эл.журналу" */
  getStudentJournalPerformance: Array<StudentJournalPerformance>;
  /** Получение всех проектов по userId и stageGroupId */
  getStudentProjectsByStageGroup: Array<Maybe<StudentItem>>;
  /** Получить историю переводов ученика между классами школы */
  getStudentStageGroupTransferHistory: Array<StudentStageGroupTransferInfo>;
  /** получение информации по посещаемости студента в школе и за рабочей станцией, за неделю (пн-вс) входящую в date */
  getStudentTraffic: StudentTraffic;
  /** Получение списка учеников Bootcamp и их вузовской почты */
  getStudentUniversityEmails: Array<StudentUniversityEmailModelBtc>;
  /** Получение количества записей списка вузовских почт */
  getStudentUniversityEmailsCount: Scalars['ID']['output'];
  /**
   * Статистика. Успеваемость учеников
   * @deprecated Использовать getStudentsAcademicPerformanceExpandedV2
   */
  getStudentsAcademicPerformance: Array<StudentAcademicPerformance>;
  getStudentsAcademicPerformanceExpanded: Array<StudentAcademicPerformanceExpanded>;
  getStudentsAcademicPerformanceExpandedV2: Array<StudentAcademicPerformanceExpandedV2>;
  /** получение списка студентов ГКПП */
  getStudentsByStageSubjectGroup: Array<StudentWithUser>;
  /** Получение списка уровней студентов */
  getStudentsLevels: Array<ExperienceLevel>;
  /** Получение списка уровней студентов для мероприятия */
  getStudentsLevelsByActivityId: Array<ExperienceLevel>;
  /** @deprecated Под удаление. EDU-48885 */
  getStudentsMarksResultDetailed: StudentFinalMarkModel;
  /** Отчет "Итоговые оценки. Детальный" с датами */
  getStudentsMarksResultDetailedByDates: StudentFinalMarkModel;
  getStudentsMarksSubjectsDetailed: StudentFinalMarkSubjectsModel;
  /** Отчет "Итоговые оценки. Детальный" по ученику и всем предметам с датами */
  getStudentsMarksSubjectsDetailedByDates: StudentFinalMarkSubjectsModel;
  /** получение списка студентов класса вместе с ГКПП по классу и предмету */
  getStudentsWithStageSubjectGroupByFilter: Array<StudentWithStageSubjectGroup>;
  getStudyPeriod: StudyPeriod;
  /** Итоговые оценки */
  getStudyPeriodMarks: Array<StudyPeriodMark>;
  getStudyPeriodSets: Array<StudyPeriodSet>;
  /** учебные периоды */
  getStudyPeriodsByStudyPeriodSet: Array<StudyPeriod>;
  /** поиск учебной программы за год */
  getStudyProgram?: Maybe<StudyProgram>;
  /** Возвращает формы контроля и их атрибуты для предметов и уровней образования для текущей школы пользователя */
  getStudyStepSubjectLearningActivities: Array<StudyStepSubjectLearningActivities>;
  /** @deprecated Use getLearningActivitySets */
  getSubjectLearningActivities: Array<LearningActivity>;
  /** список предметов, для которых в учебном году есть активные группы */
  getSubjectsByAcademicYearId: Array<Subject>;
  /** Получение списка предметов, принадлежащих образовательному учреждению или его тенантам */
  getSubjectsByOrgUnitId: Array<Subject>;
  /** список предметов для класса (для учителя только его предметы, для классного руководителя его предмет и предметы его класса) */
  getSubjectsByStageGroupAntSchoolAndTeacher: Array<Subject>;
  /** Получить список классов по предмету в планах которых есть привязка к проекту */
  getSuitableStageSubjectsForExam: Array<ClassSubject>;
  /** Получить список курсов в классах которых есть привязка к проекту */
  getSuitableStagesForExam: Array<Stage>;
  /** Получение списка системных уведомлений для текущей школы без плашки */
  getSystemNotificationsWithoutCommon: Array<SystemNotification>;
  /** Получение параметров расчета навыков за проверку задания */
  getTaskAdditionalAttributes: AdditionalAttributes;
  /** Задания на проверке */
  getTasksOnCheck: Array<TasksOnCheck>;
  /** Задания на проверке более 7 дней по ученикам */
  getTasksOnCheckForMoreThan7DaysDetailed: Array<TaskOnCheckDetailed>;
  /** Учителя */
  getTeacherSchoolMetrics: Array<TeacherSchoolMetrics>;
  /** Учителя. Выгрузка в Excel. */
  getTeacherSchoolMetricsExcel: ReportExcelFile;
  /** Учителя. Выгрузка в Excel. */
  getTeacherSchoolMetricsExcelForBTC: ReportExcelFile;
  /** Получение списка классов, в которых учитель ведет какие-либо предметы (предметные группы) */
  getTeacherStageGroups?: Maybe<Array<Maybe<StageGroupInfo>>>;
  /** Получить расписание учителя */
  getTeacherTimetable: TimetableGroupedByPeriods;
  /** Получить список учителей школы по фильтрам */
  getTeachersBySchoolAndFilters: Array<Teacher>;
  /** Запрос группы параметров комманды для проекта из локального курса */
  getTeamSettingsGroupFromLocalCourseGoal: TeamSettingsGroupWithEquivalentFlag;
  getTimeSlotSets: Array<TimeSlotSet>;
  /** Получение расписания по дням по всем классам */
  getTimetableByDays: Timetable;
  /** Получить драфт расписания на неделю */
  getTimetableDraft: TimetableDraft;
  /** Получение краткой информации по драфтам расписания по ID школы */
  getTimetableDraftSummariesPerSchool: Array<TimetableDraftSummary>;
  /** Получить драфт расписания на неделю */
  getTimetableDraftV2: TimetableDraftV2;
  getTournamentResultReport: ReportExcelFile;
  /** Метод возвращает траектории учеников */
  getTrajectories?: Maybe<Array<Scalars['String']['output']>>;
  /** Незавершенные турниры */
  getUnfinishedTournaments?: Maybe<Array<GameTournament>>;
  /** Незавершенные турниры для определенной группы по предмету */
  getUnfinishedTournamentsByStageSubjectGroup?: Maybe<Array<GameTournament>>;
  /** получить пользователя с ролями (учитель, ученик, БА), статусами и ролеспецифичными данными. */
  getUser: User;
  /** Запрос истории получения ачивки */
  getUserAwardHistoryByAwardId: Array<UserAwardHistory>;
  getUserAwardHistoryByAwardIdCount: Scalars['Int']['output'];
  /** Запрос истории получения ачивки c возможностью сортировать по awardDate */
  getUserAwardHistoryByAwardIdV2: Array<UserAwardHistory>;
  /** Список студентов в школе для выдачи монет, с информацией по текущему кол-ву монет */
  getUserCoins?: Maybe<Array<UserCoins>>;
  /** кол-во студентов в школе по данным параметрам фильтра, для выдачи монет */
  getUserCoinsCount: Scalars['Int']['output'];
  /** История начисления\списание монет по пользователю */
  getUserCoinsHistory: UserCoinsHistoryModel;
  /** получить информацию об настроенных типах аутентификации пользователя */
  getUserCredentialsInfo: UserCredentialsInfo;
  /** Получение списка черновиков в контекстной школе по фильтрам */
  getUserDrafts: UserDraftList;
  /** Получить краткую информацию о пользователе + история его награждений */
  getUserGivingsHistoryByUserId: UserGivingsHistoryModel;
  /**
   * S21. Публичный профиль студента. Получение UserId по Login пользователя
   * @deprecated use school21 query
   */
  getUserIdByLogin?: Maybe<Scalars['UUID']['output']>;
  /** Получить информацию о родителях пользователя (ученика) в контекстной школе */
  getUserParentsInfo: Array<ParentUserInfo>;
  /**
   * получить список пользователей с ролями, статусами и ролеспецифичными данными.
   * Фильтры: роли - только учитель, ученик, БА и только в текущей школе
   */
  getUsers: Array<Maybe<User>>;
  /** Запрос пользователей с указанной функциональной ролью */
  getUsersByFunctionalRole: Array<Maybe<User>>;
  /** количество записей для getUsers */
  getUsersCount: Scalars['Int']['output'];
  /**
   * Получить кол-во пользователей найденных по данным параметрам фильтра, ищет только активных студентов
   * @deprecated Используйте validateLoginsForAwardsV2
   */
  getUsersCountByFilter: Scalars['Int']['output'];
  getUsersCountV2: Scalars['Int']['output'];
  /** Список студентов в школе для выдачи достижения */
  getUsersToBadgeAward?: Maybe<Array<UsersToBadgeAward>>;
  /** количество студентов в школе для выдачи достижения */
  getUsersToBadgeAwardCount: Scalars['Int']['output'];
  /**
   * Предыдущая версия - getUsers
   * Реализован дополнительный контроль за возвращаемыми персональными данными с обязательной пагинацией
   */
  getUsersV2: Array<Maybe<User>>;
  /** Получение списка пользователей с удаленными ролями в школе */
  getUsersWithDeletedRoles: Array<UserWithDeletedRole>;
  /** Получение количества пользователей с удаленными ролями в школе */
  getUsersWithDeletedRolesCount: Scalars['Int']['output'];
  /**
   * S21. Публичный профиль студента. Получение рабочей станции за которой авторизован студент по его логин
   * @deprecated do not use. Will be deleted in 31.0
   */
  getWorkstationByLogin?: Maybe<WorkstationModel>;
  /**
   * S21. Публичный профиль студента. Получение рабочей станции за которой авторизован студент по идентификатору студента
   * @deprecated use school21 query
   */
  getWorkstationByUserId?: Maybe<WorkstationModel>;
  /** @deprecated Не поддерживается. Используйте loadGitlabProjectsAsExcelFileV3 */
  loadGitlabProjectsAsExcelFile: GitlabProjectsExcelFile;
  loadGitlabProjectsAsExcelFileV2: GitlabProjectsExcelFile;
  /** скачивание гитлаб проектов в excel-file */
  loadGitlabProjectsAsExcelFileV3: GitlabProjectsExcelFile;
  /**
   * S21. Запрос отчета по успеваемости абитуриентов
   * @deprecated use school21 query
   */
  loadStudentsPerformanceS21Report: ReportExcelFile;
  /**
   * S21. Запрос отчета по командам
   * @deprecated use school21 query
   */
  loadStudentsTeamS21Report: ReportExcelFile;
  /** Запрос настроек условий заданного типа для модуля (проекта, цели) в локальном курсе (группе проектов) */
  loadTaskEvaluationRuleGroupsFromLocalCourse: EvaluationRuleGroupsWithEquivalentFlag;
  /** Получение списка тенантов образовательного учреждения текущего пользователя с доступом на чтение */
  loadTenantsWithReadAccess: Array<School>;
  /**
   * Получение списка тенантов образовательного учреждения текущего пользователя с доступом на запись
   * @deprecated Использовать запрос checkHowToDeleteClassroom
   */
  loadTenantsWithWriteAccess: Array<School>;
  /** Получение фильтра для отчета о welcome pack */
  loadWelcomePackReportFilterParams: WelcomePackFilterParamsModel;
  /** Получение отчета о welcome pack */
  loadWelcomePackReports: Array<WelcomePackReportModel>;
  /** проверка при переводе учеников между группами по предметам */
  preventSaveClassSubjectGroupStudents: Array<SaveSubjectGroupStudentsMessage>;
  validateLoginsForAwards: LoginValidationResponse;
  /** провалидировать логины пользователей */
  validateLoginsForAwardsV2: LoginValidationResponseV2;
  validateUserInviteEmail: UserDraftOperationsResult;
  validateUserInvitePhone: UserDraftOperationsResult;
};


export type BusinessAdminQueriesCheckGitlabProjectIdsExistenceArgs = {
  projectIds: Array<Scalars['Int']['input']>;
};


export type BusinessAdminQueriesCheckGoalsContainTasksArgs = {
  goalIds: Array<InputMaybe<Scalars['ID']['input']>>;
};


export type BusinessAdminQueriesCheckHowToDeleteClassroomArgs = {
  classroomId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesCheckIfCanDeleteClassroomArgs = {
  classroomId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesCheckIfCanDeleteStageArgs = {
  stageId: Scalars['ID']['input'];
  studyPeriodSetId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesCheckIfCanDeleteStageGroupArgs = {
  stageGroupId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesCheckIfCanDeleteStudyPeriodsArgs = {
  lastStudyPeriod: Scalars['Boolean']['input'];
  studyPeriodId?: InputMaybe<Scalars['ID']['input']>;
  studyPeriodSetId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesCheckIfCanDeleteTimeSlotArgs = {
  timeSlotId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesCheckIfCanDeleteTimeSlotSetArgs = {
  timeSlotSetId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesCheckS21ClassPlanPeriodsRelocatedToPastArgs = {
  classPlan: S21ClassPlanInput;
};


export type BusinessAdminQueriesCountAllUniversitiesArgs = {
  universityInfoFilter: UniversityInfoFilterModel;
};


export type BusinessAdminQueriesCountWelcomePackReportsArgs = {
  welcomePackFilter: WelcomePackFilterInputModel;
};


export type BusinessAdminQueriesDownloadModulesProgressBySubjectAndStageExcelArgs = {
  currentRole: Scalars['String']['input'];
  endDate: Scalars['DateTime']['input'];
  reportDateTime: Scalars['String']['input'];
  startDate: Scalars['DateTime']['input'];
};


export type BusinessAdminQueriesDownloadStudentJournalPerformanceExcelArgs = {
  studentJournalPerformanceExcelInput: StudentJournalPerformanceExcelInput;
};


export type BusinessAdminQueriesDownloadStudentsAcademicPerformanceByAttestationPeriodExpandedExcelArgs = {
  closeModuleDate: Scalars['Date']['input'];
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  reportDateTime: Scalars['String']['input'];
  stageId: Scalars['Int']['input'];
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAdminQueriesDownloadStudentsAcademicPerformanceExcelArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  reportDateTime: Scalars['String']['input'];
  stageId: Scalars['Int']['input'];
  startDate: Scalars['DateTime']['input'];
};


export type BusinessAdminQueriesDownloadStudentsAcademicPerformanceExpandedExcelArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  reportDateTime: Scalars['String']['input'];
  stageId: Scalars['Int']['input'];
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAdminQueriesDownloadStudentsMarksResultDetailedExcelArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  currentRole?: InputMaybe<Scalars['String']['input']>;
  periodEndDate: Scalars['Date']['input'];
  periodStartDate: Scalars['Date']['input'];
  reportDateTime: Scalars['String']['input'];
  stageGroupId: Scalars['Int']['input'];
  stageId: Scalars['Int']['input'];
  subjectId: Scalars['Int']['input'];
};


export type BusinessAdminQueriesDownloadStudyPeriodMarksExcelArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  currentRole?: InputMaybe<Scalars['String']['input']>;
  reportDateTime: Scalars['String']['input'];
  stageGroupId?: InputMaybe<Scalars['Int']['input']>;
  stageId: Scalars['Int']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAdminQueriesDownloadTasksOnCheckExcelArgs = {
  currentRole: Scalars['String']['input'];
  endDate: Scalars['DateTime']['input'];
  reportDateTime: Scalars['String']['input'];
  stageGroupId?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageSubjectGroupId?: InputMaybe<Scalars['Int']['input']>;
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  tasksDate: Scalars['DateTime']['input'];
};


export type BusinessAdminQueriesDownloadTasksOnCheckForMoreThan7DaysDetailedExcelArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  reportDateTime: Scalars['String']['input'];
};


export type BusinessAdminQueriesExportCertificateForStudentArgs = {
  issuedId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesExportStudentUniversityEmailsArgs = {
  universityEmailFilter: UniversityEmailFilterInputModel;
};


export type BusinessAdminQueriesExportWelcomePackReportsArgs = {
  welcomePackFilter: WelcomePackFilterInputModel;
};


export type BusinessAdminQueriesFindAllStageSubjectGroupsOfSchoolArgs = {
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  stageId?: InputMaybe<Scalars['ID']['input']>;
};


export type BusinessAdminQueriesFindGitlabProjectsArgs = {
  paging: PagingInput;
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  stageGroupId?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  studentState?: InputMaybe<StudentStateEnum>;
  taskId?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAdminQueriesFindGitlabProjectsV2Args = {
  paging: PagingInput;
  schoolId: Scalars['UUID']['input'];
  stageGroupId: Scalars['ID']['input'];
  stageId: Scalars['ID']['input'];
  studentState?: InputMaybe<StudentStateEnum>;
  taskId?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAdminQueriesFindGitlabProjectsV3Args = {
  goalId?: InputMaybe<Scalars['Int']['input']>;
  paging: PagingInput;
  schoolId: Scalars['UUID']['input'];
  stageGroupId: Scalars['ID']['input'];
  stageId: Scalars['ID']['input'];
  studentState?: InputMaybe<StudentStateEnum>;
};


export type BusinessAdminQueriesFindPlatfProjectSolutionsArgs = {
  goalId?: InputMaybe<Scalars['Int']['input']>;
  paging: PagingInput;
  schoolId: Scalars['UUID']['input'];
  stageGroupId: Scalars['ID']['input'];
  stageId: Scalars['ID']['input'];
  studentState?: InputMaybe<StudentStateEnum>;
};


export type BusinessAdminQueriesFindSchoolsByRegionsArgs = {
  regionIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type BusinessAdminQueriesFindStageGroupsByGoalIdsFromStageSubjectGroupPlanArgs = {
  goalIds: Array<Scalars['ID']['input']>;
};


export type BusinessAdminQueriesFindStageSubjectGroupPlanByGoalIdsArgs = {
  goalIds: Array<Scalars['ID']['input']>;
};


export type BusinessAdminQueriesGetAcademicYearsArgs = {
  schoolId?: InputMaybe<Scalars['ID']['input']>;
};


export type BusinessAdminQueriesGetActivityEventFeedbackArgs = {
  activityEventId: Scalars['ID']['input'];
  page: PagingInput;
};


export type BusinessAdminQueriesGetActivityEventFeedbackCountArgs = {
  activityEventId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetAllInStudentWhiteListArgs = {
  createDateFrom?: InputMaybe<Scalars['DateTime']['input']>;
  createDateTo?: InputMaybe<Scalars['DateTime']['input']>;
  paging?: InputMaybe<PagingInput>;
};


export type BusinessAdminQueriesGetAllSafeSchoolArgs = {
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
};


export type BusinessAdminQueriesGetAllUniversitiesInfoArgs = {
  universityInfoFilter: UniversityInfoFilterModel;
};


export type BusinessAdminQueriesGetArchiveStageGroupsArgs = {
  stageGroupIds: Array<Scalars['ID']['input']>;
};


export type BusinessAdminQueriesGetAvatarByUserIdArgs = {
  userId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetAwardByIdArgs = {
  awardId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetAwardsArgs = {
  assignmentTypeId?: InputMaybe<Scalars['Int']['input']>;
  awardName?: InputMaybe<Scalars['String']['input']>;
  badgeKindTypeId?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<PagingInput>;
  schoolId?: InputMaybe<Scalars['ID']['input']>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
};


export type BusinessAdminQueriesGetAwardsCountArgs = {
  assignmentTypeId?: InputMaybe<Scalars['Int']['input']>;
  awardName?: InputMaybe<Scalars['String']['input']>;
  badgeKindTypeId?: InputMaybe<Scalars['Int']['input']>;
  schoolId?: InputMaybe<Scalars['ID']['input']>;
};


export type BusinessAdminQueriesGetBtcStudentsInfoForMyClassesArgs = {
  studentIds: Array<Scalars['UUID']['input']>;
};


export type BusinessAdminQueriesGetBadgesPublicProfileArgs = {
  userId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetCalendarEventsCountArgs = {
  after?: InputMaybe<Scalars['DateTime']['input']>;
  before?: InputMaybe<Scalars['DateTime']['input']>;
  endDateAfter?: InputMaybe<Scalars['DateTime']['input']>;
  endDateBefore?: InputMaybe<Scalars['DateTime']['input']>;
  eventCodes: Array<Scalars['String']['input']>;
  nameFilter?: InputMaybe<Scalars['String']['input']>;
  statuses?: InputMaybe<Array<InputMaybe<ParticipantEventStatus>>>;
};


export type BusinessAdminQueriesGetCertificateForStudentsStageGroupsArgs = {
  stageGroupIds: Array<Scalars['ID']['input']>;
};


export type BusinessAdminQueriesGetClassRoomByLoginArgs = {
  login: Scalars['String']['input'];
};


export type BusinessAdminQueriesGetClassSubjectPlansByAcademicYearIdArgs = {
  academicYearId: Scalars['ID']['input'];
  filterStageId?: InputMaybe<Scalars['ID']['input']>;
  filterStageSubjectGroupLearningTypes?: InputMaybe<Array<LearningTypeEnum>>;
  filterStageSubjectGroupName?: InputMaybe<Scalars['String']['input']>;
  filterSubjectId?: InputMaybe<Scalars['ID']['input']>;
};


export type BusinessAdminQueriesGetClassSubjectsByAcademicYearIdArgs = {
  academicYearId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetClassSubjectsByClassNameArgs = {
  className?: InputMaybe<Scalars['String']['input']>;
  limit: Scalars['Int']['input'];
  offset: Scalars['Int']['input'];
};


export type BusinessAdminQueriesGetClassSubjectsByIdsArgs = {
  classSubjectIds: Array<Scalars['ID']['input']>;
};


export type BusinessAdminQueriesGetClassSubjectsBySubjectIdAndStageIdArgs = {
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  stageId: Scalars['ID']['input'];
  subjectId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetClassSubjectsExtendedInfoArgs = {
  classSubjectIds: Array<Scalars['ID']['input']>;
};


export type BusinessAdminQueriesGetClassroomByIdArgs = {
  classroomId: Scalars['Int']['input'];
};


export type BusinessAdminQueriesGetClusterPlanStudentsByClusterIdArgs = {
  clusterId?: InputMaybe<Scalars['ID']['input']>;
};


export type BusinessAdminQueriesGetClustersSummaryArgs = {
  clusterState: ClusterState;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
};


export type BusinessAdminQueriesGetCoalitionMemberInfoModelsArgs = {
  coalitionId: Scalars['Int']['input'];
  pagingInput: PagingInput;
  searchString?: InputMaybe<Scalars['String']['input']>;
  sortingFields?: InputMaybe<Array<SortingField>>;
};


export type BusinessAdminQueriesGetCoalitionsByActivityIdArgs = {
  activityEventId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetCoalitionsBySchoolIdAndStageIdArgs = {
  schoolId: Scalars['UUID']['input'];
  stageId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetCoursesArgs = {
  courseType?: InputMaybe<CourseType>;
  filterExceptCourses?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  name?: InputMaybe<Scalars['String']['input']>;
  paging?: InputMaybe<PagingInput>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type BusinessAdminQueriesGetCurrentStudentCountByExamIdArgs = {
  examId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetDeadlineArgs = {
  deadlineId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetDeadlineShiftRequestArgs = {
  shiftRequestId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetDeadlineShiftRequestsArgs = {
  createdFrom?: InputMaybe<Scalars['DateTime']['input']>;
  createdTo?: InputMaybe<Scalars['DateTime']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  page: PagingInput;
  sorting?: InputMaybe<Array<InputMaybe<SortingField>>>;
  stageGroup?: InputMaybe<Scalars['ID']['input']>;
  status?: InputMaybe<DeadlineShiftRequestStatus>;
};


export type BusinessAdminQueriesGetDeadlineStageGroupsArgs = {
  academicYearId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetDeadlinesArgs = {
  createdFrom?: InputMaybe<Scalars['DateTime']['input']>;
  createdTo?: InputMaybe<Scalars['DateTime']['input']>;
  deadlineFrom?: InputMaybe<Scalars['DateTime']['input']>;
  deadlineStatuses?: InputMaybe<Array<InputMaybe<DeadlineStatus>>>;
  deadlineTo?: InputMaybe<Scalars['DateTime']['input']>;
  isPersonal?: InputMaybe<Scalars['Boolean']['input']>;
  page: PagingInput;
  sorting?: InputMaybe<Array<InputMaybe<SortingField>>>;
  stageGroupId?: InputMaybe<Scalars['ID']['input']>;
};


export type BusinessAdminQueriesGetDeadlinesCountArgs = {
  createdFrom?: InputMaybe<Scalars['DateTime']['input']>;
  createdTo?: InputMaybe<Scalars['DateTime']['input']>;
  deadlineFrom?: InputMaybe<Scalars['DateTime']['input']>;
  deadlineStatuses?: InputMaybe<Array<InputMaybe<DeadlineStatus>>>;
  deadlineTo?: InputMaybe<Scalars['DateTime']['input']>;
  isPersonal?: InputMaybe<Scalars['Boolean']['input']>;
  stageGroupId?: InputMaybe<Scalars['ID']['input']>;
};


export type BusinessAdminQueriesGetDeadlinesForStudentsArgs = {
  createdFrom?: InputMaybe<Scalars['DateTime']['input']>;
  createdTo?: InputMaybe<Scalars['DateTime']['input']>;
  deadlineFrom?: InputMaybe<Scalars['DateTime']['input']>;
  deadlineStatuses: Array<DeadlineStatus>;
  deadlineTo?: InputMaybe<Scalars['DateTime']['input']>;
  isClosest: Scalars['Boolean']['input'];
  page: PagingInput;
  sorting?: InputMaybe<Array<InputMaybe<SortingField>>>;
  stageGroupId?: InputMaybe<Scalars['ID']['input']>;
  studentLogin?: InputMaybe<Scalars['String']['input']>;
};


export type BusinessAdminQueriesGetDeadlinesForStudentsCountArgs = {
  createdFrom?: InputMaybe<Scalars['DateTime']['input']>;
  createdTo?: InputMaybe<Scalars['DateTime']['input']>;
  deadlineFrom?: InputMaybe<Scalars['DateTime']['input']>;
  deadlineStatuses: Array<DeadlineStatus>;
  deadlineTo?: InputMaybe<Scalars['DateTime']['input']>;
  isClosest: Scalars['Boolean']['input'];
  stageGroupId?: InputMaybe<Scalars['ID']['input']>;
  studentLogin?: InputMaybe<Scalars['String']['input']>;
};


export type BusinessAdminQueriesGetEmailbyUserIdArgs = {
  userId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetEventsReportArgs = {
  eventCodes: Array<Scalars['String']['input']>;
  from: Scalars['DateTime']['input'];
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  timeZone?: InputMaybe<Scalars['String']['input']>;
  to: Scalars['DateTime']['input'];
};


export type BusinessAdminQueriesGetExamArgs = {
  examId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetExamModulesArgs = {
  page: PagingInput;
  textInput?: InputMaybe<Scalars['String']['input']>;
};


export type BusinessAdminQueriesGetExamStudentsArgs = {
  examId: Scalars['ID']['input'];
  page: PagingInput;
};


export type BusinessAdminQueriesGetExamsArgs = {
  page: PagingInput;
  sortingField?: InputMaybe<SortingField>;
};


export type BusinessAdminQueriesGetExamsByFilterArgs = {
  paging: PagingInput;
  params: ExamEventsSearchParametersInput;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
};


export type BusinessAdminQueriesGetExamsByFilterCountArgs = {
  params: ExamEventsSearchParametersInput;
};


export type BusinessAdminQueriesGetExperienceHistoryDateArgs = {
  schoolId?: InputMaybe<Scalars['ID']['input']>;
  userId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetExperiencePublicProfileArgs = {
  userId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetFeedbackStatisticsAverageScoreArgs = {
  studentId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetFormMasterStageGroupsArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  userId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetFunctionalRolesArgs = {
  request: Array<SchoolFunctionalRoleInput>;
};


export type BusinessAdminQueriesGetGoalsByDatePeriodAndStageSubjectGroupArgs = {
  endDate?: InputMaybe<Scalars['DateTime']['input']>;
  stageSubjectGroupId: Scalars['ID']['input'];
  startDate?: InputMaybe<Scalars['DateTime']['input']>;
};


export type BusinessAdminQueriesGetGoalsByStageAndStageSubjectGroupIdsArgs = {
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageSubjectGroupIds: Array<Scalars['Int']['input']>;
};


export type BusinessAdminQueriesGetLastGivingsArgs = {
  pagingInput: PagingInput;
  userFilterInput: UserFilterInput;
};


export type BusinessAdminQueriesGetLastGivingsV2Args = {
  pagingInput: PagingInput;
  sortingFields?: InputMaybe<Array<SortingField>>;
  userFilterInput: UserFilterInput;
};


export type BusinessAdminQueriesGetLastGivingsV3Args = {
  pagingInput: PagingInput;
  sortingFields?: InputMaybe<Array<SortingField>>;
  userFilterInput: UserFilterInput;
};


export type BusinessAdminQueriesGetLastMassTransferTaskArgs = {
  sourceAcademicYearId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetLearningActivitiesBySchoolArgs = {
  schoolId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetLearningActivitiesBySchoolSubjectsArgs = {
  schoolId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetLessonArgs = {
  lessonId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetLessonPlanByIdV2Args = {
  lessonPlanId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetLessonsTransferResultArgs = {
  changeAllRepetitionsAtSameDayOfWeek: Scalars['Boolean']['input'];
  lessonInput: LessonInput;
  now: Scalars['DateTime']['input'];
  repeatEndDate: Scalars['Date']['input'];
  repeatType: CreateLessonRepeat;
};


export type BusinessAdminQueriesGetLocalMulticampusSettingAndAllStagesAndStageSubjectGroupsArgs = {
  idForFilter?: InputMaybe<Scalars['ID']['input']>;
  isStage?: InputMaybe<Scalars['Boolean']['input']>;
};


export type BusinessAdminQueriesGetModuleAttemptsSettingsArgs = {
  goalId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetModulesProgressBySubjectAndStageReportArgs = {
  currentRole: Scalars['String']['input'];
  endDate: Scalars['DateTime']['input'];
  stageSubjectGroupId?: InputMaybe<Scalars['Int']['input']>;
  startDate: Scalars['DateTime']['input'];
};


export type BusinessAdminQueriesGetNestedClassSubjectsByStageSubjectGroupIdArgs = {
  stageSubjectGroupId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetNotificationsArgs = {
  paging?: InputMaybe<PagingInput>;
  wasReadIncluded?: InputMaybe<Scalars['Boolean']['input']>;
};


export type BusinessAdminQueriesGetNotificationsByTypesArgs = {
  includeOnlyCurrentYearNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  paging?: InputMaybe<PagingInput>;
  typeIds: Array<Scalars['ID']['input']>;
  wasReadIncluded?: InputMaybe<Scalars['Boolean']['input']>;
};


export type BusinessAdminQueriesGetNotificationsCountArgs = {
  wasReadIncluded?: InputMaybe<Scalars['Boolean']['input']>;
};


export type BusinessAdminQueriesGetPeriodLessonPlansWithStatusesArgs = {
  academicYearId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetPlanModulesForDashboardArgs = {
  paging?: InputMaybe<PagingInput>;
  planId: Scalars['ID']['input'];
  planType: PlanTypeForCondition;
  sorting?: InputMaybe<SortingField>;
};


export type BusinessAdminQueriesGetProjectTeamMembersByAnswerIdArgs = {
  studentAnswerId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetRecommendedDurationForModulesArgs = {
  classSubjectId: Scalars['ID']['input'];
  goalIds: Array<Scalars['ID']['input']>;
};


export type BusinessAdminQueriesGetS21ClassPlanByStageSubjectGroupIdArgs = {
  stageSubjectGroupId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetS21StageGroupPlanArgs = {
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  stagePlanId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetSafeSchoolsByIdsArgs = {
  ids: Array<Scalars['UUID']['input']>;
};


export type BusinessAdminQueriesGetSaveStudyPeriodSetAsyncTaskByAsyncTaskIdArgs = {
  asyncTaskId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetSaveStudyPeriodSetAsyncTaskByStudyPeriodSetIdArgs = {
  studyPeriodSetId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetSchoolArgs = {
  schoolId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetSchoolGameCoalitionArgs = {
  gameCoalitionId: Scalars['Int']['input'];
};


export type BusinessAdminQueriesGetSchoolGameCoalitionMembersArgs = {
  gameCoalitionId: Scalars['Int']['input'];
  limit: Scalars['Int']['input'];
  offset: Scalars['Int']['input'];
  searchString: Scalars['String']['input'];
  sortingFields?: InputMaybe<Array<SortingField>>;
};


export type BusinessAdminQueriesGetSchoolGameCoalitionTournamentMembersArgs = {
  gameCoalitionId: Scalars['Int']['input'];
  gameTournamentId: Scalars['Int']['input'];
  page: PagingInput;
  searchString: Scalars['String']['input'];
  sortingFields: Array<SortingField>;
};


export type BusinessAdminQueriesGetSchoolGameCoalitionsArgs = {
  limit: Scalars['Int']['input'];
  offset: Scalars['Int']['input'];
};


export type BusinessAdminQueriesGetSchoolGameCoalitionsCountV2Args = {
  nameSearch?: InputMaybe<Scalars['String']['input']>;
  schoolId: Scalars['UUID']['input'];
  stageId?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAdminQueriesGetSchoolGameCoalitionsNotInTournamentArgs = {
  gameTournamentId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetSchoolGameCoalitionsV2Args = {
  nameSearch?: InputMaybe<Scalars['String']['input']>;
  pagingInput?: InputMaybe<PagingInput>;
  schoolId: Scalars['UUID']['input'];
  sortingFields?: InputMaybe<Array<SortingField>>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAdminQueriesGetSchoolGameTournamentArgs = {
  gameTournamentId: Scalars['Int']['input'];
};


export type BusinessAdminQueriesGetSchoolGameTournamentsArgs = {
  limit: Scalars['Int']['input'];
  offset: Scalars['Int']['input'];
  sortingFields?: InputMaybe<Array<SortingField>>;
};


export type BusinessAdminQueriesGetSchoolGameTournamentsCountV2Args = {
  search?: InputMaybe<Scalars['String']['input']>;
  stageId?: InputMaybe<Scalars['ID']['input']>;
  timeStatus: TimeStatus;
};


export type BusinessAdminQueriesGetSchoolGameTournamentsForTimesArgs = {
  sortingFields?: InputMaybe<Array<SortingField>>;
  timeEnd: Scalars['DateTime']['input'];
  timeStart: Scalars['DateTime']['input'];
};


export type BusinessAdminQueriesGetSchoolGameTournamentsV2Args = {
  limit: Scalars['Int']['input'];
  offset: Scalars['Int']['input'];
  search?: InputMaybe<Scalars['String']['input']>;
  sortingFields?: InputMaybe<Array<SortingField>>;
  stageId?: InputMaybe<Scalars['ID']['input']>;
  timeStatus: TimeStatus;
};


export type BusinessAdminQueriesGetSchoolIdByLoginArgs = {
  login: Scalars['String']['input'];
};


export type BusinessAdminQueriesGetSchoolLearningActivityWeightsArgs = {
  schoolId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetSchoolMandatoryFilledDataArgs = {
  schoolId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetSchoolMarkTypeGroupConfigurationsArgs = {
  schoolId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetSchoolMarkTypeGroupsBySchoolArgs = {
  schoolId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetSchoolMarksByGovernmentMarkTypeArgs = {
  governmentMarkTypeId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetSchoolMonitoringArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  schoolMonitoringInput?: InputMaybe<SchoolMonitoringInput>;
};


export type BusinessAdminQueriesGetSchoolsArgs = {
  paging?: InputMaybe<PagingInput>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type BusinessAdminQueriesGetSchoolsTagsByRegionsArgs = {
  regionIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
};


export type BusinessAdminQueriesGetShiftRequestsCountArgs = {
  createdFrom?: InputMaybe<Scalars['DateTime']['input']>;
  createdTo?: InputMaybe<Scalars['DateTime']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  stageGroup?: InputMaybe<Scalars['ID']['input']>;
  status?: InputMaybe<DeadlineShiftRequestStatus>;
};


export type BusinessAdminQueriesGetSoftSkillTypesArgs = {
  isArchive?: InputMaybe<Scalars['Boolean']['input']>;
  sortingFields?: InputMaybe<Array<SortingField>>;
};


export type BusinessAdminQueriesGetSoftSkillsByStudentIdArgs = {
  studentId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetStageByIdArgs = {
  stageId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetStageConfigurationsArgs = {
  isSchool21?: InputMaybe<Scalars['Boolean']['input']>;
};


export type BusinessAdminQueriesGetStageGroupArgs = {
  filterStageSubjectGroupLearningTypes?: InputMaybe<Array<LearningTypeEnum>>;
  stageGroupId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetStageGroupS21PublicProfileArgs = {
  studentId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetStageGroupsArgs = {
  academicYearId: Scalars['ID']['input'];
  filterStageSubjectGroupLearningTypes?: InputMaybe<Array<LearningTypeEnum>>;
  isIntergroup?: InputMaybe<Scalars['Boolean']['input']>;
};


export type BusinessAdminQueriesGetStageGroupsByFilterArgs = {
  academicYearId: Scalars['ID']['input'];
  isIntergroup?: InputMaybe<Scalars['Boolean']['input']>;
  stageId?: InputMaybe<Scalars['ID']['input']>;
  stageIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type BusinessAdminQueriesGetStageGroupsBySchoolAndTeacherArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  stageId?: InputMaybe<Scalars['ID']['input']>;
};


export type BusinessAdminQueriesGetStageGroupsByTeacherArgs = {
  academicYearId: Scalars['ID']['input'];
  teacherId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetStageGroupsS21PublicProfileArgs = {
  studentId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetStageGroupsV2Args = {
  academicYearId: Scalars['ID']['input'];
  isIntergroup?: InputMaybe<Scalars['Boolean']['input']>;
};


export type BusinessAdminQueriesGetStageGroupsWithTimeslotSetIdsArgs = {
  academicYearId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetStagePlansByIdsArgs = {
  stagePlansIds: Array<Scalars['ID']['input']>;
};


export type BusinessAdminQueriesGetStageSubjectGroupsBySchoolIdAndStageIdArgs = {
  schoolId: Scalars['UUID']['input'];
  stageId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetStageSubjectGroupsByStageGroupAndStageSubjectsArgs = {
  stageGroupId: Scalars['ID']['input'];
  stageSubjectIds: Array<Scalars['ID']['input']>;
};


export type BusinessAdminQueriesGetStageSubjectGroupsByStageGroupAndSubjectArgs = {
  stageGroupId: Scalars['ID']['input'];
  subjectId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetStageSubjectGroupsByStageGroupIdAndFilterArgs = {
  pagingInput: PagingInput;
  searchString?: InputMaybe<Scalars['String']['input']>;
  stageGroupId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetStagesArgs = {
  academicYearId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetStagesBySchoolMarkTypeGroupArgs = {
  schoolMarkTypeGroupId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetStagesWithNamesArgs = {
  academicYearId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetStudentAcademicPerformanceByAttestationPeriodArgs = {
  closeModuleDate: Scalars['Date']['input'];
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  stageId: Scalars['Int']['input'];
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAdminQueriesGetStudentAcademicPerformanceByAttestationPeriodExpandedArgs = {
  closeModuleDate: Scalars['Date']['input'];
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  stageId: Scalars['Int']['input'];
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAdminQueriesGetStudentAccountsArgs = {
  birthdayEnd?: InputMaybe<Scalars['Date']['input']>;
  birthdayStart?: InputMaybe<Scalars['Date']['input']>;
  creationDateTimeEnd?: InputMaybe<Scalars['DateTime']['input']>;
  creationDateTimeStart?: InputMaybe<Scalars['DateTime']['input']>;
  filterRoleStatus?: InputMaybe<RoleStatus>;
  filterStageGroups?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterStudentStatus?: InputMaybe<Array<StudentStatus>>;
  filterUserStatus?: InputMaybe<UserStatus>;
  graduationDateTimeEnd?: InputMaybe<Scalars['DateTime']['input']>;
  graduationDateTimeStart?: InputMaybe<Scalars['DateTime']['input']>;
  paging: PagingInput;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type BusinessAdminQueriesGetStudentIdByLoginArgs = {
  login: Scalars['String']['input'];
};


export type BusinessAdminQueriesGetStudentJournalPerformanceArgs = {
  stageId: Scalars['Int']['input'];
  studyPeriodId: Scalars['Int']['input'];
};


export type BusinessAdminQueriesGetStudentProjectsByStageGroupArgs = {
  stageGroupId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetStudentStageGroupTransferHistoryArgs = {
  studentId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetStudentTrafficArgs = {
  date: Scalars['Date']['input'];
  login: Scalars['String']['input'];
  schoolID: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetStudentUniversityEmailsArgs = {
  universityEmailFilter: UniversityEmailFilterInputModel;
};


export type BusinessAdminQueriesGetStudentUniversityEmailsCountArgs = {
  universityEmailFilter: UniversityEmailFilterInputModel;
};


export type BusinessAdminQueriesGetStudentsAcademicPerformanceArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  stageId: Scalars['Int']['input'];
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAdminQueriesGetStudentsAcademicPerformanceExpandedArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  stageId: Scalars['Int']['input'];
  startDate: Scalars['DateTime']['input'];
};


export type BusinessAdminQueriesGetStudentsAcademicPerformanceExpandedV2Args = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  stageId: Scalars['Int']['input'];
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAdminQueriesGetStudentsByStageSubjectGroupArgs = {
  pagingInput: PagingInput;
  stageSubjectGroupId: Scalars['ID']['input'];
  studentFullNameSearchString?: InputMaybe<Scalars['String']['input']>;
};


export type BusinessAdminQueriesGetStudentsLevelsByActivityIdArgs = {
  activityEventId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetStudentsMarksResultDetailedArgs = {
  stageGroupId: Scalars['Int']['input'];
  stageId: Scalars['Int']['input'];
  studyPeriodId: Scalars['Int']['input'];
  subjectId: Scalars['Int']['input'];
};


export type BusinessAdminQueriesGetStudentsMarksResultDetailedByDatesArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  currentRole?: InputMaybe<Scalars['String']['input']>;
  periodEndDate: Scalars['Date']['input'];
  periodStartDate: Scalars['Date']['input'];
  stageGroupId: Scalars['Int']['input'];
  stageId: Scalars['Int']['input'];
  subjectId: Scalars['Int']['input'];
};


export type BusinessAdminQueriesGetStudentsMarksSubjectsDetailedArgs = {
  stageId: Scalars['Int']['input'];
  studentId: Scalars['UUID']['input'];
  studyPeriodId: Scalars['Int']['input'];
};


export type BusinessAdminQueriesGetStudentsMarksSubjectsDetailedByDatesArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  periodEndDate: Scalars['Date']['input'];
  periodStartDate: Scalars['Date']['input'];
  stageId: Scalars['Int']['input'];
  studentId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetStudentsWithStageSubjectGroupByFilterArgs = {
  pagingInput: PagingInput;
  stageGroupId: Scalars['ID']['input'];
  stageSubjectId: Scalars['ID']['input'];
  studentFullNameSearchString?: InputMaybe<Scalars['String']['input']>;
};


export type BusinessAdminQueriesGetStudyPeriodArgs = {
  studyPeriodId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetStudyPeriodMarksArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  currentRole?: InputMaybe<Scalars['String']['input']>;
  stageGroupId?: InputMaybe<Scalars['Int']['input']>;
  stageId: Scalars['Int']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAdminQueriesGetStudyPeriodSetsArgs = {
  academicYearId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetStudyPeriodsByStudyPeriodSetArgs = {
  studyPeriodSetId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetStudyProgramArgs = {
  academicYearId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetSubjectLearningActivitiesArgs = {
  schoolId: Scalars['UUID']['input'];
  subjectId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetSubjectsByAcademicYearIdArgs = {
  academicYearId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetSubjectsByOrgUnitIdArgs = {
  orgUnitId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetSubjectsByStageGroupAntSchoolAndTeacherArgs = {
  stageGroupId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetSuitableStageSubjectsForExamArgs = {
  academicYearId: Scalars['ID']['input'];
  goalId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetSuitableStagesForExamArgs = {
  academicYearId: Scalars['ID']['input'];
  goalId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetSystemNotificationsWithoutCommonArgs = {
  paging?: InputMaybe<PagingInput>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type BusinessAdminQueriesGetTaskAdditionalAttributesArgs = {
  taskId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetTasksOnCheckArgs = {
  currentRole: Scalars['String']['input'];
  endDate: Scalars['DateTime']['input'];
  stageGroupId?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageSubjectGroupId?: InputMaybe<Scalars['Int']['input']>;
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  tasksDate: Scalars['DateTime']['input'];
};


export type BusinessAdminQueriesGetTasksOnCheckForMoreThan7DaysDetailedArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
};


export type BusinessAdminQueriesGetTeacherSchoolMetricsArgs = {
  currentRole: Scalars['String']['input'];
  teacherSchoolMetricsInput?: InputMaybe<SchoolMonitoringInput>;
};


export type BusinessAdminQueriesGetTeacherSchoolMetricsExcelArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  reportDateTime: Scalars['String']['input'];
  showNonNullable: Scalars['Boolean']['input'];
  showNullable: Scalars['Boolean']['input'];
  teacherSchoolMetricsInput: SchoolMonitoringInput;
};


export type BusinessAdminQueriesGetTeacherSchoolMetricsExcelForBtcArgs = {
  reportDateTime: Scalars['String']['input'];
  showNonNullable: Scalars['Boolean']['input'];
  showNullable: Scalars['Boolean']['input'];
  students?: InputMaybe<Scalars['String']['input']>;
  teacherSchoolMetricsInput: SchoolMonitoringInput;
  trajectories?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type BusinessAdminQueriesGetTeacherStageGroupsArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  userId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetTeacherTimetableArgs = {
  academicYearId: Scalars['ID']['input'];
  dateFrom: Scalars['DateTime']['input'];
  dateTo: Scalars['DateTime']['input'];
  teacherId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetTeachersBySchoolAndFiltersArgs = {
  teacherSearchInput: TeacherSearchInput;
};


export type BusinessAdminQueriesGetTeamSettingsGroupFromLocalCourseGoalArgs = {
  localCourseGoalId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetTimetableByDaysArgs = {
  academicYearId: Scalars['ID']['input'];
  beginDate: Scalars['Date']['input'];
  endDate: Scalars['Date']['input'];
};


export type BusinessAdminQueriesGetTimetableDraftArgs = {
  timetableDraftId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetTimetableDraftSummariesPerSchoolArgs = {
  schoolId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetTimetableDraftV2Args = {
  timetableDraftId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetTournamentResultReportArgs = {
  tournamentId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetUnfinishedTournamentsArgs = {
  stageGroupId: Scalars['Int']['input'];
};


export type BusinessAdminQueriesGetUnfinishedTournamentsByStageSubjectGroupArgs = {
  stageSubjectGroupId: Scalars['Int']['input'];
};


export type BusinessAdminQueriesGetUserArgs = {
  userId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetUserAwardHistoryByAwardIdArgs = {
  awardId: Scalars['ID']['input'];
  login?: InputMaybe<Scalars['String']['input']>;
  paging: PagingInput;
};


export type BusinessAdminQueriesGetUserAwardHistoryByAwardIdCountArgs = {
  awardId: Scalars['ID']['input'];
  login?: InputMaybe<Scalars['String']['input']>;
};


export type BusinessAdminQueriesGetUserAwardHistoryByAwardIdV2Args = {
  awardId: Scalars['ID']['input'];
  login?: InputMaybe<Scalars['String']['input']>;
  paging: PagingInput;
  sortingFields: Array<SortingField>;
};


export type BusinessAdminQueriesGetUserCoinsArgs = {
  coalitionId?: InputMaybe<Scalars['ID']['input']>;
  experienceLevelId?: InputMaybe<Scalars['ID']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  paging: PagingInput;
  stageGroupId?: InputMaybe<Scalars['ID']['input']>;
  stageId?: InputMaybe<Scalars['ID']['input']>;
};


export type BusinessAdminQueriesGetUserCoinsCountArgs = {
  coalitionId?: InputMaybe<Scalars['ID']['input']>;
  experienceLevelId?: InputMaybe<Scalars['ID']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  stageGroupId?: InputMaybe<Scalars['ID']['input']>;
  stageId?: InputMaybe<Scalars['ID']['input']>;
};


export type BusinessAdminQueriesGetUserCoinsHistoryArgs = {
  userId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetUserCredentialsInfoArgs = {
  userId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetUserDraftsArgs = {
  birthdayEnd?: InputMaybe<Scalars['Date']['input']>;
  birthdayStart?: InputMaybe<Scalars['Date']['input']>;
  businessRoleType?: InputMaybe<Scalars['String']['input']>;
  creationDateTimeEnd?: InputMaybe<Scalars['DateTime']['input']>;
  creationDateTimeStart?: InputMaybe<Scalars['DateTime']['input']>;
  paging: PagingInput;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type BusinessAdminQueriesGetUserGivingsHistoryByUserIdArgs = {
  pagingInput: PagingInput;
  sortingFields: Array<SortingField>;
  userId: Scalars['UUID']['input'];
};


export type BusinessAdminQueriesGetUserIdByLoginArgs = {
  login: Scalars['String']['input'];
};


export type BusinessAdminQueriesGetUserParentsInfoArgs = {
  childUserId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetUsersArgs = {
  birthdayEnd?: InputMaybe<Scalars['Date']['input']>;
  birthdayStart?: InputMaybe<Scalars['Date']['input']>;
  creationDateTimeEnd?: InputMaybe<Scalars['DateTime']['input']>;
  creationDateTimeStart?: InputMaybe<Scalars['DateTime']['input']>;
  dismissDateEnd?: InputMaybe<Scalars['DateTime']['input']>;
  dismissDateStart?: InputMaybe<Scalars['DateTime']['input']>;
  dismissTypeId?: InputMaybe<Scalars['Int']['input']>;
  entityIds?: InputMaybe<Array<Scalars['String']['input']>>;
  excludedUserIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  filterConfiguredUsers?: InputMaybe<Scalars['Boolean']['input']>;
  filterRoleStatus?: InputMaybe<RoleStatus>;
  filterRoles?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filterSchools?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterStageGroups?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterSubjects?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterUserStatus?: InputMaybe<UserStatus>;
  froleSetIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
  graduationDateTimeEnd?: InputMaybe<Scalars['DateTime']['input']>;
  graduationDateTimeStart?: InputMaybe<Scalars['DateTime']['input']>;
  paging?: InputMaybe<PagingInput>;
  showRolesOnlyForFilteredSchools?: InputMaybe<Scalars['Boolean']['input']>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type BusinessAdminQueriesGetUsersByFunctionalRoleArgs = {
  functionalRoleId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesGetUsersCountArgs = {
  birthdayEnd?: InputMaybe<Scalars['Date']['input']>;
  birthdayStart?: InputMaybe<Scalars['Date']['input']>;
  creationDateTimeEnd?: InputMaybe<Scalars['DateTime']['input']>;
  creationDateTimeStart?: InputMaybe<Scalars['DateTime']['input']>;
  dismissDateEnd?: InputMaybe<Scalars['DateTime']['input']>;
  dismissDateStart?: InputMaybe<Scalars['DateTime']['input']>;
  dismissTypeId?: InputMaybe<Scalars['Int']['input']>;
  entityIds?: InputMaybe<Array<Scalars['String']['input']>>;
  excludedUserIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  filterConfiguredUsers?: InputMaybe<Scalars['Boolean']['input']>;
  filterRoleStatus?: InputMaybe<RoleStatus>;
  filterRoles?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filterSchools?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterStageGroups?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterSubjects?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterUserStatus?: InputMaybe<UserStatus>;
  froleSetIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
  graduationDateTimeEnd?: InputMaybe<Scalars['DateTime']['input']>;
  graduationDateTimeStart?: InputMaybe<Scalars['DateTime']['input']>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type BusinessAdminQueriesGetUsersCountByFilterArgs = {
  userFilterInput: UserFilterInput;
};


export type BusinessAdminQueriesGetUsersCountV2Args = {
  birthdayEnd?: InputMaybe<Scalars['Date']['input']>;
  birthdayStart?: InputMaybe<Scalars['Date']['input']>;
  creationDateTimeEnd?: InputMaybe<Scalars['DateTime']['input']>;
  creationDateTimeStart?: InputMaybe<Scalars['DateTime']['input']>;
  dismissDateEnd?: InputMaybe<Scalars['DateTime']['input']>;
  dismissDateStart?: InputMaybe<Scalars['DateTime']['input']>;
  dismissTypeId?: InputMaybe<Scalars['Int']['input']>;
  entityIds?: InputMaybe<Array<Scalars['String']['input']>>;
  filterConfiguredUsers?: InputMaybe<Scalars['Boolean']['input']>;
  filterRoleStatus?: InputMaybe<RoleStatus>;
  filterRoles?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filterSchools?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterStageGroups?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterStudentStatus?: InputMaybe<Array<StudentStatus>>;
  filterSubjects?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterUserStatus?: InputMaybe<UserStatus>;
  froleSetIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
  graduationDateTimeEnd?: InputMaybe<Scalars['DateTime']['input']>;
  graduationDateTimeStart?: InputMaybe<Scalars['DateTime']['input']>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type BusinessAdminQueriesGetUsersToBadgeAwardArgs = {
  awardId: Scalars['ID']['input'];
  coalitionId?: InputMaybe<Scalars['ID']['input']>;
  experienceLevelId?: InputMaybe<Scalars['ID']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  paging: PagingInput;
  stageGroupId?: InputMaybe<Scalars['ID']['input']>;
  stageId?: InputMaybe<Scalars['ID']['input']>;
};


export type BusinessAdminQueriesGetUsersToBadgeAwardCountArgs = {
  awardId: Scalars['ID']['input'];
  coalitionId?: InputMaybe<Scalars['ID']['input']>;
  experienceLevelId?: InputMaybe<Scalars['ID']['input']>;
  login?: InputMaybe<Scalars['String']['input']>;
  stageGroupId?: InputMaybe<Scalars['ID']['input']>;
  stageId?: InputMaybe<Scalars['ID']['input']>;
};


export type BusinessAdminQueriesGetUsersV2Args = {
  birthdayEnd?: InputMaybe<Scalars['Date']['input']>;
  birthdayStart?: InputMaybe<Scalars['Date']['input']>;
  creationDateTimeEnd?: InputMaybe<Scalars['DateTime']['input']>;
  creationDateTimeStart?: InputMaybe<Scalars['DateTime']['input']>;
  dismissDateEnd?: InputMaybe<Scalars['DateTime']['input']>;
  dismissDateStart?: InputMaybe<Scalars['DateTime']['input']>;
  dismissTypeId?: InputMaybe<Scalars['Int']['input']>;
  entityIds?: InputMaybe<Array<Scalars['String']['input']>>;
  filterConfiguredUsers?: InputMaybe<Scalars['Boolean']['input']>;
  filterRoleStatus?: InputMaybe<RoleStatus>;
  filterRoles?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filterSchools?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterStageGroups?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterStudentStatus?: InputMaybe<Array<StudentStatus>>;
  filterSubjects?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterUserStatus?: InputMaybe<UserStatus>;
  froleSetIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
  graduationDateTimeEnd?: InputMaybe<Scalars['DateTime']['input']>;
  graduationDateTimeStart?: InputMaybe<Scalars['DateTime']['input']>;
  paging: PagingInput;
  showRolesOnlyForFilteredSchools?: InputMaybe<Scalars['Boolean']['input']>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type BusinessAdminQueriesGetUsersWithDeletedRolesArgs = {
  paging?: InputMaybe<PagingInput>;
  sortingFields?: InputMaybe<Array<SortingField>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
};


export type BusinessAdminQueriesGetUsersWithDeletedRolesCountArgs = {
  textSearch?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
};


export type BusinessAdminQueriesGetWorkstationByLoginArgs = {
  login: Scalars['String']['input'];
};


export type BusinessAdminQueriesGetWorkstationByUserIdArgs = {
  userId?: InputMaybe<Scalars['UUID']['input']>;
};


export type BusinessAdminQueriesLoadGitlabProjectsAsExcelFileArgs = {
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  stageGroupId?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  studentState?: InputMaybe<StudentStateEnum>;
  taskId?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAdminQueriesLoadGitlabProjectsAsExcelFileV2Args = {
  schoolId: Scalars['UUID']['input'];
  stageGroupId: Scalars['ID']['input'];
  stageId: Scalars['ID']['input'];
  studentState?: InputMaybe<StudentStateEnum>;
  taskId?: InputMaybe<Scalars['Int']['input']>;
};


export type BusinessAdminQueriesLoadGitlabProjectsAsExcelFileV3Args = {
  goalId?: InputMaybe<Scalars['Int']['input']>;
  schoolId: Scalars['UUID']['input'];
  stageGroupId: Scalars['ID']['input'];
  stageId: Scalars['ID']['input'];
  studentState?: InputMaybe<StudentStateEnum>;
};


export type BusinessAdminQueriesLoadStudentsPerformanceS21ReportArgs = {
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  stageSubjectGroupId: Scalars['Int']['input'];
  timeZone?: InputMaybe<Scalars['String']['input']>;
};


export type BusinessAdminQueriesLoadStudentsTeamS21ReportArgs = {
  goalId?: InputMaybe<Scalars['ID']['input']>;
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  stageId: Scalars['ID']['input'];
  stageSubjectGroupId?: InputMaybe<Scalars['ID']['input']>;
  timeZone?: InputMaybe<Scalars['String']['input']>;
};


export type BusinessAdminQueriesLoadTaskEvaluationRuleGroupsFromLocalCourseArgs = {
  conditionType: ConditionType;
  localCourseGoalId: Scalars['ID']['input'];
};


export type BusinessAdminQueriesLoadWelcomePackReportsArgs = {
  welcomePackFilter: WelcomePackFilterInputModel;
};


export type BusinessAdminQueriesPreventSaveClassSubjectGroupStudentsArgs = {
  classSubject: ClassSubjectInput;
};


export type BusinessAdminQueriesValidateLoginsForAwardsArgs = {
  logins: Array<Scalars['String']['input']>;
};


export type BusinessAdminQueriesValidateLoginsForAwardsV2Args = {
  logins: Array<Scalars['String']['input']>;
};


export type BusinessAdminQueriesValidateUserInviteEmailArgs = {
  checkUserDraft?: InputMaybe<Scalars['Boolean']['input']>;
  field: Scalars['String']['input'];
};


export type BusinessAdminQueriesValidateUserInvitePhoneArgs = {
  checkUserDraft?: InputMaybe<Scalars['Boolean']['input']>;
  field: Scalars['String']['input'];
};

/** deprecated. use BusinessAdminRoleV2 */
export type BusinessAdminRole = {
  __typename?: 'BusinessAdminRole';
  /** дата деактивации роли */
  dateEnd?: Maybe<Scalars['DateTime']['output']>;
  /** дата активации роли */
  dateStart?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  /** является ли роль дефолтной при входе пользователя в приложение */
  isDefault: Scalars['Boolean']['output'];
  /** название роли */
  role: Roles;
  school: SafeSchool;
  schoolId: Scalars['ID']['output'];
  status: RoleStatus;
};

export type BusinessAdminRoleInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  productId?: InputMaybe<Scalars['ID']['input']>;
  schoolId?: InputMaybe<Scalars['ID']['input']>;
  status?: InputMaybe<RoleStatus>;
  temporaryRoleInput?: InputMaybe<TemporaryRoleInput>;
};

export type BusinessAdminRoleV2 = {
  __typename?: 'BusinessAdminRoleV2';
  /** дата деактивации роли */
  dateEnd?: Maybe<Scalars['DateTime']['output']>;
  /** дата активации роли */
  dateStart?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  /** является ли роль дефолтной при входе пользователя в приложение */
  isDefault: Scalars['Boolean']['output'];
  orgUnitId: Scalars['ID']['output'];
  productId?: Maybe<Scalars['ID']['output']>;
  /** название роли */
  role: Roles;
  school?: Maybe<SafeSchool>;
  schoolId?: Maybe<Scalars['ID']['output']>;
  status: RoleStatus;
};

export type BusinessAdminView = {
  __typename?: 'BusinessAdminView';
  /** адрес аватара пользователя */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  fullName: Scalars['String']['output'];
  /** идентификатор пользователя */
  id: Scalars['ID']['output'];
  isSchoolDirector: Scalars['Boolean']['output'];
};

export enum BusinessTypeEnum {
  BaseIdea = 'BASE_IDEA',
  MotivationTask = 'MOTIVATION_TASK',
  ProblematicIssue = 'PROBLEMATIC_ISSUE'
}

export type BusinessWidgetInfo = {
  __typename?: 'BusinessWidgetInfo';
  /** Нетипизированная информация для бизнесс-виджета (используется только если ContentWidgetTypeEnum=Business) */
  businessInfo: Scalars['String']['output'];
  /** Бизнесс тип (используется только если ContentWidgetTypeEnum=Business) */
  businessType: BusinessTypeEnum;
};

/** S21. Занятые временные промежутки в календаре */
export type BusyTimeInterval = {
  __typename?: 'BusyTimeInterval';
  /** Дата и время завершения */
  end: Scalars['DateTime']['output'];
  /** Дата и время начала */
  start: Scalars['DateTime']['output'];
};

export type Calendar = {
  __typename?: 'Calendar';
  id: Scalars['ID']['output'];
  subjects: Array<Maybe<CalendarSubject>>;
};

/** Записи на проверку для календаря s21 */
export type CalendarBooking = {
  __typename?: 'CalendarBooking';
  /** Дополнительная информация про чек-лист */
  additionalChecklist?: Maybe<AdditionalChecklist>;
  /** Идентификатор ответа */
  answerId?: Maybe<Scalars['ID']['output']>;
  /** Статус записи на проверку */
  bookingStatus: BookingStatusEnum;
  /** Таймслот, к которому привязана запись на проверку */
  eventSlot: CalendarTimeSlot;
  /** Идентификатор таймслота */
  eventSlotId: Scalars['ID']['output'];
  /** Идентификатор записи на проверку */
  id: Scalars['ID']['output'];
  /** Онлайн проверка с Jazz */
  isOnline: Scalars['Boolean']['output'];
  /** Задание на проверку */
  task?: Maybe<Task>;
  /** Идентификатор задания на проверку */
  taskId?: Maybe<Scalars['ID']['output']>;
  /**
   * Команда, в которой состоит ученик, если на проверку записан групповой проект, иначе null
   * @deprecated Use verifiableInfo.team
   */
  team?: Maybe<ProjectTeamMembers>;
  /** Ссылка на ВКС */
  vcLinkUrl?: Maybe<Scalars['String']['output']>;
  /** Информация о проверяемых, null если не наступило время деанонимизации */
  verifiableInfo?: Maybe<VerifiableInfo>;
  /**
   * Проверяемый студент
   * @deprecated Use verifiableInfo.verifiableStudents
   */
  verifiableStudent?: Maybe<Student>;
  /** Проверяющий пользователь */
  verifierUser?: Maybe<User>;
};

/** События для календаря s21 */
export type CalendarEvent = {
  __typename?: 'CalendarEvent';
  /** Связанное мероприятие */
  activity?: Maybe<ActivityEvent>;
  /** Средняя оценка мероприятия по отзывам */
  averageFeedbackRating?: Maybe<Scalars['Float']['output']>;
  /** Список брони на данное событие */
  bookings: Array<CalendarBooking>;
  /**
   * Количество зарегестрированных
   * @deprecated  Use activity.currentStudentsCount or exam.currentStudentsCount
   */
  currentStudentsCount?: Maybe<Scalars['Int']['output']>;
  /** Описание мероприятия */
  description: Scalars['String']['output'];
  /** Дата и время завершения события */
  end: Scalars['DateTime']['output'];
  /** Код типа мероприятия */
  eventCode?: Maybe<Scalars['String']['output']>;
  /** Разбивка по интервалам */
  eventSlots: Array<CalendarTimeSlot>;
  /** Тип мероприятия для отображения */
  eventType?: Maybe<Scalars['String']['output']>;
  /** Роль пользователя (студент / сотрудник) */
  eventUserRole: CalendarEventUserRole;
  /** Связанный экзамен */
  exam?: Maybe<Exam>;
  /** Внешний идентификатор для экзаменов/мероприятий - зависит от eventType */
  externalId?: Maybe<Scalars['Int']['output']>;
  /** Количество оставленых отзывов */
  feedbackCount?: Maybe<Scalars['Int']['output']>;
  /**
   * Список модулей для проверки в данный слот
   * @deprecated Use CalendarTimeSlot.goalCheck
   */
  goals: Array<Goal>;
  /**
   * Информация по проверкам проекта
   * @deprecated Not relevant. Moved to 'Goal' type
   */
  goalsReviewInfo: Array<GoalReviewInfo>;
  /** Идентификатор события */
  id: Scalars['ID']['output'];
  /**
   * Для отображения диапазона Ip в стлучае экзамена
   * @deprecated  Use exam.ipRange
   */
  ipRange?: Maybe<Scalars['String']['output']>;
  /**
   * Место проведения
   * @deprecated  Use activity.location or exam.location
   */
  location?: Maybe<Scalars['String']['output']>;
  /**
   * Максмиально допустимое количество регистраций на мероприятие
   * @deprecated  Use activity.maxStudentCount or exam.maxStudentCount
   */
  maxStudentCount?: Maybe<Scalars['Int']['output']>;
  /** Связанный штраф */
  penalty?: Maybe<Penalty>;
  /**
   * Информация о школе, к которой привязано событие
   * null, если событие, было созданы ДО реализации привязки эвента к школе
   */
  school?: Maybe<CalendarEventSchool>;
  /** Дата и время начала события */
  start: Scalars['DateTime']['output'];
  /** Связанная проверка код-ревью. {null} - если нет связанной проверки */
  studentCodeReview?: Maybe<StudentCodeReview>;
};

/** Информация по категории для календаря */
export type CalendarEventCategory = {
  __typename?: 'CalendarEventCategory';
  /** Название цвета */
  color: Scalars['String']['output'];
  id?: Maybe<Scalars['Int']['output']>;
  /** Название категории */
  name: Scalars['String']['output'];
};

/** Для фильтрации календарных событий */
export type CalendarEventFilterInput = {
  /** Признак активности события */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Признак события на весь день */
  allDayEvent?: InputMaybe<Scalars['Boolean']['input']>;
  /** Идентификатор пользователя (userId), создавшего событие */
  creatorId?: InputMaybe<Scalars['UUID']['input']>;
  /** Дата и время окончания события */
  endTimePeriod?: InputMaybe<Scalars['DateTime']['input']>;
  /** Тип календарного события */
  eventTypeId?: InputMaybe<Scalars['Int']['input']>;
  /** Тип пользовательской группы участников события */
  groupTypeId?: InputMaybe<Scalars['Int']['input']>;
  /** Ключевая фраза */
  keyPhrase?: InputMaybe<Scalars['String']['input']>;
  /** Идентификатор пользовательной группы организатора события */
  organizerGroupId?: InputMaybe<Scalars['UUID']['input']>;
  /**
   * Идентификатор основного повторяющегося события (CalendarEvent#id)
   * для события-исключения из правила
   */
  parentCalendarEventId?: InputMaybe<Scalars['UUID']['input']>;
  /** Идентификаторы пользовательских групп участников события */
  participantGroupIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
  /** Идентификатор пользователя, являющегося участником */
  participantUserId?: InputMaybe<Scalars['UUID']['input']>;
  /** До какого числа действует правило для повторяющегося события */
  recurrenceEndTs?: InputMaybe<Scalars['DateTime']['input']>;
  /** Правило для повторяющегося события */
  recurrenceRule?: InputMaybe<Scalars['String']['input']>;
  /** Дата и время начала события */
  startTimePeriod?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Событие в календаре, с возможностью сохранения правила повторения */
export type CalendarEventInput = {
  /** Признак активности события */
  active: Scalars['Boolean']['input'];
  /** Признак события на весь день */
  allDayEvent: Scalars['Boolean']['input'];
  /** Категория события */
  calendarEventCategoryId?: InputMaybe<Scalars['Int']['input']>;
  /** Описание события */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Дата и время окончания события */
  endTime: Scalars['DateTime']['input'];
  /** Тип события (например: 5 - Мои события) */
  eventTypeId: Scalars['Int']['input'];
  /** Идентификатор события */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Место проведения/ссылка на онлайн событие */
  location: Scalars['String']['input'];
  /** Наименование события */
  name: Scalars['String']['input'];
  /**
   * Идентификатор основного повторяющегося события (CalendarEventInput#id)
   * для события-исключения из правила
   */
  parentCalendarEventId?: InputMaybe<Scalars['UUID']['input']>;
  /**
   * Идентификатор типа пользовательской группы,
   * которые могут быть участниками события (например: 2 - индивидуальная группа пользователей)
   */
  participantGroupTypeId?: InputMaybe<Scalars['Int']['input']>;
  /** До какого числа действует правило для повторяющегося события */
  recurrenceEndTs?: InputMaybe<Scalars['DateTime']['input']>;
  /** Правило для повторяющегося события */
  recurrenceRule?: InputMaybe<Scalars['String']['input']>;
  /** Дата и время начала события */
  startTime: Scalars['DateTime']['input'];
};

export type CalendarEventMutations = {
  __typename?: 'CalendarEventMutations';
  /** Создание события в календаре для администрации школы */
  createCalendarEventForSchoolAdministration: OnlineCalendarEvent;
  /** Создание события в календаре и участников события */
  createCalendarEventWithParticipants: OnlineCalendarEvent;
  /** Создать задачу в календаре */
  createCalendarTask: CalendarTask;
  /** Удалить задачу из календаря */
  deleteCalendarTask: Scalars['Boolean']['output'];
  /** Удаление события в календаре, удаление участников события */
  deleteEvent: Scalars['Boolean']['output'];
  /** Удаление события в календаре для администрации школы */
  deleteEventForSchoolAdministration: Scalars['Boolean']['output'];
  /** Отклонить событие в календаре участником */
  rejectEvent: Scalars['Boolean']['output'];
  /** Обновление события в календаре, добавление/удаление участников события */
  updateCalendarEvent: OnlineCalendarEvent;
  /** Обновление события в календаре для администрации школы */
  updateCalendarEventForSchoolAdministration: OnlineCalendarEvent;
  /** Обновить задачу в календаре */
  updateCalendarTask: CalendarTask;
};


export type CalendarEventMutationsCreateCalendarEventForSchoolAdministrationArgs = {
  event: CalendarEventInput;
};


export type CalendarEventMutationsCreateCalendarEventWithParticipantsArgs = {
  event: CalendarEventInput;
  participants: Array<CalendarEventParticipantInput>;
};


export type CalendarEventMutationsCreateCalendarTaskArgs = {
  calendarTask: CalendarTaskInput;
};


export type CalendarEventMutationsDeleteCalendarTaskArgs = {
  calendarTaskId: Scalars['UUID']['input'];
};


export type CalendarEventMutationsDeleteEventArgs = {
  eventId: Scalars['UUID']['input'];
};


export type CalendarEventMutationsDeleteEventForSchoolAdministrationArgs = {
  eventId: Scalars['UUID']['input'];
};


export type CalendarEventMutationsRejectEventArgs = {
  eventId: Scalars['UUID']['input'];
  participantGroupIds: Array<Scalars['UUID']['input']>;
};


export type CalendarEventMutationsUpdateCalendarEventArgs = {
  event: CalendarEventInput;
  participantsToAdd?: InputMaybe<Array<CalendarEventParticipantInput>>;
  participantsToDeleteByGroupId?: InputMaybe<Array<Scalars['UUID']['input']>>;
};


export type CalendarEventMutationsUpdateCalendarEventForSchoolAdministrationArgs = {
  event: CalendarEventInput;
};


export type CalendarEventMutationsUpdateCalendarTaskArgs = {
  calendarTask: CalendarTaskInput;
};

/** Участник календарного события */
export type CalendarEventParticipant = {
  __typename?: 'CalendarEventParticipant';
  /** Идентификатор календарного события */
  eventId: Scalars['UUID']['output'];
  /** Идентификатор участника события */
  id: Scalars['UUID']['output'];
  /** Статус участника события - организатор/участник */
  participantStatus: ParticipantStatus;
  /** Время регистрации на событие */
  registerTs: Scalars['DateTime']['output'];
  /** Время отклонения события */
  rejectTs?: Maybe<Scalars['DateTime']['output']>;
  /** Краткая информация по пользовательской группе участника */
  userGroup: Group;
};

/** Информация для создания участника события в календаре */
export type CalendarEventParticipantInput = {
  /** Статус участника события - организатор/участник */
  participantStatus: ParticipantStatus;
  /** Идентификатор пользовательной группы (сервис групп) участника события */
  userGroupId: Scalars['UUID']['input'];
};

export type CalendarEventQueries = {
  __typename?: 'CalendarEventQueries';
  /** Получить все события пользователя */
  getAllUserEvents: Array<OnlineCalendarEvent>;
  /** Получить все события пользователя для администрации школы */
  getAllUserEventsForSchoolAdministration: Array<OnlineCalendarEvent>;
  getCalendarEventCategories: Array<CalendarEventCategory>;
  getCalendarEventCategoriesByFrole: Array<CalendarEventCategory>;
  /** Получить список задач в календаре */
  getCalendarTasks: Array<CalendarTask>;
  /** Получить информацию по событию */
  getEventWithParticipants: OnlineCalendarEvent;
  /** Получить идентификатор пользовательской группы участника события */
  getParticipantGroupIds: Array<Scalars['UUID']['output']>;
};


export type CalendarEventQueriesGetAllUserEventsArgs = {
  calendarEventCategoryIds?: InputMaybe<Array<Scalars['Int']['input']>>;
  childUserId?: InputMaybe<Scalars['ID']['input']>;
  eventsRangeEndDateTime: Scalars['DateTime']['input'];
  eventsRangeStartDateTime: Scalars['DateTime']['input'];
  userGroupId: Scalars['UUID']['input'];
};


export type CalendarEventQueriesGetAllUserEventsForSchoolAdministrationArgs = {
  eventsRangeEndDateTime: Scalars['DateTime']['input'];
  eventsRangeStartDateTime: Scalars['DateTime']['input'];
};


export type CalendarEventQueriesGetCalendarEventCategoriesArgs = {
  childUserId?: InputMaybe<Scalars['ID']['input']>;
};


export type CalendarEventQueriesGetCalendarEventCategoriesByFroleArgs = {
  userFroleName: Scalars['String']['input'];
};


export type CalendarEventQueriesGetCalendarTasksArgs = {
  childUserId?: InputMaybe<Scalars['UUID']['input']>;
};


export type CalendarEventQueriesGetEventWithParticipantsArgs = {
  eventId: Scalars['UUID']['input'];
};


export type CalendarEventQueriesGetParticipantGroupIdsArgs = {
  userGroupTypeId: Scalars['Int']['input'];
  userIds: Array<Scalars['UUID']['input']>;
};

export type CalendarEventS21Queries = {
  __typename?: 'CalendarEventS21Queries';
  /** S21. Запрос событий для агенды студента */
  getMyAgendaEvents: Array<AgendaEvent>;
  /** S21. Запрос событий студента для выбранного диапазона */
  getMyCalendarEvents: Array<CalendarEvent>;
  /** S21. Запрос предстоящих событий студента, доступных для регистрации */
  getUpcomingEventsForRegistration: Array<Maybe<CalendarEvent>>;
};


export type CalendarEventS21QueriesGetMyAgendaEventsArgs = {
  from: Scalars['DateTime']['input'];
  limit: Scalars['Int']['input'];
  to: Scalars['DateTime']['input'];
};


export type CalendarEventS21QueriesGetMyCalendarEventsArgs = {
  from: Scalars['DateTime']['input'];
  page?: InputMaybe<PagingInput>;
  to: Scalars['DateTime']['input'];
};


export type CalendarEventS21QueriesGetUpcomingEventsForRegistrationArgs = {
  eventCodes: Array<Scalars['String']['input']>;
  page?: InputMaybe<PagingInput>;
  registrationAccessStatusFilter?: InputMaybe<RegistartionStatusEnum>;
};

/** Информация о школе, к которой привязано событие */
export type CalendarEventSchool = {
  __typename?: 'CalendarEventSchool';
  /** Идентификатор события */
  eventId: Scalars['ID']['output'];
  /** Полное наименование школы */
  fullName: Scalars['String']['output'];
  /** Идентификатор школы */
  schoolId: Scalars['ID']['output'];
  /** Короткое наименование школы */
  shortName: Scalars['String']['output'];
};

/** Тип календарного события (Мои события, урок, вебинар...) */
export type CalendarEventType = {
  __typename?: 'CalendarEventType';
  /** Описание типа календарного события (например - Мои события) */
  description: Scalars['String']['output'];
  /** Идентификатор типа календарного события */
  id: Scalars['Int']['output'];
  /** Доп. информация */
  metaData?: Maybe<Scalars['String']['output']>;
  /** Можно ли отклонять тип события */
  rejectable: Scalars['Boolean']['output'];
};

/** Роль пользователя в календаре */
export enum CalendarEventUserRole {
  /** Сотрудник */
  Staff = 'STAFF',
  /** Студент */
  Student = 'STUDENT'
}

/** Обезличенные таймслоты для календаря s21 */
export type CalendarNamelessTimeSlot = {
  __typename?: 'CalendarNamelessTimeSlot';
  /** Дата и время завершения слота */
  end: Scalars['DateTime']['output'];
  /** Признак того что слот создан сотрудником */
  staffSlot?: Maybe<Scalars['Boolean']['output']>;
  /** Дата и время начала слота */
  start: Scalars['DateTime']['output'];
  /** Возможные даты начала */
  validStartTimes: Array<Scalars['DateTime']['output']>;
};

/** Ответ на запрос обезличенных таймслотов для календаря s21 */
export type CalendarNamelessTimeSlotResponse = {
  __typename?: 'CalendarNamelessTimeSlotResponse';
  /** Запланированные проверки */
  bookings: Array<CalendarBooking>;
  /** Длительность проверки */
  checkDuration: Scalars['Int']['output'];
  /** Информация о проверках проекта */
  projectReviewsInfo: ProjectReviewsInfo;
  /**
   * Количество запланированных проверок
   * @deprecated Use projectReviewsInfo
   */
  relevantReviewUsersCount: Scalars['Int']['output'];
  /**
   * Количество проверок для сдачи проекта
   * @deprecated Use projectReviewsInfo
   */
  reviewUsersCount: Scalars['Int']['output'];
  /** Обезличенные таймслоты */
  timeSlots: Array<CalendarNamelessTimeSlot>;
};

export type CalendarSubject = {
  __typename?: 'CalendarSubject';
  events: Array<Event>;
  goals: Array<PersonalGoal>;
  id: Scalars['ID']['output'];
  personalControlWorks: Array<PersonalControlWork>;
  title: Scalars['String']['output'];
};

/** Задача в календаре */
export type CalendarTask = {
  __typename?: 'CalendarTask';
  /** Идентификатор задачи */
  calendarTaskId: Scalars['UUID']['output'];
  /** Время создания */
  createTs: Scalars['DateTime']['output'];
  /** Срок завершения задачи */
  date: Scalars['Date']['output'];
  /** Выполнено/не выполнено */
  isDone: Scalars['Boolean']['output'];
  /** Наименование задачи */
  name: Scalars['String']['output'];
  /** Идентификатор школы */
  schoolId: Scalars['UUID']['output'];
  /** Время обновления */
  updateTs?: Maybe<Scalars['DateTime']['output']>;
  /** Идентификатор пользователя */
  userId: Scalars['UUID']['output'];
  /** Роль пользователя */
  userRole: Scalars['String']['output'];
};

export type CalendarTaskInput = {
  /** Идентификатор задачи */
  calendarTaskId?: InputMaybe<Scalars['UUID']['input']>;
  /** Время создания */
  createTs?: InputMaybe<Scalars['DateTime']['input']>;
  /** Срок завершения задачи */
  date: Scalars['Date']['input'];
  /** Выполнено/не выполнено */
  isDone: Scalars['Boolean']['input'];
  /** Наименование задачи */
  name: Scalars['String']['input'];
  /** Идентификатор школы */
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  /** Время обновления */
  updateTs?: InputMaybe<Scalars['DateTime']['input']>;
  /** Идентификатор пользователя */
  userId?: InputMaybe<Scalars['UUID']['input']>;
  /** Роль пользователя */
  userRole?: InputMaybe<Scalars['String']['input']>;
};

/**
 *  Календарно-тематическое планирование
 * Календарно-тематический план
 */
export type CalendarThematicPlan = {
  __typename?: 'CalendarThematicPlan';
  /** Идентификатор плана */
  calendarThematicPlanId: Scalars['ID']['output'];
  /** Дата создания плана */
  createdTs: Scalars['DateTime']['output'];
  /** Автор плана */
  createdUser: PlanningUserInfo;
  /** Идентификатор текущего урока для КТП */
  currentLessonId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор текущей темы для КТП */
  currentTopicId?: Maybe<Scalars['ID']['output']>;
  /** Возможно ли редактирование КТП пользователем запрашивающим модель. */
  isEditableByUser?: Maybe<Scalars['Boolean']['output']>;
  /** Наименование плана */
  name: Scalars['String']['output'];
  /** Идентификатор общеобразовательного учреждения */
  orgUnitId: Scalars['UUID']['output'];
  /** Количество часов на план */
  plannedHours?: Maybe<Scalars['Int']['output']>;
  /** Идентификатор группы по предмету */
  stageSubjectGroupId: Scalars['ID']['output'];
  /** Темы в тематическом плане */
  topics?: Maybe<Array<Maybe<CalendarThematicPlanTopic>>>;
  /** Дата обновления плана */
  updatedTs?: Maybe<Scalars['DateTime']['output']>;
  /** Редактор плана */
  updatedUser?: Maybe<PlanningUserInfo>;
};

/** Фильтр для выборки тематических планов */
export type CalendarThematicPlanFilter = {
  /** список учебных лет */
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  /** список параллелей */
  stageIds: Array<Scalars['ID']['input']>;
  /** список ГКпП */
  stageSubjectGroupIds: Array<Scalars['ID']['input']>;
  /** список предметов */
  subjectIds: Array<Scalars['ID']['input']>;
};

export type CalendarThematicPlanInput = {
  /** Идентификатор плана */
  calendarThematicPlanId: Scalars['ID']['input'];
  /** Наименование плана */
  name: Scalars['String']['input'];
  /** Идентификатор общеобразовательного учреждения */
  orgUnitId: Scalars['UUID']['input'];
  /** Количество часов на план */
  plannedHours?: InputMaybe<Scalars['Int']['input']>;
  /** Идентификатор группы по предмету */
  stageSubjectGroupId: Scalars['ID']['input'];
  /** Темы в тематическом плане */
  topics?: InputMaybe<Array<InputMaybe<CalendarThematicPlanTopicInput>>>;
};

export type CalendarThematicPlanLessonStatus = {
  __typename?: 'CalendarThematicPlanLessonStatus';
  /** Id календарно-тематического плана к которому принадлежит урок */
  calendarThematicPlanId?: Maybe<Scalars['ID']['output']>;
  /** Существует ли КТП для ГКпГ */
  isCalendarThematicPlanExists: Scalars['Boolean']['output'];
  /** Существует ли урок с требуемым временем начала в КТП */
  isCalendarThematicPlanLessonExists: Scalars['Boolean']['output'];
  /** Наименование урока */
  lessonName?: Maybe<Scalars['String']['output']>;
};

/** Тема календарно-тематического плана */
export type CalendarThematicPlanTopic = {
  __typename?: 'CalendarThematicPlanTopic';
  /** Идентификатор темы */
  calendarThematicPlanTopicId: Scalars['ID']['output'];
  /** Дата и время окончания темы из расписания */
  endTimetableDate?: Maybe<Scalars['Date']['output']>;
  /** Дата и время окончания темы */
  endTopicDate?: Maybe<Scalars['Date']['output']>;
  /** Уроки по теме */
  lessons: Array<CalendarThematicPlanTopicLesson>;
  /** Дата и время начала темы из расписания */
  startTimetableDate?: Maybe<Scalars['Date']['output']>;
  /** Дата и время начала темы */
  startTopicDate?: Maybe<Scalars['Date']['output']>;
  /** Количество часов на тему */
  topicHours: Scalars['Int']['output'];
  /** Наименование темы */
  topicName: Scalars['String']['output'];
  /** Номер темы */
  topicNumber: Scalars['Int']['output'];
};

/** Тема календарно-тематического плана */
export type CalendarThematicPlanTopicInput = {
  /** Идентификатор темы */
  calendarThematicPlanTopicId: Scalars['ID']['input'];
  /** Уроки по теме */
  lessons?: InputMaybe<Array<InputMaybe<CalendarThematicPlanTopicLessonInput>>>;
  /** Количество часов на тему */
  topicHours: Scalars['Int']['input'];
  /** Наименование темы */
  topicName: Scalars['String']['input'];
  /** Номер темы */
  topicNumber: Scalars['Int']['input'];
};

/** Уроки темы календарно-тематического плана */
export type CalendarThematicPlanTopicLesson = {
  __typename?: 'CalendarThematicPlanTopicLesson';
  /** Идентификатор урока в теме */
  calendarThematicPlanTopicLessonId: Scalars['ID']['output'];
  /** Признак наличия контрольной работы */
  controlWork: Scalars['Boolean']['output'];
  /** Плановая дата проведения урока */
  lessonDateTime?: Maybe<Scalars['DateTime']['output']>;
  /** Наименование урока */
  lessonName: Scalars['String']['output'];
  /** Номер урока */
  lessonNumber: Scalars['Int']['output'];
  /** Плановая дата проведения урока из расписания */
  timetableDateTime?: Maybe<Scalars['DateTime']['output']>;
};

/** Уроки темы календарно-тематического плана */
export type CalendarThematicPlanTopicLessonInput = {
  /** Идентификатор урока в теме */
  calendarThematicPlanTopicLessonId: Scalars['ID']['input'];
  /** Признак наличия контрольной работы */
  controlWork: Scalars['Boolean']['input'];
  /** Наименование урока */
  lessonName: Scalars['String']['input'];
  /** Номер урока */
  lessonNumber: Scalars['Int']['input'];
};

/** Таймслоты для календаря s21 */
export type CalendarTimeSlot = {
  __typename?: 'CalendarTimeSlot';
  /** бронь на данный слот */
  booking?: Maybe<CalendarBooking>;
  /** Дата и время завершения слота */
  end: Scalars['DateTime']['output'];
  /** Событие в календаре, к которому привязан слот */
  event: CalendarEvent;
  /** Идентификатор события */
  eventId: Scalars['ID']['output'];
  /** Модуль для проверки в данный таймслот */
  goalCheck?: Maybe<GoalCheck>;
  /** Идентификатор таймслота */
  id: Scalars['ID']['output'];
  /**
   * Флаг видимости для мультикампустности для БА
   * {null}, если таймслот принадлежит студенту
   */
  isMultiVisible?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Школа, в которой создан слот
   * null, если не наступило время деанонимизации
   */
  school?: Maybe<School>;
  /** Дата и время начала слота */
  start: Scalars['DateTime']['output'];
  /** Тип слота */
  type: TimeSlotTypeEnum;
};

export type CatalogErrorDescription = {
  __typename?: 'CatalogErrorDescription';
  error: Scalars['String']['output'];
  itemId: Scalars['UUID']['output'];
};

export type CatalogFixResult = {
  __typename?: 'CatalogFixResult';
  errors: Array<CatalogErrorDescription>;
  processed: Array<Scalars['UUID']['output']>;
  /** @deprecated Field no longer supported */
  skipped: Array<Scalars['UUID']['output']>;
  totalErrors: Scalars['Int']['output'];
  totalProcessed: Scalars['Int']['output'];
  totalSkipped: Scalars['Int']['output'];
};

/** Информация о запрошенной странице материалов медиатеки */
export type CategoryItemPage = {
  __typename?: 'CategoryItemPage';
  /** Сами материалы */
  categoryItems: Array<ContentItem>;
  /** Запрошенная страница */
  pageNumber: Scalars['Int']['output'];
  /** Размер запрошенной страницы */
  pageSize: Scalars['Int']['output'];
  /** Общее количество материалов в категории, соответствующих фильтру */
  totalCategoryItems: Scalars['Int']['output'];
};

/** Свидетельство о прохождение траектории */
export type CertificateInputModel = {
  /** Необходимый уровень прохождения для получения сертификата */
  achieveLevel: Scalars['Int']['input'];
  /** Титул свидетельства */
  courseTitle: Scalars['String']['input'];
  /** Шаблон сертификата */
  templateType: Scalars['String']['input'];
  /** Название траектории для выдачи свидетельства (может не совпадать с trajectoryTemplateName) */
  trajectoryTitle: Scalars['String']['input'];
};

/** Свидетельство к выдаче о прохождение траектории */
export type CertificateOfParticipation = {
  __typename?: 'CertificateOfParticipation';
  /** Необходимый уровень прохождения для получения сертификата */
  achieveLevel: Scalars['Int']['output'];
  /** ID сертификата */
  certificateId: Scalars['ID']['output'];
  /** Титул свидетельства */
  courseTitle: Scalars['String']['output'];
  /** Плановая трудоемкость в часах */
  planLaboriousness?: Maybe<Scalars['Int']['output']>;
  /** Шаблон сертификата */
  templateType: Scalars['String']['output'];
  /** ID траектории */
  trajectoryTemplateId: Scalars['ID']['output'];
  /** Название траектории */
  trajectoryTemplateSlug: Scalars['String']['output'];
  /** Название траектории для выдачи свидетельства (может не совпадать с trajectoryTemplateName) */
  trajectoryTitle: Scalars['String']['output'];
};

export type CertificateOfParticipationInfoModel = {
  __typename?: 'CertificateOfParticipationInfoModel';
  /** Необходимый уровень прохождения для получения сертификата */
  achieveLevel: Scalars['Int']['output'];
  /** Титул свидетельства */
  courseTitle: Scalars['String']['output'];
  /** Текущий уровень прохождения траектории учеником */
  trajectoryProgress: Scalars['Int']['output'];
  /** Название траектории для выдачи свидетельства (может не совпадать с trajectoryTemplateName) */
  trajectoryTitle: Scalars['String']['output'];
};

export type ChallengeSubjectCategory = {
  __typename?: 'ChallengeSubjectCategory';
  /** название предмета */
  name: Scalars['String']['output'];
  /** Короткое название предмета */
  shortName: Scalars['String']['output'];
  /** идентификатор категории предмета */
  subjectCategoryId: Scalars['ID']['output'];
};

export type ChallengeSubjectV2 = {
  __typename?: 'ChallengeSubjectV2';
  /** название предмета */
  name: Scalars['String']['output'];
  /** идентификатор предмета */
  subjectId: Scalars['ID']['output'];
};

/** Изменение баллов участников коалиции в рамках турнира */
export type ChangeCoalitionMemberPointsInput = {
  /** ID участника коалиции */
  coalitionMemberId: Scalars['ID']['input'];
  /** Сколько баллов добавить/убрать */
  delta: Scalars['Int']['input'];
  /** Причина добавления/вычитания баллов */
  reasonDescription: Scalars['String']['input'];
};

/** Результаты начисления очков коалиции по логинам или по фильтру */
export type ChangeCoalitionMemberPointsResponse = {
  __typename?: 'ChangeCoalitionMemberPointsResponse';
  notFound: Array<Maybe<Scalars['String']['output']>>;
  notInActiveTournament: Array<Maybe<Scalars['String']['output']>>;
  notInCoalition: Array<Maybe<Scalars['String']['output']>>;
  success: Array<Maybe<Scalars['String']['output']>>;
};

/** Изменение баллов коалиции в рамках турнира */
export type ChangeCoalitionPointsInput = {
  /** ID связки коалиции и турнира */
  coalitionTournamentId: Scalars['ID']['input'];
  /** Сколько баллов добавить/убрать */
  delta: Scalars['Int']['input'];
  /** Причина добавления/вычитания баллов */
  reasonDescription: Scalars['String']['input'];
};

export type ChangeContentProductionStatusResponse = {
  __typename?: 'ChangeContentProductionStatusResponse';
  log?: Maybe<ContentProductionStatusChangeLog>;
};

export type ChangeLessonLearningActivityResult = {
  __typename?: 'ChangeLessonLearningActivityResult';
  changedFinalMarks: Array<JournalFinalStudentMark>;
  isSuccess: Scalars['Boolean']['output'];
};

export enum ChangeRequestStatusType {
  Accepted = 'ACCEPTED',
  Cancelled = 'CANCELLED',
  CheckInProgress = 'CHECK_IN_PROGRESS',
  Rejected = 'REJECTED'
}

export enum ChangeRequestType {
  Create = 'CREATE',
  Update = 'UPDATE'
}

export type ChangeScopeAndStatusForContentEntitiesRequest = {
  /** Тип сущности, по которой мы изменяем скоуп или статус производства контента */
  contentEntityType: ContentEntityType;
  /** Идентификаторы сущностей */
  entityIds: Array<Scalars['ID']['input']>;
  /** Статус для перевода, в случае если */
  productionStatus?: InputMaybe<ContentEntityProductionStatus>;
  /** Область видимости дла перевода, в случае если передан null, то переводить не нужно */
  scope?: InputMaybe<ScopeEnum>;
};

export type ChangeStudentModuleGoalLevelForAchieveRequest = {
  /** новая трудоемкость */
  goalLevelForAchieve: Scalars['Float']['input'];
  /** флаг - проверять аффектит ли учебный процесс студента выполняемое изменение */
  isNeedToCheckAffecting: Scalars['Boolean']['input'];
  /** идентификатор Учебного Модуля (goals.goal_id) */
  moduleId: Scalars['ID']['input'];
  /** идентификатор студента (tudents.student_id) */
  studentId: Scalars['UUID']['input'];
};

export type ChangeStudentModuleGoalLevelForAchieveResponse = {
  __typename?: 'ChangeStudentModuleGoalLevelForAchieveResponse';
  /** успешно ли выполнение запроса (пройдены ли все проверки) */
  isSuccess: Scalars['Boolean']['output'];
  /** Персонализированный Учебный Модуль */
  module: StudentModule;
};

export type ChangeStudentModuleLaboriousnessAndDatesRequest = {
  /** новая запланированная дата окончания Учебного Модуля */
  endDate: Scalars['Date']['input'];
  /** флаг - проверять аффектит ли учебный процесс студента выполняемое изменение */
  isNeedToCheckAffecting: Scalars['Boolean']['input'];
  /** новая трудоемкость */
  laboriousness: Scalars['Int']['input'];
  /** идентификатор Учебного Модуля (goals.goal_id) */
  moduleId: Scalars['ID']['input'];
  /** новая запланированная дата начала Учебного Модуля */
  startDate: Scalars['Date']['input'];
  /** идентификатор студента (tudents.student_id) */
  studentId: Scalars['UUID']['input'];
};

export type ChangeStudentModuleLaboriousnessAndDatesResponse = {
  __typename?: 'ChangeStudentModuleLaboriousnessAndDatesResponse';
  /** успешно ли выполнение запроса (пройдены ли все проверки) */
  isSuccess: Scalars['Boolean']['output'];
  /** Персонализированный Учебный Модуль */
  module: StudentModule;
};

export type ChangeStudentTaskStatusInput = {
  /** Критерии оценивания */
  criteriaEvaluations: Array<EvaluatedTaskCriterionInput>;
  /** Опциональная оценка задания */
  governmentMarkId?: InputMaybe<Scalars['Int']['input']>;
  /** Ид задания студента которому меняем статус */
  studentTaskId: Scalars['ID']['input'];
  /** Данные по модели для электронного журнала */
  studentTaskLessonInputModel?: InputMaybe<StudentTaskLessonInputModel>;
  /** Статус, в который необходимо перевести задание */
  taskStatus: TaskStatusEnum;
};

export type ChangeStudentTaskStatusesRequest = {
  /** Список запросов по обновлению статуса Заданий Учеников от Учителя */
  changeStudentTaskStatusInputModels: Array<ChangeStudentTaskStatusInput>;
  /**
   * Параметры сортировки по полям StudentTasKWidgetAnswerModel
   * (student_task_widget_answers.modify_time/create_time)
   */
  sortingFields: Array<SortingField>;
};

/** Информация по обновлённым/проверенным Учителем Заданиям в контексте Студента */
export type ChangeStudentTaskStatusesResponse = {
  __typename?: 'ChangeStudentTaskStatusesResponse';
  eJournalStudentMarks: Array<EJournalStudentMark>;
  studentTasksInfos: Array<StudentTaskInfo>;
};

export type ChangeTaskSetSlotRequest = {
  /** флаг - проверять аффектит ли учебный процесс студента выполняемое изменение */
  isNeedToCheckAffecting: Scalars['Boolean']['input'];
  /** новая структура слота */
  newSlot: TaskSetSlotInput;
  /** идентификатор слота набора заданий (base_playlist_slots.base_playlist_slot_id или teacher_playlist_slots.teacher_playlist_slot_id) */
  slotId: Scalars['ID']['input'];
  /** необязательный идентификатор студента для того, чтобы в ответ получить персональную информацию по заданиям, добавленным в слот */
  studentIdForContext?: InputMaybe<Scalars['UUID']['input']>;
  /** идентификатор набора заданий (base_playlists.base_playlist_id или teacher_playlists.teacher_playlist_id) */
  taskSetId: Scalars['ID']['input'];
  /** тип плейлиста */
  taskSetType: PlaylistType;
};

export type ChangeTaskSetSlotResponse = {
  __typename?: 'ChangeTaskSetSlotResponse';
  /** измененный слот */
  changedSlot: TaskSetSlot;
  /** успешно ли выполнение запроса (пройдены ли все проверки) */
  isSuccess: Scalars['Boolean']['output'];
  /** задания в контексте студента для случая, когда плейлист изменяется в контексте студента */
  studentTasks: Array<StudentTask>;
  /** измененный набор заданий */
  taskSet: TaskSet;
};

export type ChangeTaskSetSlotsRequest = {
  /** флаг - проверять аффектит ли учебный процесс студента выполняемое изменение */
  isNeedToCheckAffecting: Scalars['Boolean']['input'];
  /** флаг школы 21 */
  isSchool21?: InputMaybe<Scalars['Boolean']['input']>;
  /** тип плейлиста */
  playlistType: PlaylistType;
  /** Слоты для изменения */
  slots: Array<TaskSetSlotInput>;
  /** идентификатор набора заданий (base_playlists.base_playlist_id или teacher_playlists.teacher_playlist_id) */
  taskSetId: Scalars['ID']['input'];
};

export type ChangeTaskSetSlotsResponse = {
  __typename?: 'ChangeTaskSetSlotsResponse';
  /** успешно ли выполнение запроса (пройдены ли все проверки) */
  isSuccess: Scalars['Boolean']['output'];
  /** измененный набор заданий */
  taskSet: TaskSet;
};

export type Channel = {
  __typename?: 'Channel';
  channelActive: Scalars['Boolean']['output'];
  channelId: Scalars['ID']['output'];
  channelName: Scalars['String']['output'];
};

export type ChannelInput = {
  channelActive: Scalars['Boolean']['input'];
  channelId: Scalars['ID']['input'];
  channelName?: InputMaybe<Scalars['String']['input']>;
};

export type CheckAutoAwardsEventInput = {
  schoolId: Scalars['UUID']['input'];
  studentId: Scalars['UUID']['input'];
  trigger: Scalars['String']['input'];
  userId: Scalars['UUID']['input'];
};

export type CheckSequenceSettings = {
  __typename?: 'CheckSequenceSettings';
  checks: Array<CheckWeight>;
  countingFormula: CountingFormulaType;
  taskId: Scalars['ID']['output'];
};

export type CheckSequenceSettingsInput = {
  checks: Array<CheckWeightInput>;
  countingFormula: CountingFormulaType;
  taskId: Scalars['ID']['input'];
};

export type CheckWeight = {
  __typename?: 'CheckWeight';
  checkType: TaskCheckEnum;
  order?: Maybe<Scalars['Int']['output']>;
  percentage?: Maybe<Scalars['Int']['output']>;
};

export type CheckWeightInput = {
  checkType: TaskCheckEnum;
  order?: InputMaybe<Scalars['Int']['input']>;
  percentage?: InputMaybe<Scalars['Int']['input']>;
};

/** Чек-листы для проверки задания */
export type Checklist = {
  __typename?: 'Checklist';
  /** Список доступных языков чеклиста */
  availableLanguages?: Maybe<Array<LanguageCodeType>>;
  /** Описание чек-листа */
  comment?: Maybe<Scalars['String']['output']>;
  /** Дата создания */
  createTime: Scalars['DateTime']['output'];
  /** Инструкция чек-листа */
  guidelines: Scalars['String']['output'];
  /** Идентификатор */
  id: Scalars['ID']['output'];
  /** Вступление чек-листа */
  introduction?: Maybe<Scalars['String']['output']>;
  /** Язык */
  language: Scalars['String']['output'];
  /** Язык */
  languageCode: LanguageCodeType;
  /** Название чеклиста */
  name?: Maybe<Scalars['String']['output']>;
  /** Набор допустимых быстрых действий */
  quickActions: Array<QuickAction>;
  /** Секции чек-листа */
  sectionList: Array<ChecklistSection>;
  /** Идентификатор задания */
  taskId: Scalars['ID']['output'];
};

/** Заполненный чек-лист */
export type ChecklistFilledInput = {
  /** Комментарий */
  comment: Scalars['String']['input'];
  /** Идентификатор заполненного чек-листа */
  filledChecklistId: Scalars['ID']['input'];
  /** Флаг быстрого действия */
  quickAction?: InputMaybe<QuickAction>;
  /** Оценки вопросов чек-листа */
  scoreQuestions?: InputMaybe<Array<ScoreQuestionInput>>;
};

/** Секция чек-листа */
export type ChecklistSection = {
  __typename?: 'ChecklistSection';
  /** Идентификатор чек-листа */
  checklistId: Scalars['ID']['output'];
  /** Идентификатор секции */
  checklistSectionId: Scalars['ID']['output'];
  /** Описание секции */
  description?: Maybe<Scalars['String']['output']>;
  /** Вид категории */
  kindQuestionId: Scalars['ID']['output'];
  /** Название секции */
  name: Scalars['String']['output'];
  /** Вопросы секции */
  questionList?: Maybe<Array<Maybe<SectionQuestion>>>;
};

export type ChildUserInfo = {
  __typename?: 'ChildUserInfo';
  avatarUrl: Scalars['String']['output'];
  firstName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  lastName: Scalars['String']['output'];
  middleName?: Maybe<Scalars['String']['output']>;
  studentRoles: Array<StudentRole>;
};

export type CityModel = {
  __typename?: 'CityModel';
  /** ID города */
  cityId: Scalars['ID']['output'];
  /** Название города */
  cityName: Scalars['String']['output'];
};

/** Информация о классе взята из stage_subject_groups */
export type ClassInStage = {
  __typename?: 'ClassInStage';
  /** имя класса */
  name: Scalars['String']['output'];
  /** id группы класса по предмету (stage_subject_groups_id) */
  stageSubjectGroupId: Scalars['ID']['output'];
};

/** План на Класс по Предмету (план привязанный к stageSubjectGroup) */
export type ClassPlan = {
  __typename?: 'ClassPlan';
  /** Дата создания плана */
  createTime: Scalars['DateTime']['output'];
  /** Последний день последнего модуля */
  endDate?: Maybe<Scalars['Date']['output']>;
  /** список Учебных Модулей в Плане с привязкой к датам и необходимому для достижения уровню */
  frames: Array<ClassPlanFrame>;
  /** Идентификатор (stage_subject_group_plans.stage_subject_group_plan_id) */
  id: Scalars['ID']['output'];
  /** Флаг, означающий что План на Класс по Предмету отличается от соответствующего Плана на Параллель */
  isChanged: Scalars['Boolean']['output'];
  /** Флаг, означающий что СЗ в Плане на Класс по Предмету отличаются от дефолтных (для  V4) */
  isPlaylistsChanged: Scalars['Boolean']['output'];
  /** Общая трудоемкость */
  laboriousness?: Maybe<Scalars['Int']['output']>;
  /** Дата изменения плана */
  modifyTime: Scalars['DateTime']['output'];
  /** Количество модулей */
  modulesCount?: Maybe<Scalars['Int']['output']>;
  /** статус Плана */
  status: PlanStatusEnum;
};

export type ClassPlanChangeResponse = {
  __typename?: 'ClassPlanChangeResponse';
  isSuccess: Scalars['Boolean']['output'];
  plan?: Maybe<ClassPlan>;
};

/** Учебный модуль внутри Плана на Класс по Предмету */
export type ClassPlanFrame = {
  __typename?: 'ClassPlanFrame';
  /** Уровень, на котором Учебный Модуль объявляется достигнутым учеником */
  achieveLevel: Scalars['Float']['output'];
  /**
   * Идентификатор Базового Плейлиста,
   * назначенного по Учебному Модулю в рамках классового Плана (base_playlists.base_playlist_id)
   */
  basePlaylistId?: Maybe<Scalars['ID']['output']>;
  /** Условия прохождения учебного модуля в плане */
  conditions: Array<PlanFrameCondition>;
  /** Запланированная дата достижения Учебного Модуля */
  endDate: Scalars['DateTime']['output'];
  /** Идентификатор (stage_subject_group_plan_goals.stage_subject_group_plan_goal_id) */
  id: Scalars['ID']['output'];
  /** Является ли дедлайл жестким. После истечения жесткого дедлайна нельзять отправлять задания модуля на проверку */
  isHardEndDate: Scalars['Boolean']['output'];
  /** Примерная трудоемкость Учебного Модуля в часах в рамках текущего Плана */
  laboriousness: Scalars['Int']['output'];
  /** Флаг обязательности Учебного Модуля в рамках конкретного Плана на Группу по Предмету */
  mandatory: Scalars['Boolean']['output'];
  /** Учебный Модуль(GoalDTO) */
  module: StudyModule;
  /** Идентификатор Учебного Модуля (goals.goal_id) */
  moduleId: Scalars['ID']['output'];
  /** Плейлист назначенный по Учебному Модулю в рамках классового Плана (teacher_playlists.teacher_playlist_id или base_playlists.base_playlist_id) */
  playlist: TaskSet;
  /** Запланированная дата начала изучения Учебного модуля */
  startDate: Scalars['DateTime']['output'];
  /**
   * Идентификатор Учительского Плейлиста,
   * назначенного по Учебному Модулю в рамках классового Плана (teacher_playlists.teacher_playlist_id)
   */
  teacherPlaylistId?: Maybe<Scalars['ID']['output']>;
};

export type ClassPlanFrameInput = {
  /** Уровень, на котором Учебный Модуль объявляется достигнутым учеником */
  achieveLevel: Scalars['Float']['input'];
  /** Идентификатор Базового Плейлиста (base_playlists.base_playist_id) */
  basePlaylistId?: InputMaybe<Scalars['ID']['input']>;
  /** Условия прохождения Учебного Модуля */
  conditions: Array<PlanFrameConditionInput>;
  /** Запланированная дата достижения Учебного Модуля */
  endDate: Scalars['String']['input'];
  /** Является ли дедлайл жестким. После истечения жесткого дедлайна нельзять отправлять задания модуля на проверку */
  isHardEndDate: Scalars['Boolean']['input'];
  /** Примерная трудоемкость Учебного Модуля в часах в рамках текущего Плана */
  laboriousness: Scalars['Int']['input'];
  /** Флаг обязательности Учебного Модуля в рамках конкретного Плана на Группу по Предмету */
  mandatory: Scalars['Boolean']['input'];
  /** Учебный Модуль */
  moduleId: Scalars['ID']['input'];
  /** Запланированная дата начала изучения Учебного модуля */
  startDate: Scalars['String']['input'];
  /** Идентификатор Учительского Плейлиста (teacher_playlists.teacher_playlist_id) */
  teacherPlaylistId?: InputMaybe<Scalars['ID']['input']>;
};

/** Модули версии плана на класс */
export type ClassPlanFrameVersion = {
  __typename?: 'ClassPlanFrameVersion';
  /** Уровень, на котором Учебный Модуль объявляется достигнутым учеником */
  achieveLevel: Scalars['Float']['output'];
  /**
   * Идентификатор Базового Плейлиста,
   * назначенного по Учебному Модулю в рамках классового Плана (base_playlists.base_playlist_id)
   */
  basePlaylistId?: Maybe<Scalars['ID']['output']>;
  /** Запланированная дата достижения Учебного Модуля */
  endDate: Scalars['DateTime']['output'];
  /** Идентификатор */
  id: Scalars['ID']['output'];
  /** Является ли дедлайл жестким. После истечения жесткого дедлайна нельзять отправлять задания модуля на проверку */
  isHardEndDate: Scalars['Boolean']['output'];
  /** Примерная трудоемкость Учебного Модуля в часах в рамках текущего Плана */
  laboriousness: Scalars['Int']['output'];
  /** Флаг обязательности Учебного Модуля в рамках конкретного Плана на Группу по Предмету */
  mandatory: Scalars['Boolean']['output'];
  /** Идентификатор Учебного Модуля (goals.goal_id) */
  moduleId: Scalars['ID']['output'];
  /** Запланированная дата начала изучения Учебного модуля */
  startDate: Scalars['DateTime']['output'];
  /**
   * Идентификатор Учительского Плейлиста,
   * назначенного по Учебному Модулю в рамках классового Плана (teacher_playlists.teacher_playlist_id)
   */
  teacherPlaylistId?: Maybe<Scalars['ID']['output']>;
};

/** Информация о плане для модуля в медиатеке для Учителя */
export type ClassPlanMediateka = {
  __typename?: 'ClassPlanMediateka';
  /** Название класса по предмету */
  classSubjectName: Scalars['String']['output'];
  /** ID плана */
  planId: Scalars['Int']['output'];
};

/** Версия плана на класс */
export type ClassPlanVersion = {
  __typename?: 'ClassPlanVersion';
  frames: Array<ClassPlanFrameVersion>;
  id: Scalars['ID']['output'];
  versionCreateTime: Scalars['DateTime']['output'];
  versionCreateUser: User;
};

export enum ClassProgressEnum {
  HighClassProgress = 'HIGH_CLASS_PROGRESS',
  LowClassProgress = 'LOW_CLASS_PROGRESS',
  MiddleClassProgress = 'MIDDLE_CLASS_PROGRESS'
}

export type ClassRoom = {
  __typename?: 'ClassRoom';
  /** Количество свободных мест */
  availableCapacity: Scalars['Int']['output'];
  /** Здание, в котором расположен кабинет (кластер) */
  building: Building;
  /** Количество мест */
  capacity: Scalars['Int']['output'];
  /** План кластера (комнаты) */
  classroomPlan?: Maybe<ClassroomPlan>;
  /** Специализации кабинета c дополнительными признаками */
  classroomSpecializations: Array<ClassroomSpecialization>;
  floor: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  isActive: Scalars['Boolean']['output'];
  /** В кабинете можно проводить только предмет по специализации. */
  isHighlySpecialized: Scalars['Boolean']['output'];
  /** Номер комнаты (название) */
  number: Scalars['String']['output'];
  /** @deprecated Use classroomSpecializations field */
  specialization: Scalars['String']['output'];
  /**
   * Специализации кабинета
   * @deprecated Use classroomSpecializations field
   */
  specializations: Array<Scalars['String']['output']>;
  teacher?: Maybe<Teacher>;
};

/** deprecated */
export type ClassRoomInput = {
  capacity: Scalars['Int']['input'];
  floor: Scalars['Int']['input'];
  id?: InputMaybe<Scalars['ID']['input']>;
  isActive: Scalars['Boolean']['input'];
  number: Scalars['String']['input'];
  specialization: Scalars['String']['input'];
};

export type ClassRoomInputModel = {
  capacity: Scalars['Int']['input'];
  /** Специализация кабинета с дополнительными признаками */
  classroomSpecializations?: InputMaybe<Array<ClassroomSpecializationInputModel>>;
  floor: Scalars['Int']['input'];
  id?: InputMaybe<Scalars['ID']['input']>;
  isActive: Scalars['Boolean']['input'];
  /**
   * @deprecated(reason: "use classroomSpecializations") закомментировано, потому что нельзя сделать поле необязательным, а обязательное поле нельзя депрекейтить
   * В кабинете можно проводить только предмет по специализации.
   */
  isHighlySpecialized?: InputMaybe<Scalars['Boolean']['input']>;
  number: Scalars['String']['input'];
  specialization: Array<Scalars['String']['input']>;
  teacherId?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * Группа класса по предмету - ГКпП
 * Например, (5А, Биология)
 */
export type ClassSubject = {
  __typename?: 'ClassSubject';
  /** Академический год в рамках которого существует группа по предмету */
  academicYear: AcademicYear;
  /** Идентификатор класса, в котором расположена ГКпП (stageGroupId) */
  classId: Scalars['ID']['output'];
  /** Имя класса(stageGroupName: 5A) */
  className: Scalars['String']['output'];
  /** План на Класс по Предмету, назначенный учителем/завучем на конкретную Класс по Предмету (stageSubjectGroup) */
  classPlan?: Maybe<ClassPlan>;
  /** Прогресс класса(5А) по предмету(Биология) */
  classProgress: ClassProgressEnum;
  /** Контрольные Работы назначенные на Группу По Предмету */
  controlWorks: Array<ClassSubjectControlWork>;
  /** Информацию о текущем модуле и статистике работы учеников с ним */
  currentModulePerformance?: Maybe<CurrentModulePerformance>;
  /** Информация о количестве учеников в группах успеваемости в текущем учебном периоде */
  currentPeriodPerformance?: Maybe<CurrentPeriodPerformance>;
  /** Кол-во часов в год, выделенных по предмету на класс в рамках созданной в школе учебной программы */
  hoursInYearForSubject?: Maybe<Scalars['Int']['output']>;
  /** количество часов в неделю */
  hoursPerWeek?: Maybe<Scalars['String']['output']>;
  /** ID класса по предмету(stageSubjectGroupId) */
  id: Scalars['ID']['output'];
  /** последняя просмотренная версия плана */
  lastViewedClassPlanVersion?: Maybe<ClassPlanVersion>;
  /** Тип обучения */
  learningType?: Maybe<LearningTypeEnum>;
  /** Имя класса по предмету(stageSubjectGroupName: 5а, биология) */
  name: Scalars['String']['output'];
  /** Время/Дата следующего урока по предмету */
  nextLessonDateTime?: Maybe<Scalars['DateTime']['output']>;
  /** Ближайшая запланированная Контрольная Работа */
  nextPlannedControlWork?: Maybe<ClassSubjectControlWork>;
  /** Конфигурация оценивания */
  ratingConfiguration: RatingConfiguration;
  /** Необходимость специального оборудования для урока */
  requiresEquipment: Scalars['Boolean']['output'];
  /** Признак того, что группа является единственной по предмету */
  singleSubjectGroup?: Maybe<Scalars['Boolean']['output']>;
  /** Параллель(Пятые классы) */
  stage: Stage;
  /**
   * Класс, в котором расположена ГКпП (classId)
   * Фактически поле является non-nullable. Добавлено как nullable из-за ограничений расширения gql-схемы
   */
  stageGroup?: Maybe<StageGroup>;
  /** План на Параллель, в которую входит Класс По Предмету, назначенный на класс методистом. */
  stagePlan?: Maybe<StagePlan>;
  /** Идентификатор предмета на параллель */
  stageSubjectId: Scalars['ID']['output'];
  /** Дата начала плана на класс */
  startDate?: Maybe<Scalars['DateTime']['output']>;
  /** количество студентов в группе */
  studentNumber: Scalars['Int']['output'];
  /** студенты группы */
  students: Array<Student>;
  /** Все четверти, в которых учиться Класс По Предмету в текущем учебном году */
  studyPeriods: Array<StudyPeriod>;
  /** Подгруппы учеников по предмету */
  subgroups: Array<Subgroup>;
  /** Предмет который преподается в Группе */
  subject: Subject;
  /** Количество групп по предмету в рамках одного предмета */
  subjectStageSubjectGroupsQuantity?: Maybe<Scalars['Int']['output']>;
  /** кол-во задач на проверку класса по предмету */
  tasksNeedCheckCount: Scalars['Int']['output'];
  /** учитель */
  teacher?: Maybe<User>;
  /** Идентификатор учителя */
  teacherId?: Maybe<Scalars['ID']['output']>;
};

export type ClassSubjectBaseInput = {
  /** название группы (Физкультура девочки) */
  name: Scalars['String']['input'];
  /** необходимость специального оборудования для урока, по умолчанию false */
  requiresEquipment: Scalars['Boolean']['input'];
  /** признак того, что группа является единственной по предмету */
  singleSubjectGroup?: InputMaybe<Scalars['Boolean']['input']>;
  /** идентификатор класса, частью которого является группа */
  stageGroupId: Scalars['ID']['input'];
  /** идентификатор предмета группы */
  subjectId: Scalars['ID']['input'];
  /** идентификатор учителя */
  teacherId: Scalars['ID']['input'];
};

/** Контрольная работа на Группу по Предмету */
export type ClassSubjectControlWork = {
  __typename?: 'ClassSubjectControlWork';
  /** идентификатор Группы по Предмету (stage_subject_groups.stage_subject_group_id) */
  classSubjectId?: Maybe<Scalars['ID']['output']>;
  /** Название Группы по Предмету, на который назначена Контрольная */
  classSubjectName?: Maybe<Scalars['String']['output']>;
  /** Дата и время конца Контрольной Работы UTC!!!!! */
  closeTime?: Maybe<Scalars['DateTime']['output']>;
  /** Комментарий к Контрольной */
  comment?: Maybe<Scalars['String']['output']>;
  /** Дата и время создания Контрольной */
  createTime: Scalars['DateTime']['output'];
  /** Продолжительность Контрольной */
  duration: Scalars['Int']['output'];
  /** Идентификатор stage_subject_group_control_works(stage_subject_group_control_work_id) */
  id: Scalars['ID']['output'];
  /** Дата и время последней модификации Контрольной */
  modifyTime?: Maybe<Scalars['DateTime']['output']>;
  /** Учебный Модуль, по которому проводится Контрольная */
  module: StudyModule;
  /** Название Контрольной */
  name: Scalars['String']['output'];
  /** Количество Студентов с назначенными вариантами */
  numberOfStudentsWithVariants: Scalars['Int']['output'];
  permissionStatus?: Maybe<Scalars['Boolean']['output']>;
  /** Дата и Время, в которые Учитель планирует начать Контрольную Работу UTC!!!!! */
  planTime?: Maybe<Scalars['DateTime']['output']>;
  /** Дата и время начала Контрольной Работы UTC!!!!! */
  startTime?: Maybe<Scalars['DateTime']['output']>;
  /** Статус Контрольной */
  status: ControlWorkStatus;
  /** Предмет по Контрольной */
  subject: Subject;
  /** Общее количество студентов в Группе по Предмету */
  totalNumberOfStudents: Scalars['Int']['output'];
  /** Варианты Контрольной */
  variants: Array<ClassSubjectControlWorkVariant>;
  /** Показывается ли содержимое Контрольной Работы ученикам */
  visible: Scalars['Boolean']['output'];
};

export type ClassSubjectControlWorkInfo = {
  __typename?: 'ClassSubjectControlWorkInfo';
  /** Группа по Предмету, в которой проходит Работа */
  classSubject: ClassSubject;
  /** Контрольная Работа на ГРуппу по Предмету */
  controlWork: ClassSubjectControlWork;
  /** Персональные Контрольные Работы, относящиеся к Контрольной Работе на Группу по Предмету */
  personalControlWorks: Array<PersonalControlWork>;
};

/** Вариант Контрольной Работы на Группу по Предмету */
export type ClassSubjectControlWorkVariant = {
  __typename?: 'ClassSubjectControlWorkVariant';
  /** Идентификатор варианта (stage_subject_control_work_variants.stage_subject_group_control_work_variant_id) */
  id: Scalars['ID']['output'];
  /** Номер варианта */
  number: Scalars['Int']['output'];
  /** Задания, входящие в вариант */
  tasks: Array<Task>;
};

export type ClassSubjectIdToPermission = {
  __typename?: 'ClassSubjectIdToPermission';
  ClassSubjectId: Scalars['ID']['output'];
  classSubjectPermission: ClassSubjectPermission;
};

export type ClassSubjectInput = {
  /** идентификатор группы. Если пусто - создастся новая группа */
  classSubjectGroupId?: InputMaybe<Scalars['ID']['input']>;
  /** количество часов в неделю */
  hoursPerWeek?: InputMaybe<Scalars['String']['input']>;
  /** название группы (Физкультура девочки) */
  name: Scalars['String']['input'];
  /** список студентов на удаление */
  removedStudents?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** необходимость специального оборудования для урока, по умолчанию false */
  requiresEquipment?: InputMaybe<Scalars['Boolean']['input']>;
  /** признак того, что группа является единственной по предмету */
  singleSubjectGroup?: InputMaybe<Scalars['Boolean']['input']>;
  /** идентификатор класса, частью которого является группа */
  stageGroupId: Scalars['ID']['input'];
  /** список идентификаторов студентов группы */
  students: Array<Scalars['ID']['input']>;
  /** идентификатор предмета группы */
  subjectId: Scalars['ID']['input'];
  /** идентификатор учителя */
  teacher?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * Тип результата невалидного процесса расчета успеваемости класса, связанный с результатами фильтров
 * или отсутствия данных как самих по себе, так и в результате фильтрации
 */
export enum ClassSubjectPerformanceErrorEnum {
  /** Общий статус для отсутствующего результата */
  NothingFound = 'NOTHING_FOUND',
  /** Студенты не найдены */
  StudentsNotFound = 'STUDENTS_NOT_FOUND',
  /** Задания студентов не найдены */
  StudentTasksNotFound = 'STUDENT_TASKS_NOT_FOUND',
  /** Траектории не найдены */
  TrajectoriesNotFound = 'TRAJECTORIES_NOT_FOUND'
}

/** Уровень доступа относительно группы по предмету */
export enum ClassSubjectPermission {
  /** Нет прав */
  NoPermissions = 'NO_PERMISSIONS',
  /** Просмотр и Изменение */
  ReadAndWrite = 'READ_AND_WRITE',
  /** Только просмотр */
  ReadOnly = 'READ_ONLY'
}

/** Постраничный список студентов по подгруппам */
export type ClassSubjectStudentsBySubgroupsPage = {
  __typename?: 'ClassSubjectStudentsBySubgroupsPage';
  /** Подгруппы учеников по предмету */
  subgroups: Array<Subgroup>;
  /** общее количество без пагинации */
  total: Scalars['Int']['output'];
};

export enum ClassroomDeletionCode {
  CanBeSafelyDeleted = 'CAN_BE_SAFELY_DELETED',
  HasLessonsInTheFuture = 'HAS_LESSONS_IN_THE_FUTURE',
  HasLessonsInThePast = 'HAS_LESSONS_IN_THE_PAST',
  HasLessonsInThePastAndFuture = 'HAS_LESSONS_IN_THE_PAST_AND_FUTURE'
}

/** План кластера (комнаты) */
export type ClassroomPlan = {
  __typename?: 'ClassroomPlan';
  /** Идентификатор плана кластера */
  classroomPlanId: Scalars['ID']['output'];
  /** Метаданные плана кластера */
  planMeta: Scalars['String']['output'];
};

export type ClassroomSpecialization = {
  __typename?: 'ClassroomSpecialization';
  /**
   * Специализацией кабинета, может быть:
   * - название предмета (subjectId заполняется),
   * - свободный ввод пользователя (subjectId не заполняется)
   */
  name: Scalars['String']['output'];
  /**
   * Идентификатор предмета, который может проводиться в кабинете,
   * null если name не является предметом
   */
  subjectId?: Maybe<Scalars['ID']['output']>;
};

export type ClassroomSpecializationInputModel = {
  /**
   * Специализацией кабинета, может быть:
   * - название предмета (subjectId заполняется),
   * - свободный ввод пользователя (subjectId не заполняется)
   */
  name: Scalars['String']['input'];
  /**
   * Идентификатор предмета, который может проводиться в кабинете,
   * null если name не является предметом
   */
  subjectId?: InputMaybe<Scalars['ID']['input']>;
};

/** Типы значений для условия фильтрации */
export enum ClauseValueTypeEnum {
  /** значение можно ввести вручную */
  Number = 'NUMBER',
  /** значение можно выбрать только из выпадающего списка */
  Select = 'SELECT',
  /** можно выбрать несколько значений из выпадающего списка */
  SelectMultiple = 'SELECT_MULTIPLE',
  /** текстовое значение можно ввести вручную */
  Text = 'TEXT'
}

/** Информация по студентам за рабочими станциями в кластере */
export type ClusterPlanStudents = {
  __typename?: 'ClusterPlanStudents';
  /** Количество свободных мест */
  freePlaceCount: Scalars['Int']['output'];
  /** Студенты прошедшие аутентификацию за рабочими станциями */
  occupiedPlaces: Array<CurrentWorkstationUser>;
};

export enum ClusterState {
  Available = 'AVAILABLE',
  Draft = 'DRAFT'
}

export type ClusterSummaryModel = {
  __typename?: 'ClusterSummaryModel';
  /** Идентификатор кластера */
  clusterId: Scalars['Int']['output'];
  /** Состояние кластера */
  clusterState: ClusterState;
  /** Этаж */
  floor: Scalars['Int']['output'];
  /** Дата последнего редактирования */
  lastEditDate?: Maybe<Scalars['DateTime']['output']>;
  /** Последний редактирущий */
  lastEditLogin?: Maybe<Scalars['String']['output']>;
  /** Название кластера */
  name: Scalars['String']['output'];
  /** Короткое название(одна из специализаций) */
  shortName: Scalars['String']['output'];
  /** Общее кол-во посадочных мест */
  totalSeatsCount: Scalars['Int']['output'];
};

/** Подложки(фоны) для коалиций */
export type CoalitionBackground = {
  __typename?: 'CoalitionBackground';
  bigImg: Scalars['String']['output'];
  coalitionBackgroundId: Scalars['Int']['output'];
  smallImg: Scalars['String']['output'];
};

/** Аватары для мастера трайба */
export type CoalitionMasterAvatar = {
  __typename?: 'CoalitionMasterAvatar';
  coalitionMasterAvatarId: Scalars['Int']['output'];
  imgUrl: Scalars['String']['output'];
};

/** Участник коалиции */
export type CoalitionMember = {
  __typename?: 'CoalitionMember';
  active: Scalars['Boolean']['output'];
  coalition: GameCoalition;
  coalitionId: Scalars['ID']['output'];
  currentTournamentPowerRank?: Maybe<CoalitionMemberPowerRank>;
  /** coalitionMemberId */
  id: Scalars['ID']['output'];
  user: User;
  userId: Scalars['UUID']['output'];
};

/** Сводная информация об участнике коалиции */
export type CoalitionMemberInfoModel = {
  __typename?: 'CoalitionMemberInfoModel';
  /** Аватар пользователя */
  avatarUrl: Scalars['String']['output'];
  /** Идентификатор участника коалиции */
  coalitionMemberId: Scalars['Int']['output'];
  /** Уровень опыта пользователя */
  experienceLvl: Scalars['Int']['output'];
  /** Фамилия пользователя */
  firstName: Scalars['String']['output'];
  /** Имя пользователя */
  lastName: Scalars['String']['output'];
  /** Логин пользователя */
  login: Scalars['String']['output'];
  /** Сколько у пользователя очков в текущем турнире, null если текущего турнира нет */
  points?: Maybe<Scalars['Int']['output']>;
  /** Рейтинг пользователя в своей коалиции в текущем турнире, null если текущего турнира нет */
  rankInCoalition?: Maybe<Scalars['Int']['output']>;
  /** Идентификатор пользователя */
  userId: Scalars['ID']['output'];
};

/** Баллы участника коалиции в рамках турнира */
export type CoalitionMemberPower = {
  __typename?: 'CoalitionMemberPower';
  /** ID участника */
  coalitionMemberId: Scalars['ID']['output'];
  /** Сущность пользователя участника */
  coalitionMemberUser: User;
  /** Коалиция в рамках турнира */
  coalitionTournament: CoalitionTournament;
  id: Scalars['ID']['output'];
  /** Количество баллов */
  points: Scalars['Int']['output'];
};

/** Ранг члена коалиции в рамках турнира */
export type CoalitionMemberPowerRank = {
  __typename?: 'CoalitionMemberPowerRank';
  /** coalitionMemberId */
  id: Scalars['ID']['output'];
  /** Баллы */
  power: CoalitionMemberPower;
  /** Ранг участника */
  rank: Scalars['Int']['output'];
};

/** Коалиция в рамках турнира */
export type CoalitionTournament = {
  __typename?: 'CoalitionTournament';
  coalition: GameCoalition;
  coalitionId: Scalars['ID']['output'];
  /** Баллы выданные/отнятые в ручну */
  extraPoints: Scalars['Int']['output'];
  /** coalition_tournament_id */
  id: Scalars['ID']['output'];
  /**
   * Участник, с наибольшим количеством баллов в этой коалиции
   * {null} если нет лидера
   */
  mvpMember?: Maybe<CoalitionMemberPower>;
  /** Баллы */
  points: Scalars['Int']['output'];
  tournament: GameTournament;
  tournamentId: Scalars['ID']['output'];
};

/** Коалиция в рамках турнира c рангом */
export type CoalitionTournamentRank = {
  __typename?: 'CoalitionTournamentRank';
  coalitionTournament: CoalitionTournament;
  /** coalition_tournament_id */
  id: Scalars['ID']['output'];
  /** Ранг коалиции */
  rank: Scalars['Int']['output'];
};

export type CodeAnswerBody = {
  __typename?: 'CodeAnswerBody';
  /** Ответ на виджет */
  code: Scalars['String']['output'];
};

export type CodeAnswerBodyInput = {
  /** Ответ на виджет */
  code: Scalars['String']['input'];
};

/** Студенческий модуль по код-ревью */
export type CodeReview = {
  __typename?: 'CodeReview';
  /**
   * Статус (возвращает заглушку CodeReviewStatus.WAIT_FOR_REVIEW)
   * @deprecated Use studentCodeReviewStatus
   */
  codeReviewStatus: CodeReviewStatus;
  /** Тип выполнения модуля */
  goalExecutionType: ModuleExecutionType;
  /** Идентификатор модуля */
  goalId: Scalars['ID']['output'];
  /** Наименование модуля */
  goalTitle: Scalars['String']['output'];
  /** Статус */
  studentCodeReviewStatus: StudentCodeReviewStatus;
  /** Идентификатор модуля студента */
  studentGoalId: Scalars['ID']['output'];
  /** Дополнительные атрибуты задания, доступные для студента */
  studentTaskAdditionalAttributesModel: StudentTaskAdditionalAttributes;
};

/** Информация о проверках проекта */
export type CodeReviewChecksInfo = {
  __typename?: 'CodeReviewChecksInfo';
  /** Стоимость проверки (Code Review Points) */
  codeReviewCost: Scalars['Int']['output'];
  /** Длительность проверки (код-ревью, в минутах) */
  codeReviewDuration: Scalars['Int']['output'];
  /** Максимальное количество проверяющих (код-ревью) */
  maxCodeReviewCount: Scalars['Int']['output'];
};

/** Информация о блоке за код-ревью */
export type CodeReviewInfo = {
  __typename?: 'CodeReviewInfo';
  /** Усредненная оценка */
  averageMark: CodeReviewMark;
  /** Информация о проверках код-ревью студенческого проекта */
  codeReviewInstances: Array<CodeReviewInstance>;
  /** Фактический процент пройденного код-ревью */
  finalPercentageCodeReview: Scalars['Int']['output'];
  /** Ссылка на созданный MR */
  httpUrl?: Maybe<Scalars['String']['output']>;
};

/** Модель экземпляра код-ревью */
export type CodeReviewInstance = {
  __typename?: 'CodeReviewInstance';
  /** Финальная оценка проекта после код ревью */
  finalMark?: Maybe<Scalars['Boolean']['output']>;
  /** Время, когда установлена финальная оценка по проекту */
  markTime?: Maybe<Scalars['DateTime']['output']>;
  /** Логин студента проводящего код ревью */
  reviewerLogin: Scalars['String']['output'];
  /** Навык за код-ревью */
  softSkill?: Maybe<Scalars['Int']['output']>;
  /** Идентификатор процесса код ревью модуля студента */
  studentCodeReviewId: Scalars['ID']['output'];
};

export type CodeReviewLimitInfo = {
  __typename?: 'CodeReviewLimitInfo';
  limitByWeek: Scalars['Int']['output'];
  usedByWeek: Scalars['Int']['output'];
};

/** Справочник оценок по код ревью */
export enum CodeReviewMark {
  /** Согласен */
  Agree = 'AGREE',
  /** Полностью согласен */
  CompletelyAgree = 'COMPLETELY_AGREE',
  /** Полностью не согласен */
  CompletelyDisagree = 'COMPLETELY_DISAGREE',
  /** Трудно ответить */
  DifficultToAnswer = 'DIFFICULT_TO_ANSWER',
  /** Не согласен */
  Disagree = 'DISAGREE'
}

/** Проекты участвующие в код-ревью, сгруппированные по статусу */
export type CodeReviewProjects = {
  __typename?: 'CodeReviewProjects';
  /** Проходят раунд 1 код-ревью */
  firstRound: Array<CodeReview>;
  /** Проходят раунд 2 код-ревью */
  secondRound: Array<CodeReview>;
  /** Ожидают начала код-ревью */
  waitForReview: Array<CodeReview>;
};

/** Этапы код-ревью */
export type CodeReviewRound = {
  __typename?: 'CodeReviewRound';
  /** ID этапа код-ревью */
  codeReviewRoundId: Scalars['ID']['output'];
  /** Этап раунда код-ревью */
  codeReviewRoundType: CodeReviewRoundType;
  /** Статус код-ревью */
  codeReviewStatus: CodeReviewStatus;
  /** Время создания */
  createTime: Scalars['DateTime']['output'];
  /** Время завершения */
  endTime: Scalars['DateTime']['output'];
  /** ID публичного события */
  eventId?: Maybe<Scalars['ID']['output']>;
  /** Ссылка на MR проверяемого студента (персональный для ревьювера) */
  mergeRequestURL: Scalars['String']['output'];
  /** Время начала */
  startTime: Scalars['DateTime']['output'];
  /** ID процесса код-ревью модуля студента */
  studentCodeReviewId: Scalars['ID']['output'];
};

export enum CodeReviewRoundType {
  /** Раунд 1 */
  FirstRound = 'FIRST_ROUND',
  /** Раунд 2 */
  SecondRound = 'SECOND_ROUND'
}

export enum CodeReviewStatus {
  /** Завершен */
  Completed = 'COMPLETED',
  /** Провален */
  Failed = 'FAILED',
  /** В ревью */
  InReview = 'IN_REVIEW',
  /** Ожидает ревью */
  WaitForReview = 'WAIT_FOR_REVIEW',
  /** Ожидает начала раунда 1 */
  WaitForRound_1 = 'WAIT_FOR_ROUND_1',
  /** Ожидает начала раунда 2 */
  WaitForRound_2 = 'WAIT_FOR_ROUND_2'
}

/** Оценка ревьювера */
export type CodeReviewersMarksInput = {
  /** Оценка */
  mark: CodeReviewMark;
  /** Идентификатор студента-ревьювера */
  studentId: Scalars['UUID']['input'];
};

/** Варианты языков программирования для разметки */
export enum CodeWidgetLanguageEnum {
  Bash = 'BASH',
  C = 'C',
  Css = 'CSS',
  CSharp = 'C_SHARP',
  Go = 'GO',
  Html = 'HTML',
  Java = 'JAVA',
  JavaScript = 'JAVA_SCRIPT',
  Kotlin = 'KOTLIN',
  Php = 'PHP',
  Python = 'PYTHON',
  Ruby = 'RUBY',
  Sql = 'SQL',
  Swift = 'SWIFT',
  TypeScript = 'TYPE_SCRIPT'
}

/** Информация о "схлопнутых" комментариях в рамках задания */
export type CollapsedTaskCommentsInfo = {
  __typename?: 'CollapsedTaskCommentsInfo';
  /** Список ИД всех непрочитанных Уведомлений о комментарии, которые относятся к данному заданию */
  collapsedLastUnreadTaskCommentNotificationIds: Array<Scalars['ID']['output']>;
  /** Уведомление о последнем комментарии по заданию */
  lastUnreadTaskCommentNotificationId: Scalars['ID']['output'];
  /** Идентификатор задания в рамках которого подсчитано кол-во непрочитанных комментариев */
  taskId: Scalars['ID']['output'];
  /** Кол-во не прочитанных комментариев по заданию */
  unreadTaskCommentsCount: Scalars['Int']['output'];
};

/** Файл общий для системы */
export type CommonFile = {
  __typename?: 'CommonFile';
  /** Код файла */
  code: CommonFileCode;
  /** Описание файла */
  description: Scalars['String']['output'];
  /** Ссылка на файл */
  link: Scalars['String']['output'];
};

/** Коды общих для системы файлов */
export enum CommonFileCode {
  /** Приглашение на Хакатон */
  AllAdditionalInformation_1 = 'ALL_ADDITIONAL_INFORMATION_1',
  /** Положение о конкурсе */
  AllAdditionalInformation_2 = 'ALL_ADDITIONAL_INFORMATION_2',
  /** Приложение - ИИ */
  AllAdditionalInformation_3 = 'ALL_ADDITIONAL_INFORMATION_3',
  /** Руководство конфигуратора */
  BusinessAdminUg = 'BUSINESS_ADMIN_UG',
  /** Руководство родителя */
  ParentUg = 'PARENT_UG',
  /** Руководство ученика */
  StudentUg = 'STUDENT_UG',
  /** Руководство системного конфигуратора */
  SystemAdminUg = 'SYSTEM_ADMIN_UG',
  /** Памятка учителя */
  TeacherNotes = 'TEACHER_NOTES',
  /** Руководство учителя */
  TeacherUg = 'TEACHER_UG'
}

/** Файл общий для системы */
export type CommonFileInput = {
  /** Код файла */
  code: CommonFileCode;
  /** Ссылка на файл */
  link: Scalars['String']['input'];
};

export type Complaint = {
  __typename?: 'Complaint';
  /** браузер */
  browser?: Maybe<Scalars['String']['output']>;
  /** дополнительный материал */
  catalogItem?: Maybe<ContentItem>;
  /** ФИО пользователя, загрузившего дополнительный материал */
  catalogItemCreator?: Maybe<User>;
  /** Школа в рамках которой загружался материал (может отсутствовать, например материал глобальный) */
  catalogItemSchool?: Maybe<SafeSchool>;
  /** Предмет каталожного материала (если есть) */
  catalogItemSubject?: Maybe<Subject>;
  /** комментарий */
  comment?: Maybe<Scalars['String']['output']>;
  /** дата создания */
  createTime?: Maybe<Scalars['Date']['output']>;
  /** сообщение об исключении */
  exceptionMessage?: Maybe<Scalars['String']['output']>;
  /** stackTrace */
  exceptionStacktrace?: Maybe<Scalars['String']['output']>;
  /** тип исключения */
  exceptionType?: Maybe<Scalars['String']['output']>;
  /** уникальный идентификатор исключения */
  exceptionUniqueCode?: Maybe<Scalars['UUID']['output']>;
  /** Комментарий исполнителя */
  executorComment?: Maybe<Scalars['String']['output']>;
  /** ID жалобы */
  id: Scalars['ID']['output'];
  /** логин пользователя */
  login?: Maybe<Scalars['String']['output']>;
  /** метод в котором произошла ошибка */
  method?: Maybe<Scalars['String']['output']>;
  /** Модуль */
  module?: Maybe<StudyModule>;
  /** id школы */
  schoolId?: Maybe<Scalars['UUID']['output']>;
  /** путь к скриншоту в файлохранилище */
  screenshot: Scalars['String']['output'];
  /** Причины жалобы */
  selectedReasons: Array<ComplaintReason>;
  /** Класс создателя жалобы */
  stageGroup?: Maybe<Scalars['String']['output']>;
  /** Статус жалобы */
  status: ComplaintAndSystemErrorStatus;
  /** версия системы */
  systemVersion?: Maybe<Scalars['String']['output']>;
  /** Задание */
  task?: Maybe<Task>;
  /** url страницы, на которую была написана жалоба */
  url: Scalars['String']['output'];
  /** Пользователь, отправивший жалобу */
  user: User;
};

/** Статус жалобы */
export enum ComplaintAndSystemErrorStatus {
  /** В работе */
  InWork = 'IN_WORK',
  /** Обработана */
  Processed = 'PROCESSED',
  /** Не обработана */
  Unprocessed = 'UNPROCESSED'
}

export type ComplaintExportFilterInput = {
  /** Фильтры по дате создания жалобы */
  dateFrom?: InputMaybe<Scalars['DateTime']['input']>;
  dateTo?: InputMaybe<Scalars['DateTime']['input']>;
  /** Фильтр по статусу жалоб */
  filterStatus?: InputMaybe<ComplaintAndSystemErrorStatus>;
  /** Фильтр по идентификатору модуля */
  moduleId?: InputMaybe<Scalars['ID']['input']>;
  /** Фильтр по идентификатору предмета */
  subjectId?: InputMaybe<Scalars['ID']['input']>;
  /** Фильтр по идентификатору задания */
  taskId?: InputMaybe<Scalars['ID']['input']>;
  /** Строка поиска по почте и комментарию */
  textSearch?: InputMaybe<Scalars['String']['input']>;
};

export type ComplaintFilterInput = {
  /** Фильтры по дате создания жалобы */
  dateFrom?: InputMaybe<Scalars['DateTime']['input']>;
  dateTo?: InputMaybe<Scalars['DateTime']['input']>;
  /** Фильтр по статусу жалоб */
  filterStatus?: InputMaybe<ComplaintAndSystemErrorStatus>;
  /** Фильтр по идентификатору модуля */
  moduleId?: InputMaybe<Scalars['ID']['input']>;
  /** Параметры пагинации */
  paging?: InputMaybe<PagingInput>;
  /** Фильтр по идентификатору предмета */
  subjectId?: InputMaybe<Scalars['ID']['input']>;
  /** Фильтр по идентификатору задания */
  taskId?: InputMaybe<Scalars['ID']['input']>;
  /** Строка поиска по почте и комментарию */
  textSearch?: InputMaybe<Scalars['String']['input']>;
};

export type ComplaintInput = {
  /** браузер */
  browser?: InputMaybe<Scalars['String']['input']>;
  /** Идентификатор айтема в каталоге */
  catalogItemId?: InputMaybe<Scalars['UUID']['input']>;
  /** комментарий */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** сообщение об исключении */
  exceptionMessage?: InputMaybe<Scalars['String']['input']>;
  /** stackTrace */
  exceptionStacktrace?: InputMaybe<Scalars['String']['input']>;
  /** тип исключения */
  exceptionType?: InputMaybe<Scalars['String']['input']>;
  /** уникальный идентификатор исключения */
  exceptionUniqueCode?: InputMaybe<Scalars['UUID']['input']>;
  /** логин пользователя */
  login?: InputMaybe<Scalars['String']['input']>;
  /** метод в котором произошла ошибка */
  method?: InputMaybe<Scalars['String']['input']>;
  /** id модуля на которое отправлена жалоба */
  moduleId?: InputMaybe<Scalars['ID']['input']>;
  /** id школы */
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  /** путь к скриншоту в файлохранилище */
  screenshot: Scalars['String']['input'];
  /** перечень причин жалоб */
  selectedReasons: Array<Scalars['ID']['input']>;
  /** версия системы */
  systemVersion?: InputMaybe<Scalars['String']['input']>;
  /** id задания на которое отправлена жалоба */
  taskId?: InputMaybe<Scalars['ID']['input']>;
  /** url страницы, на которую была написана жалоба */
  url: Scalars['String']['input'];
};

export type ComplaintReason = {
  __typename?: 'ComplaintReason';
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  requiresComment: Scalars['Boolean']['output'];
  requiresContext: Scalars['Boolean']['output'];
  systemComplaint: Scalars['Boolean']['output'];
};

/** Статус результата выполнения студентом своего модуля (проекта)/курса (группы проектов)/экзамена */
export enum CompletionResultStatus {
  /** Не достигнут обязательный порог прохождения */
  FailByCalculation = 'FAIL_BY_CALCULATION',
  /** Провал по дедлайну регистрации */
  FailByRegistrationDeadline = 'FAIL_BY_REGISTRATION_DEADLINE',
  /** Провал при капитуляции */
  FailBySurrender = 'FAIL_BY_SURRENDER',
  /** Успешно выполнен */
  Success = 'SUCCESS'
}

/** Типы условий */
export enum ConditionType {
  /** Условия для работы с планами */
  Accessibility = 'ACCESSIBILITY',
  /** Условия доступности модуля в планах с привязкой к конкретным датам для потока */
  AccessibilityDate = 'ACCESSIBILITY_DATE',
  /** Условие выбора проверяющих */
  Checked = 'CHECKED',
  /** Условия выбора для дедлайнов Ш21 */
  Deadline = 'DEADLINE',
  /** Условия выбора выполняющих */
  Performing = 'PERFORMING',
  /** Условие строго последовательного прохождения уровней */
  SequenceLevelAccess = 'SEQUENCE_LEVEL_ACCESS'
}

/** Конфигурация (параметр, настройка) системы */
export type Configuration = {
  __typename?: 'Configuration';
  /** Метаинформация настройки */
  configurationMeta?: Maybe<ConfigurationMeta>;
  /** ID объекта орг.структуры, для которого задана настройка */
  entityId?: Maybe<Scalars['UUID']['output']>;
  /** Код настройки */
  propertyCode: Scalars['String']['output'];
  /** Информация о тарифе (Лайт, ПМО) */
  tariffs?: Maybe<Tariffs>;
  /** Значение настройки */
  value: Scalars['String']['output'];
};

export type ConfigurationByTariff = {
  __typename?: 'ConfigurationByTariff';
  configuration: Array<Maybe<Configuration>>;
  tariffs?: Maybe<Tariffs>;
};

export type ConfigurationDeleteInput = {
  entityId: Scalars['UUID']['input'];
  propertyCode: Scalars['String']['input'];
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

export type ConfigurationEntity = {
  __typename?: 'ConfigurationEntity';
  configurationMeta?: Maybe<ConfigurationMeta>;
  entityId?: Maybe<Scalars['UUID']['output']>;
  propertyCode: Scalars['String']['output'];
  regionId?: Maybe<Scalars['UUID']['output']>;
  schoolId?: Maybe<Scalars['UUID']['output']>;
  tariffs?: Maybe<Tariffs>;
  userId?: Maybe<Scalars['UUID']['output']>;
  value: Scalars['String']['output'];
};

/** Фильтр для получения списка конфигураций c бэкенда по фильтрам для вкладок "Параметры" -> "Региональные", "Школьные" */
export type ConfigurationFilterInput = {
  configurationLevel?: InputMaybe<Scalars['String']['input']>;
  groupNames?: InputMaybe<Array<Scalars['String']['input']>>;
  propertyCodes?: InputMaybe<Array<Scalars['String']['input']>>;
  propertyValues?: InputMaybe<Array<Scalars['String']['input']>>;
  regionIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
  schoolIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
  schoolTags?: InputMaybe<Array<Scalars['String']['input']>>;
  userIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
};

export type ConfigurationInput = {
  entityId: Scalars['UUID']['input'];
  propertyCode: Scalars['String']['input'];
  userId?: InputMaybe<Scalars['UUID']['input']>;
  value: Scalars['String']['input'];
};

/** Метаинформация настройки системы */
export type ConfigurationMeta = {
  __typename?: 'ConfigurationMeta';
  /** человеко читаемое название настройки */
  displayableName: Scalars['String']['output'];
  /** человеко читаемое название группы настроек */
  groupDisplayableName?: Maybe<Scalars['String']['output']>;
  /** максимальное значение для численных, даты */
  maxLength?: Maybe<Scalars['String']['output']>;
  /** минимальная значение для численных, даты */
  minLength?: Maybe<Scalars['String']['output']>;
  /** Допустимое значение enum */
  possibleValues?: Maybe<Array<EnumValue>>;
  /** длина строки будет передаваться с помощью regexp */
  regex?: Maybe<Scalars['String']['output']>;
  /** Тип значения настройки */
  type: ValueType;
};

/** Список типов визуальных элементов для управления настройкой */
export enum ConfigurationPropertyInputType {
  /** Правила выставления оценок */
  MarkRules = 'MARK_RULES',
  /** Степпер */
  Stepper = 'STEPPER',
  /** Переключатель */
  Switcher = 'SWITCHER',
  /** Текстовое поле */
  Text = 'TEXT'
}

export type ConfigurationsOfTariff = {
  __typename?: 'ConfigurationsOfTariff';
  /** значение по умолчанию */
  defaultValue?: Maybe<Scalars['String']['output']>;
  /** название конфигцрации */
  propertyCode: Scalars['String']['output'];
};

export type ConfigurationsOfTariffInput = {
  /** значение по умолчанию */
  defaultValue?: InputMaybe<Scalars['String']['input']>;
  /** название конфигцрации */
  propertyCode: Scalars['String']['input'];
};

/** Объяснения ограничения */
export type ConstraintExplanation = {
  __typename?: 'ConstraintExplanation';
  /** Счет */
  constraintScore: Score;
  /** Количество срабатываний */
  matchCount: Scalars['Int']['output'];
  /** Срабатывания */
  matches: Array<EduConstraintMatch>;
  /** Название ограничения */
  name: Scalars['String']['output'];
};

/** Результат обработки ограничения */
export type ConstraintResult = {
  __typename?: 'ConstraintResult';
  /** как отображать результат */
  isSuccessful: Scalars['Boolean']['output'];
  /** текст, объясняющий результат обработки ограничения */
  text: Scalars['String']['output'];
};

export type ContactData = {
  __typename?: 'ContactData';
  type?: Maybe<Scalars['String']['output']>;
  value: Scalars['String']['output'];
};

export type ContentBodyPage = {
  __typename?: 'ContentBodyPage';
  pageId: Scalars['ID']['output'];
  /** Номер страницы задания */
  pageNumber: Scalars['Int']['output'];
  /** Css-стили страницы */
  pageStyle?: Maybe<Scalars['String']['output']>;
  /** Список виджетов, размещенных на данной странице */
  sections: Array<ContentBodySection>;
};

export type ContentBodyPageInput = {
  /** Идентификатор страницы */
  pageId?: InputMaybe<Scalars['ID']['input']>;
  /** Номер страницы задания */
  pageNumber: Scalars['Int']['input'];
  /** Css-стили страницы */
  pageStyle?: InputMaybe<Scalars['String']['input']>;
  /** Список виджетов, располагающихся на данной странице */
  sections: Array<ContentBodySectionInput>;
};

export type ContentBodySection = {
  __typename?: 'ContentBodySection';
  sectionId: Scalars['ID']['output'];
  /** Опциональный порядок секции внутри страницы (НЕОБХОДИМ ДЛЯ МИГРАЦИИ МОТОБЛОКОВ) */
  sectionOrder?: Maybe<Scalars['Int']['output']>;
  /** Css-стили секции */
  sectionStyle?: Maybe<Scalars['String']['output']>;
  /** Тип секции */
  sectionType: SectionType;
  /** Список виджетов в секции */
  sectionWidgets?: Maybe<Array<Widget>>;
  /** Список виджетов */
  widgets: Array<ContentBodyWidget>;
};

export type ContentBodySectionInput = {
  /** Идентификатор секции */
  sectionId?: InputMaybe<Scalars['ID']['input']>;
  /** Опциональный порядок секции внутри страницы (НЕОБХОДИМ ДЛЯ МИГРАЦИИ МОТОБЛОКОВ) */
  sectionOrder?: InputMaybe<Scalars['Int']['input']>;
  /** Css-стили секции */
  sectionStyle?: InputMaybe<Scalars['String']['input']>;
  /** Тип секции */
  sectionType: SectionType;
  /** Список виджетов в секции */
  sectionWidgets?: InputMaybe<Array<WidgetInput>>;
  /** Список виджетов DEPRECATED!!! */
  widgets: Array<ContentBodyWidgetInput>;
};

export type ContentBodyWidget = {
  __typename?: 'ContentBodyWidget';
  /** Содержимое виджета */
  body: Scalars['String']['output'];
  /** Информация для виджета бизнес-типа (ContentWidgetTypeEnum=BUSINESS) */
  businessWidgetInfo?: Maybe<BusinessWidgetInfo>;
  /** Тип контента виджета */
  contentWidgetType: ContentWidgetTypeEnum;
  /** Правильный ответ */
  correctAnswer?: Maybe<Scalars['String']['output']>;
  widgetId: Scalars['ID']['output'];
  /** Порядковый номер виджета на странице задания */
  widgetNumber: Scalars['Int']['output'];
  /** Css-стили виджета */
  widgetStyle?: Maybe<Scalars['String']['output']>;
};

export type ContentBodyWidgetInput = {
  /** Содержимое виджета */
  body: Scalars['String']['input'];
  /** Бизнесс тип (используется только если ContentWidgetTypeEnum=Business) */
  businessType?: InputMaybe<BusinessTypeEnum>;
  /** Тип контента виджета */
  contentWidgetType: ContentWidgetTypeEnum;
  /** Правильный ответ */
  correctAnswer?: InputMaybe<Scalars['String']['input']>;
  /** Идентификатор виджета */
  widgetId?: InputMaybe<Scalars['ID']['input']>;
  /** Порядковый номер виджета на странице */
  widgetNumber: Scalars['Int']['input'];
  /** Css-стили виджета */
  widgetStyle?: InputMaybe<Scalars['String']['input']>;
};

/** Производственный статус Учебного Модуля */
export enum ContentEntityProductionStatus {
  /** Черновик, автоматически присваивается после создания модуля */
  Draft = 'DRAFT',
  /** На экспертизе, переход из DRAFT и ON_PROOFREADING */
  InReview = 'IN_REVIEW',
  /** На корректуре, переход из DRAFT и IN_REVIEW */
  OnProofreading = 'ON_PROOFREADING',
  /** Опубликован, переход из VERIFIED */
  Published = 'PUBLISHED',
  /** Верифицирован, присваивается автоматически, если проставляется обе визы: и эксперта и корректора */
  Verified = 'VERIFIED',
  /** Верифицирован корректором, переход из DRAFT или VERIFIED */
  VerifiedByCorrector = 'VERIFIED_BY_CORRECTOR',
  /** Верифицирован экспертом, переход из DRAFT или VERIFIED */
  VerifiedByExpert = 'VERIFIED_BY_EXPERT'
}

/** Тип сущности, которая находится в определенном статусе */
export enum ContentEntityType {
  Goal = 'GOAL',
  Task = 'TASK'
}

export enum ContentExternalCodeTypeEnum {
  /** Тип кода к модулю в системе Просвещение */
  GoalAxaptaId = 'GOAL_AXAPTA_ID',
  /** Тип кода к мягкому навыку в системе Просвещение */
  SoftSkillProsveschenieCode = 'SOFT_SKILL_PROSVESCHENIE_CODE'
}

/** Код сущности сервиса Контент во внешней системе */
export type ContentExternalEntityCode = {
  __typename?: 'ContentExternalEntityCode';
  /** Код */
  code: Scalars['String']['output'];
  /** Тип кода */
  codeType: ContentExternalCodeTypeEnum;
  /** Внешняя система */
  externalSystem: ContentExternalSystemEnum;
  id: Scalars['ID']['output'];
};

export enum ContentExternalSystemEnum {
  /** Просвещение */
  Prosveschenie = 'PROSVESCHENIE'
}

/** Модель для фильтрации данных в отчете БМ */
export type ContentFilterData = {
  __typename?: 'ContentFilterData';
  /** Выбрано значение или нет */
  checked?: Maybe<Scalars['Boolean']['output']>;
  /** подчиненные данные для фильтрации */
  children?: Maybe<Array<Maybe<ContentFilterData>>>;
  /** Маркер мандаторности */
  isAlwaysOnValue?: Maybe<Scalars['Boolean']['output']>;
  /** Метка для UI */
  label: Scalars['String']['output'];
  /** идентификатор значения */
  value: Scalars['ID']['output'];
};

export type ContentInput = {
  /** Тип контента */
  contentType: ContentTypeEnum;
  /** Тип представления контента */
  contentViewType?: InputMaybe<ContentViewTypeEnum>;
  /** Идентификатор внешнего задания */
  externalTaskId?: InputMaybe<Scalars['ID']['input']>;
  /** Список секций мотоблока */
  mbSectionList?: InputMaybe<Array<ContentMbSectionInput>>;
  /** Представление контента в мотивирующих заданияс с мигрированным мотивационным блоком */
  motivationView?: InputMaybe<ContentMotivationViewInput>;
  /** Содержимое страниц задания */
  pages: Array<ContentBodyPageInput>;
  /** Представление контента в расширенном виде */
  proView?: InputMaybe<ContentProViewInput>;
  /** Список страниц для контента ш21 */
  s21PageList?: InputMaybe<Array<ContentS21PageInput>>;
  /** Представление контента для ш21 */
  s21View?: InputMaybe<ContentS21ViewInput>;
  /** Список секций контента */
  sectionList?: InputMaybe<Array<ContentSectionInput>>;
  /** Представление контента в стандартном виде */
  simpleView?: InputMaybe<ContentSimpleViewInput>;
  /** Содержимое задания */
  taskContent?: InputMaybe<Scalars['String']['input']>;
  /** Оценка задания */
  taskEvaluation?: InputMaybe<TaskEvaluationInput>;
  /** Список виджетов контента */
  widgetList?: InputMaybe<Array<ContentWidgetInput>>;
};

/** Представление материала из каталога */
export type ContentItem = {
  __typename?: 'ContentItem';
  /** Признак активности item (false значение для архивированных item) */
  active?: Maybe<Scalars['Boolean']['output']>;
  /** Идентификатор группы, для которой элемент добавлен в закладки */
  bookmarkedForGroupId?: Maybe<Scalars['ID']['output']>;
  /** Признак того, что пользователь имеет право копировать материал (только для задания и модуля) */
  canCopy?: Maybe<Scalars['Boolean']['output']>;
  /** Признак того что пользователь имеет право редактировать материал */
  canEdit?: Maybe<Scalars['Boolean']['output']>;
  /** Категории, к которым принадлежит элемент */
  categories: Array<ItemCategory>;
  /** Типы проверки заданий */
  checkTypes: Array<Maybe<TaskCheckEnum>>;
  /** Автор материала */
  contentAuthor?: Maybe<Scalars['String']['output']>;
  /** Название материала */
  contentName: Scalars['String']['output'];
  /** Издатель материала (например, видеохостинг) */
  contentPublisher?: Maybe<Scalars['String']['output']>;
  /** Источник материала */
  contentSource?: Maybe<Scalars['String']['output']>;
  /** Тип материала */
  contentType: AdditionalContentType;
  /** URL для загрузки (открытия) материала */
  contentUrl: Scalars['String']['output'];
  /** Дата и время создания */
  createDate: Scalars['DateTime']['output'];
  /** Идентификатор пользователя, загрузившего данный материал */
  creatorUserId: Scalars['UUID']['output'];
  /** Описание */
  description?: Maybe<Scalars['String']['output']>;
  /** Длительность (в секундах) */
  duration?: Maybe<Scalars['Int']['output']>;
  /**
   * Признак того, может ли текущий пользователь редактировать данный материал
   * @deprecated Более не используется как признак
   */
  editable: Scalars['Boolean']['output'];
  /** Учебный материал (Учебник) */
  educational?: Maybe<Scalars['Boolean']['output']>;
  /** Дата окончания */
  endDate?: Maybe<Scalars['DateTime']['output']>;
  /** Тип материала с подтипом */
  extendedContentType: ExtendedContentType;
  /** id модуля или задания (только для модулей и заданий) */
  externalId?: Maybe<Scalars['Int']['output']>;
  /** Расширение файла */
  fileExtension?: Maybe<Scalars['String']['output']>;
  /** Имя файла */
  fileName?: Maybe<Scalars['String']['output']>;
  /** Размер файла в мегабайтах */
  fileSize?: Maybe<Scalars['Int']['output']>;
  /** Онлайн/Офлайн */
  format?: Maybe<AdditionalContentFormat>;
  /** Информационный материал (Учусь учиться) */
  informational?: Maybe<Scalars['Boolean']['output']>;
  /** Добавлен ли элемент в закладки */
  itemBookmarked?: Maybe<Scalars['Boolean']['output']>;
  /** Идентификатор айтема в каталоге */
  itemId: Scalars['UUID']['output'];
  /** Добавлен ли материал в какую-либо подборку */
  itemInSelection: Scalars['Boolean']['output'];
  /** Трудозатраты */
  laboriousness?: Maybe<Scalars['String']['output']>;
  /** Стаус прохождения модуля для ученика */
  moduleState?: Maybe<StudentModuleState>;
  /** ФИО учителя, назначивший модуль на план для ученика */
  planTeacherFullName?: Maybe<Scalars['String']['output']>;
  /** Планы, в которые входит модуль, для учителя */
  plans?: Maybe<Array<ClassPlanMediateka>>;
  /** Подготовительный материал (Для подготовки к олимпиадам и экзаменам) */
  preparative?: Maybe<Scalars['Boolean']['output']>;
  /** URL файла предпросмотра дополнительного материала (изображения) */
  previewUrl?: Maybe<Scalars['String']['output']>;
  /** Информация о цене и факте покупки */
  pricing: ContentItemPricing;
  /** Статус верификации */
  productionStatus?: Maybe<ContentEntityProductionStatus>;
  /** Регион */
  regions?: Maybe<Array<Scalars['UUID']['output']>>;
  /** Область видимости */
  scope?: Maybe<ScopeEnum>;
  /** Мягкие навыки */
  softSkills?: Maybe<Array<SoftSkill>>;
  /**
   * Массив учебных параллелей, с которыми связан данный материал.
   * Может быть пустым, если материал относится ко всем параллелям
   * @deprecated Переход к Stage
   */
  stageIds: Array<AdditionalContentStage>;
  /** Список учебных параллелей */
  stages: Array<Stage>;
  /** Дата начала */
  startDate?: Maybe<Scalars['DateTime']['output']>;
  /** статус айтема в человекочитаемом виде */
  status: Scalars['String']['output'];
  /** Признак того, существует ли связь айтема из каталога с предметом */
  subjectContentBookmarked?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Признак того, может ли пользователь удалять связь айтема из каталога с предметом
   * @deprecated Более не используется как признак
   */
  subjectContentEditable: Scalars['Boolean']['output'];
  /**
   * Идентификатор дополнительного материала (связи материала из каталога с предметом)
   * @deprecated Будет удален, теперь используется subjectContentBookmarked
   */
  subjectContentId?: Maybe<Scalars['UUID']['output']>;
  /** Идентификаторы предметов, к которым относится данный материал */
  subjectIds: Array<Scalars['ID']['output']>;
  /** Субтитры для видео */
  subtitleLink?: Maybe<Scalars['String']['output']>;
  /** Ссылка на файл субтитров для определенного языка */
  subtitleLinks?: Maybe<Array<SubtitleLinkForLanguage>>;
  /** плоский список кодов для тегов */
  tagIds: Array<Scalars['ID']['output']>;
  /**
   * Теги материала
   * @deprecated Field no longer supported
   */
  tags: Array<Scalars['String']['output']>;
  /** теги с иерархией */
  tagsV2: Array<TagHierarchyElement>;
  /** Тип задания */
  taskType?: Maybe<TaskTypeEnum>;
};

export type ContentItemPricing = {
  __typename?: 'ContentItemPricing';
  /**
   * Куплен материал или нет. null для бесплатных материалов;
   * #true, если материал куплен или был недоступен сервис подписок; #false, если сервис
   * подписок был доступен и вернул информацию, что подписка для текущего пользователя не оформлена.
   */
  bought?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Дата окончания покупки/подписки. null, если элемент бесплатный, не оплачен, бессрочный или сервис
   * подписок был недоступен. Не null, если сервис подписок вернул информацию об активной подписке для
   * пользователя с датой завершения.
   */
  expirationDate?: Maybe<Scalars['Date']['output']>;
  /**
   * Признак платности материала. true, если материал платный. false,
   * если материал бесплатныЙ или если сервис цен был недоступен.
   */
  paid: Scalars['Boolean']['output'];
  /**
   * Цена (в рублях). null, если материал бесплатный или если сервис цен был недоступен. Цена обязана быть,
   * если материал платный (установлен флаг paid).
   */
  price?: Maybe<Price>;
};

/**
 * Обновление материалов из каталога
 * Набор параметров для обновления материала из каталога
 */
export type ContentItemUpdateInput = {
  /** Категории, к которым принадлежит материал */
  categoryIds: Array<Scalars['ID']['input']>;
  /** Автор материала */
  contentAuthor?: InputMaybe<Scalars['String']['input']>;
  /** Название материала */
  contentName: Scalars['String']['input'];
  /** Издатель материала (например, видеохостинг) */
  contentPublisher?: InputMaybe<Scalars['String']['input']>;
  /** Описание */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Учебный материал(Учебник) */
  educational?: InputMaybe<Scalars['Boolean']['input']>;
  /** Дата окончания матерала */
  endDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Онлайн/Офлайн материала */
  format?: InputMaybe<AdditionalContentFormat>;
  /** Информационный материал (Учусь учиться) */
  informational?: InputMaybe<Scalars['Boolean']['input']>;
  /** Подготовительный материал (Для подготовки к олимпиадам и экзаменам) */
  preparative?: InputMaybe<Scalars['Boolean']['input']>;
  /** URL предпросмотра материала (изображения), являющийся путём к файловому серверу */
  previewUrl?: InputMaybe<Scalars['String']['input']>;
  /** Регион материала */
  regions?: InputMaybe<Array<Scalars['UUID']['input']>>;
  /** Уровень видимости материала */
  scope?: InputMaybe<ScopeEnum>;
  /**
   * НЕ ИСПОЛЬЗОВАТЬ, УСТАРЕЛО
   * Использовать stageIdsV2
   * Идентификаторы учебных параллелей, с которыми связан материал
   */
  stageIds: Array<AdditionalContentStage>;
  /** Дата начала материла */
  startDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Идентификаторы предметов, к которым относится данный материал */
  subjectIds: Array<Scalars['ID']['input']>;
  /** Субтитры для видео */
  subtitleLink?: InputMaybe<Scalars['String']['input']>;
  /** Ссылка на файл субтитров для определенного языка */
  subtitleLinks?: InputMaybe<Array<SubtitleLinkForLanguageInput>>;
  /** Теги V2 */
  tagIdsV2?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**
   * Список тегов материала
   * deprecated "Use tagsV2"
   */
  tags: Array<Scalars['String']['input']>;
};

/**
 * Обновление материалов из каталога
 * Набор параметров для обновления материала из каталога
 */
export type ContentItemUpdateInputV2 = {
  /** Категории, к которым принадлежит материал */
  categoryIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Автор материала */
  contentAuthor?: InputMaybe<Scalars['String']['input']>;
  /** Название материала */
  contentName: Scalars['String']['input'];
  /** Издатель материала (например, видеохостинг) */
  contentPublisher?: InputMaybe<Scalars['String']['input']>;
  /** URL со ссылкой на внешний материал */
  contentUrl?: InputMaybe<Scalars['String']['input']>;
  /** Описание */
  description: Scalars['String']['input'];
  /** Учебный материал(Учебник) */
  educational?: InputMaybe<Scalars['Boolean']['input']>;
  /** Дата окончания матерала */
  endDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Онлайн/Офлайн материала */
  format?: InputMaybe<AdditionalContentFormat>;
  /** Информационный материал (Учусь учиться) */
  informational?: InputMaybe<Scalars['Boolean']['input']>;
  /** Подготовительный материал (Для подготовки к олимпиадам и экзаменам) */
  preparative?: InputMaybe<Scalars['Boolean']['input']>;
  /** URL предпросмотра материала (изображения), являющийся путём к файловому серверу */
  previewUrl?: InputMaybe<Scalars['String']['input']>;
  /** Регион материала */
  regions?: InputMaybe<Array<Scalars['UUID']['input']>>;
  /** Уровень видимости материала */
  scope?: InputMaybe<ScopeEnum>;
  /** Идентификаторы учебных параллелей (Stage) материала */
  stageIds: Array<Scalars['ID']['input']>;
  /** Дата начала материла */
  startDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Идентификаторы предметов, к которым относится данный материал */
  subjectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Субтитры для видео */
  subtitleLink?: InputMaybe<Scalars['String']['input']>;
  /** Ссылка на файл субтитров для определенного языка */
  subtitleLinks?: InputMaybe<Array<SubtitleLinkForLanguageInput>>;
  /** Теги V2 */
  tagIdsV2?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Список тегов материала */
  tags: Array<Scalars['String']['input']>;
};

/** вид контента */
export enum ContentKind {
  /** внешний ЭОР (для поиска по табл. external_tasks) */
  Eor = 'EOR',
  /** созданный объект Task с необходимыми атрибутами (для поиска по табл. tasks) */
  Task = 'TASK',
  /** не поддерживаемый вид (неверный префикс shortcut) */
  Unsupported = 'UNSUPPORTED'
}

/** Описание поставки контента */
export type ContentLoad = {
  __typename?: 'ContentLoad';
  contentProvider: ContentProvider;
  created: Scalars['DateTime']['output'];
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
};

export type ContentMbSection = {
  __typename?: 'ContentMBSection';
  /** Количество блоков в секции */
  blocksCount?: Maybe<Scalars['Int']['output']>;
  /** Идентификатор секции */
  entityId: Scalars['ID']['output'];
  /** Параметр фиксации высоты\резиновости секции */
  isLockedHeight: Scalars['Boolean']['output'];
  /** Список сущностей, связанных с секцией */
  items: Array<ContentMbSectionItem>;
  /** Тип секции */
  sectionType: Scalars['String']['output'];
};

export type ContentMbSectionInput = {
  /** Количество блоков в секции */
  blocksCount?: InputMaybe<Scalars['Int']['input']>;
  /** Идентификатор секции */
  entityId: Scalars['ID']['input'];
  /** Параметр фиксации высоты\резиновости секции */
  isLockedHeight: Scalars['Boolean']['input'];
  /** Список сущностей, связанных с секцией */
  items: Array<ContentMbSectionItemInput>;
  /** Тип секции */
  sectionType: Scalars['String']['input'];
};

export type ContentMbSectionItem = {
  __typename?: 'ContentMBSectionItem';
  /** Номер позиции сущности в секции */
  positionId: Scalars['Int']['output'];
  /** Тип связанной сущности */
  target: Scalars['String']['output'];
  /** Идентификатор связанной сущности */
  targetEntityId: Scalars['ID']['output'];
};

export type ContentMbSectionItemInput = {
  /** Номер позиции сущности в секции */
  positionId: Scalars['Int']['input'];
  /** Тип связанной сущности */
  target: Scalars['String']['input'];
  /** Идентификатор связанной сущности */
  targetEntityId: Scalars['ID']['input'];
};

export enum ContentMigrationEntityType {
  EducationalMaterials = 'EDUCATIONAL_MATERIALS',
  ExternalTask = 'EXTERNAL_TASK',
  Module = 'MODULE',
  Task = 'TASK'
}

export type ContentMotivationView = {
  __typename?: 'ContentMotivationView';
  /** Идентификатор представления */
  entityId: Scalars['String']['output'];
  /** Список сущностей, связанных с представлением */
  items: Array<ContentMotivationViewItem>;
};

export type ContentMotivationViewInput = {
  /** Идентификатор представления */
  entityId: Scalars['String']['input'];
  /** Список сущностей, связанных с представлением */
  items?: InputMaybe<Array<ContentMotivationViewItemInput>>;
};

export type ContentMotivationViewItem = {
  __typename?: 'ContentMotivationViewItem';
  /** Номер по порядку */
  order: Scalars['Int']['output'];
  /** Тип связанной сущности */
  target: Scalars['String']['output'];
  /** Идентификатор связанной сущности */
  targetEntityId: Scalars['ID']['output'];
};

export type ContentMotivationViewItemInput = {
  /** Номер по порядку */
  order: Scalars['Int']['input'];
  /** Тип связанной сущности */
  target: Scalars['String']['input'];
  /** Идентификатор связанной сущности */
  targetEntityId: Scalars['ID']['input'];
};

export type ContentMutations = {
  __typename?: 'ContentMutations';
  /**
   * Переводит сущность контента в определенный производственный статус.
   * Возвращает идентификатор созданной записей в content_entity_production_status_logs
   */
  changeContentEntityProductionStatus: ChangeContentProductionStatusResponse;
  /** Смена статуса или видимости модуля/темы */
  changeScopeAndStatusForContentEntities: ScopeAndStatusChangeResponse;
  /** Смена видимости модуля */
  changeScopeGoalAndTask: StudyModule;
  /** Копирование модуля, возвращает скопированный модуль */
  copyModule: StudyModule;
  /** Копирование модуля, возвращает скопированный модуль */
  copyModules: Array<StudyModule>;
  /** Мутация для создания контента */
  createContent: TaskContent;
  /** Мутация для создания задания */
  createTask: Task;
  /** Мутация для привязки контента к заданию */
  linkContentToTask: Task;
  /** Сохранение сессии на печать задания */
  saveTaskPrint: PrintTaskMeta;
  /** Мутация для обновления контента */
  updateContent: TaskContent;
  /** Мутация для обновления задания */
  updateTask: Task;
};


export type ContentMutationsChangeContentEntityProductionStatusArgs = {
  entityId: Scalars['String']['input'];
  entityType: ContentEntityType;
  status: ContentEntityProductionStatus;
};


export type ContentMutationsChangeScopeAndStatusForContentEntitiesArgs = {
  requests: ChangeScopeAndStatusForContentEntitiesRequest;
};


export type ContentMutationsChangeScopeGoalAndTaskArgs = {
  goalId: Scalars['ID']['input'];
  scope: ScopeEnum;
};


export type ContentMutationsCopyModuleArgs = {
  localTimestamp: Scalars['String']['input'];
  moduleId: Scalars['ID']['input'];
};


export type ContentMutationsCopyModulesArgs = {
  localTimestamp: Scalars['String']['input'];
  moduleId: Array<Scalars['ID']['input']>;
};


export type ContentMutationsCreateContentArgs = {
  content?: InputMaybe<ContentInput>;
};


export type ContentMutationsCreateTaskArgs = {
  linkSlot?: InputMaybe<LinkSlotInput>;
  taskMeta?: InputMaybe<TaskMetaInput>;
};


export type ContentMutationsLinkContentToTaskArgs = {
  contentId: Scalars['String']['input'];
  taskId: Scalars['ID']['input'];
};


export type ContentMutationsSaveTaskPrintArgs = {
  taskId: Scalars['ID']['input'];
};


export type ContentMutationsUpdateContentArgs = {
  content?: InputMaybe<ContentInput>;
  contentId: Scalars['String']['input'];
};


export type ContentMutationsUpdateTaskArgs = {
  taskId: Scalars['ID']['input'];
  taskMeta?: InputMaybe<TaskMetaInput>;
};

export type ContentProView = {
  __typename?: 'ContentProView';
  /** Идентификатор представления */
  entityId: Scalars['String']['output'];
  /** Список сущностей, связанных с представлением */
  items: Array<ContentProViewItem>;
};

export type ContentProViewInput = {
  /** Идентификатор представления */
  entityId: Scalars['String']['input'];
  /** Список сущностей, связанных с представлением */
  items?: InputMaybe<Array<ContentProViewItemInput>>;
};

export type ContentProViewItem = {
  __typename?: 'ContentProViewItem';
  /** Номер по порядку */
  order: Scalars['Int']['output'];
  /** Тип связанной сущности */
  target: Scalars['String']['output'];
  /** Идентификатор связанной сущности */
  targetEntityId: Scalars['ID']['output'];
};

export type ContentProViewItemInput = {
  /** Номер по порядку */
  order: Scalars['Int']['input'];
  /** Тип связанной сущности */
  target: Scalars['String']['input'];
  /** Идентификатор связанной сущности */
  targetEntityId: Scalars['ID']['input'];
};

/** История изменений производственного статуса Учебного Модуля */
export type ContentProductionStatusChangeLog = {
  __typename?: 'ContentProductionStatusChangeLog';
  /** Дата-время перехода в статус */
  createTime: Scalars['DateTime']['output'];
  /** Пользователь, который перевел в статус */
  createUser: User;
  /** Дата-время перехода в следующий статус */
  endTime?: Maybe<Scalars['DateTime']['output']>;
  /** Идентификатор экземпляра сущности */
  entityId: Scalars['String']['output'];
  /** Тип сущности, которая находится в определенном статусе */
  entityType: ContentEntityType;
  /** Идентификатор записи о нахождении в статусе */
  logId: Scalars['ID']['output'];
  /** Статус, согласно enum */
  status: ContentEntityProductionStatus;
};

/** Поставщик контента */
export type ContentProvider = {
  __typename?: 'ContentProvider';
  description: Scalars['String']['output'];
  externalContentProvider: ExternalContentProviderEnum;
  id: Scalars['ID']['output'];
  logoUrl?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
};

export type ContentQueries = {
  __typename?: 'ContentQueries';
  /** Получение Книг по идентификаторам. */
  getBooksByIds: Array<Book>;
  /** Получения контента по его идентификатору */
  getContent: TaskContent;
  /** Возвращает список тегов, полученных по идентификатору сущности и массиву типов тегов */
  getContentTags: Array<ContentTag>;
  /**
   * Возвращает рандомные варианты по идентификаторам виджетов.
   * В случае если виджет невариативен (variationMeta = null) ничего не вернет в массиве
   * count - кол-во вариантов, которые вернет контент по каждому widgetId (НЕ БОЛЬШЕ 100)
   */
  getRandomVariantsByWidgetIds: Array<WidgetVariant>;
  /** Возвращает список тегов, полученных по названию и типам тегов с заданным лимитом и оффсетом */
  searchTags: Array<ContentTag>;
};


export type ContentQueriesGetBooksByIdsArgs = {
  bookIds: Array<Scalars['ID']['input']>;
};


export type ContentQueriesGetContentArgs = {
  contentId: Scalars['String']['input'];
};


export type ContentQueriesGetContentTagsArgs = {
  entityId: Scalars['ID']['input'];
  tagTypes: Array<ContentTagTypeEnum>;
  taggedEntityType: TaggedEntityTypeEnum;
};


export type ContentQueriesGetRandomVariantsByWidgetIdsArgs = {
  count: Scalars['Int']['input'];
  widgetIds: Array<Scalars['ID']['input']>;
};


export type ContentQueriesSearchTagsArgs = {
  filterTag: Scalars['String']['input'];
  filterTagType: Array<ContentTagTypeEnum>;
  limit: Scalars['Int']['input'];
  offset: Scalars['Int']['input'];
};

export type ContentS21Page = {
  __typename?: 'ContentS21Page';
  /** Идентификатор страницы */
  entityId: Scalars['ID']['output'];
  /** Список сущностей, связанных со страницей */
  items: Array<ContentS21PageItem>;
};

export type ContentS21PageInput = {
  /** Идентификатор страницы */
  entityId: Scalars['ID']['input'];
  /** Список сущностей, связанных со страницей */
  items: Array<ContentS21PageItemInput>;
};

export type ContentS21PageItem = {
  __typename?: 'ContentS21PageItem';
  /** Номер по порядку */
  order: Scalars['Int']['output'];
  /** Тип связанной сущности */
  target: Scalars['String']['output'];
  /** Идентификатор связанной сущности */
  targetEntityId: Scalars['ID']['output'];
};

export type ContentS21PageItemInput = {
  /** Номер по порядку */
  order: Scalars['Int']['input'];
  /** Тип связанной сущности */
  target: Scalars['String']['input'];
  /** Идентификатор связанной сущности */
  targetEntityId: Scalars['ID']['input'];
};

export type ContentS21View = {
  __typename?: 'ContentS21View';
  /** Идентификатор представления */
  entityId: Scalars['String']['output'];
  /** Список сущностей, связанных с представлением */
  items: Array<ContentS21ViewItem>;
};

export type ContentS21ViewInput = {
  /** Идентификатор представления */
  entityId: Scalars['String']['input'];
  /** Список сущностей, связанных с представлением */
  items: Array<ContentS21ViewItemInput>;
};

export type ContentS21ViewItem = {
  __typename?: 'ContentS21ViewItem';
  /** Номер по порядку */
  order: Scalars['Int']['output'];
  /** Тип связанной сущности */
  target: Scalars['String']['output'];
  /** Идентификатор связанной сущности */
  targetEntityId: Scalars['ID']['output'];
};

export type ContentS21ViewItemInput = {
  /** Номер по порядку */
  order: Scalars['Int']['input'];
  /** Тип связанной сущности */
  target: Scalars['String']['input'];
  /** Идентификатор связанной сущности */
  targetEntityId: Scalars['ID']['input'];
};

export type ContentSection = {
  __typename?: 'ContentSection';
  /** Идентификатор секции */
  entityId: Scalars['ID']['output'];
  /** Список сущностей, связанных с секцией */
  items: Array<ContentSectionItem>;
  /** Опции секции */
  options?: Maybe<ContentSectionOptions>;
};

export type ContentSectionInput = {
  /** Идентификатор секции */
  entityId: Scalars['ID']['input'];
  /** Список сущностей, связанных с секцией */
  items: Array<ContentSectionItemInput>;
  /** Опции секции */
  options?: InputMaybe<ContentSectionOptionsInput>;
};

export type ContentSectionItem = {
  __typename?: 'ContentSectionItem';
  /** Расположение секции контента */
  layout: Scalars['String']['output'];
  /** Опции элемента секции */
  options?: Maybe<ContentSectionItemOptions>;
  /** Тип связанной сущности */
  target: Scalars['String']['output'];
  /** Идентификатор связанной сущности */
  targetEntityId: Scalars['ID']['output'];
};

export type ContentSectionItemInput = {
  /** Расположение секции контента */
  layout: Scalars['String']['input'];
  /** Опции элемента секции */
  options?: InputMaybe<ContentSectionItemOptionsInput>;
  /** Тип связанной сущности */
  target: Scalars['String']['input'];
  /** Идентификатор связанной сущности */
  targetEntityId: Scalars['ID']['input'];
};

export type ContentSectionItemOptions = {
  __typename?: 'ContentSectionItemOptions';
  /** Цвет фона элемента */
  backgroundColor?: Maybe<Scalars['String']['output']>;
  /** Тень элемента */
  boxShadow?: Maybe<Scalars['Boolean']['output']>;
};

export type ContentSectionItemOptionsInput = {
  /** Цвет фона элемента */
  backgroundColor?: InputMaybe<Scalars['String']['input']>;
  /** Тень элемента */
  boxShadow?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ContentSectionOptions = {
  __typename?: 'ContentSectionOptions';
  /** Цвет фона секции */
  backgroundColor?: Maybe<Scalars['String']['output']>;
  /** Изображение фона секции */
  backgroundImage?: Maybe<Scalars['String']['output']>;
  /** Минимальная высота секции */
  minimumHeight?: Maybe<Scalars['Int']['output']>;
};

export type ContentSectionOptionsInput = {
  /** Цвет фона секции */
  backgroundColor?: InputMaybe<Scalars['String']['input']>;
  /** Изображение фона секции */
  backgroundImage?: InputMaybe<Scalars['String']['input']>;
  /** Минимальная высота секции */
  minimumHeight?: InputMaybe<Scalars['Int']['input']>;
};

/** Подборка материалов (из каталога) */
export type ContentSelection = {
  __typename?: 'ContentSelection';
  /** Содержимое подборки */
  items: Array<ContentItem>;
  /** Имя для отображения */
  name: Scalars['String']['output'];
  /** ИД подборки */
  selectionId: Scalars['UUID']['output'];
};


/** Подборка материалов (из каталога) */
export type ContentSelectionItemsArgs = {
  page: PagingInput;
};

export type ContentSimpleView = {
  __typename?: 'ContentSimpleView';
  /** Идентификатор представления */
  entityId: Scalars['String']['output'];
  /** Список сущностей, связанных с представлением */
  items: Array<ContentSimpleViewItem>;
};

export type ContentSimpleViewInput = {
  /** Идентификатор представления */
  entityId: Scalars['String']['input'];
  /** Список сущностей, связанных с представлением */
  items?: InputMaybe<Array<ContentSimpleViewItemInput>>;
};

export type ContentSimpleViewItem = {
  __typename?: 'ContentSimpleViewItem';
  /** Номер по порядку */
  order: Scalars['Int']['output'];
  /** Тип связанной сущности */
  target: Scalars['String']['output'];
  /** Идентификатор связанной сущности */
  targetEntityId: Scalars['ID']['output'];
};

export type ContentSimpleViewItemInput = {
  /** Номер по порядку */
  order: Scalars['Int']['input'];
  /** Тип связанной сущности */
  target: Scalars['String']['input'];
  /** Идентификатор связанной сущности */
  targetEntityId: Scalars['ID']['input'];
};

/** Представление словарной сущности (тип материала, тип книги и т.п.) */
export type ContentSubtype = {
  __typename?: 'ContentSubtype';
  /** Идентификатор сущности */
  id: Scalars['ID']['output'];
  /** Читаемое название (для отображения) */
  title: Scalars['String']['output'];
};

/** Тег контента */
export type ContentTag = {
  __typename?: 'ContentTag';
  /** Идентификатор тэга в Медиатеке (не используется при кастомном тэгировании) */
  mediatekaTagId?: Maybe<Scalars['ID']['output']>;
  /** ID тега */
  tagId: Scalars['ID']['output'];
  /** Имя тэга */
  tagName: Scalars['String']['output'];
  /** Тип тэга */
  tagType: ContentTagTypeEnum;
};

/** Тэг контента */
export type ContentTagInput = {
  /** Идентифкатор тэга в Медиатеке (не используется при кастомном тэгировании) */
  mediatekaTagId?: InputMaybe<Scalars['ID']['input']>;
  /** Тэг */
  tagName: Scalars['String']['input'];
  /** Тип тэга */
  tagType: ContentTagTypeEnum;
};

/** Типы тегов */
export enum ContentTagTypeEnum {
  /** Старые кастомные тэги (редактируемые) */
  Custom = 'CUSTOM',
  /** Тэги Медиатеки (нередактируемые) */
  Mediateka = 'MEDIATEKA'
}

export type ContentTagsMutations = {
  __typename?: 'ContentTagsMutations';
  /**
   * задать список тэгов tags для объекта objectType с кодом objectId
   * @deprecated Use setContentTags instead.
   */
  setTags?: Maybe<Scalars['Boolean']['output']>;
};


export type ContentTagsMutationsSetTagsArgs = {
  objectId: Scalars['ID']['input'];
  objectType: TaggedObjectsEnum;
  tags: Array<Scalars['String']['input']>;
};

export type ContentTagsQueries = {
  __typename?: 'ContentTagsQueries';
  /**
   * получить список тегов для для объекта objectType с кодом objectId
   * @deprecated Field no longer supported
   */
  getTags: Array<Scalars['String']['output']>;
  /**
   * получить список всех тэгов (сортировка по алфавиту)
   * @deprecated Field no longer supported
   */
  searchTags: Array<Scalars['String']['output']>;
};


export type ContentTagsQueriesGetTagsArgs = {
  objectId: Scalars['ID']['input'];
  objectType: TaggedObjectsEnum;
};


export type ContentTagsQueriesSearchTagsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  tag?: InputMaybe<Scalars['String']['input']>;
};

/** Тип задания */
export enum ContentTypeEnum {
  /** Задание с редактором кода */
  CodeMirror = 'CODE_MIRROR',
  /** Задание из внешнего поставщика контента */
  ExternalContent = 'EXTERNAL_CONTENT',
  /** Задание, которое проходится на внешнем ресурсе */
  ExternalTask = 'EXTERNAL_TASK',
  /** Задание "нового конструктора и плеера" */
  Generic = 'GENERIC',
  /** Простое текстовое задание */
  Html = 'HTML',
  /** iFrame задание от поставщика внешнего контента */
  Iframe = 'IFRAME',
  /** Тест Survey */
  Json = 'JSON',
  /** Задание, созданное в экспертном режиме */
  Markdown = 'MARKDOWN',
  /** Задание, содержащее тренажёр */
  TrainingIntegration = 'TRAINING_INTEGRATION'
}

/** Тип представления контента (сетка) */
export enum ContentViewTypeEnum {
  /** Представление мотоблока */
  Motivation = 'MOTIVATION',
  /** Расширенное представление */
  Pro = 'PRO',
  /** Представление ш21 */
  S21 = 'S21',
  /** Простое представление */
  Simple = 'SIMPLE'
}

export type ContentWidget = {
  __typename?: 'ContentWidget';
  /** тело виджета */
  body: WidgetBody;
  /** Идентификатор виджета */
  entityId: Scalars['ID']['output'];
  /** Список сущностей, связанных с виджетом */
  items: Array<ContentWidgetItem>;
  /** Мета-информация о вариативности виджета */
  variationMeta?: Maybe<WidgetVariationMeta>;
  /** Тип группы виджетов */
  widgetGroupType: WidgetGroupTypeEnum;
  /** Тип виджета */
  widgetType: WidgetTypeEnum;
};

export type ContentWidgetInput = {
  /** тело виджета */
  body?: InputMaybe<WidgetBodyCompositionInput>;
  /** Идентификатор виджета */
  entityId: Scalars['ID']['input'];
  /** Список сущностей, связанных с виджетом */
  items: Array<ContentWidgetItemInput>;
  /** Мета-информация о вариативности виджета */
  variationMeta?: InputMaybe<WidgetVariationMetaInput>;
  /** Тип группы виджетов */
  widgetGroupType: WidgetGroupTypeEnum;
  /** Тип виджета */
  widgetType: WidgetTypeEnum;
};

export type ContentWidgetItem = {
  __typename?: 'ContentWidgetItem';
  /** Тип связанной сущности */
  target: Scalars['String']['output'];
  /** Идентификатор связанной сущности */
  targetEntityId: Scalars['ID']['output'];
};

export type ContentWidgetItemInput = {
  /** Тип связанной сущности */
  target: Scalars['String']['input'];
  /** Идентификатор связанной сущности */
  targetEntityId: Scalars['ID']['input'];
};

/** Тип виджета */
export enum ContentWidgetTypeEnum {
  /** Бизнесс-тип с предобработкой на backend */
  Business = 'BUSINESS',
  /** Информационный(для информации, без ответа) */
  Info = 'INFO',
  /** Интерактивный(есть возможность ввести ответ и может быть предусмотрен правильный ответ) */
  Interactive = 'INTERACTIVE',
  /** Смешанный(есть возможность ввести ответ, но правильного ответа не предусмотрено) */
  Mixed = 'MIXED'
}

export enum ControlWorkStatus {
  /** Контрольная работа закрыта */
  Closed = 'CLOSED',
  /** Черновик, создана, но не запланирована */
  Draft = 'DRAFT',
  /** Контрольная работа запланирована */
  Planned = 'PLANNED',
  /** Контрольная работа идет */
  Started = 'STARTED'
}

/** Результат удаления варианта контрольной работы */
export type ControlWorkVariantRemoveResult = {
  __typename?: 'ControlWorkVariantRemoveResult';
  /** Кол-во учеников, которых аффектит удаление варианта контрольной работы */
  affectedStudentsByRemoveCount: Scalars['Int']['output'];
  /** Контрольная работа, вариант которой удаляют */
  classSubjectControlWorkModel: ClassSubjectControlWork;
  /** флаг - успешно ли прошла операция удаления */
  isSuccess: Scalars['Boolean']['output'];
};

/** Данные для расчета разбаловки */
export type CountInfo = {
  __typename?: 'CountInfo';
  /** Процент бонусной части */
  percentageOfBonus: Scalars['Int']['output'];
  /** Балл за задание */
  points: Scalars['Int']['output'];
  /** Навыки и проценты для каждого вопроса */
  questionSkills: Array<SkillWithNameInChecklist>;
  /** Категория секции */
  sectionCategory: Scalars['String']['output'];
  /** Навыки и проценты для задания */
  taskSkills: Array<SkillWithNameInChecklist>;
};

/** Новые данные разбалловки */
export type CountInfoInput = {
  /** Процент бонусной части */
  percentageOfBonus: Scalars['Int']['input'];
  /** Балл за задание */
  points: Scalars['Int']['input'];
  /** Навыки и проценты для каждого вопроса */
  questionSkills: Array<SkillWithNameInChecklistInput>;
  /** Навыки и проценты для задания */
  taskSkills: Array<SkillWithNameInChecklistInput>;
};

export type CounterInfo = {
  __typename?: 'CounterInfo';
  /** кол-во назначенных подборок */
  bound: Scalars['Int']['output'];
  /** всего подборок */
  total: Scalars['Int']['output'];
};

export type CounterInvite = {
  __typename?: 'CounterInvite';
  teamId: Scalars['UUID']['output'];
  teamName: Scalars['String']['output'];
};

export type CounterView = {
  __typename?: 'CounterView';
  teamId: Scalars['UUID']['output'];
  teamName: Scalars['String']['output'];
};

export enum CountingFormulaType {
  Average = 'AVERAGE',
  Maximum = 'MAXIMUM',
  Minimum = 'MINIMUM',
  Weighted = 'WEIGHTED'
}

export type Country = {
  __typename?: 'Country';
  hasRegions: Scalars['Boolean']['output'];
  id: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
};

/** Название сущностей, назначенных на курс с привязкой к типу */
export type CourseAssignedEntitiesNamesByType = {
  __typename?: 'CourseAssignedEntitiesNamesByType';
  /** Массив названий сущностей, относящихся этому типу */
  assignedEntitiesNames: Array<Scalars['String']['output']>;
  /** Тип сущности, на которую назначается курс */
  assignedEntityType: LocalCourseAssignedEntityType;
  /** Количество сущностей */
  countEntities: Scalars['Int']['output'];
};

/** Базовые параметры курса */
export type CourseBaseParameters = {
  __typename?: 'CourseBaseParameters';
  /** Признак, является ли курс оцениваемым */
  isGradedCourse: Scalars['Boolean']['output'];
};

/** Информация о консистентности курса */
export type CourseConsistency = {
  __typename?: 'CourseConsistency';
  /** Идентификатор курса */
  courseId: Scalars['ID']['output'];
  /** Список объектов, содержащих параметры консистентности проектов курса */
  goalConsistencyModels?: Maybe<Array<GoalConsistency>>;
  /** В курсе есть проект без дедлайнов и со случайным формированием команды */
  hasDeadlineFreeRandomTeam?: Maybe<Scalars['Boolean']['output']>;
  /** Признак консистентности всех проектов в курсе */
  isAllGoalsConsistent: Scalars['Boolean']['output'];
  /** Признак консистентности курса */
  isConsistent: Scalars['Boolean']['output'];
  /** Конструкторы для проекта корректны */
  isConstructorsValid?: Maybe<Scalars['Boolean']['output']>;
  /** Название курса */
  name: Scalars['String']['output'];
};

/** Информация на обложке курса для студента */
export type CourseCoverInformation = {
  __typename?: 'CourseCoverInformation';
  /** Описание курса */
  courseDescription: Scalars['String']['output'];
  /** Наименование курса */
  courseName: Scalars['String']['output'];
  /**
   * Статус курса (deprecated)
   * @deprecated изменен на расширенный список отображаемых статусов (DisplayedCourseStatus)
   */
  courseStatus?: Maybe<CourseStatus>;
  /** История статусов курсов (отсортированная от раннего к позднему) */
  courseStatusesHistory: Array<CourseStatus>;
  /** Тип курса */
  courseType: CourseType;
  /** Кол-во текущих пользователей которые сейчас проходит курс */
  currentStudentCount: Scalars['Int']['output'];
  /** Статус курса */
  displayedCourseStatus?: Maybe<DisplayedCourseStatus>;
  /** Суммарная продолжительность всех проектов внутри курса */
  duration: Scalars['Int']['output'];
  /** Максимальный балл за прохождение курса */
  experience: Scalars['Int']['output'];
  /** Фактический балл за прохождение курса */
  experienceFact?: Maybe<Scalars['Int']['output']>;
  /** Фактический % выполнения курса */
  finalPercentage: Scalars['Int']['output'];
  /** Кол-во успешных завершений курса */
  finishedCount: Scalars['Int']['output'];
  /** ИД глобального курса */
  globalCourseId?: Maybe<Scalars['ID']['output']>;
  /** Отображение кнопки для ручного завершения курса */
  isCourseCanBeFinished?: Maybe<Scalars['Boolean']['output']>;
  /** Возможно ли запустить повторную попытку выполнения курса */
  isRetryAvailable?: Maybe<Scalars['Boolean']['output']>;
  /** Идентификатор локального курса */
  localCourseId?: Maybe<Scalars['ID']['output']>;
  /** Статус результата последней попытки выполнения курса */
  resultCourseCompletion?: Maybe<CompletionResultStatus>;
  /** Кол-во попыток прохождения курса */
  retriesCount: Scalars['Int']['output'];
  /** Кол-во попыток прохождения курса текущими пользователями */
  retriesOfCurrentStudents: Scalars['Int']['output'];
  /** Дата окончания регистрации на курс */
  signUpEndDate?: Maybe<Scalars['DateTime']['output']>;
  /** Дата начала регистрации на курс */
  signUpStartDate?: Maybe<Scalars['DateTime']['output']>;
  /** Список гибких навыков с макс. кол-вом очков за все задания этого курса */
  softSkills: Array<SoftSkillPoint>;
  /** Кол-во команд ожидающих проверки по групповым проектам */
  teamsWaitingEvaluationCount: Scalars['Int']['output'];
  /**
   * Timeline курса, список этапов прохождения проекта со статусами и опциональными датами начала/окончания
   * каждого этапа
   */
  timeline: Array<ProjectTimelineItem>;
  /** Дата окончания выполнения проекта */
  workEndDate?: Maybe<Scalars['DateTime']['output']>;
  /** Дата начала выполнения проекта */
  workStartDate?: Maybe<Scalars['DateTime']['output']>;
};

export type CourseGoalExperience = {
  __typename?: 'CourseGoalExperience';
  /** Идентификатор проекта в глобальном курсе */
  courseGoalId: Scalars['ID']['output'];
  /** Опыт, выдаваемый за прохождение проекта в курсе */
  experience: Scalars['Int']['output'];
};

/** Модель весов для проекта в курсе */
export type CourseGoalWeightInput = {
  /** Идентификатор проекта в глобальном курсе */
  globalCourseGoalId: Scalars['ID']['input'];
  /** Вес проекта в курсе */
  weight: Scalars['Int']['input'];
};

/** Модель весов для проекта в курсе c XP */
export type CourseGoalXpAndWeight = {
  __typename?: 'CourseGoalXpAndWeight';
  /** Количество получаемого опыта (рассчитываемое) */
  experience?: Maybe<Scalars['Int']['output']>;
  /** Идентификатор проекта в глобальном курсе */
  globalCourseGoalId: Scalars['ID']['output'];
  /** Название проекта */
  projectName: Scalars['String']['output'];
  /** Вес проекта в курсе в % */
  weight?: Maybe<Scalars['Int']['output']>;
};

/** Модель весов для всех проектов в курсе c XP */
export type CourseGoalsWeights = {
  __typename?: 'CourseGoalsWeights';
  /** Список проектов с весами и XP */
  projectsWeights: Array<CourseGoalXpAndWeight>;
  /** Суммарный % весов за все проекты курса */
  sumWeight: Scalars['Int']['output'];
  /** Суммарное XP за курс за все проекты курса */
  sumXp: Scalars['Int']['output'];
};

/** Мета-информация по группе проектов (курс) */
export type CourseMeta = {
  __typename?: 'CourseMeta';
  /** Тип формулы финальной сборки */
  attemptCountingFormula?: Maybe<AttemptCountingFormulaEnum>;
  /** Количесто попыток перепрохождения */
  attemptsCount?: Maybe<Scalars['Int']['output']>;
  /** Список контент-тегов */
  contentTags: Array<ContentTag>;
  /** Идентификатор курса */
  courseId: Scalars['ID']['output'];
  /** Тип курса */
  courseType: CourseType;
  /** Дата создания задания */
  createTime: Scalars['DateTime']['output'];
  /** Пользователь, создавший задание */
  createUser: User;
  /** Описание курса */
  description: Scalars['String']['output'];
  /** Максимальный балл за прохождение курса */
  experience: Scalars['Int']['output'];
  /** Список объектов, содержащих параметры консистентности проектов курса */
  goalConsistencyModels?: Maybe<Array<GoalConsistency>>;
  /** Количество проектов в курсе */
  goalCount: Scalars['Int']['output'];
  /** Признак наличия проектов в курсе */
  hasGoals: Scalars['Boolean']['output'];
  /** Признак консистентности всех проектов в курсе */
  isAllGoalsConsistent: Scalars['Boolean']['output'];
  /**
   * Признак Глобальной области видимости всех проектов в курсе
   * @deprecated включен в формулу вычисления признака консистентности Курса - isConsistent, теперь его передача на фронт не требуется
   */
  isAllGoalsGlobalScoped?: Maybe<Scalars['Boolean']['output']>;
  /** Признак заархивированности курса */
  isArchived?: Maybe<Scalars['Boolean']['output']>;
  /** Признак консистентности курса */
  isConsistent: Scalars['Boolean']['output'];
  /** Признак опубликованности курса */
  isPublic?: Maybe<Scalars['Boolean']['output']>;
  /** Признак неограниченного кол-ва попыток перепрохождения */
  isUnlimitedAttempts?: Maybe<Scalars['Boolean']['output']>;
  /** Дата последнего изменения задания */
  modifyTime?: Maybe<Scalars['DateTime']['output']>;
  /** Пользователь, который последний раз модифицировал задание */
  modifyUser?: Maybe<User>;
  /** Название курса */
  name: Scalars['String']['output'];
  /** Порог прохождения экзамена в % */
  percentageOfCompletion: Scalars['Int']['output'];
  /** Набор уровней обучения, в которых находятся модули(проекты) курса */
  planStages: Array<Stage>;
  /** Предмет */
  subject: Subject;
  /** Тэги */
  tags: Array<Scalars['String']['output']>;
};

/** Мета-информация по группе проектов (курс) */
export type CourseMetaInput = {
  /** Тип формулы финальной сборки */
  attemptCountingFormula?: InputMaybe<AttemptCountingFormulaEnum>;
  /** Количесто попыток перепрохождения */
  attemptsCount?: InputMaybe<Scalars['Int']['input']>;
  /** Список контент-тегов */
  contentTags?: InputMaybe<Array<ContentTagInput>>;
  /** Идентификатор курса */
  courseId?: InputMaybe<Scalars['ID']['input']>;
  /** Тип курса */
  courseType: CourseType;
  /** Описание курса */
  description: Scalars['String']['input'];
  /** Максимальный балл за прохождение курса */
  experience: Scalars['Int']['input'];
  /** Признак неограниченного кол-ва попыток перепрохождения */
  isUnlimitedAttempts?: InputMaybe<Scalars['Boolean']['input']>;
  /** Название курса */
  name: Scalars['String']['input'];
  /** Порог прохождения экзамена в % */
  percentageOfCompletion: Scalars['Int']['input'];
  /** Идентификатор предмета */
  subjectId: Scalars['ID']['input'];
  /** Список тегов */
  tags: Array<Scalars['String']['input']>;
};

export type CourseMutations = {
  __typename?: 'CourseMutations';
  /** Изменение статуса локальных курсов по результату критериального поиска или по списку id локальных курсов */
  changePublicationStatusForLocalCourses: Scalars['Boolean']['output'];
  /** Завершение публикации пачки локальных курсов */
  completionOfPublishS21LocalCourses: Scalars['Boolean']['output'];
  /** Завершить курс студентом по кнопке */
  finishCourse: Scalars['Boolean']['output'];
  /**
   * -----------------------------Мутации админа-----------------------------
   *  Публикация глобального курса по его идентификатору без предварительного сохранения
   */
  publishGlobalCourseById: Scalars['Boolean']['output'];
  /** Публикация локального курса по его идентификатору без предварительного сохранения */
  publishLocalCourseById: Scalars['Boolean']['output'];
  /**
   * -----------------------------Мутации студента-----------------------------
   *  регистрация на курс студентом
   */
  registrationForTheCourse: StudentCourseModel;
  /** Начать новую попытку прохождения курса */
  retryCourse?: Maybe<Scalars['Boolean']['output']>;
  /** Повторная попытка сохранения локального курса с текущей версией */
  retryLocalCourseSavingWithCurrentVersion: Scalars['Boolean']['output'];
  /** Повтороное сохранение локального курса в пакете */
  retryPublishingS21LocalCourseByPackageItemId: Scalars['Boolean']['output'];
  /** Откат локального курса до последней успешной версии */
  rollbackLocalCourseToLastSuccessVersion: Scalars['Boolean']['output'];
  /** Откат публикации локального курса в пакете */
  rollbackS21LocalCoursesSaveProcessItem: Scalars['Boolean']['output'];
  /** Сохранение настроек выполнения для глобального курса (группы проектов) вне плана */
  saveCourseEvaluationRulesWithoutPlan: Array<EvaluationRuleGroup>;
  /** Сохранение настроек условий фильтрации для модуля (проекта, цели) в локальном курсе */
  saveEvaluationRulesForLocalCourseGoal: Array<EvaluationRuleGroup>;
  /** Сохранение/обновление локального курса */
  saveLocalCourse: LocalCourse;
  /** Сохранение настроек условий заданного типа для локального курса вне плана */
  saveLocalCourseEvaluationRulesWithoutPlan: Array<EvaluationRuleGroup>;
  /** Сохранение параметров команды в модуле локального курса */
  saveTeamSettingsInLocalCourseGoal: Scalars['Boolean']['output'];
  /** Пропустить публикацию локального курса */
  skipS21LocalCoursesSaveProcessItem: Scalars['Boolean']['output'];
};


export type CourseMutationsChangePublicationStatusForLocalCoursesArgs = {
  criteria?: InputMaybe<LocalCourseSearchCriteriaInput>;
  isPublished: Scalars['Boolean']['input'];
  localCourseIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type CourseMutationsFinishCourseArgs = {
  localCourseId: Scalars['ID']['input'];
};


export type CourseMutationsPublishGlobalCourseByIdArgs = {
  courseId: Scalars['ID']['input'];
};


export type CourseMutationsPublishLocalCourseByIdArgs = {
  localCourseId: Scalars['ID']['input'];
};


export type CourseMutationsRegistrationForTheCourseArgs = {
  localCourseId: Scalars['ID']['input'];
};


export type CourseMutationsRetryCourseArgs = {
  localCourseId: Scalars['ID']['input'];
};


export type CourseMutationsRetryLocalCourseSavingWithCurrentVersionArgs = {
  localCourseId: Scalars['ID']['input'];
};


export type CourseMutationsRetryPublishingS21LocalCourseByPackageItemIdArgs = {
  s21LocalCoursesSavingPackageItemId: Scalars['ID']['input'];
};


export type CourseMutationsRollbackLocalCourseToLastSuccessVersionArgs = {
  localCourseId: Scalars['ID']['input'];
};


export type CourseMutationsRollbackS21LocalCoursesSaveProcessItemArgs = {
  s21LocalCoursesSavingPackageItemId: Scalars['ID']['input'];
};


export type CourseMutationsSaveCourseEvaluationRulesWithoutPlanArgs = {
  conditionType: ConditionType;
  evaluationRules: Array<EvaluationRuleGroupInput>;
  globalCourseId: Scalars['ID']['input'];
};


export type CourseMutationsSaveEvaluationRulesForLocalCourseGoalArgs = {
  conditionType: ConditionType;
  evaluationRules: Array<EvaluationRuleGroupInput>;
  localCourseGoalId: Scalars['ID']['input'];
};


export type CourseMutationsSaveLocalCourseArgs = {
  localCourse: LocalCourseInput;
};


export type CourseMutationsSaveLocalCourseEvaluationRulesWithoutPlanArgs = {
  conditionType: ConditionType;
  evaluationRules: Array<EvaluationRuleGroupInput>;
  localCourseId: Scalars['ID']['input'];
};


export type CourseMutationsSaveTeamSettingsInLocalCourseGoalArgs = {
  isMulticampusEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  localCourseGoalId: Scalars['ID']['input'];
  teamSettings: TeamSettingsInput;
};


export type CourseMutationsSkipS21LocalCoursesSaveProcessItemArgs = {
  s21LocalCoursesSavingPackageItemId: Scalars['ID']['input'];
};

/** Статус публикации курса */
export enum CoursePublishedStatus {
  /** Все */
  All = 'ALL',
  /** Опубликован */
  Published = 'PUBLISHED',
  /** НЕ опубликован */
  Unpublished = 'UNPUBLISHED'
}

export type CourseQueries = {
  __typename?: 'CourseQueries';
  /** Проверка групповых проектов в локальном курсе (группе проектов) */
  checkGroupProjectsInLocalCourse: Scalars['Boolean']['output'];
  /** Критериальный поиск локальных курсов */
  findLocalCoursesByCriteria: LocalCourseSearchResult;
  /** Получить информацию о попытке прохождения курса */
  getAttemptInfo: StudentCourseAttempt;
  /** Получить список классов доступных для назначения курса */
  getAvailableClassesForAssignmentToTheCourse: Array<AvailableClassForAssignmentCourse>;
  /** Получение возможных действий для курсов, попадающих под критерий поиска */
  getAvailablePublicationActionsForLocalCoursesByCriteria: AvailablePublicationActions;
  /** Получение статистики по попыткам прохождения курса студентом */
  getCourseAttemptStatistic?: Maybe<Array<Maybe<StudentCourseAttemptStatistic>>>;
  /** Получение статистики по попыткам прохождения курса для определённого студента */
  getCourseAttemptStatisticByStudent?: Maybe<Array<Maybe<StudentCourseAttemptStatistic>>>;
  /** Получение информации по обложке локального курса */
  getCourseCoverInformation: CourseCoverInformation;
  /** Получение информации по обложке локального курса для определённого студента */
  getCourseCoverInformationByStudent: CourseCoverInformation;
  /**
   * Получение списка модулей курса для дашборда, в зависимости от id глобального курса.
   * Сортировка реализована только по полю localizedType - для идентичности с дашбордом по планам
   */
  getCourseModulesForDashboard: DashboardCourseModules;
  /** Получить информацию по ретраям курса студента */
  getCourseRetryInfo: StudentGoalRetryInfo;
  /** Получить информацию по ретраям курса студента */
  getCourseRetryInfoByStudent: StudentGoalRetryInfo;
  /**
   * -----------------------------Запросы админа-----------------------------
   *  Получить список глобальный курсов с учетом указанных фильтров
   */
  getCourses: GlobalCourseSearchResult;
  /** Возвращает локальный курс по идентификатору */
  getLocalCourse: LocalCourse;
  /** Получить локальный курс по идентификатору глобального курса */
  getLocalCourseByGlobalCourseId: LocalCourse;
  /**
   * -----------------------------Запросы студента-----------------------------
   *  Получение информации по локальному курсу в окне Projects
   */
  getLocalCourseGoals: LocalCourseGoals;
  /** Получение информации по локальному курсу в окне Projects для определённого студента */
  getLocalCourseGoalsByStudent: LocalCourseGoals;
  /** Получить текущий статус по процессу сохранения локального курса */
  getLocalCourseS21SavingProgress: LocalCourseS21SavingProgress;
  /** Получение процесса сохранения локальных курсов. Nullable и не более одной is_active */
  getS21LocalCoursesSavingPackage?: Maybe<S21LocalCoursesSavingPackage>;
  /** Получение условий выполнения курса */
  loadCourseEvaluationRules: Array<StudentEvaluationRuleGroup>;
  /** Получение условий выполнения курса для определённого студента */
  loadCourseEvaluationRulesByStudent: Array<StudentEvaluationRuleGroup>;
  /** Запрос настроек условий заданного типа для курса (группы проектов) вне плана */
  loadCourseEvaluationRulesWithoutPlan: Array<EvaluationRuleGroup>;
  /** Запрос на получение всех попыток и всех гибких навыков за попытки по локальному курсу */
  loadLocalCourseAttemptsSoftSkills?: Maybe<LocalCourseAttemptsSoftSkills>;
  /** Запрос настроек условий заданного типа для локального курса вне плана */
  loadLocalCourseEvaluationRuleGroupsWithoutPlan: EvaluationRuleGroupsWithEquivalentFlag;
  /** Получение списка проектов и количества в них студентов, которые ещё не закончили обучение */
  loadUnfinishedGoalsAndStudentCount: Array<GoalStudentsCount>;
  /** Валидация локального курса перед сохранением */
  validationLocalCourseBeforeSaving: Scalars['Boolean']['output'];
};


export type CourseQueriesCheckGroupProjectsInLocalCourseArgs = {
  localCourse: LocalCourseInput;
};


export type CourseQueriesFindLocalCoursesByCriteriaArgs = {
  criteria: LocalCourseSearchCriteriaInput;
};


export type CourseQueriesGetAttemptInfoArgs = {
  studentCourseAttemptId: Scalars['ID']['input'];
};


export type CourseQueriesGetAvailableClassesForAssignmentToTheCourseArgs = {
  className?: InputMaybe<Scalars['String']['input']>;
  courseId?: InputMaybe<Scalars['ID']['input']>;
  stageId?: InputMaybe<Scalars['ID']['input']>;
};


export type CourseQueriesGetAvailablePublicationActionsForLocalCoursesByCriteriaArgs = {
  criteria: LocalCourseSearchCriteriaInput;
};


export type CourseQueriesGetCourseAttemptStatisticArgs = {
  localCourseId: Scalars['ID']['input'];
};


export type CourseQueriesGetCourseAttemptStatisticByStudentArgs = {
  localCourseId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type CourseQueriesGetCourseCoverInformationArgs = {
  localCourseId: Scalars['ID']['input'];
};


export type CourseQueriesGetCourseCoverInformationByStudentArgs = {
  localCourseId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type CourseQueriesGetCourseModulesForDashboardArgs = {
  globalCourseId: Scalars['ID']['input'];
  paging?: InputMaybe<PagingInput>;
  sorting?: InputMaybe<SortingField>;
};


export type CourseQueriesGetCourseRetryInfoArgs = {
  localCourseId: Scalars['ID']['input'];
};


export type CourseQueriesGetCourseRetryInfoByStudentArgs = {
  localCourseId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type CourseQueriesGetCoursesArgs = {
  coursePublishedStatus?: InputMaybe<CoursePublishedStatus>;
  courseType?: InputMaybe<CourseType>;
  filterExceptCourses?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  name?: InputMaybe<Scalars['String']['input']>;
  paging?: InputMaybe<PagingInput>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type CourseQueriesGetLocalCourseArgs = {
  localCourseId: Scalars['ID']['input'];
};


export type CourseQueriesGetLocalCourseByGlobalCourseIdArgs = {
  courseEndRegisterDate?: InputMaybe<Scalars['DateTime']['input']>;
  courseStartDate?: InputMaybe<Scalars['DateTime']['input']>;
  courseStartRegisterDate?: InputMaybe<Scalars['DateTime']['input']>;
  globalCourseId: Scalars['ID']['input'];
};


export type CourseQueriesGetLocalCourseGoalsArgs = {
  localCourseId: Scalars['ID']['input'];
};


export type CourseQueriesGetLocalCourseGoalsByStudentArgs = {
  localCourseId: Scalars['ID']['input'];
  sortingFields: Array<SortingField>;
  studentId: Scalars['UUID']['input'];
};


export type CourseQueriesGetLocalCourseS21SavingProgressArgs = {
  localCourseId: Scalars['ID']['input'];
};


export type CourseQueriesLoadCourseEvaluationRulesArgs = {
  localCourseId: Scalars['ID']['input'];
};


export type CourseQueriesLoadCourseEvaluationRulesByStudentArgs = {
  localCourseId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type CourseQueriesLoadCourseEvaluationRulesWithoutPlanArgs = {
  conditionType: ConditionType;
  globalCourseId: Scalars['ID']['input'];
};


export type CourseQueriesLoadLocalCourseAttemptsSoftSkillsArgs = {
  studentCourseId: Scalars['ID']['input'];
};


export type CourseQueriesLoadLocalCourseEvaluationRuleGroupsWithoutPlanArgs = {
  conditionType: ConditionType;
  localCourseId: Scalars['ID']['input'];
};


export type CourseQueriesLoadUnfinishedGoalsAndStudentCountArgs = {
  goalIds: Array<Scalars['ID']['input']>;
  localCourseId: Scalars['ID']['input'];
};


export type CourseQueriesValidationLocalCourseBeforeSavingArgs = {
  localCourseInput: LocalCourseInput;
};

/** Информация о результатах попытки в мета */
export type CourseResultMeta = {
  __typename?: 'CourseResultMeta';
  attemptCountingFormula: Scalars['String']['output'];
  courseSoftSkillForMeta: Array<CourseSoftSkillForMeta>;
  studentCourseAttemptId: Scalars['ID']['output'];
};

/** Тип для работы с поиском курсов */
export type CourseSearchResult = {
  __typename?: 'CourseSearchResult';
  /** Количество курсов соответствующих фильтру */
  count: Scalars['Int']['output'];
  /** Найденные курсы */
  courses?: Maybe<Array<CourseMeta>>;
};

/** Информация о результатах гибких навыков попытки в мета */
export type CourseSoftSkillForMeta = {
  __typename?: 'CourseSoftSkillForMeta';
  maxAvailableSoftSkillPoint?: Maybe<Scalars['Int']['output']>;
  softSkillId: Scalars['ID']['output'];
  softSkillPoint: Scalars['Int']['output'];
};

/** Статус группы проектов (курса) */
export enum CourseStatus {
  /** Курс сдан успешно */
  Accepted = 'ACCEPTED',
  /** Студент записан на курс */
  Assigned = 'ASSIGNED',
  /** Курс сдан не успешно */
  Failed = 'FAILED',
  /** Студент зарегистрировался на курс */
  InProgress = 'IN_PROGRESS',
  /** Студент зарегистрировался на курс */
  Registered = 'REGISTERED'
}

/** Тип группы проектов (курса) */
export enum CourseType {
  /** Интенсив */
  Intensive = 'INTENSIVE',
  /** Марафон */
  Marathon = 'MARATHON',
  /** Модульный проект */
  ModuleProject = 'MODULE_PROJECT',
  /** Самостоятельные проекты */
  SeparateProjects = 'SEPARATE_PROJECTS'
}

/** Результаты поиска проектов и курсов в глобальном поиске Ш21 */
export type CoursesSearchResult = {
  __typename?: 'CoursesSearchResult';
  /** Общее количество найденных профилей */
  count?: Maybe<Scalars['Int']['output']>;
  /** Проекты с учетом пагинации */
  courses: Array<Maybe<StudentItem>>;
};

/** Тип повтора при создании урока */
export enum CreateLessonRepeat {
  /** Нет повтора */
  None = 'NONE',
  /** Еженедельно */
  Weekly = 'WEEKLY'
}

export type CreateTaskSetSlotRequest = {
  /** флаг - проверять аффектит ли учебный процесс студента выполняемое изменение */
  isNeedToCheckAffecting: Scalars['Boolean']['input'];
  /** флаг школы 21 */
  isSchool21?: InputMaybe<Scalars['Boolean']['input']>;
  /** новая структура слота */
  newSlot: TaskSetSlotInput;
  /** необязательный идентификатор студента для того, чтобы в ответ получить персональную информацию по заданиям, добавленным в слот */
  studentIdForContext?: InputMaybe<Scalars['UUID']['input']>;
  /** идентификатор набора заданий (base_playlists.base_playlist_id или teacher_playlists.teacher_playlist_id) */
  taskSetId: Scalars['ID']['input'];
  /** тип плейлиста */
  taskSetType: PlaylistType;
};

export type CreateTaskSetSlotResponse = {
  __typename?: 'CreateTaskSetSlotResponse';
  /** измененный слот */
  createdSlot?: Maybe<TaskSetSlot>;
  /** успешно ли выполнение запроса (пройдены ли все проверки) */
  isSuccess: Scalars['Boolean']['output'];
  /** задания в контексте студента для случая, когда плейлист изменяется в контексте студента */
  studentTasks: Array<StudentTask>;
};

export type Criteria = {
  __typename?: 'Criteria';
  criteriaId: Scalars['ID']['output'];
  criteriaSetId: Scalars['ID']['output'];
  isActive?: Maybe<Scalars['Boolean']['output']>;
  name: Scalars['String']['output'];
  skillId?: Maybe<Scalars['ID']['output']>;
};

export type CriteriaInput = {
  name: Scalars['String']['input'];
  skillId?: InputMaybe<Scalars['ID']['input']>;
};

export enum CriteriaRecommendedValue {
  /** Не зачтено */
  NotPassed = 'NOT_PASSED',
  /** Зачтено */
  Passed = 'PASSED',
  /** Зачтено. Оценка - 3 */
  Passed_3 = 'PASSED_3',
  /** Зачтено. Оценка - 4 */
  Passed_4 = 'PASSED_4',
  /** Зачтено. Оценка - 5 */
  Passed_5 = 'PASSED_5'
}

export type CriteriaSet = {
  __typename?: 'CriteriaSet';
  criteriaSetId: Scalars['ID']['output'];
  criteriaThreshold: Scalars['Int']['output'];
  criterias: Array<Criteria>;
  isActive?: Maybe<Scalars['Boolean']['output']>;
  taskId: Scalars['ID']['output'];
};

export type CriteriaSetInput = {
  criteriaThreshold: Scalars['Int']['input'];
  criterias: Array<CriteriaInput>;
};

export enum CriteriaValue {
  /** Скорее соответствует */
  AlmostMatches = 'ALMOST_MATCHES',
  /** Скорее не соответствует */
  AlmostMismatch = 'ALMOST_MISMATCH',
  /** Полностью соответствует */
  Matches = 'MATCHES',
  /** Не соответствует */
  Mismatch = 'MISMATCH'
}

/** Критерий оценивания задания */
export type Criterion = {
  __typename?: 'Criterion';
  /** Идентификатор (task_assessment_criteria.task_assessment_criteria_id) */
  criterionId: Scalars['ID']['output'];
  /** Название критерия */
  title: Scalars['String']['output'];
};

/** Пресет связки критерия со шкалой */
export type CriterionPreset = {
  __typename?: 'CriterionPreset';
  /** Критерий */
  criterion: Criterion;
  /** Идентификатор (xref_criteria_scales.criteria_scale_id) */
  id: Scalars['ID']['output'];
  /** Шкала */
  scale: CriterionScale;
};

/** Шкала оценок по критериям */
export type CriterionScale = {
  __typename?: 'CriterionScale';
  /** Идентификатор (task_assessment_scales.task_assessment_scale_id) */
  criterionScaleId: Scalars['ID']['output'];
  /** Тип */
  description: Scalars['String']['output'];
  /** Максимальное значение шкалы */
  maxValue?: Maybe<Scalars['Int']['output']>;
  /** Минимальное значение шкалы */
  minValue?: Maybe<Scalars['Int']['output']>;
  /** Идентификаторы оценок */
  scaleWeights: Array<KeyValue>;
  /** Шаг шкалы */
  step?: Maybe<Scalars['Int']['output']>;
  /** Тип шкалы */
  type: CriterionScaleType;
};

/** Типы шкал для оценок заданий по критериям */
export enum CriterionScaleType {
  /** Шкала, состоящая из букв кириллицы */
  AlphabetCyrillic = 'ALPHABET_CYRILLIC',
  /** Шкала, состоящая из букв латинского алфавита */
  AlphabetLatin = 'ALPHABET_LATIN',
  /** S21 Шкала с 2-я статусами, успешно или провалено */
  Boolean = 'BOOLEAN',
  /** Произвольная шкала, значения оценок в которой заданы строками */
  Custom = 'CUSTOM',
  /** Целочисленная шкала */
  Numerical = 'NUMERICAL',
  /** S21 Шкала с 5-и бальной оценкой */
  Scale_5 = 'SCALE_5'
}

export type Currency = {
  __typename?: 'Currency';
  /** Код валюты по ISO-4217. */
  code: Scalars['String']['output'];
  /** Количество цифр после запятой в представлении стоимости. */
  fractionDigits: Scalars['Int']['output'];
  /** Символ для представления валюты ($, €, ₽...) */
  symbol?: Maybe<Scalars['String']['output']>;
};

/** Текущий и доступные скоупы для изменения текущим пользователем */
export type CurrentAndAvailableScopeTypes = {
  __typename?: 'CurrentAndAvailableScopeTypes';
  /** Доступные скоупы */
  available: Array<ScopeEnum>;
  /** @deprecated Не используется в бизнес-логике */
  availablePresets: Array<ScopePresetEnum>;
  /** Текущий скоуп */
  scope?: Maybe<ScopeEnum>;
};

/** Данные по текущим оценкам ученика */
export type CurrentMarksData = {
  __typename?: 'CurrentMarksData';
  /** Общее кол-во уроков за период */
  lessonsNumber: Scalars['Int']['output'];
  /** Список текущих оценок */
  marks: Array<EJournalStudentMark>;
  /** Кол-во пропущенных уроков за период */
  missedLessons: Scalars['Int']['output'];
  /**
   * ссылка на аватар учителя
   * @deprecated используйте userAccountOfSubjectTeacher
   */
  teacherAvatarUrl: Scalars['String']['output'];
  /**
   * имя учителя
   * @deprecated используйте userAccountOfSubjectTeacher
   */
  teacherName: Scalars['String']['output'];
  /** Учитель по предмету */
  userAccountOfSubjectTeacher: UserAccount;
};

/** Модель запроса текущих оценок */
export type CurrentMarksRequest = {
  /** Идентификатор пользователя ребенка */
  childUserId?: InputMaybe<Scalars['ID']['input']>;
  /** Идентификатор АП */
  periodId: Scalars['ID']['input'];
  /** Идентификатор типа АП */
  periodTypeId: Scalars['ID']['input'];
  /** Идентификатор предмета параллели */
  stageSubjectId: Scalars['ID']['input'];
};

/** Ответ на запрос текущих оценок */
export type CurrentMarksResponse = {
  __typename?: 'CurrentMarksResponse';
  /** Данные */
  data?: Maybe<CurrentMarksData>;
  /** Ошибки */
  error?: Maybe<FinalMarksError>;
  /** Успешность операции */
  isSuccess: Scalars['Boolean']['output'];
};

/** Тип содержит информацию о текущем модуле из планна на класс и его системе заданий */
export type CurrentModuleInfo = {
  __typename?: 'CurrentModuleInfo';
  /** Дата достижения учебного модуля в плане на класс */
  endDate: Scalars['DateTime']['output'];
  /** Идентификатор учебного модуля */
  moduleId: Scalars['ID']['output'];
  /** Название учебного модуля */
  moduleTitle: Scalars['String']['output'];
  /** Тип системы заданий */
  playlistType: PlaylistType;
  /** Дата начала изучения модуля в плане на класс */
  startDate: Scalars['DateTime']['output'];
  /** Идентификатор системы заданий из плана на класс */
  taskSetId: Scalars['ID']['output'];
  /** Общее Количество заданий, которое должно быть выполнено учениками в рамках модуля */
  totalTaskCount: Scalars['Int']['output'];
};

/** Тип содержит информацию о текущем модуле и статистику работы учеников с ним */
export type CurrentModulePerformance = {
  __typename?: 'CurrentModulePerformance';
  /** Текщий учебный модуль из плана класса по предмету */
  currentModule?: Maybe<CurrentModuleInfo>;
  /** Статистика работы учеников с текущим модулем */
  taskStatusesWithQuantities: Array<TaskStatusWithQuantity>;
};

/** Тип содержит информацию о количестве учеников в группах успеваемости в текущем учебном периоде */
export type CurrentPeriodPerformance = {
  __typename?: 'CurrentPeriodPerformance';
  /** Количество отличников */
  excellentCount: Scalars['Int']['output'];
  /** Количество отстающих */
  fallingBehindCount: Scalars['Int']['output'];
  /** Количество хорошистов */
  goodCount: Scalars['Int']['output'];
  /** Количество учеников без оценок */
  notRatedCount: Scalars['Int']['output'];
};

export type CurrentProgress = {
  __typename?: 'CurrentProgress';
  /** Прогресс по добавленным достижениям в профиль (суммарно) */
  achievementProgress: Scalars['Int']['output'];
  /** идентификатор большого вызова */
  bigChallengeId: Scalars['ID']['output'];
  /** Прогресс по учусь учиться (суммарно) */
  llTaskProgress: Scalars['Int']['output'];
  /** Прогресс по квестам в метавселенной (суммарно) */
  questProgress: Scalars['Int']['output'];
  /** id ученика */
  studentId: Scalars['UUID']['output'];
  /** Прогресс по категориям школьных предметов (суммарно) */
  subjectCategoryProgress: Scalars['Int']['output'];
};

/** Информация о заявке на расформирование команды */
export type CurrentTeamDisbandRequestInfo = {
  __typename?: 'CurrentTeamDisbandRequestInfo';
  /** Информация о проводимом голосовании для расформирования команды */
  disbandmentTeamVotingInfo?: Maybe<DisbandmentTeamVotingInfo>;
  /** Количество часов, которое заявка находится на рассмотрении */
  hoursToConsider?: Maybe<Scalars['Int']['output']>;
  /** Флаг отмечающий просроченные заявки */
  isExpiredRequest?: Maybe<Scalars['Boolean']['output']>;
  /** Флаг отмечающий новые заявки на расформирование команды */
  isNewRequest?: Maybe<Scalars['Boolean']['output']>;
  /** Название параллели, с которой пришла заявка */
  parallelName?: Maybe<Scalars['String']['output']>;
  /** Название проекта */
  projectName?: Maybe<Scalars['String']['output']>;
  /** Дата регистрации заявки */
  teamDisbandRequestDate?: Maybe<Scalars['DateTime']['output']>;
  /** Идентификатор заявки на расформирование команды */
  teamDisbandRequestId?: Maybe<Scalars['ID']['output']>;
  /** Информация о размере команды */
  teamSizeInfo?: Maybe<TeamSizeInfo>;
};

/** Информация о студенте за рабочей станцией с указанием места размещения */
export type CurrentWorkstationUser = {
  __typename?: 'CurrentWorkstationUser';
  /** Опыт пользователя */
  experience: UserExperience;
  /**
   * Идентификатор текущего уровня
   * @deprecated use experience. Will be deleted in 29.0
   */
  experienceLevelId: Scalars['Int']['output'];
  /** Номер места */
  number: Scalars['Int']['output'];
  /** Ряд */
  row: Scalars['String']['output'];
  /** Название класса */
  stageGroupName: Scalars['String']['output'];
  /** Название параллели */
  stageName: Scalars['String']['output'];
  /** Платформа студента */
  studentType: StudentPlatformType;
  /** Студент прошедший аутентификацию за рабочей станцией */
  user: User;
};

export type Customer = {
  __typename?: 'Customer';
  id: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
};

/** информация о посещаемости за день */
export type DailyTraffic = {
  __typename?: 'DailyTraffic';
  /** Дата, день когда была активность. */
  date: Scalars['Date']['output'];
  /** Время авторизации за рабочей станцией в кампусе (в секундах) */
  periodAuthorizIMac: Scalars['String']['output'];
  /** Время авторизации в ШЦП (в секундах) */
  periodAuthorizSDP: Scalars['String']['output'];
  /** Время посещения в кампусе (в секундах) */
  periodOnCampus: Scalars['String']['output'];
};

/** модель курса для dashboard */
export type DashboardCourseModules = {
  __typename?: 'DashboardCourseModules';
  /** общее количество проектов в курсе */
  count: Scalars['Int']['output'];
  /** модули плана */
  dashboardPlanItemModels: Array<Maybe<DashboardPlanItem>>;
  /** автоматическая настройка весов */
  isAutoWeightsSetting?: Maybe<Scalars['Boolean']['output']>;
  /** признак оцениваемый ли курс */
  isGradedCourse: Scalars['Boolean']['output'];
  /** наименование курса */
  name: Scalars['String']['output'];
  /** процент выполнения */
  percentageOfCompletion?: Maybe<Scalars['Int']['output']>;
  /** xp */
  pointTask?: Maybe<Scalars['Int']['output']>;
};

/** модель элемента плана для dashboard */
export type DashboardPlanItem = {
  __typename?: 'DashboardPlanItem';
  /** формула вычисления */
  attemptCountingFormula?: Maybe<AttemptCountingFormulaEnum>;
  /** количество попыток выполнения */
  attemptsNumber?: Maybe<Scalars['Int']['output']>;
  /** Bonus xp */
  bonusXP?: Maybe<Scalars['Int']['output']>;
  /** тип формулы подсчета итогового балла */
  countingFormulaType?: Maybe<CountingFormulaType>;
  /** тип курса */
  courseType?: Maybe<CourseType>;
  /** если это курс, проекты внутри курса */
  dashboardPlanItemModelList: Array<Maybe<DashboardPlanItem>>;
  /** id курса */
  globalCourseId?: Maybe<Scalars['Int']['output']>;
  /** id в плане */
  globalPlanModuleId?: Maybe<Scalars['Int']['output']>;
  /** тип проекта */
  goalExecutionType?: Maybe<ModuleExecutionType>;
  /** id проекта */
  goalId?: Maybe<Scalars['Int']['output']>;
  /** Автотест */
  isAutotest?: Maybe<Scalars['Boolean']['output']>;
  /** cicd */
  isCiCd?: Maybe<Scalars['Boolean']['output']>;
  /** Кодревью */
  isCodeReview?: Maybe<Scalars['Boolean']['output']>;
  /** p2p проверка */
  isP2P?: Maybe<Scalars['Boolean']['output']>;
  /** длительность */
  laboriousness?: Maybe<Scalars['Int']['output']>;
  /** Локализованное название типа проекта/курса */
  localizedType?: Maybe<Scalars['String']['output']>;
  /** название модуля */
  name: Scalars['String']['output'];
  /** порядок */
  order?: Maybe<Scalars['Int']['output']>;
  /** количество процентов за лидерство */
  percentageForLeadership?: Maybe<Scalars['Int']['output']>;
  /** процент выполнения */
  percentageOfCompletion?: Maybe<Scalars['Int']['output']>;
  /** xp */
  pointTask?: Maybe<Scalars['Int']['output']>;
};

/** модель плана для dashboard */
export type DashboardPlanModules = {
  __typename?: 'DashboardPlanModules';
  /** количество записей */
  count?: Maybe<Scalars['Int']['output']>;
  /** модули плана */
  dashboardPlanItemModels: Array<Maybe<DashboardPlanItem>>;
};

/** Активность пользователей за периоды */
export type DashboardUsersActivity = {
  __typename?: 'DashboardUsersActivity';
  /** @deprecated Field no longer supported */
  activeUsersCount: Scalars['Int']['output'];
  activeUsersCountNullable?: Maybe<Scalars['Int']['output']>;
  period: Scalars['String']['output'];
};

/** Интервал дат */
export type DateInterval = {
  __typename?: 'DateInterval';
  endDate: Scalars['Date']['output'];
  intervalCode?: Maybe<Scalars['Int']['output']>;
  startDate: Scalars['Date']['output'];
};

/** Интервал дат для сохранения */
export type DateIntervalInput = {
  endDate: Scalars['Date']['input'];
  intervalCode: Scalars['Int']['input'];
  startDate: Scalars['Date']['input'];
};

/** Отчетные периоды */
export type DateIntervals = {
  __typename?: 'DateIntervals';
  dateIntervals: Array<DateInterval>;
};

export type DatePeriodLessonPlanInput = {
  endDate: Scalars['Date']['input'];
  startDate: Scalars['Date']['input'];
};

/** Дедлайн для Ш21 */
export type Deadline = {
  __typename?: 'Deadline';
  /** Комментарий к дедлайну */
  comment?: Maybe<Scalars['String']['output']>;
  /** Дата создания */
  createTs: Scalars['DateTime']['output'];
  /** Идентификатор дедлайна */
  deadlineId: Scalars['ID']['output'];
  /** Идентификатор родительского дедлайна */
  deadlineParentId?: Maybe<Scalars['ID']['output']>;
  /**
   * Время в днях до дедлайна
   * @deprecated Field no longer supported
   */
  deadlineToDays: Scalars['Int']['output'];
  /** Время в днях до дедлайна */
  deadlineToDaysArray: Array<Maybe<Scalars['Int']['output']>>;
  /** Время наступления дедлайна */
  deadlineTs: Scalars['DateTime']['output'];
  /** Название дедлайна */
  description: Scalars['String']['output'];
  /** Тип дедлайна персональный или массовый */
  isPersonal: Scalars['Boolean']['output'];
  /** Набор правил для конструктора целей дедлайна */
  rules: Array<Maybe<EvaluationRuleGroup>>;
  /** Отсрочка */
  shift: Scalars['String']['output'];
  /** Классы дедлайна (для массового) */
  stageGroups?: Maybe<Array<Maybe<StageGroup>>>;
  /** Статус дедлайна */
  status: DeadlineStatus;
  /** Дата последнего изменения */
  updateTs?: Maybe<Scalars['DateTime']['output']>;
};

/** Конфигурация для игры в "Дедлайн" в рамках школы */
export type DeadlineGameConfiguration = {
  __typename?: 'DeadlineGameConfiguration';
  /** Кол-во часов, через которое можно снова получить печеньку за игру */
  cookieCoolDown: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  /** Максимальное кол-во печенек за одну игру */
  maxCookieCountPerGame: Scalars['Int']['output'];
};

/** Уровень в игре "Дедлайн" */
export type DeadlineGameLevel = {
  __typename?: 'DeadlineGameLevel';
  /** Id уровня, соответствующий числовому представлению */
  id: Scalars['ID']['output'];
  /** Наименование уровня */
  name: Scalars['String']['output'];
  /** Значения констант для уровня */
  range: DeadlineGameLevelRange;
};

export type DeadlineGameLevelInput = {
  attributes: Scalars['String']['input'];
  name: Scalars['String']['input'];
};

/** Диапазон значений констант для уровня в игре "Дедлайн" */
export type DeadlineGameLevelRange = {
  __typename?: 'DeadlineGameLevelRange';
  /** Константы для игры в виде JSON. Используется только на фронте */
  attributes: Scalars['String']['output'];
  /** ID диапазона */
  id: Scalars['ID']['output'];
  /** Уровень */
  level: Scalars['Int']['output'];
};

export type DeadlineGameResult = {
  __typename?: 'DeadlineGameResult';
  /** Кол-во заработанных печенек */
  cookieCount: Scalars['Int']['output'];
  /** Общее время в игре hh:mm:ss */
  durationTime: Scalars['Time']['output'];
  /** Дата и время игры */
  gameDateTime: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  /** Достигнутый уровень */
  levelId: Scalars['Int']['output'];
  /** Кол-во заработанных баллов */
  pointCount: Scalars['Int']['output'];
};

export type DeadlineGameResultInput = {
  /** Кол-во заработанных печенек */
  cookieCount: Scalars['Int']['input'];
  /** Общее время в игре, вида hh:mm:ss */
  durationTime: Scalars['String']['input'];
  /** Достигнутый уровень */
  levelId: Scalars['Int']['input'];
  /** Кол-во заработанных баллов */
  pointCount: Scalars['Int']['input'];
};

/** Необходимые цели дедлайна Ш21 */
export type DeadlineGoal = {
  __typename?: 'DeadlineGoal';
  /** Инфо о целевых группах проектов студента */
  goalCourses?: Maybe<Array<Maybe<CourseCoverInformation>>>;
  /** Инфо о целевых проектах студента */
  goalProjects?: Maybe<Array<Maybe<StudentProjectInfo>>>;
  /** Уровни, которые необходимо достичь */
  levels?: Maybe<Array<Maybe<ExperienceLevelRange>>>;
  /**
   * Проекты для завершения
   * @deprecated use goalProjects
   */
  projects?: Maybe<Array<Maybe<StudentModule>>>;
};

/** Инпут дедлайна Ш21 deprecated (использовать DeadlineS21Input) */
export type DeadlineInput = {
  /** Комментарий к дедлайну */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** Идентификатор родительского дедлайна */
  deadlineParentId?: InputMaybe<Scalars['UUID']['input']>;
  /** Время в днях до дедлайна */
  deadlineToDays: Scalars['Int']['input'];
  /** Время наступления дедлайна */
  deadlineTs: Scalars['DateTime']['input'];
  /** Название дедлайна */
  description: Scalars['String']['input'];
  /** Тип дедлайна персональный или массовый */
  isPersonal: Scalars['Boolean']['input'];
  /** Классы */
  stageGroups?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Идентификатор студента (для персонального дедлайна) */
  studentId?: InputMaybe<Scalars['UUID']['input']>;
};

/** Инпут дедлайна Ш21 */
export type DeadlineS21Input = {
  /** Комментарий к дедлайну */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** Идентификатор родительского дедлайна */
  deadlineParentId?: InputMaybe<Scalars['UUID']['input']>;
  /** Время в днях до дедлайна */
  deadlineToDaysArray: Array<InputMaybe<Scalars['Int']['input']>>;
  /** Время наступления дедлайна */
  deadlineTs: Scalars['DateTime']['input'];
  /** Название дедлайна */
  description: Scalars['String']['input'];
  /** Тип дедлайна персональный или массовый */
  isPersonal: Scalars['Boolean']['input'];
  /** Классы */
  stageGroups?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Идентификатор студента (для персонального дедлайна) */
  studentId?: InputMaybe<Scalars['UUID']['input']>;
};

/** Запрос на отсрочку Дедлайна для Ш21 */
export type DeadlineShiftRequest = {
  __typename?: 'DeadlineShiftRequest';
  /** Комментарий студента */
  comment?: Maybe<Scalars['String']['output']>;
  /** Время создания */
  createTs: Scalars['DateTime']['output'];
  /** Количество дней для сдвига */
  daysToShift: Scalars['Int']['output'];
  /** Идентификатор дедлайна для сдвига */
  deadlineId: Scalars['UUID']['output'];
  /** Идентификатор запроса на сдвиг дедлайна */
  deadlineShiftRequestId: Scalars['UUID']['output'];
  /** Дата сдвигаемого дедлайна */
  deadlineTs: Scalars['DateTime']['output'];
  /** Статус запроса */
  status: DeadlineShiftRequestStatus;
  /** Идентификатор студента */
  studentId: Scalars['UUID']['output'];
  /** Идентификатор пользователя */
  userId: Scalars['UUID']['output'];
  /** Логин студента */
  userLogin: Scalars['String']['output'];
};

/** Запрос на отсрочку с привязанным дедлайном */
export type DeadlineShiftRequestInfo = {
  __typename?: 'DeadlineShiftRequestInfo';
  /** Дедлайн */
  deadline: Deadline;
  /** Запрос на отсрочку */
  shiftRequest: DeadlineShiftRequest;
};

/** Запрос на сдвиг дедлайна */
export type DeadlineShiftRequestInput = {
  /** Комментарий студента о причинах отсрочки */
  comment: Scalars['String']['input'];
  /** Идентификатор запрашиваемого дедлайна на сдвиг */
  deadlineId: Scalars['UUID']['input'];
};

/** Статус запроса на отсрочку дедлайна */
export enum DeadlineShiftRequestStatus {
  /** Удаленный */
  Cancelled = 'CANCELLED',
  /** Перенесенный */
  Shifted = 'SHIFTED',
  /** Новый */
  ToShift = 'TO_SHIFT'
}

/** Статус дедлайна */
export enum DeadlineStatus {
  /** Удаленный */
  Cancelled = 'CANCELLED',
  /** Закрытый (выполненный) */
  Closed = 'CLOSED',
  /** Новый */
  Open = 'OPEN',
  /** Просроченный */
  Overdue = 'OVERDUE',
  /** Перенесенный */
  Shifted = 'SHIFTED'
}

/** Инфо о дедлане для студента Ш21 */
export type DeadlineStudentInfo = {
  __typename?: 'DeadlineStudentInfo';
  /** Дедлайн */
  deadline: Deadline;
  /** Цель дедлайна */
  deadlineGoal?: Maybe<DeadlineGoal>;
  /** Количество отсрочек по дедлайну */
  shiftCount: Scalars['Int']['output'];
  /** Запросы на отсрочку по дедлайну */
  shiftRequests: Array<Maybe<DeadlineShiftRequest>>;
  /** Идентификатор студента */
  studentId: Scalars['UUID']['output'];
  /** Логин студента */
  studentLogin?: Maybe<Scalars['String']['output']>;
  /** Пользователь студента */
  studentUser: User;
};

export type DeckWidgetNotification = {
  __typename?: 'DeckWidgetNotification';
  academicYearName?: Maybe<Scalars['String']['output']>;
  achievedGoalLevel?: Maybe<Scalars['String']['output']>;
  controlWorkPlanTime?: Maybe<Scalars['String']['output']>;
  goalId?: Maybe<Scalars['ID']['output']>;
  goalName?: Maybe<Scalars['String']['output']>;
  governmentMarkValue?: Maybe<Scalars['String']['output']>;
  moduleEndTime?: Maybe<Scalars['String']['output']>;
  motivationBlockPresent?: Maybe<Scalars['Boolean']['output']>;
  notification: Notification;
  personalTrajectoryPresent?: Maybe<Scalars['Boolean']['output']>;
  studyPeriodEndDate?: Maybe<Scalars['String']['output']>;
  studyPeriodId?: Maybe<Scalars['ID']['output']>;
  studyPeriodName?: Maybe<Scalars['String']['output']>;
  studyPeriodStartDate?: Maybe<Scalars['String']['output']>;
  subjectId?: Maybe<Scalars['ID']['output']>;
  subjectName?: Maybe<Scalars['String']['output']>;
  targetGoalLevel?: Maybe<Scalars['String']['output']>;
  taskId?: Maybe<Scalars['String']['output']>;
  taskStatusId?: Maybe<Scalars['ID']['output']>;
  userFromFirstName?: Maybe<Scalars['String']['output']>;
  userFromLastName?: Maybe<Scalars['String']['output']>;
  wasSentToReviewer?: Maybe<Scalars['Boolean']['output']>;
};

export type DeclineReason = {
  __typename?: 'DeclineReason';
  declineType: DeclineType;
  description: Scalars['String']['output'];
  id: Scalars['UUID']['output'];
};

/** Тип причины отклонения заявки на участие в проекте акселератора */
export enum DeclineType {
  Recall = 'RECALL',
  Reject = 'REJECT'
}

/** Расшифровка вида контента */
export type DecodedContent = {
  __typename?: 'DecodedContent';
  /** код PK в базе (в зависимости от вида контента) */
  contentId: Scalars['ID']['output'];
  /** для кэша */
  id: Scalars['ID']['output'];
  /** вид контента */
  kind: ContentKind;
};

export type DefaultResponse = {
  __typename?: 'DefaultResponse';
  responseTime: Scalars['DateTime']['output'];
  status: Scalars['String']['output'];
};

export type DeleteGitlabProjectsResponse = {
  __typename?: 'DeleteGitlabProjectsResponse';
  success: Scalars['Boolean']['output'];
};

/** S21. Ответ на удаление файлов из решений проектов с платформенным типом решения */
export type DeletePlatfProjectSolutionsResponse = {
  __typename?: 'DeletePlatfProjectSolutionsResponse';
  /** Кол-во успешно удаленных файлов */
  deletedCount: Scalars['Int']['output'];
  /** Идентификаторы ответов студентов, в которых остались неудаленные файлы */
  studentAnswerIds: Array<Scalars['Int']['output']>;
  /** Общее кол-во файлов */
  totalCount: Scalars['Int']['output'];
};

export type DetailTrajectoryBtcInputModel = {
  /** Начало диапазона плановой даты начала обучения */
  planStartDateFrom?: InputMaybe<Scalars['Date']['input']>;
  /** Конец диапазона плановой даты начала обучения */
  planStartDateTo?: InputMaybe<Scalars['Date']['input']>;
  /** Траектории, фильтр по траекториям. Null, если не нужно фильтровать по траекториям */
  trajectories?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Уровень сложности задания */
export enum DifficultyLevelEnum {
  Difficult = 'DIFFICULT',
  Simple = 'SIMPLE'
}

/** Результат верификации направления программы */
export type DirectionValidation = {
  __typename?: 'DirectionValidation';
  /** Список ошибок валидации */
  errors: Array<Scalars['String']['output']>;
  /** Сообщение */
  info?: Maybe<Scalars['String']['output']>;
};

/** Идентификатор статуса заявки на расформирование команды */
export enum DisbandRequestStatus {
  /** На рассмотрении модератором */
  ConsiderationModerator = 'CONSIDERATION_MODERATOR',
  /** Расформирована автоматически */
  DisbandedAuto = 'DISBANDED_AUTO',
  /** Расформирована модератором */
  DisbandedModerator = 'DISBANDED_MODERATOR',
  /** Отклонена модератором */
  RejectedModerator = 'REJECTED_MODERATOR',
  /** Заявка подана */
  Submit = 'SUBMIT'
}

/** Информация о проводимом голосовании для расформирования команды */
export type DisbandmentTeamVotingInfo = {
  __typename?: 'DisbandmentTeamVotingInfo';
  /** Количество отправленных запросов на расформирование команды */
  numberOfRequestsSent?: Maybe<Scalars['Int']['output']>;
  /** Количество участников команды */
  numberOfTeamMembers?: Maybe<Scalars['Int']['output']>;
  /** Процент голосования */
  percentageOfVoting?: Maybe<Scalars['Int']['output']>;
};

/** Расширенный перечень статусов курсов(групп проектов). Вычисляется по запросу и не сохраняется в БД. */
export enum DisplayedCourseStatus {
  /** Курс выполне */
  Completed = 'COMPLETED',
  /** Курс провален */
  Failed = 'FAILED',
  /** В процессе выполнения */
  InProgress = 'IN_PROGRESS',
  /** Готов к выполнению */
  ReadyToStart = 'READY_TO_START',
  /** Регистрация временно недоступна */
  RegistrationIsNotAvailableYet = 'REGISTRATION_IS_NOT_AVAILABLE_YET',
  /** Регистрация открыта */
  RegistrationIsOpen = 'REGISTRATION_IS_OPEN',
  /** Курс недоступн */
  Unavailable = 'UNAVAILABLE',
  /** Ожидает начала выполнения */
  WaitingForStart = 'WAITING_FOR_START'
}

/** Расширенный перечень статусов целей, используемый только для frontend. Вычисляется по запросу и не сохраняется в БД. */
export enum DisplayedGoalStatus {
  /** Оценивается автоматически */
  AutoEvaluations = 'AUTO_EVALUATIONS',
  /** в процессе код ревью round1 */
  CodeReviewRound1 = 'CODE_REVIEW_ROUND1',
  /** в процессе код ревью round2 */
  CodeReviewRound2 = 'CODE_REVIEW_ROUND2',
  /** Цель выполнена */
  Completed = 'COMPLETED',
  /** Цель провалена */
  Failed = 'FAILED',
  /** В процессе выполнения */
  InProgress = 'IN_PROGRESS',
  /** Оценивается P2P */
  P2PEvaluations = 'P2P_EVALUATIONS',
  /** Готов к выполнению */
  ReadyToStart = 'READY_TO_START',
  /** Регистрация временно недоступна */
  RegistrationIsNotAvailableYet = 'REGISTRATION_IS_NOT_AVAILABLE_YET',
  /** Регистрация открыта */
  RegistrationIsOpen = 'REGISTRATION_IS_OPEN',
  /** Цель недоступна */
  Unavailable = 'UNAVAILABLE',
  /** Ожидает оценки */
  WaitingForEvaluations = 'WAITING_FOR_EVALUATIONS',
  /** Ожидает начала выполнения */
  WaitingForStart = 'WAITING_FOR_START',
  /** Ожидает проверку код ревью */
  WaitForCodeReview = 'WAIT_FOR_CODE_REVIEW',
  /** Ожидает проверку код ревью round1 */
  WaitForCodeReviewRound1 = 'WAIT_FOR_CODE_REVIEW_ROUND1',
  /** Ожидает проверку код ревью round2 */
  WaitForCodeReviewRound2 = 'WAIT_FOR_CODE_REVIEW_ROUND2'
}

/** Черновик */
export type Draft = {
  __typename?: 'Draft';
  /** Содержимое черновика */
  content: Scalars['String']['output'];
  /** ID задания или модуля к которому привязан черновик */
  entityId: Scalars['String']['output'];
  /** Время последнего редактирования */
  ts: Scalars['DateTime']['output'];
  /** Тип черновика */
  type: DraftTypeEnum;
};

export type DraftQueries = {
  __typename?: 'DraftQueries';
  /**
   * Получить черновик  ребенка-ученика
   * Если черновика нет, возвращается null
   */
  getChildDraft?: Maybe<Draft>;
  /**
   * Получить черновик ученика
   * Если черновика нет, возвращается null
   */
  getStudentDraft?: Maybe<Draft>;
};


export type DraftQueriesGetChildDraftArgs = {
  childUserId: Scalars['UUID']['input'];
  draftType: DraftTypeEnum;
  entityId: Scalars['String']['input'];
};


export type DraftQueriesGetStudentDraftArgs = {
  draftType: DraftTypeEnum;
  entityId: Scalars['String']['input'];
  studentUserId: Scalars['UUID']['input'];
};

/** Типы черновиков */
export enum DraftTypeEnum {
  /** Жалоба на модуль */
  GoalComplaint = 'GOAL_COMPLAINT',
  /** Содержание модуля */
  GoalContent = 'GOAL_CONTENT',
  /** Обобщенное состояние модуля в контексте пользователя */
  ModuleState = 'MODULE_STATE',
  /** Мотивационный блок */
  MotivationBlock = 'MOTIVATION_BLOCK',
  /** Персональный план */
  PersonalPlan = 'PERSONAL_PLAN',
  /** Ответ на задание */
  TaskAnswer = 'TASK_ANSWER',
  /** Комментарий к заданию */
  TaskComment = 'TASK_COMMENT',
  /** Комментарий к задания, приложеные файлы */
  TaskCommentContent = 'TASK_COMMENT_CONTENT',
  /** Жалоба на задание */
  TaskComplaint = 'TASK_COMPLAINT',
  /** Содержимое задания */
  TaskContent = 'TASK_CONTENT',
  /** Отзыв о задании */
  TaskFeedback = 'TASK_FEEDBACK',
  /** Профиль пользователя */
  UserProfile = 'USER_PROFILE'
}

/** Модель комментария в дневнике */
export type EDiaryComment = {
  __typename?: 'EDiaryComment';
  /** Текст комментария */
  comment: Scalars['String']['output'];
  /** Признак роли учителя гкпп */
  isStageSubjectGroupTeacher: Scalars['Boolean']['output'];
  /** Пользователь, последний внесший изменения в комментарий */
  user: User;
};

/** Модель данных дневника */
export type EDiaryData = {
  __typename?: 'EDiaryData';
  /** Данные уроков по дням */
  lessonsByDate: Array<EDiaryLessonsByDate>;
};

/** Модель ответа данных дневника */
export type EDiaryDataResponse = {
  __typename?: 'EDiaryDataResponse';
  /** Данные */
  data?: Maybe<EDiaryData>;
  /** Ошибки ЭД */
  error?: Maybe<EDiaryError>;
  /** Успешность операции */
  isSuccess: Scalars['Boolean']['output'];
};

/** Модель ошибки ЭД */
export type EDiaryError = {
  __typename?: 'EDiaryError';
  /** Код ошибки */
  errorCode: EDiaryErrorCode;
};

/** Коды ошибок ЭД */
export enum EDiaryErrorCode {
  /** Нет уроков в выбранном периоде */
  NoLessonsFound = 'NO_LESSONS_FOUND'
}

/** Модель данных урока в дневнике */
export type EDiaryLessonData = {
  __typename?: 'EDiaryLessonData';
  /** Номер кабинета, где проходит урок */
  classRoomName: Scalars['String']['output'];
  /** Количество заметок ученику, являющихся ДЗ к данному уроку */
  homeworkNotesNumber: Scalars['Int']['output'];
  /** Количество заданий и материалов, являющихся ДЗ к данному уроку */
  homeworkTaskAndMaterialNumber: Scalars['Int']['output'];
  /** Признак того, что в КТП на данный урок запланирована контрольная работа */
  isControlWork: Scalars['Boolean']['output'];
  /** Время опоздания в минутах */
  lateTime?: Maybe<Scalars['Int']['output']>;
  /** Комментарий к уроку */
  lessonComment?: Maybe<EDiaryComment>;
  /** Время окончания урока */
  lessonEndTime: Scalars['Time']['output'];
  /** Идентификатор урока */
  lessonId: Scalars['ID']['output'];
  /** Время начала урока */
  lessonStartTime: Scalars['Time']['output'];
  /** URL для подключения к дистанционному уроку */
  linkOnlineLesson?: Maybe<Scalars['String']['output']>;
  /** Оценки, полученные учеником на уроке */
  marks?: Maybe<Array<EDiaryMark>>;
  /** Комментарий к уроку для ученика */
  studentComment?: Maybe<EDiaryComment>;
  /** Статус посещаемости ученика для урока */
  studentVisitStatus?: Maybe<StudentVisitStatus>;
  /** Название предмета урока */
  subjectName: Scalars['String']['output'];
};

/** Модель данных дня в дневнике */
export type EDiaryLessonsByDate = {
  __typename?: 'EDiaryLessonsByDate';
  /** Дата */
  date: Scalars['Date']['output'];
  /** Признак каникул */
  isHoliday: Scalars['Boolean']['output'];
  /** Уроки на дату */
  lessons: Array<EDiaryLessonData>;
};

/** Модель оценки в дневнике */
export type EDiaryMark = {
  __typename?: 'EDiaryMark';
  /** Комментарий к оценке */
  comment?: Maybe<EDiaryComment>;
  /** Пользователь, который поставил оценку */
  createdUser: User;
  /** Название формы контроля, за которую выставлена оценка */
  formControlName: Scalars['String']['output'];
  /** Признак того, что форма контроля, за которую выставлена оценка, имеет тип контрольная */
  isControlWork: Scalars['Boolean']['output'];
  /** Признак роли учителя гкпп */
  isStageSubjectGroupTeacher: Scalars['Boolean']['output'];
  /** Название оценки */
  markCustomName: Scalars['String']['output'];
  /** Отложенная дата выставления оценки */
  temporaryMarkDate?: Maybe<Scalars['Date']['output']>;
  /** Вес оценки */
  weight: Scalars['Int']['output'];
};

/** Период */
export enum EDiaryPeriod {
  /** День */
  Day = 'DAY',
  /** Неделя */
  Week = 'WEEK'
}

export type EDiaryQueries = {
  __typename?: 'EDiaryQueries';
  /** Запрос списка академических годов школы */
  getAcademicYears: Array<AcademicYear>;
  /** Запрос данных электронного дневника */
  getEDiaryData: EDiaryDataResponse;
};


export type EDiaryQueriesGetEDiaryDataArgs = {
  eDiaryRequestInput: EDiaryRequestInput;
};

/** Входная модель запроса данных дневника */
export type EDiaryRequestInput = {
  /** Идентификатор пользователя ребенка (в случае запроса дневника родителем) */
  childUserId?: InputMaybe<Scalars['UUID']['input']>;
  /** Дата с которой необходимо получить данные дневника */
  dateFrom: Scalars['Date']['input'];
  /** Период за который необходимо получить данные дневника (день, неделя) */
  period: EDiaryPeriod;
};

/** Объект, содержащий фильтры для поиска ГКпП, к ЭЖ которых у вызывающего пользователя есть доступ */
export type EJournalAvailableEJournalsFilterInput = {
  /** Фильтр академического года, в котором заведены ГКпП */
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  /** Фильтр идентификаторов классов, к которым относятся ГКпП */
  stageGroupIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Фильтр идентификаторов предметов, по которым происходит обучение в ГКпП */
  stageSubjectGroupSubjectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**
   * Фильтр, ограничивающий выборку только ГКпП тех классов, где вызывающий
   * пользователь имеет следующее отношение к роли классного руководителя:
   *  true - является классным руководителем
   *  false - не является классным руководителем
   *  null - без разницы
   */
  userStageGroupFormMaster?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Модель средневзвешенной оценки ученика для ЭЖ */
export type EJournalAverageWeightedStudentMark = {
  __typename?: 'EJournalAverageWeightedStudentMark';
  /** Идентификатор периода, за который рассчитана оценка */
  finalPeriodId: Scalars['ID']['output'];
  /** Тип периода, за который рассчитана оценка */
  finalPeriodType: FinalPeriodType;
  /** Значение средневзвешенной оценки (СРВ) */
  markValue: Scalars['String']['output'];
  /** Идентификатор ученика, для которого рассчитана оценка */
  studentId: Scalars['ID']['output'];
};

/**
 * Модель, содержащая информацию для ячейки таблицы Электронного журнала (ЭЖ)
 * Ячейка - пересечение ученика и урока в таблице
 */
export type EJournalCell = {
  __typename?: 'EJournalCell';
  /** Идентификатор урока, к которому относится ячейка ЭЖ */
  lessonId: Scalars['ID']['output'];
  /** Идентификатор ученика, к которому относится ячейка ЭЖ */
  studentId: Scalars['ID']['output'];
  /** Список оставленных комментариев к уроку #lessonId для ученика #studentId */
  studentLessonComments?: Maybe<Array<EJournalStudentLessonComment>>;
  /** Список оценок ученика #studentId за урок #lessonId */
  studentLessonMarks: Array<EJournalStudentMark>;
  /** Информация о посещении урока #lessonId учеником #studentId */
  studentLessonVisitInfo?: Maybe<EJournalStudentVisit>;
  /**
   * Признак того, числился ли ученик в ГКпП во время урока
   * ГКпП - та группа, относительно которой агрегируем ЭЖ
   */
  wasInGroup: Scalars['Boolean']['output'];
};

/** Список аттестационных периодов, по которым происходит аттестация в ГКпП */
export type EJournalConfiguredFinalPeriodsForStageSubjectGroup = {
  __typename?: 'EJournalConfiguredFinalPeriodsForStageSubjectGroup';
  /** Идентификатор учебного года */
  academicYearId: Scalars['Int']['output'];
  /** Список аттестационных периодов, по которым происходит аттестация в ГКпП #stageSubjectGroupId */
  finalPeriods: Array<EJournalFinalPeriod>;
  /** Идентификатор ГКпП */
  stageSubjectGroupId: Scalars['ID']['output'];
};

/** Модель ответа на запрос периодов, по которым происходит аттестация в переданной ГКпП */
export type EJournalConfiguredFinalPeriodsForStageSubjectGroupResponse = {
  __typename?: 'EJournalConfiguredFinalPeriodsForStageSubjectGroupResponse';
  /** Тело ответа */
  data?: Maybe<EJournalConfiguredFinalPeriodsForStageSubjectGroup>;
  /** Описание ошибки, возникшей в ходе выполнения запроса */
  error?: Maybe<EJournalError>;
  /** Признак успешности выполнения запроса */
  isSuccess: Scalars['Boolean']['output'];
};

/** Список сконфигурированных типов итоговых оценок для ГКпП */
export type EJournalConfiguredFinalStudentMarkTypesForStageSubjectGroup = {
  __typename?: 'EJournalConfiguredFinalStudentMarkTypesForStageSubjectGroup';
  /** Сконфигурированные для ГКпП типы итоговых оценок */
  configuredFinalStudentMarkTypes: Array<EJournalFinalStudentMarkType>;
  /** Идентификатор ГКпП */
  stageSubjectGroupId: Scalars['ID']['output'];
};

/** Модель ответа на запрос типов итоговых отметок, сконфигурированных для ГКпП */
export type EJournalConfiguredFinalStudentMarkTypesForStageSubjectGroupResponse = {
  __typename?: 'EJournalConfiguredFinalStudentMarkTypesForStageSubjectGroupResponse';
  /** Тело ответа */
  data?: Maybe<EJournalConfiguredFinalStudentMarkTypesForStageSubjectGroup>;
  /** Описание ошибки, возникшей в ходе выполнения запроса */
  error?: Maybe<EJournalError>;
  /** Признак успешности выполнения запроса */
  isSuccess: Scalars['Boolean']['output'];
};

/** Модель систем оценивания, сконфигурированных для школы */
export type EJournalConfiguredGovernmentMarkTypesForSchool = {
  __typename?: 'EJournalConfiguredGovernmentMarkTypesForSchool';
  /** Сконфигурированные для школы #schoolId системы оценивания */
  configuredGovernmentMarkTypes: Array<EJournalGovernmentMarkType>;
  /** Идентификатор школы */
  schoolId: Scalars['ID']['output'];
};

/** Модель ответа на запрос сконфигурированных систем оценивания для ГКпП */
export type EJournalConfiguredGovernmentMarkTypesForSchoolResponse = {
  __typename?: 'EJournalConfiguredGovernmentMarkTypesForSchoolResponse';
  /** Тело ответа */
  data?: Maybe<EJournalConfiguredGovernmentMarkTypesForSchool>;
  /** Описание ошибки, возникшей в ходе выполнения запроса */
  error?: Maybe<EJournalError>;
  /** Признак успешности выполнения запроса */
  isSuccess: Scalars['Boolean']['output'];
};

/** Модель систем оценивания, сконфигурированных для ГКпП */
export type EJournalConfiguredGovernmentMarkTypesForStageSubjectGroup = {
  __typename?: 'EJournalConfiguredGovernmentMarkTypesForStageSubjectGroup';
  /** Сконфигурированные для ГКпП #stageSubjectGroupId системы оценивания */
  configuredGovernmentMarkTypes: Array<EJournalGovernmentMarkType>;
  /** Идентификатор ГКпП */
  stageSubjectGroupId: Scalars['ID']['output'];
};

/** Модель ответа на запрос сконфигурированных систем оценивания для ГКпП */
export type EJournalConfiguredGovernmentMarkTypesForStageSubjectGroupResponse = {
  __typename?: 'EJournalConfiguredGovernmentMarkTypesForStageSubjectGroupResponse';
  /** Тело ответа */
  data?: Maybe<EJournalConfiguredGovernmentMarkTypesForStageSubjectGroup>;
  /** Описание ошибки, возникшей в ходе выполнения запроса */
  error?: Maybe<EJournalError>;
  /** Признак успешности выполнения запроса */
  isSuccess: Scalars['Boolean']['output'];
};

/** Модель форм контроля, сконфигурированных для ГКпП */
export type EJournalConfiguredLearningActivitiesForStageSubjectGroup = {
  __typename?: 'EJournalConfiguredLearningActivitiesForStageSubjectGroup';
  /** Список форм контроля, сконфигурированных для ГКпП */
  configuredLearningActivities: Array<LearningActivity>;
  /** Идентификатор ГКпП */
  stageSubjectGroupId: Scalars['ID']['output'];
};

/** Модель ответа на запрос сконфигурированных форм контроля для ГКпП */
export type EJournalConfiguredLearningActivitiesForStageSubjectGroupResponse = {
  __typename?: 'EJournalConfiguredLearningActivitiesForStageSubjectGroupResponse';
  /** Тело ответа */
  data?: Maybe<EJournalConfiguredLearningActivitiesForStageSubjectGroup>;
  /** Описание ошибки, возникшей в ходе выполнения запроса */
  error?: Maybe<EJournalError>;
  /** Признак успешности выполнения запроса */
  isSuccess: Scalars['Boolean']['output'];
};

export type EJournalCreateFinalStudentMarkInput = {
  /** Комментарий к оценке */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** Идентификатор периода, за который выставлена итоговая оценка */
  finalPeriodId: Scalars['ID']['input'];
  /** Идентификатор типа периода, за который выставлена итоговая оценка */
  finalPeriodType: FinalPeriodType;
  /** Идентификатор типа итоговой оценки */
  finalStudentMarkType: FinalStudentMarkType;
  /** Идентификатор оценки */
  markId: Scalars['ID']['input'];
  /** Идентификатор предмета параллели по которому выставлена оценка */
  stageSubjectId: Scalars['ID']['input'];
  /** Идентификатор ученика, которому поставлена оценка */
  studentId: Scalars['ID']['input'];
};

export type EJournalCreateLessonCommentInput = {
  comment: Scalars['String']['input'];
  lessonId: Scalars['ID']['input'];
};

export type EJournalCreateStudentLessonCommentInput = {
  comment: Scalars['String']['input'];
  lessonId: Scalars['ID']['input'];
  studentId: Scalars['ID']['input'];
};

export type EJournalCreateStudentMarkInput = {
  /** Комментарий к оценке */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** Идентификатор типа формы контроля */
  formControlType: FormControlTypeEnum;
  /** Идентификатор формы контроля, за которую проставлена оценка */
  learningActivityId: Scalars['ID']['input'];
  /** Идентификатор урока, за который проставлена оценка */
  lessonId: Scalars['ID']['input'];
  /** Идентификатор выставленной оценки */
  markId: Scalars['ID']['input'];
  /** Идентификатор ученика, которому проставлена оценка */
  studentId: Scalars['ID']['input'];
  /** Идентификатор настройки формы контроля для предмета и уровня образования из которой были извлечены атрибуты оценки */
  studyStepSubjectLearningActivityId?: InputMaybe<Scalars['ID']['input']>;
  /** Отложенная дата выставления оценки. В случае выставления временной оценки, указывается дата, когда оценка будет считаться проставленной в журнал */
  temporaryMarkDate?: InputMaybe<Scalars['Date']['input']>;
  /** Вес оценки на момент выставления */
  weight: Scalars['Int']['input'];
};

export type EJournalCreateStudentVisitInput = {
  comment?: InputMaybe<Scalars['String']['input']>;
  lateTime?: InputMaybe<Scalars['Int']['input']>;
  lessonId: Scalars['ID']['input'];
  studentId: Scalars['ID']['input'];
  studentVisitStatus: StudentVisitStatus;
};

/** Модель, агрегирующая информацию таблицы ЭЖ */
export type EJournalData = {
  __typename?: 'EJournalData';
  /** Информация для ячеек ЭЖ */
  journalCells?: Maybe<Array<EJournalCell>>;
  /** Список уроков за аттестационный период, в рамках которого агрегируем информацию */
  lessons?: Maybe<Array<EJournalLesson>>;
  /** Учебный план ГКпП, информацию для ЭЖ которой запросили */
  stageSubjectGroupPlan?: Maybe<ClassPlan>;
  /** Список учеников, найденных в соответствии с фильтрами запроса */
  students?: Maybe<Array<EJournalStudent>>;
};

/** Модель ответа на запрос информации по журнальной сетке ЭЖ для ГКпП */
export type EJournalDataResponse = {
  __typename?: 'EJournalDataResponse';
  /** Тело ответа */
  data?: Maybe<EJournalData>;
  /** Описание ошибки, возникшей в ходе выполнения запроса */
  error?: Maybe<EJournalError>;
  /** Признак успешности выполнения запроса */
  isSuccess: Scalars['Boolean']['output'];
};

export type EJournalDeleteOperationResponse = {
  __typename?: 'EJournalDeleteOperationResponse';
  data?: Maybe<Scalars['Boolean']['output']>;
  error?: Maybe<EJournalError>;
  isSuccess: Scalars['Boolean']['output'];
};

/** Модель ошибки ЭЖ */
export type EJournalError = {
  __typename?: 'EJournalError';
  /** Дополнительная информация по ошибке (опционально) */
  error?: Maybe<Scalars['String']['output']>;
  /** Код ошибки */
  errorCode: EJournalErrorCode;
};

/** Коды ошибок ЭЖ */
export enum EJournalErrorCode {
  /** Нельзя менять значение оценки, если она не является отложенной */
  CannotChangeNotTemporaryMark = 'CANNOT_CHANGE_NOT_TEMPORARY_MARK',
  /** Итоговая оценка студента не найдена */
  JournalFinalStudentMarkNotFound = 'JOURNAL_FINAL_STUDENT_MARK_NOT_FOUND',
  /** Комментарий учителя к уроку в журнале не найден */
  JournalLessonCommentNotFound = 'JOURNAL_LESSON_COMMENT_NOT_FOUND',
  /** Комментарий учителя к уроку в журнале для ученика не найден */
  JournalStudentLessonCommentNotFound = 'JOURNAL_STUDENT_LESSON_COMMENT_NOT_FOUND',
  /** Оценка студента за урок не найдена */
  JournalStudentMarkNotFound = 'JOURNAL_STUDENT_MARK_NOT_FOUND',
  /** Статус посещения урока студентом не найден */
  JournalStudentVisitNotFound = 'JOURNAL_STUDENT_VISIT_NOT_FOUND',
  /** Для данного урока уже есть комментарий */
  LessonCommentAlreadyExists = 'LESSON_COMMENT_ALREADY_EXISTS',
  /** Нет уроков в выбранном учебном периоде */
  NoLessonsFoundInStudyPeriod = 'NO_LESSONS_FOUND_IN_STUDY_PERIOD',
  /** Нет учеников в ГКпП */
  NoStudentsFound = 'NO_STUDENTS_FOUND',
  /** Не найдено учеников в ГКпП в соответствии с заданными фильтрами */
  NoStudentsFoundByFilter = 'NO_STUDENTS_FOUND_BY_FILTER',
  /** Не найдены учебные периоды для ГКпП */
  NoStudyPeriodsFound = 'NO_STUDY_PERIODS_FOUND',
  /** Не найдена ГКпП */
  StageSubjectGroupNotFound = 'STAGE_SUBJECT_GROUP_NOT_FOUND',
  /** Количество найденных учеников в ГКпП превышает установленный лимит */
  StudentsCountLimitExceeded = 'STUDENTS_COUNT_LIMIT_EXCEEDED',
  /** Для данного урока и студента уже есть комментарий учителя к уроку */
  StudentCommentAlreadyExists = 'STUDENT_COMMENT_ALREADY_EXISTS',
  /** За данный период у студента уже есть оценка такого типа */
  StudentFinalMarkAlreadyExists = 'STUDENT_FINAL_MARK_ALREADY_EXISTS',
  /** Для данного урока и студента уже есть статус посещаемости */
  StudentVisitAlreadyExists = 'STUDENT_VISIT_ALREADY_EXISTS',
  /** Для опоздавшего студента не указано время опоздания, либо значение отрицательное */
  StudentVisitStatusIsAbsentButLateTimeIsNullOrNegative = 'STUDENT_VISIT_STATUS_IS_ABSENT_BUT_LATE_TIME_IS_NULL_OR_NEGATIVE',
  /** Дата отложенной оценки должна быть в будущем */
  TemporaryMarkDateNotInFuture = 'TEMPORARY_MARK_DATE_NOT_IN_FUTURE',
  /** Нельзя сбросить дату отложенной оценки т.к. она совпадает с настоящей датой или находиться в прошлом */
  TooLateToResetTemporaryMarkDate = 'TOO_LATE_TO_RESET_TEMPORARY_MARK_DATE',
  /** У пользователя нет прав на редактирование итоговых оценок в данной ГКПП */
  UserHasNoAccessToEditFinalStudentMarks = 'USER_HAS_NO_ACCESS_TO_EDIT_FINAL_STUDENT_MARKS',
  /** У пользователя нет прав на редактирование посещаемости в прошедших периодах */
  UserHasNoAccessToEditFinalStudentMarksInEndedPeriods = 'USER_HAS_NO_ACCESS_TO_EDIT_FINAL_STUDENT_MARKS_IN_ENDED_PERIODS',
  /** У пользователя нет прав на редактирование комментариев в журнале данной ГКПП */
  UserHasNoAccessToEditLessonComments = 'USER_HAS_NO_ACCESS_TO_EDIT_LESSON_COMMENTS',
  /** У пользователя нет прав на редактирование статусов посещаемости уроков студентом в журнале данной ГКПП */
  UserHasNoAccessToEditStudentAttendance = 'USER_HAS_NO_ACCESS_TO_EDIT_STUDENT_ATTENDANCE',
  /** У пользователя нет прав на редактирование комментариев в журнале данной ГКПП */
  UserHasNoAccessToEditStudentComments = 'USER_HAS_NO_ACCESS_TO_EDIT_STUDENT_COMMENTS',
  /** У пользователя нет прав на редактирование текущих оценок в данной ГКПП */
  UserHasNoAccessToEditStudentMarks = 'USER_HAS_NO_ACCESS_TO_EDIT_STUDENT_MARKS',
  /**
   * У пользователя нет прав на редактирование оценок в прошедших периодах или
   * уроках старше чем указано в конфигурации edu.service.e-journal.editing-available-days"
   */
  UserHasNoAccessToEditStudentMarksInEndedPeriodsOrLessonsOlderThanSpecified = 'USER_HAS_NO_ACCESS_TO_EDIT_STUDENT_MARKS_IN_ENDED_PERIODS_OR_LESSONS_OLDER_THAN_SPECIFIED',
  /**
   * У пользователя нет прав на редактирование посещаемости в прошедших периодах или
   * уроках старше чем указано в конфигурации edu.service.e-journal.editing-available-days"
   */
  UserHasNoAccessToEditStudentVisistsInEndedPeriodsOrLessonsOlderThanSpecified = 'USER_HAS_NO_ACCESS_TO_EDIT_STUDENT_VISISTS_IN_ENDED_PERIODS_OR_LESSONS_OLDER_THAN_SPECIFIED',
  /** У пользователя нет доступа к электронному журналу ГКпП */
  UserHasNoAccessToJournal = 'USER_HAS_NO_ACCESS_TO_JOURNAL'
}

/** Модель аттестационного периода, за который ученикам ставят итоговые отметки */
export type EJournalFinalPeriod = {
  __typename?: 'EJournalFinalPeriod';
  /** Дата окончания периода (включительно) */
  periodEndDate: Scalars['Date']['output'];
  /** Идентификатор аттестационного периода */
  periodId: Scalars['ID']['output'];
  /** Наименование периода */
  periodName: Scalars['String']['output'];
  /**
   * Порядок периода в группе.
   * Если передается одиночный период, можно игнорировать (0)
   */
  periodOrderInGroup: Scalars['Int']['output'];
  /** Дата начала периода (включительно) */
  periodStartDate: Scalars['Date']['output'];
  /** Тип периода */
  periodType: EJournalFinalPeriodType;
};

/** Модель типа периода, за который ученикам выставляются итоговые оценки */
export type EJournalFinalPeriodType = {
  __typename?: 'EJournalFinalPeriodType';
  /** Идентификатор типа периода */
  id: Scalars['ID']['output'];
  /** Код типа периода */
  periodTypeCode: FinalPeriodType;
};

/** Модель итоговой оценки ученика в Электронном журнале */
export type EJournalFinalStudentMark = {
  __typename?: 'EJournalFinalStudentMark';
  /** Комментарий к оценке */
  comment?: Maybe<Scalars['String']['output']>;
  /** Дата и время первичного проставления оценки */
  createdTs: Scalars['DateTime']['output'];
  /** Идентификатор пользователя, выставившего оценку */
  createdUserId: Scalars['ID']['output'];
  /** Идентификатор периода, за который выставлена итоговая оценка */
  finalPeriodId: Scalars['ID']['output'];
  /** Идентификатор типа периода, за который выставлена итоговая оценка */
  finalPeriodType: FinalPeriodType;
  /** Первичный ключ итоговой оценки */
  finalStudentMarkId: Scalars['ID']['output'];
  /** Идентификатор типа итоговой оценки */
  finalStudentMarkType: FinalStudentMarkType;
  /** Значение оценки в баллах в момент выставления */
  initialValue?: Maybe<Scalars['Int']['output']>;
  /**
   * Модель оценки #markId
   * Необходима здесь, т.к оценка, с которой была выставлена "оценка ученика", может быть
   * впоследствии исключена из системы оценивания школы. Тогда мы не получим ее модель в
   * отдельном запросе актуальной системы оценивания.
   */
  mark?: Maybe<SchoolMark>;
  /** Идентификатор оценки */
  markId: Scalars['ID']['output'];
  /** Идентификатор предмета параллели по которому выставлена оценка */
  stageSubjectId: Scalars['ID']['output'];
  /** Идентификатор ученика, которому поставлена оценка */
  studentId: Scalars['ID']['output'];
  /** Дата и время последнего изменения оценки */
  updatedTs?: Maybe<Scalars['DateTime']['output']>;
  /** Дата и время последнего изменения оценки */
  updatedUserId?: Maybe<Scalars['ID']['output']>;
};

/** Модель типа итоговой оценки FinalStudentMarkType */
export type EJournalFinalStudentMarkType = {
  __typename?: 'EJournalFinalStudentMarkType';
  /** За какой тип периодов можно поставить данный тип итоговых оценок */
  finalPeriodTypeForWhichThisMarkTypeIsAllowed?: Maybe<EJournalFinalPeriodType>;
  /** Идентификатор типа итоговой оценки */
  id: Scalars['ID']['output'];
  /** Сокращенное название типа итоговой оценки */
  markTypeAbbreviation: Scalars['String']['output'];
  /** Код типа итоговой оценки */
  markTypeCode: FinalStudentMarkType;
};

/** Модель, агрегирующая итоговые оценки учеников */
export type EJournalFinalStudentMarks = {
  __typename?: 'EJournalFinalStudentMarks';
  /** Средние взвешенные оценки (СРВ) учеников за аттестационные периоды */
  studentAverageWeightedMarks: Array<EJournalAverageWeightedStudentMark>;
  /** Итоговые оценки учеников за аттестационные периоды, проставляемые учителем */
  studentFinalMarks: Array<EJournalFinalStudentMark>;
  /** Возможные итоговые учеников за аттестационные периоды */
  studentPredictedFinalMarks: Array<EJournalPredictedFinalStudentMark>;
  /** Информация о пользователях */
  usersInfo?: Maybe<Array<EJournalUserInfo>>;
};

/** Модель ответа на запрос списка итоговых оценок учеников */
export type EJournalFinalStudentMarksResponse = {
  __typename?: 'EJournalFinalStudentMarksResponse';
  /** Тело ответа */
  data?: Maybe<EJournalFinalStudentMarks>;
  /** Описание ошибки, возникшей в ходе выполнения запроса */
  error?: Maybe<EJournalError>;
  /** Признак успешности выполнения запроса */
  isSuccess: Scalars['Boolean']['output'];
};

export type EJournalGetLessonDetailsResponse = {
  __typename?: 'EJournalGetLessonDetailsResponse';
  /** Тело ответа */
  data?: Maybe<EJournalLesson>;
  /** Описание ошибки, возникшей в ходе выполнения запроса */
  error?: Maybe<EJournalError>;
  /** Признак успешности выполнения запроса */
  isSuccess: Scalars['Boolean']['output'];
};

/** Система оценивания ЭЖ */
export type EJournalGovernmentMarkType = {
  __typename?: 'EJournalGovernmentMarkType';
  /** Допустимые оценки, входящую в систему оценивания #governmentMarkTypeId */
  availableMarks: Array<SchoolMark>;
  /** Модель системы оценивания */
  governmentMarkType: GovernmentMarkType;
  /** Идентификатор системы оценивания */
  governmentMarkTypeId: Scalars['ID']['output'];
  /** Порядок следования системы оценивания в списке выбора оценки */
  governmentMarkTypePosition: Scalars['Int']['output'];
};

/** Модель урока для Электронного журнала (ЭЖ) */
export type EJournalLesson = {
  __typename?: 'EJournalLesson';
  /** Идентификатор КТП для ГКПП, к которой относится урок */
  calendarThematicPlanIdOfAssociatedStageSubjectGroup?: Maybe<Scalars['ID']['output']>;
  /** Признак, запланировано ли на урок проведение контрольной работы */
  controlWorkScheduled: Scalars['Boolean']['output'];
  /** Признак, назначено ли на урок домашнее задание */
  homeworkAssigned: Scalars['Boolean']['output'];
  /** Урок запланирован в календарно-тематическом плане (КТП) */
  includedInCalendarThematicPlan: Scalars['Boolean']['output'];
  /** Признак замены урока */
  isReplacement: Scalars['Boolean']['output'];
  /** Комментарий ко всему уроку */
  lessonComment?: Maybe<EJournalLessonComment>;
  /** Дата-время окончания урока */
  lessonEndDate: Scalars['DateTime']['output'];
  /** Идентификатор урока */
  lessonId: Scalars['ID']['output'];
  /** Признак, находится ли урок в будущем относительно даты/времени запроса? */
  lessonInFuture: Scalars['Boolean']['output'];
  /** Идентификатор плана урока (в любом статусе) */
  lessonPlanId?: Maybe<Scalars['ID']['output']>;
  /** Дата-время начала урока */
  lessonStartDate: Scalars['DateTime']['output'];
  /** Признак, назначена ли уроку тема (lessonTopicName) */
  lessonTopicAssigned: Scalars['Boolean']['output'];
  /** Тема урока для отображения. Берется либо из плана урока, либо КТП */
  lessonTopicName?: Maybe<Scalars['String']['output']>;
  /** Уроки, с которых было назначено домашнее задание на этот урок */
  lessonsFromWhichHomeworkWasAssigned: Array<EJournalLesson>;
  /** Модель опубликованного плана на урок */
  publishedLessonPlan?: Maybe<LessonPlanV4>;
  /** Идентификатор ГКпП, к которой относится урок */
  stageSubjectGroupId: Scalars['ID']['output'];
};

/** Комментарий в журнале ко всему уроку */
export type EJournalLessonComment = {
  __typename?: 'EJournalLessonComment';
  /** Текст комментария */
  comment: Scalars['String']['output'];
  /** Дата/время создания комментария */
  createdTs: Scalars['DateTime']['output'];
  /** Идентификатор пользователя, создавшего комментарий */
  createdUserId: Scalars['ID']['output'];
  /** Идентификатор комментария */
  journalLessonCommentId: Scalars['ID']['output'];
  /** Идентификатор урока, которому добавлен комментарий */
  lessonId: Scalars['ID']['output'];
  /** Дата/время последнего редактирования комментария */
  updatedTs?: Maybe<Scalars['DateTime']['output']>;
  /** Идентификатор пользователя, выполнившего последнее изменение комментария */
  updatedUserId?: Maybe<Scalars['ID']['output']>;
};

export type EJournalMutations = {
  __typename?: 'EJournalMutations';
  /** Создание итоговой оценки */
  createEJournalFinalStudentMark: EJournalUpdateFinalStudentMarkResponse;
  /** Создание комментария учителя к уроку в журнале */
  createEJournalLessonComment: EJournalUpdateLessonCommentResponse;
  /** Создание комментария учителя к уроку в журнале для ученика */
  createEJournalStudentLessonComment: EJournalUpdateStudentLessonCommentResponse;
  /** Создание текущей оценки ученика за урок */
  createEJournalStudentMark: EJournalUpdateStudentMarkResponse;
  /** Создание записи посещения студентом урока */
  createEJournalStudentVisit: EJournalUpdateStudentVisitResponse;
  /** Удаление итоговой оценки */
  deleteEJournalFinalStudentMark: EJournalDeleteOperationResponse;
  /** Удаление текущей оценки ученика за урок */
  deleteEJournalStudentMark: EJournalDeleteOperationResponse;
  /** Удаление записи посещаемости урока студентом */
  deleteEJournalStudentVisit: EJournalDeleteOperationResponse;
  /** Сброс отложенной даты выставления оценки */
  resetEJournalTemporaryMarkDate: EJournalUpdateStudentMarkResponse;
  /** Сохранение факта посещения студентом видеоурока */
  saveStudentVideoLessonVisit?: Maybe<Scalars['Boolean']['output']>;
  /** Изменение значение итоговой оценки */
  updateEJournalFinalStudentMark: EJournalUpdateFinalStudentMarkResponse;
  /** Изменение комментария к итоговой оценке */
  updateEJournalFinalStudentMarkComment: EJournalUpdateFinalStudentMarkResponse;
  /** Изменение комментария учителя к уроку в журнале */
  updateEJournalLessonComment: EJournalUpdateLessonCommentResponse;
  /** Изменение комментария учителя к уроку в журнале для ученика */
  updateEJournalStudentLessonComment: EJournalUpdateStudentLessonCommentResponse;
  /** Изменение комментария к текущей оценке учерника за урок */
  updateEJournalStudentMarkComment: EJournalUpdateStudentMarkResponse;
  /** Изменение комментария в записи посещаемости урока студентом */
  updateEJournalStudentVisitComment: EJournalUpdateStudentVisitResponse;
  /** Изменение статуса посещаемости урока студентом */
  updateEJournalStudentVisitStatus: EJournalUpdateStudentVisitResponse;
  /** Обновление отложенной оценки */
  updateEJournalTemporaryMark: EJournalUpdateStudentMarkResponse;
  /** Изменение отложенной даты выставления оценки */
  updateEJournalTemporaryMarkDate: EJournalUpdateStudentMarkResponse;
};


export type EJournalMutationsCreateEJournalFinalStudentMarkArgs = {
  eJournalCreateFinalStudentMarkInput: EJournalCreateFinalStudentMarkInput;
};


export type EJournalMutationsCreateEJournalLessonCommentArgs = {
  eJournalCreateLessonCommentInput: EJournalCreateLessonCommentInput;
};


export type EJournalMutationsCreateEJournalStudentLessonCommentArgs = {
  eJournalCreateStudentLessonCommentInput: EJournalCreateStudentLessonCommentInput;
};


export type EJournalMutationsCreateEJournalStudentMarkArgs = {
  eJournalCreateStudentMarkInput: EJournalCreateStudentMarkInput;
};


export type EJournalMutationsCreateEJournalStudentVisitArgs = {
  eJournalStudentVisitInput: EJournalCreateStudentVisitInput;
};


export type EJournalMutationsDeleteEJournalFinalStudentMarkArgs = {
  eJournalFinalStudentMarkId: Scalars['ID']['input'];
};


export type EJournalMutationsDeleteEJournalStudentMarkArgs = {
  journalStudentMarkId: Scalars['ID']['input'];
};


export type EJournalMutationsDeleteEJournalStudentVisitArgs = {
  journalStudentVisitId: Scalars['ID']['input'];
};


export type EJournalMutationsResetEJournalTemporaryMarkDateArgs = {
  journalStudentMarkId: Scalars['ID']['input'];
};


export type EJournalMutationsSaveStudentVideoLessonVisitArgs = {
  lessonId: Scalars['ID']['input'];
};


export type EJournalMutationsUpdateEJournalFinalStudentMarkArgs = {
  journalFinalStudentMarkId: Scalars['ID']['input'];
  markId: Scalars['ID']['input'];
};


export type EJournalMutationsUpdateEJournalFinalStudentMarkCommentArgs = {
  comment: Scalars['String']['input'];
  journalFinalStudentMarkId: Scalars['ID']['input'];
};


export type EJournalMutationsUpdateEJournalLessonCommentArgs = {
  comment: Scalars['String']['input'];
  journalLessonCommentId: Scalars['ID']['input'];
};


export type EJournalMutationsUpdateEJournalStudentLessonCommentArgs = {
  comment: Scalars['String']['input'];
  journalStudentCommentId: Scalars['ID']['input'];
};


export type EJournalMutationsUpdateEJournalStudentMarkCommentArgs = {
  comment: Scalars['String']['input'];
  journalStudentMarkId: Scalars['ID']['input'];
};


export type EJournalMutationsUpdateEJournalStudentVisitCommentArgs = {
  comment: Scalars['String']['input'];
  journalStudentVisitId: Scalars['ID']['input'];
};


export type EJournalMutationsUpdateEJournalStudentVisitStatusArgs = {
  eJournalUpdateStudentVisitStatusInput: EJournalUpdateStudentVisitStatusInput;
};


export type EJournalMutationsUpdateEJournalTemporaryMarkArgs = {
  journalStudentMarkId: Scalars['ID']['input'];
  markId: Scalars['ID']['input'];
};


export type EJournalMutationsUpdateEJournalTemporaryMarkDateArgs = {
  date: Scalars['Date']['input'];
  journalStudentMarkId: Scalars['ID']['input'];
};

/** Модель прогнозируемой итоговой оценки ученика для ЭЖ */
export type EJournalPredictedFinalStudentMark = {
  __typename?: 'EJournalPredictedFinalStudentMark';
  /** Идентификатор периода, за который рассчитана прогнозируемая оценка */
  finalPeriodId: Scalars['ID']['output'];
  /** Идентификатор типа периода, за который рассчитана прогнозируемая оценка */
  finalPeriodType: FinalPeriodType;
  /** Значение прогнозируемой итоговой оценки */
  predictedFinalMarkValue?: Maybe<Scalars['String']['output']>;
  /** Идентификатор ученика, для которого рассчитана оценка */
  studentId: Scalars['ID']['output'];
};

export type EJournalQueries = {
  __typename?: 'EJournalQueries';
  /**
   * Получение доступных в переданной школы систем оценивания, оценки которых можно использовать
   * для проставления итоговых отметок ученикам
   */
  getAvailableFinalMarksBySchool: EJournalConfiguredGovernmentMarkTypesForSchoolResponse;
  /**
   * Получение доступных в переданной ГКпП систем оценивания, оценки которых можно использовать
   * для проставления итоговых отметок ученикам
   */
  getAvailableFinalMarksByStageSubjectGroup: EJournalConfiguredGovernmentMarkTypesForStageSubjectGroupResponse;
  /** Получение ГКпП контекстной школы, к ЭЖ которых у контекстного пользователя есть минимальный доступ */
  getClassSubjectsByFilters: Array<ClassSubject>;
  /** Получение данных ЭЖ для ГКпП */
  getEJournalDataByFilters: EJournalDataResponse;
  /** Получение расширенной информации по уроку */
  getEJournalLessonDetails: EJournalGetLessonDetailsResponse;
  /** Получение итоговых оценок учеников ГКпП */
  getJournalFinalStudentMarksByFilters: EJournalFinalStudentMarksResponse;
  /** Получение сконфигурированных форм контроля для ГКпП */
  getLearningActivitiesByStageSubjectGroup: EJournalConfiguredLearningActivitiesForStageSubjectGroupResponse;
  /**
   * Получение доступных в переданной ГКпП систем оценивания, оценки которых можно использовать
   * для проставления текущих отметок ученикам
   */
  getMarkTypesWithMarksByStageSubjectGroup: EJournalConfiguredGovernmentMarkTypesForStageSubjectGroupResponse;
  /** Получение периодов, по которым происходит аттестация в переданной ГКпП */
  getPeriodsByStageSubjectGroup: EJournalConfiguredFinalPeriodsForStageSubjectGroupResponse;
  /** Получение текущего времени контекстной школы */
  getSchoolDate: Scalars['Date']['output'];
  /** Получение типов итоговых оценок, сконфигурированных для переданной ГКпП */
  getStageFinalStudentMarkTypes: EJournalConfiguredFinalStudentMarkTypesForStageSubjectGroupResponse;
  /** Получение информации о ГКПП */
  getStageSubjectGroupInfo: StageSubjectGroupInfoResponse;
  /** Получение списка разрешений ЭЖ ГКпП для текущего пользователя */
  getUserPermissionsForEJournal: EJournalUserPermissionsResponse;
};


export type EJournalQueriesGetAvailableFinalMarksBySchoolArgs = {
  schoolId: Scalars['ID']['input'];
};


export type EJournalQueriesGetAvailableFinalMarksByStageSubjectGroupArgs = {
  stageSubjectGroupId: Scalars['ID']['input'];
};


export type EJournalQueriesGetClassSubjectsByFiltersArgs = {
  filter: EJournalAvailableEJournalsFilterInput;
};


export type EJournalQueriesGetEJournalDataByFiltersArgs = {
  aggregationPeriodFilter: FinalPeriodFilter;
  stageSubjectGroupId: Scalars['ID']['input'];
  studentStatusInGroupFilter: StudentStatusInGroup;
};


export type EJournalQueriesGetEJournalLessonDetailsArgs = {
  lessonId: Scalars['ID']['input'];
};


export type EJournalQueriesGetJournalFinalStudentMarksByFiltersArgs = {
  aggregationPeriodFilter: FinalPeriodFilter;
  stageSubjectGroupId: Scalars['ID']['input'];
  studentStatusInGroupFilter: StudentStatusInGroup;
};


export type EJournalQueriesGetLearningActivitiesByStageSubjectGroupArgs = {
  stageSubjectGroupId: Scalars['ID']['input'];
};


export type EJournalQueriesGetMarkTypesWithMarksByStageSubjectGroupArgs = {
  stageSubjectGroupId: Scalars['ID']['input'];
};


export type EJournalQueriesGetPeriodsByStageSubjectGroupArgs = {
  stageSubjectGroupId: Scalars['ID']['input'];
};


export type EJournalQueriesGetStageFinalStudentMarkTypesArgs = {
  stageSubjectGroupId: Scalars['ID']['input'];
};


export type EJournalQueriesGetStageSubjectGroupInfoArgs = {
  stageSubjectGroupId: Scalars['ID']['input'];
};


export type EJournalQueriesGetUserPermissionsForEJournalArgs = {
  stageSubjectGroupId: Scalars['ID']['input'];
};

/** Данные ученика ГКпП для ЭЖ, агрегированные за аттестационный период */
export type EJournalStudent = {
  __typename?: 'EJournalStudent';
  /** Признак того, активен ли ученик в ГКпП в течение аттестационного периода */
  activeInGroupAtPeriodEnd?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Признак того, что ученик перед последним в рассматриваемом аттестационном периоде переводом
   * в текущую ГКПП #stageSubjectGroupId находился в других ГКПП этой же параллели,
   * этой же школы и этого же предмета (равносильно предмету параллели - StageSubject)
   */
  attendedOtherGroups?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Признак того, что ученик перед последним в рассматриваемом периоде переводом
   * в текущую ГКПП {@code stageSubjectGroupId} находился в других ГКПП этой же параллели,
   * этой же школы и этого же предмета и имеет там оценки
   */
  hasMarksInOtherGroups?: Maybe<Scalars['Boolean']['output']>;
  /** Идентификатор ГКпП, в которой состоит ученик */
  stageSubjectGroupId: Scalars['ID']['output'];
  /** Информация о пользователе как ученике школы, в которой заведена ГКпП #stageSubjectGroupId */
  studentAccount: StudentAccount;
};

/** Комментарий учителя к уроку в ЭЖ для ученика */
export type EJournalStudentLessonComment = {
  __typename?: 'EJournalStudentLessonComment';
  /** Текст комментария */
  comment: Scalars['String']['output'];
  /** Дата и время создания комментария */
  createdTs: Scalars['DateTime']['output'];
  /** Идентификатор пользователя, создавшего комментарий */
  createdUserId: Scalars['ID']['output'];
  /** Идентификатор комментария */
  journalStudentCommentId: Scalars['ID']['output'];
  /** Идентификатор урока, которому добавлен комментарий */
  lessonId: Scalars['ID']['output'];
  /** Идентификатор ученика, которому был адресован комментарий */
  studentId: Scalars['ID']['output'];
  /** Дата и время последнего редактирования комментария */
  updatedTs?: Maybe<Scalars['DateTime']['output']>;
  /** Идентификатор пользователя, выполнившего последнее изменение комментария */
  updatedUserId?: Maybe<Scalars['ID']['output']>;
};

/** Модель текущей (промежуточной) оценки ученика в Электронном журнале */
export type EJournalStudentMark = {
  __typename?: 'EJournalStudentMark';
  /** Комментарий к оценке */
  comment?: Maybe<Scalars['String']['output']>;
  /** Дата и время первичного проставления оценки */
  createdTs: Scalars['DateTime']['output'];
  /** Идентификатор пользователя, выставившего оценку */
  createdUserId: Scalars['ID']['output'];
  /** Идентификатор типа формы контроля */
  formControlType: FormControlTypeEnum;
  /** Значение оценки в баллах в момент выставления */
  initialValue: Scalars['Int']['output'];
  /** Идентификатор текущей оценки студента */
  journalStudentMarkId: Scalars['ID']['output'];
  /** Модель формы контроля #learningActivityId */
  learningActivity?: Maybe<LearningActivity>;
  /** Идентификатор формы контроля, за которую проставлена оценка */
  learningActivityId: Scalars['ID']['output'];
  /** Идентификатор ученика, которому проставлена эта оценка */
  lessonId: Scalars['ID']['output'];
  /** Модель оценки #markId */
  mark?: Maybe<SchoolMark>;
  /** Идентификатор выставленной оценки */
  markId: Scalars['ID']['output'];
  /** Идентификатор урока, за который проставлена оценка */
  studentId: Scalars['ID']['output'];
  /** Идентификатор настройки формы контроля для предмета и уровня образования из которой были извлечены атрибуты оценки */
  studyStepSubjectLearningActivityId?: Maybe<Scalars['ID']['output']>;
  /**
   * Отложенная дата выставления оценки
   * В случае выставления временной оценки, указывается дата, когда оценка будет считаться проставленной в журнал
   */
  temporaryMarkDate?: Maybe<Scalars['Date']['output']>;
  /** Дата и время последнего изменения оценки */
  updatedTs?: Maybe<Scalars['DateTime']['output']>;
  /** Идентификатор пользователя, сделавшего последнее изменение в оценке */
  updatedUserId?: Maybe<Scalars['ID']['output']>;
  /** Пользователь, редактировавший оценку (в широком смысле) последним */
  userWhoLastUpdatedMark?: Maybe<UserAccount>;
  /** Вес оценки на момент выставления */
  weight: Scalars['Int']['output'];
};

/** Информация о посещении урока учеником */
export type EJournalStudentVisit = {
  __typename?: 'EJournalStudentVisit';
  /** Комментарий учителя к посещению урока учеником */
  comment?: Maybe<Scalars['String']['output']>;
  /** Дата/время создания записи о посещаемости */
  createdTs: Scalars['DateTime']['output'];
  /** Идентификатор пользователя, создавшего запись о посещаемости */
  createdUserId: Scalars['ID']['output'];
  /** Идентификатор записи посещения */
  journalStudentVisitId: Scalars['ID']['output'];
  /** Длительность опоздания ученика на урок в минутах */
  lateTimeMinutes?: Maybe<Scalars['Int']['output']>;
  /** Идентификатор урока, посещенного учеником */
  lessonId: Scalars['ID']['output'];
  /** Идентификатор ученика, посетившего урок */
  studentId: Scalars['ID']['output'];
  /** Дата/время последнего редактирования записи о посещаемости */
  updatedTs?: Maybe<Scalars['DateTime']['output']>;
  /** Идентификатор пользователя, выполнившего последнее изменение записи о посещаемости */
  updatedUserId?: Maybe<Scalars['ID']['output']>;
  /** Статус посещения урока учеником */
  visitStatus: StudentVisitStatus;
};

export type EJournalUpdateFinalStudentMarkResponse = {
  __typename?: 'EJournalUpdateFinalStudentMarkResponse';
  data?: Maybe<EJournalFinalStudentMark>;
  error?: Maybe<EJournalError>;
  isSuccess: Scalars['Boolean']['output'];
};

export type EJournalUpdateLessonCommentResponse = {
  __typename?: 'EJournalUpdateLessonCommentResponse';
  data?: Maybe<EJournalLessonComment>;
  error?: Maybe<EJournalError>;
  isSuccess: Scalars['Boolean']['output'];
};

export type EJournalUpdateStudentLessonCommentResponse = {
  __typename?: 'EJournalUpdateStudentLessonCommentResponse';
  data?: Maybe<EJournalStudentLessonComment>;
  error?: Maybe<EJournalError>;
  isSuccess: Scalars['Boolean']['output'];
};

export type EJournalUpdateStudentMarkResponse = {
  __typename?: 'EJournalUpdateStudentMarkResponse';
  data?: Maybe<EJournalStudentMark>;
  error?: Maybe<EJournalError>;
  isSuccess: Scalars['Boolean']['output'];
};

export type EJournalUpdateStudentVisitResponse = {
  __typename?: 'EJournalUpdateStudentVisitResponse';
  data?: Maybe<EJournalStudentVisit>;
  error?: Maybe<EJournalError>;
  isSuccess: Scalars['Boolean']['output'];
};

export type EJournalUpdateStudentVisitStatusInput = {
  journalStudentVisitId: Scalars['ID']['input'];
  lateTime?: InputMaybe<Scalars['Int']['input']>;
  studentVisitStatus: StudentVisitStatus;
};

export type EJournalUserInfo = {
  __typename?: 'EJournalUserInfo';
  firstName: Scalars['String']['output'];
  lastName: Scalars['String']['output'];
  middleName?: Maybe<Scalars['String']['output']>;
  userId: Scalars['ID']['output'];
};

/** Список разрешений, которые имеет пользователь по отношению к Электронному журналу (ЭЖ) ГКпП */
export type EJournalUserPermissions = {
  __typename?: 'EJournalUserPermissions';
  /** Список разрешений, которые есть у пользователя по отношению к ЭЖ ГКпП #stageSubjectGroupId */
  permissions: Array<Scalars['String']['output']>;
  /** Идентификатор ГКпП, к ЭЖ которой у пользователя есть разрешения #permissions */
  stageSubjectGroupId: Scalars['ID']['output'];
};

/** Результат запроса списка разрешений пользователя по отношению к ЭЖ ГКпП */
export type EJournalUserPermissionsResponse = {
  __typename?: 'EJournalUserPermissionsResponse';
  /** Тело ответа */
  data?: Maybe<EJournalUserPermissions>;
  /** Описание ошибки, возникшей в ходе выполнения запроса */
  error?: Maybe<EJournalError>;
  /** Признак успешности выполнения запроса */
  isSuccess: Scalars['Boolean']['output'];
};

export type EditMobileNumberVerifyResult = {
  __typename?: 'EditMobileNumberVerifyResult';
  /** Сколько осталось попыток */
  attemptsLeft: Scalars['Int']['output'];
  /** Признак совпали ли введеный и ожидаемый код */
  codesAreEqual: Scalars['Boolean']['output'];
};

/** Запрос на изменение ячейки в журнале посещаемости */
export type EditVisitJournalCellInput = {
  /** Значение */
  value: VisitJournalCellValueEnum;
  /** Идентификатор ячейки журнала */
  visitJournalCellId: Scalars['ID']['input'];
};

/** Срабатывание ограничения */
export type EduConstraintMatch = {
  __typename?: 'EduConstraintMatch';
  /** Счет */
  matchScore: Score;
  /** Параметры */
  parameters: Array<Scalars['String']['output']>;
};

export type EducationDocument = {
  __typename?: 'EducationDocument';
  dateOfIssue: Scalars['Date']['output'];
  name: Scalars['String']['output'];
};

export type EducationDocumentInput = {
  dateOfIssue: Scalars['Date']['input'];
  name: Scalars['String']['input'];
};

export type EducationalOrganizationFilter = {
  /** ID региона */
  regionId: Scalars['UUID']['input'];
  /** Текст поиска */
  searchText?: InputMaybe<Scalars['String']['input']>;
  /** Тип пользователя */
  userTypeId: Scalars['String']['input'];
};

/** Статусы заданий для электронного журнала */
export type ElectonicJournalStudentTasks = {
  __typename?: 'ElectonicJournalStudentTasks';
  /** статусы заданий студентов */
  cells: Array<StudentTaskStatusesMap>;
  /** список заданий */
  lessonPlanTasks: Array<Maybe<ElectronicJournalLessonPlanTask>>;
};

/** Задания на урок для электронного журнала */
export type ElectronicJournalLessonPlanTask = {
  __typename?: 'ElectronicJournalLessonPlanTask';
  /** Признак является ли задание домашней работой */
  isHomework: Scalars['Boolean']['output'];
  /** Идентификатор задания в плане на урок */
  taskId: Scalars['ID']['output'];
  /** Наименование задания */
  taskName: Scalars['String']['output'];
};

/** Уровень доступа относительно группы по предмету */
export enum ElectronicJournalPermission {
  /** Нет прав */
  NoPermissions = 'NO_PERMISSIONS',
  /** Просмотр и Изменение */
  ReadAndWrite = 'READ_AND_WRITE',
  /** Просмотр и Изменение только журнала посещаемости */
  ReadAndWriteToVisitJournal = 'READ_AND_WRITE_TO_VISIT_JOURNAL',
  /** Только просмотр */
  ReadOnly = 'READ_ONLY'
}

export type ElectronicJournalQueries = {
  __typename?: 'ElectronicJournalQueries';
  /** Катаолог учебных активностей для школы */
  getLearningActivitiesBySchool: Array<LearningActivity>;
  /** запрос итоговых оценок студента */
  getStudentJournalFinalMarks?: Maybe<Array<Maybe<JournalFinalStudentMarkByStageSubject>>>;
  /** запрос итоговых оценок студента для его родителя */
  getStudentJournalFinalMarksForParent?: Maybe<Array<Maybe<JournalFinalStudentMarkByStageSubject>>>;
  /** Получение информации об уроках по предмету за учебный период */
  getStudentJournalMarks: Array<Maybe<StudentStudyDate>>;
  /** Получение информации об уроках по предмету за учебный период для родителя */
  getStudentJournalMarksForParent: Array<Maybe<StudentStudyDate>>;
  /** Получение оценок по предмету за учебные периоды */
  getStudentJournalMarksInPeriods: Array<Maybe<StudentPeriodMarks>>;
  /** Получение оценок по предмету за учебные периоды для родителя */
  getStudentJournalMarksInPeriodsForParent: Array<Maybe<StudentPeriodMarks>>;
};


export type ElectronicJournalQueriesGetLearningActivitiesBySchoolArgs = {
  schoolId: Scalars['UUID']['input'];
};


export type ElectronicJournalQueriesGetStudentJournalFinalMarksForParentArgs = {
  childUserId: Scalars['ID']['input'];
};


export type ElectronicJournalQueriesGetStudentJournalMarksArgs = {
  studyPeriodId: Scalars['ID']['input'];
  subjectId: Scalars['ID']['input'];
};


export type ElectronicJournalQueriesGetStudentJournalMarksForParentArgs = {
  childUserId: Scalars['ID']['input'];
  studyPeriodId: Scalars['ID']['input'];
  subjectId: Scalars['ID']['input'];
};


export type ElectronicJournalQueriesGetStudentJournalMarksInPeriodsArgs = {
  studyPeriodIds: Array<Scalars['ID']['input']>;
  subjectId: Scalars['ID']['input'];
};


export type ElectronicJournalQueriesGetStudentJournalMarksInPeriodsForParentArgs = {
  childUserId: Scalars['ID']['input'];
  studyPeriodIds: Array<Scalars['ID']['input']>;
  subjectId: Scalars['ID']['input'];
};

/** Статусы верификации университетсклй почты */
export enum EmailConfirmationStatus {
  /** Почта подтверждена */
  Confirmed = 'CONFIRMED',
  /** Не подтверждена */
  NotConfirmed = 'NOT_CONFIRMED',
  /** Ожилание получения кода подтверждения */
  WaitingForConfirmationCode = 'WAITING_FOR_CONFIRMATION_CODE'
}

export type EnabledWidget = {
  __typename?: 'EnabledWidget';
  category: Array<Scalars['String']['output']>;
  description: Scalars['String']['output'];
  group: Array<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  preview: Scalars['String']['output'];
  title: Scalars['String']['output'];
  visual: Array<Scalars['String']['output']>;
};

export type EnabledWidgets = {
  __typename?: 'EnabledWidgets';
  categories: Array<Scalars['String']['output']>;
  groups: Array<Scalars['String']['output']>;
  visuals: Array<Scalars['String']['output']>;
  widgets: Array<EnabledWidget>;
};

export type Entity = {
  __typename?: 'Entity';
  entityId: Scalars['ID']['output'];
  entityType: EntityType;
};

/** Школы, учителя и ученики на платформе */
export type EntityOnPlatform = {
  __typename?: 'EntityOnPlatform';
  dynamic?: Maybe<Scalars['Int']['output']>;
  entitiesCount?: Maybe<Scalars['Int']['output']>;
  yearMonth: Scalars['String']['output'];
};

export enum EntityType {
  Homework = 'HOMEWORK',
  Lesson = 'LESSON',
  LessonPlan = 'LESSON_PLAN',
  LessonPlanMaterialBlock = 'LESSON_PLAN_MATERIAL_BLOCK',
  Module = 'MODULE',
  Stage = 'STAGE',
  Subject = 'SUBJECT'
}

export type EnumValue = {
  __typename?: 'EnumValue';
  displayableName: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

/** Экипировка */
export type Equipment = {
  __typename?: 'Equipment';
  /** Какие характеристики и насколько прокачивает экипировка */
  abilities: Array<AbilityPower>;
  /** Относительное ссылка в файловый сервис на изображение шмотки в положении анфас для отображения надетой на персонажа */
  dressedImageUrl: Scalars['String']['output'];
  /** Слот экипировки (шлем, ботинки, меч и etc.) */
  equipmentSlot: EquipmentSlotEnum;
  id: Scalars['ID']['output'];
  /** Относительная ссылка на изображение экипировки */
  imageUrl: Scalars['String']['output'];
  /** Литературное имя */
  name: Scalars['String']['output'];
};

/** Слот для экипировки */
export enum EquipmentSlotEnum {
  /** Тело */
  Body = 'BODY',
  /** Ботинки */
  Boots = 'BOOTS',
  /** Очки */
  Glasses = 'GLASSES',
  /** Шапка */
  Helmet = 'HELMET',
  /** Перчатка на левую руку */
  LeftArmGlove = 'LEFT_ARM_GLOVE',
  /** Оружие в левой руке */
  LeftArmWeapon = 'LEFT_ARM_WEAPON',
  /** Украшение на шею */
  Necklace = 'NECKLACE',
  /** Перчатка на правую руку */
  RightArmGlove = 'RIGHT_ARM_GLOVE',
  /** Оружие в правой руке */
  RightArmWeapon = 'RIGHT_ARM_WEAPON',
  /** Штаны */
  Trousers = 'TROUSERS',
  /** Футболка */
  TShirt = 'T_SHIRT'
}

export type EvaluatedTaskCriterion = {
  __typename?: 'EvaluatedTaskCriterion';
  /** Идентификатор (student_task_assessment_criteria_values.student_task_assessment_criteria_value_id) */
  evaluatedTaskCriterionId: Scalars['ID']['output'];
  /** Критерий, для которого задана оценка */
  taskCriterion: TaskCriterion;
  /** Значение оценки */
  value: Scalars['String']['output'];
};

/** Данные для оценки критериев (student_task_assessment_criteria_values) */
export type EvaluatedTaskCriterionInput = {
  /** Идентификатор критерия задания (xref_task_assessment_criteria_scales.task_criteria_scale_id) */
  taskCriterionId: Scalars['ID']['input'];
  /** Значение оценки */
  value: Scalars['String']['input'];
};

export type EvaluationRule = {
  __typename?: 'EvaluationRule';
  deletable: Scalars['Boolean']['output'];
  editable: Scalars['Boolean']['output'];
  logicalOperatorId?: Maybe<LogicalLinkTypeEnum>;
  value: EvaluationRuleValue;
};

/** Правило фильтрации и его возможные настройки */
export type EvaluationRuleFieldOption = {
  __typename?: 'EvaluationRuleFieldOption';
  /** Идентификатор правила */
  id: Scalars['ID']['output'];
  /** Название */
  name: Scalars['String']['output'];
  /** Операторы, используемые в правиле фильтрации */
  operators: Array<Scalars['String']['output']>;
  subFields?: Maybe<Array<KeyValue>>;
  /** Тип значения может быть выбираемым из списка ('select') или простое число ('number') */
  valueType: ClauseValueTypeEnum;
  values?: Maybe<Array<KeyValue>>;
};

export type EvaluationRuleGroup = {
  __typename?: 'EvaluationRuleGroup';
  logicalOperatorId?: Maybe<LogicalLinkTypeEnum>;
  rulesInGroup: Array<EvaluationRule>;
};

export type EvaluationRuleGroupInput = {
  logicalOperatorId?: InputMaybe<LogicalLinkTypeEnum>;
  rulesInGroup: Array<EvaluationRuleInput>;
};

/** Группы правил фильтрации в текущем и вышестоящем плане с результатом их сравнения */
export type EvaluationRuleGroupsWithEquivalentFlag = {
  __typename?: 'EvaluationRuleGroupsWithEquivalentFlag';
  equivalentRuleGroup: Scalars['Boolean']['output'];
  evaluationRuleGroup: Array<EvaluationRuleGroup>;
  multiCampusEvaluationRuleGroup?: Maybe<Array<EvaluationRuleGroup>>;
  multiCampusIsEnabled?: Maybe<Scalars['Boolean']['output']>;
  superiorEvaluationRuleGroup?: Maybe<Array<EvaluationRuleGroup>>;
};

export type EvaluationRuleInput = {
  deletable?: InputMaybe<Scalars['Boolean']['input']>;
  editable?: InputMaybe<Scalars['Boolean']['input']>;
  logicalOperatorId?: InputMaybe<LogicalLinkTypeEnum>;
  value: EvaluationRuleValueInput;
};

/** Заполненный единичный элемент правила фильтрации */
export type EvaluationRuleValue = {
  __typename?: 'EvaluationRuleValue';
  fieldId: Scalars['ID']['output'];
  operator: Scalars['String']['output'];
  subFieldKey?: Maybe<Scalars['String']['output']>;
  value: Array<Scalars['String']['output']>;
};

/** Определяет тип value в StudentEvaluationRuleValue */
export enum EvaluationRuleValueFieldType {
  ProjectLink = 'PROJECT_LINK',
  Text = 'TEXT'
}

/** Заполненный элемент правила фильтрации для сохранения */
export type EvaluationRuleValueInput = {
  fieldId: Scalars['ID']['input'];
  operator: Scalars['String']['input'];
  subFieldKey?: InputMaybe<Scalars['String']['input']>;
  value: Array<Scalars['String']['input']>;
};

/** Запланированное Событие(домашняя работа, урок, факультатив) */
export type Event = {
  __typename?: 'Event';
  /** @deprecated Field no longer supported */
  achievedGoalLevel?: Maybe<Scalars['Float']['output']>;
  /** @deprecated Field no longer supported */
  averageScore?: Maybe<Scalars['Float']['output']>;
  /** Имя класса(пример: 5А) */
  className: Scalars['String']['output'];
  /** Название Группы по Предмету, в рамках которого происходит событие (stage_subject_groups.name) */
  classSubjectName?: Maybe<Scalars['String']['output']>;
  /** Описание события (пример: название кабинета в котором будет событие) */
  description: Scalars['String']['output'];
  /** Дата и время завершения события */
  end: Scalars['DateTime']['output'];
  /** @deprecated Field no longer supported */
  goalId?: Maybe<Scalars['ID']['output']>;
  /** иконка */
  icon: Scalars['String']['output'];
  /** Идентификатор события(timetableId) */
  id: Scalars['ID']['output'];
  /** заметка к плану урока */
  lessonNoteToLessonPlan?: Maybe<LessonNoteToLessonPlan>;
  /** Идентификатор плана урока */
  lessonPlanId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор интервала времени, в который проводится событие */
  lessonTimeslotId?: Maybe<Scalars['ID']['output']>;
  /** Тема к плану урока */
  lessonTopicToLessonPlan?: Maybe<LessonTopicToLessonPlan>;
  /** Название события(пример: Биология/Домашняя работа/Факультатив) */
  name: Scalars['String']['output'];
  /** Номер урока, когда type=Lesson */
  number: Scalars['String']['output'];
  /** онлайн-урок к плану урока */
  onlineLessonToLessonPlan?: Maybe<OnlineLessonToLessonPlan>;
  /** @deprecated Field no longer supported */
  plannedGoalLevel?: Maybe<Scalars['Float']['output']>;
  /** id группы по предмету */
  stageSubjectGroupId?: Maybe<Scalars['Int']['output']>;
  /** Дата и время начала события */
  start: Scalars['DateTime']['output'];
  /** @deprecated use studentTaskProgress */
  studentProgress?: Maybe<StudentSubjectProgress>;
  /** @deprecated Field no longer supported */
  studentTaskProgress?: Maybe<ThermometerPmoStatusEnum>;
  /** Предмет (пример: Биология) */
  subject: Subject;
  /** учитель */
  teacher?: Maybe<Teacher>;
  /** Отметка о посещении Учеником события */
  visitJournalValue?: Maybe<VisitJournalCellValueEnum>;
};

/** Данные о событии */
export type EventData = {
  /** Событие */
  event: Scalars['JsonNode']['input'];
  /** Имя класса события */
  eventClassName: Scalars['String']['input'];
};

/** Мапа eventId->event */
export type EventDataMap = {
  __typename?: 'EventDataMap';
  /** Данные о событии */
  event: Scalars['JsonNode']['output'];
  /** Идентификатор события */
  eventId: Scalars['String']['output'];
};

/** Типы филдов в событиях */
export enum EventFieldTypeEnum {
  /** Булево */
  Boolean = 'BOOLEAN',
  /** Дата и время */
  DateTime = 'DATE_TIME',
  /** Числовое */
  Number = 'NUMBER',
  /** Строковое */
  String = 'STRING'
}

/** Модификации событий */
export type EventGeneratorMutations = {
  __typename?: 'EventGeneratorMutations';
  /** Отправить список событий */
  sendEvents: Array<EventDataMap>;
};


/** Модификации событий */
export type EventGeneratorMutationsSendEventsArgs = {
  events: Array<InputMaybe<EventData>>;
  shard?: InputMaybe<Scalars['String']['input']>;
};

/** Запросы данных о событиях */
export type EventGeneratorQueries = {
  __typename?: 'EventGeneratorQueries';
  /** Получить информацию о структуре события */
  getEventStructure: EventStructureData;
  /** Получение мета-данных о возможных событиях */
  getEventsMeta: Array<EventMeta>;
  /** Получить информацию о списке шард */
  getShardSet: Array<Scalars['String']['output']>;
};


/** Запросы данных о событиях */
export type EventGeneratorQueriesGetEventStructureArgs = {
  eventClassName: Scalars['String']['input'];
};

/** Информация о предстоящем событии в экзаменационной среде */
export type EventInfo = {
  __typename?: 'EventInfo';
  /** Причина недоступности события для прохождения */
  denialReason?: Maybe<ExamDenialReason>;
  /** Дата и время окончания события */
  endDateTime: Scalars['DateTime']['output'];
  /** Идентификатор события */
  examEventId: Scalars['ID']['output'];
  /** Тип события */
  examEventType: ExamType;
  /** Название проекта по которому проводится событие */
  goalName: Scalars['String']['output'];
  /** Дата и время начала события */
  startDateTime: Scalars['DateTime']['output'];
};

/** Мета-данные о событии */
export type EventMeta = {
  __typename?: 'EventMeta';
  /** Имя класса события */
  eventClassName: Scalars['String']['output'];
};

export type EventMutations = {
  __typename?: 'EventMutations';
  /** БА - одобрить заявку на мероприятие участника */
  approveParticipantEvent: ActivityEvent;
  /** Участник - отозвать предложенное мероприятие */
  cancelParticipantEvent: ActivityEvent;
  /** БА - Создание мероприятия в школе */
  createActivityEvent: ActivityEvent;
  /** Участник - предложить мероприятие */
  createParticipantEvent: ActivityEvent;
  /** БА - отклонить заявку на мероприятие участника */
  rejectParticipantEvent: ActivityEvent;
  /** БА - Обновление мероприятия в школе */
  updateActivityEvent: ActivityEvent;
  /** Участник - редактировать предложенное мероприятие */
  updateParticipantEvent: ActivityEvent;
};


export type EventMutationsApproveParticipantEventArgs = {
  activityEventId: Scalars['ID']['input'];
  comment?: InputMaybe<Scalars['String']['input']>;
  input?: InputMaybe<ActivityEventInput>;
  withChanges?: InputMaybe<Scalars['Boolean']['input']>;
};


export type EventMutationsCancelParticipantEventArgs = {
  activityEvent: Scalars['ID']['input'];
};


export type EventMutationsCreateActivityEventArgs = {
  activityEvent: ActivityEventInput;
};


export type EventMutationsCreateParticipantEventArgs = {
  input: ActivityEventByStudentInputModel;
};


export type EventMutationsRejectParticipantEventArgs = {
  activityEventId: Scalars['ID']['input'];
  comment?: InputMaybe<Scalars['String']['input']>;
};


export type EventMutationsUpdateActivityEventArgs = {
  activityEvent: ActivityEventInput;
  activityEventId: Scalars['ID']['input'];
};


export type EventMutationsUpdateParticipantEventArgs = {
  activityEventId: Scalars['ID']['input'];
  input: ActivityEventByStudentInputModel;
};

export type EventQueries = {
  __typename?: 'EventQueries';
  /** Получение мероприятия по идентификатору */
  getActivityEvent: ActivityEvent;
  /** Получение количества мероприятий */
  getActivityEventCount: Scalars['Int']['output'];
  /** Получение списка отзывов по идентификатору мероприятия */
  getActivityEventFeedback: Array<Maybe<StudentEventFeedback>>;
  /** Получение количества отзывов по идентификатору мероприятия */
  getActivityEventFeedbackCount: Scalars['Int']['output'];
  /** Получение списка предложенных мероприятий */
  getActivityEvents: Array<ActivityEvent>;
  /** Получение списка событий "Мероприятие" по идентификатору школу */
  getCalendarEventParticipantsReport: ReportExcelFile;
  getEventStudents: Array<StudentEvent>;
  /** Получение рекомендованной продолжительности мероприятия */
  getLaboriousnessByGoalId: Scalars['Int']['output'];
  /** Получение участником списка предложенных им мероприятий */
  getMySuggestedActivities?: Maybe<Array<CalendarEvent>>;
  /** Получение участником количества предложенных им мероприятий */
  getMySuggestedActivitiesCount: Scalars['Int']['output'];
  /** Получение списка классов по предмету для мероприятия */
  getStageSubjectGroupsByEventId: Array<StageSubjectGroup>;
  /** Получение списка параллелей для мероприятия */
  getStagesByEventId: Array<Stage>;
};


export type EventQueriesGetActivityEventArgs = {
  activityEventId: Scalars['ID']['input'];
};


export type EventQueriesGetActivityEventFeedbackArgs = {
  activityEventId: Scalars['ID']['input'];
  page: PagingInput;
};


export type EventQueriesGetActivityEventFeedbackCountArgs = {
  activityEventId: Scalars['ID']['input'];
};


export type EventQueriesGetActivityEventsArgs = {
  page: PagingInput;
  sortingField?: InputMaybe<SortingField>;
};


export type EventQueriesGetCalendarEventParticipantsReportArgs = {
  eventId: Scalars['ID']['input'];
};


export type EventQueriesGetEventStudentsArgs = {
  eventId: Scalars['ID']['input'];
  page: PagingInput;
  studentType: StudentEventTypeEnum;
};


export type EventQueriesGetLaboriousnessByGoalIdArgs = {
  goalId: Scalars['ID']['input'];
};


export type EventQueriesGetMySuggestedActivitiesArgs = {
  page: PagingInput;
  statuses?: InputMaybe<Array<InputMaybe<ParticipantEventStatus>>>;
};


export type EventQueriesGetMySuggestedActivitiesCountArgs = {
  statuses?: InputMaybe<Array<InputMaybe<ParticipantEventStatus>>>;
};


export type EventQueriesGetStageSubjectGroupsByEventIdArgs = {
  eventId: Scalars['ID']['input'];
};


export type EventQueriesGetStagesByEventIdArgs = {
  eventId: Scalars['ID']['input'];
};

/** Данные о структуре события */
export type EventStructureData = {
  __typename?: 'EventStructureData';
  /** Имя класса события */
  eventClassName: Scalars['String']['output'];
  /** Набор полей события */
  fields: Array<Maybe<FieldData>>;
};

/** Экзамен в школе */
export type Exam = {
  __typename?: 'Exam';
  /** Дата начала экзамена */
  beginDate: Scalars['DateTime']['output'];
  /** Дата создания экзамена */
  createDate: Scalars['DateTime']['output'];
  /** Текущее число зарегистрированных студентов на экзамен */
  currentStudentsCount: Scalars['Int']['output'];
  /** Текущее число студентов в списке ожидания */
  currentWaitListStudentsCount: Scalars['Int']['output'];
  /** Дата окончания экзамена */
  endDate: Scalars['DateTime']['output'];
  /** Идентификатор события */
  eventId: Scalars['ID']['output'];
  /** Тип события */
  eventType?: Maybe<Scalars['String']['output']>;
  /** Идентификатор экзамена */
  examId: Scalars['ID']['output'];
  /** Формат проведения */
  examType: ExamType;
  /** Проект */
  goalId: Scalars['ID']['output'];
  /** Наименование модуля */
  goalName: Scalars['String']['output'];
  /**
   * IP аудитории
   * @deprecated Не решает бизнес-задачи
   */
  ip?: Maybe<Scalars['String']['output']>;
  /** Находится ли студент в листе ожидания */
  isInWaitList?: Maybe<Scalars['Boolean']['output']>;
  /** Факт включения прокторинга */
  isProctoring?: Maybe<Scalars['Boolean']['output']>;
  /** Зарегистрирован студент на событие или нет */
  isRegistered?: Maybe<Scalars['Boolean']['output']>;
  /** Виден ли экзамен студентам */
  isVisible: Scalars['Boolean']['output'];
  /** Активен ли лист ожидания */
  isWaitListActive: Scalars['Boolean']['output'];
  /** Место проведения */
  location: Scalars['String']['output'];
  /** Максимальное количество участников */
  maxStudentCount?: Maybe<Scalars['Int']['output']>;
  /** Название проекта */
  name: Scalars['String']['output'];
  /** Статус регистрации на календарное событие */
  registrationAccessStatus: ExamEventRegistrationAccessStatus;
  /** Индентификатор школы */
  schoolId: Scalars['ID']['output'];
  /** Список классов (групп по предмету) */
  stageSubjectGroups?: Maybe<Array<Maybe<StageSubjectGroup>>>;
  /** Курсы */
  stages?: Maybe<Array<Maybe<Stage>>>;
  /** Дата начала регистрации на экзамен */
  startRegisterDate?: Maybe<Scalars['DateTime']['output']>;
  /** Дата завершения регистрации на экзамен */
  stopRegisterDate?: Maybe<Scalars['DateTime']['output']>;
  /** Дата обновления экзамена */
  updateDate: Scalars['DateTime']['output'];
};

/** Причина недопуска студента в экзамен */
export enum ExamDenialReason {
  /** Экзаменационное событие не найдено */
  ExamEventNotFound = 'EXAM_EVENT_NOT_FOUND',
  /** Забыл записаться в обоих местах */
  ForgotToRegisterOnBoth = 'FORGOT_TO_REGISTER_ON_BOTH',
  /** Забыл записаться на событие */
  ForgotToRegisterOnEvent = 'FORGOT_TO_REGISTER_ON_EVENT',
  /** Забыл записаться на экзаменационный модуль */
  ForgotToRegisterOnModule = 'FORGOT_TO_REGISTER_ON_MODULE'
}

/** статус доступности регистрации на экзамен для конкретного студента */
export enum ExamEventRegistrationAccessStatus {
  /** Экзамен недоступен для регистрации (кончились места или время регистрации) */
  Closed = 'CLOSED',
  /** Экзамен конфликтует по времени с другим экзаменом, на котором студент уже зарегистрирован */
  Conflict = 'CONFLICT',
  /** Экзамен доступен для регистрации */
  Open = 'OPEN'
}

export type ExamEventsSearchParametersInput = {
  /** Дата начала периода поиска экзаменов */
  beginDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Дата окончания периода поиска экзаменов */
  endDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Формат проведения */
  examType?: InputMaybe<ExamType>;
  /** Id мероприятий исключенных из поиска */
  excludedEventIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Проект */
  goalId?: InputMaybe<Scalars['ID']['input']>;
  /** Кампус */
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  /** Группы по предметам */
  stageSubjectGroupIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Параллели */
  stages?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/** Экзамен в школе */
export type ExamInput = {
  /** Дата начала экзамена */
  beginDate: Scalars['DateTime']['input'];
  /** Дата окончания экзамена */
  endDate: Scalars['DateTime']['input'];
  /** Формат проведения */
  examType?: InputMaybe<ExamType>;
  /** Проект */
  goalId: Scalars['ID']['input'];
  /** IP аудитории */
  ip?: InputMaybe<Scalars['String']['input']>;
  /** Факт включения прокторинга */
  isProctoring?: InputMaybe<Scalars['Boolean']['input']>;
  /** Видимость */
  isVisible?: InputMaybe<Scalars['Boolean']['input']>;
  /** Активен ли лист ожидания */
  isWaitListActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Место проведения */
  location: Scalars['String']['input'];
  /** Максимальное количество участников */
  maxStudentCount?: InputMaybe<Scalars['Int']['input']>;
  /** Название проекта */
  name: Scalars['String']['input'];
  /** Группы по предметам */
  stageSubjectGroups: Array<Scalars['ID']['input']>;
  /** Параллели */
  stages: Array<Scalars['ID']['input']>;
  /** Дата начала регистрации на экзамен */
  startRegisterDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Дата завершения регистрации на экзамен */
  stopRegisterDate?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Учебный модуль s21 */
export type ExamModule = {
  __typename?: 'ExamModule';
  /** Общая информация о учебном модуле */
  generalInformation?: Maybe<ExamModuleGeneralInfo>;
  /** Идентификатор учебного модуля */
  goalId: Scalars['ID']['output'];
  /** Мета информация о учебном модуле */
  projectSettings?: Maybe<ExamModuleSettings>;
  /** Задания учебного модуля */
  tasks?: Maybe<ExamModuleTasks>;
};

/** Общая информация о учебном модуле s21 */
export type ExamModuleGeneralInfo = {
  __typename?: 'ExamModuleGeneralInfo';
  /** Количество попыток на экзамен */
  examAttempts: Scalars['Int']['output'];
  /** Очки за экзамен */
  examPoints: Scalars['Int']['output'];
  /** Идентификатор учебного модуля */
  goalId: Scalars['ID']['output'];
  /** Повышающий коэффициент */
  multiplier: Scalars['Float']['output'];
  /** Процент выполнения */
  percentageOfCompletion: Scalars['Int']['output'];
  /** Начисление баллов: Успех */
  successLevelPoints: Scalars['Int']['output'];
  /** Количество попыток на задание */
  taskAttempts: Scalars['Int']['output'];
  /** Начисление баллов: Ошибка */
  taskFailPoints: Scalars['Int']['output'];
  /** Начисление баллов: Пропуск */
  taskSkipPoints: Scalars['Int']['output'];
};

/** Общая информация о учебном модуле s21 */
export type ExamModuleGeneralInfoInput = {
  /** Количество попыток на задание */
  examAttempts: Scalars['Int']['input'];
  /** Очки за экзамен */
  examPoints: Scalars['Int']['input'];
  /** Идентификатор учебного модуля */
  goalId: Scalars['ID']['input'];
  /** Повышающий коэффициент */
  multiplier: Scalars['Float']['input'];
  /** Процент выполнения */
  percentageOfCompletion: Scalars['Int']['input'];
  /** Начисление баллов: Успех */
  successLevelPoints: Scalars['Int']['input'];
  /** Количество попыток на задание */
  taskAttempts: Scalars['Int']['input'];
  /** Начисление баллов: Ошибка */
  taskFailPoints: Scalars['Int']['input'];
  /** Начисление баллов: Пропуск */
  taskSkipPoints: Scalars['Int']['input'];
};

/** Задания учебного модуля разибтые на "уровни" s21 */
export type ExamModuleLevelTaskGroup = {
  __typename?: 'ExamModuleLevelTaskGroup';
  /** Идентификатор уровня (playlist) */
  levelId: Scalars['ID']['output'];
  /** Порядковый номер уровня */
  levelOrder: Scalars['Int']['output'];
  /** Комментарий в рамках уровня */
  note?: Maybe<Scalars['String']['output']>;
  /** Информация о заданиях учебного модуля */
  tasks?: Maybe<Array<ExamModuleTask>>;
};

/** Задания учебного модуля разбитые на "уровни" s21 */
export type ExamModuleLevelTaskGroupInput = {
  /** Идентификатор уровня экзамена */
  levelId: Scalars['ID']['input'];
  /** Порядковый номер уровня */
  levelOrder: Scalars['Int']['input'];
  /** Текстовое описание уровня */
  note?: InputMaybe<Scalars['String']['input']>;
  /** Задания внутри уровня */
  tasks?: InputMaybe<Array<ExamModuleTaskInput>>;
};

/** Мета информация о учебном модуле s21 */
export type ExamModuleSettings = {
  __typename?: 'ExamModuleSettings';
  /** Дата создания Учебного Модуля */
  createTime: Scalars['DateTime']['output'];
  /** Пользователь, создавший Учебный Модуль */
  createUser: User;
  /** Описание экзамена */
  description: Scalars['String']['output'];
  /** Название экзамена */
  examName: Scalars['String']['output'];
  /** Идентификатор учебного модуля */
  goalId: Scalars['ID']['output'];
  /** Описание учебного модуля */
  idea: Scalars['String']['output'];
  /** Рекомендуемая трудоемкость в часах */
  laboriousness: Scalars['Int']['output'];
  /** Дата последнего изменения Учебного Модуля */
  modifyTime?: Maybe<Scalars['DateTime']['output']>;
  /** Пользователь, который последний раз модифицировал Учебный Модуль */
  modifyUser?: Maybe<User>;
  /** Название учебного модуля */
  name: Scalars['String']['output'];
  /** Заметка для методиста АНО */
  note?: Maybe<Scalars['String']['output']>;
  /** "Уровень публикации" */
  scope: ScopeEnum;
  /** Параллель, для которой рекомендован Учебный Модуль */
  stage: Stage;
  /** Предмет, для которого создан Учебный Модуль */
  subject: Subject;
};

/** Мета информация о учебном модуле s21 */
export type ExamModuleSettingsInput = {
  /** Тип контента */
  contentType: ModuleType;
  /** Тип выполнения */
  executionType: ModuleExecutionType;
  /** Идентификатор учебного модуля */
  goalId?: InputMaybe<Scalars['ID']['input']>;
  /** Название учебного модуля */
  goalName: Scalars['String']['input'];
  /** Описание учебного модуля */
  idea: Scalars['String']['input'];
  /** Рекомендуемая трудоемкость в часах */
  laboriousness: Scalars['Int']['input'];
  /** Заметка для методиста АНО */
  note?: InputMaybe<Scalars['String']['input']>;
  /** "Уровень публикации" */
  scope: ScopeEnum;
  /** Параллель, для которой рекомендован Учебный Модуль */
  stageId: Scalars['ID']['input'];
  /** Предмет, для которого создан Учебный Модуль */
  subjectId: Scalars['ID']['input'];
};

/** Информация о задании учебного модуля s21 */
export type ExamModuleTask = {
  __typename?: 'ExamModuleTask';
  /** Дата создания задания */
  createTime: Scalars['DateTime']['output'];
  /** Пользователь, создавший задание */
  createUser: User;
  /** Дата последнего изменения задания */
  modifyTime?: Maybe<Scalars['DateTime']['output']>;
  /** Пользователь, который последний раз модифицировал задание */
  modifyUser?: Maybe<User>;
  /** Идентификатор задания */
  taskId: Scalars['ID']['output'];
  /** Название задания */
  taskName: Scalars['String']['output'];
  /** Порядковый номер для корректного отображения на фронте */
  taskOrder: Scalars['Int']['output'];
};

/** Задание учебного модуля с указанием его порядкового номера в списке s21 */
export type ExamModuleTaskInput = {
  /** Идентификатор задания */
  taskId: Scalars['ID']['input'];
  /** Порядковый уровень задания в рамках всего экзамена (для отображения на фронте) */
  taskOrder: Scalars['Int']['input'];
};

/** Задания учебного модуля s21 */
export type ExamModuleTasks = {
  __typename?: 'ExamModuleTasks';
  /** Идентификатор учебного модуля */
  goalId: Scalars['ID']['output'];
  /** Задания учебного модуля разибтые на "уровни" */
  levelTaskGroups?: Maybe<Array<ExamModuleLevelTaskGroup>>;
};

/** Задания учебного модуля s21 */
export type ExamModuleTasksInput = {
  /** Идентификатор учебного модуля */
  goalId: Scalars['ID']['input'];
  /** Уровни внутри экзамена с заданиями */
  levelTaskGroups?: InputMaybe<Array<ExamModuleLevelTaskGroupInput>>;
};

/** Мета информации для подготовки студента к прохождению экзамена */
export type ExamPassingUser = {
  __typename?: 'ExamPassingUser';
  /** Описание экзамена */
  examDescription: Scalars['String']['output'];
  /** Идентификатор экзамена (goal) */
  examId: Scalars['ID']['output'];
  /** Заголовок экзамена */
  examName: Scalars['String']['output'];
  /** Временный идентификатор пользователя в другой системе */
  fakeExternalSystemUserId: Scalars['String']['output'];
  /** Временный логин пользователя в другой системе */
  fakeExternalSystemUserLogin: Scalars['String']['output'];
  /** Флаг, показывающий был ли начат экзамен (хотя бы одно задание было начато пользователем) */
  isExamStarted: Scalars['Boolean']['output'];
  /** SSH ключ */
  key?: Maybe<Scalars['String']['output']>;
};

/** Информация о результатах экзамена */
export type ExamResult = {
  __typename?: 'ExamResult';
  /** Это первая попытка прохождения (true/false) */
  isFirstAttempt: Scalars['Boolean']['output'];
  /** Бинарный результат для текущей попытки - пройден/провален */
  isPassed: Scalars['Boolean']['output'];
  /** Бинарный результат для всех попыток (пройден/провален) */
  isPassedAllAttempts: Scalars['Boolean']['output'];
  /** Количество пройденных уровней в текущей попытке */
  levelsPassed: Scalars['Int']['output'];
  /** Всего уровней в экзамене в текущей попытке */
  levelsTotal: Scalars['Int']['output'];
  /** Количество ошибок в экзамене которые можно было допустить в текущей попытке */
  mistakesAvailableTotal: Scalars['Int']['output'];
  /** Количество фактически допущенных ошибок в текущей попытке */
  mistakesMade: Scalars['Int']['output'];
  /** Набранное количество баллов в текущей попытке */
  score: Scalars['Int']['output'];
  /** Набранное кол-во XP (баллов) за все попытки */
  scoreAllAttempts: Scalars['Int']['output'];
  /** Процент выполнения экзамена в текущей попытке */
  successRate: Scalars['Int']['output'];
  /** Процент выполнения за все попытки */
  successRateAllAttempts: Scalars['Int']['output'];
  /** Количество выполненных верно заданий в текущей попытке */
  successTaskCount: Scalars['Int']['output'];
};

/** Информация о задании во время прохождения экзамена с указанием кол-ва попыток и статусами */
export type ExamStatusInfo = {
  __typename?: 'ExamStatusInfo';
  /** Причина по которой не пускаем судента в экзамен */
  denialReason?: Maybe<ExamDenialReason>;
  /** Продолжительность экзамена в минутах */
  duration: Scalars['Int']['output'];
  /** Дата и время окончания экзамена */
  endDateTime: Scalars['DateTime']['output'];
  /** Количество попыток прохождения на весь экзамен */
  examAttemptsCount: Scalars['Int']['output'];
  /** Идентификатор события, в котором происходит экзамен */
  examEventId: Scalars['Int']['output'];
  /** Идентификаор экзамена */
  goalId: Scalars['Int']['output'];
  /** Выолняется ли данный экзамен в рамках курса */
  isExamInCourse?: Maybe<Scalars['Boolean']['output']>;
  /** признак включения прокторинга для экзамена */
  isProctoring?: Maybe<Scalars['Boolean']['output']>;
  /** Количество уровней заданий экзамена */
  levelCount: Scalars['Int']['output'];
  /** Текущее время сервера */
  nowDateTime: Scalars['DateTime']['output'];
  /** Дата и время начала экзамена */
  startDateTime: Scalars['DateTime']['output'];
  /** Текущий статус экзамена */
  status: GoalStatus;
  /** Количество попыток прохождения на одно задание */
  taskAttemptsCount: Scalars['Int']['output'];
};

/** Информация о задании во время прохождения экзамена с указанием кол-ва попыток и статусами */
export type ExamTaskWithStatuses = {
  __typename?: 'ExamTaskWithStatuses';
  /** Контент (markdown) задания */
  contentText: Scalars['String']['output'];
  /** Дата и время окончания экзамена */
  endDateTime: Scalars['DateTime']['output'];
  /** Идентификатор уровня */
  levelId: Scalars['Int']['output'];
  /** Комментарий (описание) к уровню экзамена */
  levelNote: Scalars['String']['output'];
  /** Порядковый номер уровня */
  levelOrder: Scalars['Int']['output'];
  /** Массив со статусами всех заданий (в том числе не начатых) распределённых по уровням внутри экзамена */
  levelsStatuses: Array<ExamTasksStatusesByLevel>;
  /** Текущее время сервера */
  nowDateTime: Scalars['DateTime']['output'];
  /** Контент задания с правильными подставленными ссылками на изображения */
  taskContent?: Maybe<Task>;
  /** Ссылка на проект с заданием в гитлабе */
  taskGitlabProjectUrl: Scalars['String']['output'];
  /** Идентификатор задания */
  taskId: Scalars['Int']['output'];
  /** Номер задания внутри уровня */
  taskOrder: Scalars['Int']['output'];
  /** Название задания */
  taskTitle: Scalars['String']['output'];
  /** Кол-во оставшихся попыток в рамках всего экзамена */
  tryCountExamRemain: Scalars['Int']['output'];
  /** Кол-во доступных попыток в рамках этого задания */
  tryCountTaskAvailable: Scalars['Int']['output'];
  /** Кол-во оставшихся попыток в рамках этого задания */
  tryCountTaskRemain: Scalars['Int']['output'];
  /** Кол-во израсходованных попыток в рамках этого задания */
  tryCountTaskSpent: Scalars['Int']['output'];
};

export type ExamTasksStatusesByLevel = {
  __typename?: 'ExamTasksStatusesByLevel';
  /** Порядковый номер уровня */
  levelOrder: Scalars['Int']['output'];
  /** Список статусов для задач внутри одного уровня */
  tasksStatuses: Array<Maybe<TaskStatusEnum>>;
};

/** Информация о результатах прохождения экзаменационного теста */
export type ExamTestResult = {
  __typename?: 'ExamTestResult';
  /** Всего ответов на задание в дженерике в текущей попытке */
  allAnswersCount: Scalars['Int']['output'];
  /** Это первая попытка прохождения (true/false) */
  isFirstAttempt: Scalars['Boolean']['output'];
  /** Бинарный результат - пройден/провален для текущей попытки */
  isPassed: Scalars['Boolean']['output'];
  /** Бинарный результат для всех попыток (пройден/провален) */
  isPassedAllAttempts: Scalars['Boolean']['output'];
  /** Набранное количество XP (баллов) в текущей попытке */
  score: Scalars['Int']['output'];
  /** Набранное кол-во XP (баллов) за все попытки */
  scoreAllAttempts: Scalars['Int']['output'];
  /** Полная информация по заданию в контексте студента */
  studentTaskInfo: StudentTaskInfo;
  /** Количество верных ответов в текущей попытке */
  successAnswersCount: Scalars['Int']['output'];
  /** Процент выполнения задания в текущей попытке */
  successRate: Scalars['Int']['output'];
  /** Процент выполнения за все попытки */
  successRateAllAttempts: Scalars['Int']['output'];
};

/** Информация о экзаменационном тесте */
export type ExamTestStatusInfo = {
  __typename?: 'ExamTestStatusInfo';
  /** Причина по которой не пускаем судента в экз. тест */
  denialReason?: Maybe<ExamDenialReason>;
  /** Продолжительность теста в минутах */
  duration: Scalars['Int']['output'];
  /** Дата и время окончания теста */
  endDateTime: Scalars['DateTime']['output'];
  /** Идентификатор события, в котором происходит экз. тест */
  examEventId: Scalars['Int']['output'];
  /** Идентификаор модуля с тестом */
  goalId: Scalars['Int']['output'];
  /** Выолняется ли данный тест в рамках курса */
  isExamInCourse?: Maybe<Scalars['Boolean']['output']>;
  /** Текущее время сервера */
  nowDateTime: Scalars['DateTime']['output'];
  /** Дата и время начала теста */
  startDateTime: Scalars['DateTime']['output'];
  /** Текущий статус экз. теста */
  status: GoalStatus;
  /** Идентификатор задания для теста */
  taskId: Scalars['Int']['output'];
};

/** Формат проведения экзамена в Ш21 */
export enum ExamType {
  /** Экзамен */
  Exam = 'EXAM',
  /** Тест */
  Test = 'TEST'
}

export type ExcelWithAffectedStudentsModel = {
  __typename?: 'ExcelWithAffectedStudentsModel';
  /** Base64 эксель со студентами, которых затронет перепубликация */
  base64Excel?: Maybe<Scalars['String']['output']>;
  /** Количество студентов, которых затронет перепубликация */
  numberOfAffectedStudents: Scalars['Int']['output'];
};

/** Подробная информация о запрете выполнения задания */
export type ExecuteDenyInfo = {
  __typename?: 'ExecuteDenyInfo';
  /** Мета информация */
  meta?: Maybe<Scalars['String']['output']>;
  /** Причина запрета выполнения задания */
  reason: ExecuteDenyReason;
};

/** Причина, по которой выполнение запрещено */
export enum ExecuteDenyReason {
  /** Срок жесткого дедлайна истек */
  HardDeadlineExpired = 'HARD_DEADLINE_EXPIRED',
  /** Один из предыдущих уровней модуля не выполнен */
  PreviousLevelNotAchieved = 'PREVIOUS_LEVEL_NOT_ACHIEVED'
}

/** Результат отчисления студентов */
export type ExpelResult = {
  __typename?: 'ExpelResult';
  /** Студенты, в ходе отчисления которых возникли ошибки */
  studentsWithErrors?: Maybe<Array<Student>>;
  /** Успешно отчисленные студенты */
  successfullyExpelledStudents?: Maybe<Array<Student>>;
};

/** Полученный опыт за конкретные дни */
export type ExperienceHistoryDate = {
  __typename?: 'ExperienceHistoryDate';
  /** дата получения опыта */
  awardDate: Scalars['Date']['output'];
  /** количество накопленного опыта на дату */
  expValue: Scalars['Int']['output'];
  /** количество накопленного опыта за день */
  experienceReceived: Scalars['Int']['output'];
};

export type ExperienceLevel = {
  __typename?: 'ExperienceLevel';
  /** Уровень (Id уровня) */
  id: Scalars['Int']['output'];
  /** Код уровня */
  levelCode: Scalars['Int']['output'];
  /** предыдущий уровень  (Id предыдущего уровня) */
  previous: Scalars['Int']['output'];
  /** вилка опыта на данном уровне */
  range: ExperienceLevelRange;
  /** статус, выдаваемый за достижение уровня */
  status: Scalars['String']['output'];
  tenantShortName?: Maybe<Scalars['String']['output']>;
};

/** Диапазон опыта за уровень */
export type ExperienceLevelRange = {
  __typename?: 'ExperienceLevelRange';
  /**
   * Стикер-Аватар выдаваемый при достижении уровня
   * {null} в случае, если за достижения уровня не назначена выдача стикера
   */
  avatar?: Maybe<Avatar>;
  /** Награды, выдаваемые за достижение данного уровня */
  awards: Array<Award>;
  /**
   * Часть стикер-фона выдаваемого при достижении уровня
   * {null} в случае, если за достижения уровня не назначена выдача стикер-фона
   */
  bgStickerPart?: Maybe<BgStickerPart>;
  /** id диапазона */
  id: Scalars['ID']['output'];
  /** наименьшее количество опыта на данном уровне */
  leftBorder: Scalars['Int']['output'];
  /** id уровня */
  level: Scalars['Int']['output'];
  /** код уровня */
  levelCode: Scalars['Int']['output'];
  /** максимальное количество опыта на данном уровне */
  rightBorder: Scalars['Int']['output'];
};

export type ExperienceLevelRangeInput = {
  /**
   * ID Стикер-Аватара выдаваемого при достижении уровня
   * {null} в случае, если за достижения уровня не назначена выдача стикера
   */
  avatarId?: InputMaybe<Scalars['Int']['input']>;
  /** ID наград, выдаваемых при достижении уровня */
  awardIds: Array<Scalars['ID']['input']>;
  /**
   * ID части стикер-фона выдаваемого при достижении уровня
   * {null} в случае, если за достижения уровня не назначена выдача стикер-фона
   */
  bgStickerPartId?: InputMaybe<Scalars['Int']['input']>;
  /** наименьшее количество опыта на данном уровне */
  leftBorder: Scalars['Int']['input'];
  /** максимальное количество опыта на данном уровне */
  rightBorder: Scalars['Int']['input'];
};

/** Условия начисления очков опыта за выполнения заданий */
export type ExperienceTaskType = {
  __typename?: 'ExperienceTaskType';
  /** дополнительная информация */
  additionalInfo: Scalars['String']['output'];
  /** описание условия начисления опыта */
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** количество начисляемых очков опыта */
  power: Scalars['Int']['output'];
};

/** Информация о не завершенных в сорк Домашних Работах ученика */
export type ExpiredStudentHomeworksInfo = {
  __typename?: 'ExpiredStudentHomeworksInfo';
  /** Список Домашних Работ для Ученика, разбитый по датам (в зоне школы) */
  homeworksByDate: Array<StudentHomeworksByDate>;
  /** Общее кол-во дат с не завершеными в сорк Домашними Работами */
  totalDatesWithExpiredHomeworksCount: Scalars['Int']['output'];
};

export type ExportQueries = {
  __typename?: 'ExportQueries';
  /** Экспорт списка модулей Учителя по json модели данных */
  getTeacherModules: Scalars['String']['output'];
};


export type ExportQueriesGetTeacherModulesArgs = {
  filterAccess?: InputMaybe<Scalars['Boolean']['input']>;
  filterArchived?: InputMaybe<Scalars['Boolean']['input']>;
  filterCreateTimeFrom?: InputMaybe<Scalars['String']['input']>;
  filterCreateTimeTo?: InputMaybe<Scalars['String']['input']>;
  filterExceptGoals?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterExecutionType?: InputMaybe<Scalars['Int']['input']>;
  filterForCurrentUser?: InputMaybe<Scalars['Boolean']['input']>;
  filterImported?: InputMaybe<Scalars['Boolean']['input']>;
  filterIsCreatedByCurrentUser?: InputMaybe<Scalars['Boolean']['input']>;
  filterLaboriousnessFrom?: InputMaybe<Scalars['Int']['input']>;
  filterLaboriousnessTo?: InputMaybe<Scalars['Int']['input']>;
  filterReady?: InputMaybe<Scalars['Boolean']['input']>;
  filterScope?: InputMaybe<ScopeEnum>;
  filterStages?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterSubjects?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  jsonModel: Scalars['String']['input'];
  nameOnlyTextSearch?: InputMaybe<Scalars['Boolean']['input']>;
  paging?: InputMaybe<PagingInput>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};

export type ExtendedContentType = {
  __typename?: 'ExtendedContentType';
  contentType: AdditionalContentType;
  subtypes: Array<ContentSubtype>;
};

/** Урок по группе класса по предмету */
export type ExtendedLesson = {
  __typename?: 'ExtendedLesson';
  classroom: Scalars['String']['output'];
  /** Есть ли хотя бы одна активная оценка по уроку */
  hasLessonLearningActivities: Scalars['Boolean']['output'];
  /** Есть ли план урока */
  hasLessonPlans: Scalars['Boolean']['output'];
  /** Есть ли отметки о посещаемости по уроку */
  hasVisitJournalCells: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** Архивирован ли урок */
  isArchived?: Maybe<Scalars['Boolean']['output']>;
  /** Опубликован ли урок */
  isPublished?: Maybe<Scalars['Boolean']['output']>;
  isStageGroupIsIntergroup: Scalars['Boolean']['output'];
  /** Является ли урок онлайн-уроком */
  isVideoLesson?: Maybe<Scalars['Boolean']['output']>;
  lessonEndTime: Scalars['Time']['output'];
  lessonNote?: Maybe<Scalars['String']['output']>;
  lessonNumber: Scalars['Int']['output'];
  /** Ид плана урока */
  lessonPlanId?: Maybe<Scalars['ID']['output']>;
  /** Комментарии к плану */
  lessonPlanNotes?: Maybe<Array<Scalars['String']['output']>>;
  lessonStartTime: Scalars['Time']['output'];
  onlineLessonLink?: Maybe<Scalars['String']['output']>;
  stageGroupName: Scalars['String']['output'];
  stageGroups: Array<StageGroup>;
  stageId: Scalars['ID']['output'];
  stageSubjectGroup: Scalars['String']['output'];
  stageSubjectGroupId: Scalars['ID']['output'];
  subject: Scalars['String']['output'];
  teacher: TeacherCommonInfo;
  /** Тип видеоконференции */
  videoconferenceTypeId?: Maybe<Scalars['ID']['output']>;
};

/** Драфт урока по ГКпП */
export type ExtendedLessonDraft = {
  __typename?: 'ExtendedLessonDraft';
  /** Идентификатор здания */
  buildingId: Scalars['ID']['output'];
  /** Наименование кабинета */
  classroom: Scalars['String']['output'];
  /** Идентификатор кабинета */
  classroomId: Scalars['ID']['output'];
  /** Является ли группа межклассовой */
  isStageGroupIsIntergroup: Scalars['Boolean']['output'];
  /** Идентификатор драфта урока */
  lessonDraftId: Scalars['ID']['output'];
  /** Время окончания урока */
  lessonEndTime: Scalars['Time']['output'];
  /** Номер урока */
  lessonNumber: Scalars['Int']['output'];
  /** Время начала урока */
  lessonStartTime: Scalars['Time']['output'];
  /** Идентификатор интервала времени, в который проводится урок */
  lessonTimeslotId: Scalars['ID']['output'];
  /** Идентификатор класса */
  stageGroupId: Scalars['ID']['output'];
  /** Наименование класса */
  stageGroupName: Scalars['String']['output'];
  /** Данные о классе */
  stageGroups: Array<StageGroup>;
  /** Идентификатор параллели, к которой относится группа */
  stageId: Scalars['ID']['output'];
  /** Наименование ГКпП */
  stageSubjectGroup: Scalars['String']['output'];
  /** Идентификатор ГКпП */
  stageSubjectGroupId: Scalars['ID']['output'];
  /** Наименование предмета */
  subject: Scalars['String']['output'];
  /** Идентификатор предмета */
  subjectId: Scalars['ID']['output'];
  /** Идентификатор учителя и его идентификатор пользователя */
  teacher: TeacherCommonInfo;
};

/** Описание внешней системы для проверки заданий с типом "Проверка во внешней системе" */
export type ExternalCheckingSystem = {
  __typename?: 'ExternalCheckingSystem';
  code: Scalars['String']['output'];
  name: Scalars['String']['output'];
  sync: Scalars['Boolean']['output'];
};

/** информация по конкурсам */
export type ExternalCompetition = {
  __typename?: 'ExternalCompetition';
  /** ID конкурса */
  checkBucketId: Scalars['ID']['output'];
  /** Название конкурса */
  learningProgramShortName: Scalars['String']['output'];
};

export type ExternalContentMutations = {
  __typename?: 'ExternalContentMutations';
  /** Загрузка SCORM пакетов */
  loadScorm: ExternalTask;
};


export type ExternalContentMutationsLoadScormArgs = {
  packageName: Scalars['String']['input'];
  stage?: InputMaybe<Scalars['String']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
  taskName: Scalars['String']['input'];
  taskType: Scalars['String']['input'];
  url: Scalars['String']['input'];
};

export enum ExternalContentProviderEnum {
  None = 'NONE',
  /** PHYSICON в будущем будет, возможно, аналогичен SCORM */
  Physicon = 'PHYSICON',
  RosUchebnik = 'ROS_UCHEBNIK',
  Scorm = 'SCORM',
  /** Интеграция с тренажерами */
  TrainingIntegration = 'TRAINING_INTEGRATION'
}

export type ExternalContentQueries = {
  __typename?: 'ExternalContentQueries';
  /** Возвращает расшифровку вида контента по shortcut (в будущем вид shortcut усложнится) */
  decodeShortcut: DecodedContent;
  getAllStages: Array<Scalars['String']['output']>;
  /** Временно, пока нет привязки к кодам предметов, возвращаем просто строки с наименованиями */
  getAllSubjects: Array<Scalars['String']['output']>;
  /** Временно, пока нет привязки к кодам типов заданий, возвращаем просто строки с наименованиями */
  getAllTaskTypes: Array<Scalars['String']['output']>;
  /**
   * получение списка ЭОР (фильтр по полям), использовать searchExternalTasks
   * @deprecated Field no longer supported
   */
  getExternalTasks: Array<ExternalTask>;
  /** получени списка ЭОР (строка поиска) */
  searchExternalTasks: Array<ExternalTask>;
  /** получени кол-ва элементов по списку ЭОР (строка поиска) */
  searchExternalTasksCount: Scalars['Int']['output'];
};


export type ExternalContentQueriesDecodeShortcutArgs = {
  shortcut: Scalars['String']['input'];
};


export type ExternalContentQueriesGetExternalTasksArgs = {
  externalTaskFilter: FilterExternalTaskInput;
};


export type ExternalContentQueriesSearchExternalTasksArgs = {
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  contentProviderActive?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<SearchExternalTaskInput>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  myStages?: InputMaybe<Scalars['Boolean']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  search: Scalars['String']['input'];
  sortingFields?: InputMaybe<Array<SortingField>>;
};


export type ExternalContentQueriesSearchExternalTasksCountArgs = {
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  contentProviderActive?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<SearchExternalTaskInput>;
  myStages?: InputMaybe<Scalars['Boolean']['input']>;
  search: Scalars['String']['input'];
};

export type ExternalLearningMutations = {
  __typename?: 'ExternalLearningMutations';
  /** Создание школьной группы проверяющих */
  addSchoolVerifierGroupUsers: Scalars['Boolean']['output'];
  /** Добавление новой учебной программы */
  createLearningProgram: LearningProgram;
  /** Добавление направления в учебную программу */
  createLearningProgramDirection: LearningProgramDirection;
  /** Добавление школ в программу */
  createLearningProgramSchools: Scalars['Boolean']['output'];
  /** Добавление школ в программу c фильтром */
  createLearningProgramSchoolsWithFilterWithoutIds: Scalars['Boolean']['output'];
  /** Удаление школы участника программы (активные переходят в статус DISABLED) */
  deleteLearningProgramSchool: Scalars['Boolean']['output'];
  /** Удаление школьной группы проверяющих (возвращение регионального) */
  deleteSchoolVerifierGroup: Scalars['Boolean']['output'];
  /** Редактирование направления в учебную программу, изменение ролей */
  editLearningProgramDirectionRoles: Scalars['Boolean']['output'];
  /** Изменение проверяющих по школьной группе */
  editSchoolVerifierGroupUsers: Scalars['Boolean']['output'];
  /** Изменение статуса школы участника программы в ENABLED */
  enableLearningProgramSchool: Scalars['Boolean']['output'];
  /**
   * Миграция
   * @deprecated unusable
   */
  migrate: Scalars['String']['output'];
  /** Публикация программы */
  publishLearningProgram: Scalars['Boolean']['output'];
  /** Публикация направлений */
  publishLearningProgramDirections: Scalars['Boolean']['output'];
  /** Удаление направления программы */
  removeLearningProgramDirection: Scalars['Boolean']['output'];
  /** Сохранение списка администраторов программы */
  saveAdministrators: Scalars['Boolean']['output'];
  /** Сохранение проверяющих по региональным группам */
  saveRegionVerifierGroupUsers: Scalars['Boolean']['output'];
  /** Изменение глобального плана (шаблона плана для направления) */
  updateLearningDirectionGlobalPlanPattern: GlobalPlan;
  /** Изменение учебной программы */
  updateLearningProgram: LearningProgram;
  /** Изменение времени активации школы участника программы */
  updatedLearningProgramSchoolDate: Scalars['Boolean']['output'];
};


export type ExternalLearningMutationsAddSchoolVerifierGroupUsersArgs = {
  learningProgramId: Scalars['ID']['input'];
  schoolId: Scalars['UUID']['input'];
  subjectId: Scalars['ID']['input'];
  userIdsAdd: Array<Scalars['UUID']['input']>;
};


export type ExternalLearningMutationsCreateLearningProgramArgs = {
  name: Scalars['String']['input'];
  shortName: Scalars['String']['input'];
  type: LearningTypeEnum;
};


export type ExternalLearningMutationsCreateLearningProgramDirectionArgs = {
  directionInput: LearningProgramDirectionInput;
};


export type ExternalLearningMutationsCreateLearningProgramSchoolsArgs = {
  learningProgramId: Scalars['ID']['input'];
  schoolIdsAdd: Array<Scalars['UUID']['input']>;
};


export type ExternalLearningMutationsCreateLearningProgramSchoolsWithFilterWithoutIdsArgs = {
  exceptSchoolIds?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  learningProgramSchoolInput: LearningProgramSchoolInput;
};


export type ExternalLearningMutationsDeleteLearningProgramSchoolArgs = {
  learningProgramSchoolId: Scalars['ID']['input'];
};


export type ExternalLearningMutationsDeleteSchoolVerifierGroupArgs = {
  schoolVerifierGroupId: Scalars['ID']['input'];
};


export type ExternalLearningMutationsEditLearningProgramDirectionRolesArgs = {
  learningProgramDirectionId: Scalars['ID']['input'];
  userRoles: Array<Roles>;
};


export type ExternalLearningMutationsEditSchoolVerifierGroupUsersArgs = {
  schoolVerifierGroupId: Scalars['ID']['input'];
  userIdsAdd: Array<Scalars['UUID']['input']>;
  userIdsRemove: Array<Scalars['UUID']['input']>;
};


export type ExternalLearningMutationsEnableLearningProgramSchoolArgs = {
  learningProgramSchoolId: Scalars['ID']['input'];
};


export type ExternalLearningMutationsMigrateArgs = {
  schoolTag: Scalars['String']['input'];
};


export type ExternalLearningMutationsPublishLearningProgramArgs = {
  learningProgramId: Scalars['ID']['input'];
};


export type ExternalLearningMutationsPublishLearningProgramDirectionsArgs = {
  learningProgramDirectionIds: Array<Scalars['ID']['input']>;
};


export type ExternalLearningMutationsRemoveLearningProgramDirectionArgs = {
  learningProgramDirctionId: Scalars['ID']['input'];
};


export type ExternalLearningMutationsSaveAdministratorsArgs = {
  learningProgramId: Scalars['ID']['input'];
  userIdsAdd: Array<Scalars['UUID']['input']>;
  userIdsRemove: Array<Scalars['UUID']['input']>;
};


export type ExternalLearningMutationsSaveRegionVerifierGroupUsersArgs = {
  regionVerifierGroupIds: Array<Scalars['ID']['input']>;
  userIdsAdd: Array<Scalars['UUID']['input']>;
  userIdsRemove: Array<Scalars['UUID']['input']>;
};


export type ExternalLearningMutationsUpdateLearningDirectionGlobalPlanPatternArgs = {
  globalPlanId: Scalars['ID']['input'];
  planGoalInputModels: Array<GlobalPlanGoalInput>;
};


export type ExternalLearningMutationsUpdateLearningProgramArgs = {
  learningProgramId: Scalars['ID']['input'];
  name: Scalars['String']['input'];
  shortName: Scalars['String']['input'];
  type: LearningTypeEnum;
};


export type ExternalLearningMutationsUpdatedLearningProgramSchoolDateArgs = {
  dateEnable: Scalars['Date']['input'];
  learningProgramSchoolId: Scalars['ID']['input'];
};

export type ExternalLearningQueries = {
  __typename?: 'ExternalLearningQueries';
  /** Получение списка администраторов программы */
  getAdministrators: Array<User>;
  /** Получение программы по id */
  getLearningProgramById: LearningProgram;
  /** Получение списка школ участников программы */
  getLearningProgramSchoolsByParam: LearningProgramSchoolsPage;
  /** Получение списка опубликованных активных программ по типу */
  getLearningProgramsActiveAndPublishedByType: Array<LearningProgramSimply>;
  /** Получение программ по школе-организатору */
  getLearningProgramsByOrganizerSchoolId: Array<LearningProgram>;
  /** Получение набора типов обучения */
  getLearningTypes: Array<LearningTypeEnum>;
  /** Получение списка проверяющих по программе */
  getProgramVerifiers: Array<ProgramVerifierGroups>;
  /** Получение списка проверяющих по предмету */
  getSchoolVerifiers: Array<SchoolVerifier>;
  /**
   * Получение списка школ для добавления в программу
   * @deprecated Use getSchoolsForLearningProgramWithFilter instead.
   */
  getSchoolsForLearningProgram: Array<SchoolForLearningProgram>;
  /** Получение списка школ для добавления в программу c фильтром и пагинацией */
  getSchoolsForLearningProgramWithFilter: LearningProgramSchoolList;
  /** Верификация направления программы */
  validateDirection: DirectionValidation;
  /** Верификация настроек программы */
  validateProgram: ProgramValidation;
};


export type ExternalLearningQueriesGetAdministratorsArgs = {
  learningProgramId: Scalars['ID']['input'];
};


export type ExternalLearningQueriesGetLearningProgramByIdArgs = {
  learningProgramId: Scalars['ID']['input'];
};


export type ExternalLearningQueriesGetLearningProgramSchoolsByParamArgs = {
  learningProgramId: Scalars['ID']['input'];
  paging?: InputMaybe<PagingInput>;
  regionName?: InputMaybe<Scalars['String']['input']>;
  schoolIdentifier?: InputMaybe<Scalars['String']['input']>;
  schoolName?: InputMaybe<Scalars['String']['input']>;
  showEditedOnly?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ExternalLearningQueriesGetLearningProgramsActiveAndPublishedByTypeArgs = {
  type: LearningTypeEnum;
};


export type ExternalLearningQueriesGetProgramVerifiersArgs = {
  learningProgramId: Scalars['ID']['input'];
  schoolId: Scalars['UUID']['input'];
};


export type ExternalLearningQueriesGetSchoolVerifiersArgs = {
  subjectId: Scalars['ID']['input'];
};


export type ExternalLearningQueriesGetSchoolsForLearningProgramArgs = {
  learningProgramId: Scalars['ID']['input'];
  tag?: InputMaybe<Scalars['String']['input']>;
};


export type ExternalLearningQueriesGetSchoolsForLearningProgramWithFilterArgs = {
  learningProgramSchoolInput: LearningProgramSchoolInput;
  paging?: InputMaybe<PagingInput>;
};


export type ExternalLearningQueriesValidateDirectionArgs = {
  learningProgramDirectionId: Scalars['ID']['input'];
};


export type ExternalLearningQueriesValidateProgramArgs = {
  learningProgramId: Scalars['ID']['input'];
};

/** Для внешних опросников (input) */
export type ExternalSurveyAnswerInput = {
  /** строка в BASE64 */
  htmlContent?: InputMaybe<Scalars['String']['input']>;
  /** строка в BASE64 */
  jsonContent?: InputMaybe<Scalars['String']['input']>;
};

/** Описание внешнего задания */
export type ExternalTask = {
  __typename?: 'ExternalTask';
  api?: Maybe<Scalars['String']['output']>;
  archived: Scalars['Boolean']['output'];
  config?: Maybe<Scalars['String']['output']>;
  contentLoad: ContentLoad;
  contentProviderActive?: Maybe<Scalars['Boolean']['output']>;
  contentProviderId: Scalars['ID']['output'];
  externalId: Scalars['String']['output'];
  hash?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  jsonMeta?: Maybe<Scalars['String']['output']>;
  /** продублировано из ContentProvider */
  logoUrl?: Maybe<Scalars['String']['output']>;
  path: Scalars['String']['output'];
  /** короткая ссылка ЭОР (относительный путь) */
  shortcut: Scalars['String']['output'];
  stage: Scalars['Int']['output'];
  subject: Scalars['String']['output'];
  subjectId?: Maybe<Scalars['ID']['output']>;
  taskName: Scalars['String']['output'];
  taskType: Scalars['String']['output'];
  taskTypeId?: Maybe<Scalars['ID']['output']>;
  url: Scalars['String']['output'];
  version?: Maybe<Scalars['Float']['output']>;
};

export type ExternalWork = {
  __typename?: 'ExternalWork';
  files: Array<File>;
  id: Scalars['ID']['output'];
  mark?: Maybe<SchoolMark>;
  name: Scalars['String']['output'];
  percentageMark?: Maybe<Scalars['Float']['output']>;
};

export type ExternalWorkInput = {
  fileInputs: Array<FileInput>;
  markId?: InputMaybe<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
  percentageMark?: InputMaybe<Scalars['Float']['input']>;
  stageSubjectId: Scalars['ID']['input'];
  studentId: Scalars['ID']['input'];
  studyPeriodId: Scalars['ID']['input'];
};

export type ExternalWorkV2Input = {
  fileInputs: Array<FileInput>;
  markId?: InputMaybe<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
  percentageMark?: InputMaybe<Scalars['Float']['input']>;
  periodTypeId?: InputMaybe<Scalars['ID']['input']>;
  stageSubjectId: Scalars['ID']['input'];
  studentId: Scalars['ID']['input'];
  studyPeriodId: Scalars['ID']['input'];
};

/** Любимый предмет ученика */
export type FavoriteSubject = {
  __typename?: 'FavoriteSubject';
  /** ID любимого предмета ученика */
  id: Scalars['Int']['output'];
  /** Наименование любимого предмета */
  name: Scalars['String']['output'];
};

export type FeatureFlagsPerSchool = {
  __typename?: 'FeatureFlagsPerSchool';
  enabled: Scalars['Boolean']['output'];
  schoolId?: Maybe<Scalars['ID']['output']>;
};

export type Feedback = {
  __typename?: 'Feedback';
  /** Комментарий */
  comment?: Maybe<Scalars['String']['output']>;
  /** дата создания */
  createTime?: Maybe<Scalars['Date']['output']>;
  /** ИД вида оценки (что понравилось больше всего) */
  feedbackSubjectsId?: Maybe<Array<Scalars['ID']['output']>>;
  /** ID записи */
  id: Scalars['ID']['output'];
  /** Модуль */
  module?: Maybe<StudyModule>;
  /**
   * Рейтинг
   * 1 = Дизлайк. 5 = Лайк
   */
  rating: Scalars['Int']['output'];
  /** Задание */
  task: Task;
  /** Автор */
  user: User;
};

/** Плашка с информация о проекте или курсе на экранах студента */
export type FeedbackAverageScore = {
  __typename?: 'FeedbackAverageScore';
  /** Код метрики */
  categoryCode?: Maybe<Scalars['String']['output']>;
  /** Название метрики */
  categoryName?: Maybe<Scalars['String']['output']>;
  /**
   * Тип метрики
   * @deprecated Field no longer supported
   */
  categoryType?: Maybe<Scalars['String']['output']>;
  /** Значение параметра */
  value?: Maybe<Scalars['String']['output']>;
};

/** Критерии, по которым оценивается проверяющий p2p задания и сам процесс проверки */
export enum FeedbackCategoryEnum {
  ReviewerShowedInterestInYourWork = 'REVIEWER_SHOWED_INTEREST_IN_YOUR_WORK',
  ReviewerShowedUpOnTime = 'REVIEWER_SHOWED_UP_ON_TIME',
  ReviewerWasCourteous = 'REVIEWER_WAS_COURTEOUS',
  ReviewerWasRigorous = 'REVIEWER_WAS_RIGOROUS'
}

/** Оценка, которая может быть выставлена по каждому из критериев оценки p2p задания */
export enum FeedbackCategoryValueEnum {
  Excellent = 'EXCELLENT',
  Fail = 'FAIL',
  Good = 'GOOD',
  ProbablyFail = 'PROBABLY_FAIL',
  ProbablyGood = 'PROBABLY_GOOD'
}

export type FeedbackFilterInputModel = {
  /** Фильтры по дате создания жалобы */
  dateFrom?: InputMaybe<Scalars['DateTime']['input']>;
  dateTo?: InputMaybe<Scalars['DateTime']['input']>;
  /** Модуль в котором оставили отзыв */
  moduleId?: InputMaybe<Scalars['ID']['input']>;
  /** Параметры пагинации */
  paging?: InputMaybe<PagingInput>;
  /** Рейтинг */
  rating?: InputMaybe<Scalars['Int']['input']>;
  rootPath?: InputMaybe<Scalars['String']['input']>;
  /** Идентификатор задания */
  taskId?: InputMaybe<Scalars['ID']['input']>;
  /** Строка поиска */
  textSearch?: InputMaybe<Scalars['String']['input']>;
};

/** S21. Форма для обратной связи */
export type FeedbackForm = {
  __typename?: 'FeedbackForm';
  /** Тип формы */
  feedbackFormEnum: FeedbackFormEnum;
  /** Вопросы с формы для обратной связи */
  feedbackFormQuestions: Array<FeedbackFormQuestion>;
  /** ID формы для обратной связи */
  id: Scalars['ID']['output'];
  /** Название формы */
  name: Scalars['String']['output'];
};

/** S21. Тип формы опроса */
export enum FeedbackFormEnum {
  /** Неуспешная форма для попытки */
  FailedAttempt = 'FAILED_ATTEMPT',
  /** Успешная форма для попытки */
  SuccessfulAttempt = 'SUCCESSFUL_ATTEMPT'
}

/** S21. Вопрос с формы для обратной связи */
export type FeedbackFormQuestion = {
  __typename?: 'FeedbackFormQuestion';
  /** Описание вопроса на английском */
  descriptionEn?: Maybe<Scalars['String']['output']>;
  /** Тип секции вопроса */
  feedbackSectionEnum: FeedbackSectionEnum;
  /** ID вопроса формы для обратной связи */
  id: Scalars['ID']['output'];
  /** Текст быстрого действия на английском */
  quickActionEn?: Maybe<Scalars['String']['output']>;
  /** Номер вопроса на форме обратной связи */
  serialNumber: Scalars['Int']['output'];
  /** Заголовок вопроса на английском */
  titleEn: Scalars['String']['output'];
  /** Тип сущности ответа, ожидаемый от вопроса */
  typeValue: Scalars['String']['output'];
};

/** Отзыв от сотрудника */
export type FeedbackFromStaff = {
  __typename?: 'FeedbackFromStaff';
  /** Тип проверки */
  checkType: FilledChecklistCheckType;
  /** Тип проекта */
  executionType: ModuleExecutionType;
  /** Отзыв на участников */
  feedbackOnParticipants: Array<FeedbackOnParticipant>;
  /** Этап заполненного чек-листа с отзывом */
  filledChecklistStageEnum: FilledChecklistStageEnum;
  /** Название проекта */
  goalName: Scalars['String']['output'];
  /** ID проверяющего */
  reviewUserId: Scalars['UUID']['output'];
  /** Название команды, если это групповой проект */
  teamName?: Maybe<Scalars['String']['output']>;
};

export type FeedbackInput = {
  /** Комментарий */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** Идентификаторы вида оценки (что понравилось или не понравилось больше всего) */
  feedbackSubjectsId?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Рейтинг */
  rating: Scalars['Int']['input'];
  /** Идентификатор задания */
  taskId: Scalars['ID']['input'];
};

/** Отзыв на участника */
export type FeedbackOnParticipant = {
  __typename?: 'FeedbackOnParticipant';
  /** Отзыв на участника */
  comment?: Maybe<Scalars['String']['output']>;
  /** Роль участника в команде */
  role?: Maybe<TeamRole>;
  /** Участник */
  user: User;
};

export type FeedbackReportBtc = {
  __typename?: 'FeedbackReportBTC';
  comment?: Maybe<Scalars['String']['output']>;
  createTs: Scalars['DateTime']['output'];
  feedbackId: Scalars['ID']['output'];
  rating: Scalars['Int']['output'];
  task: Task;
  user: User;
};

/** S21. Тип секции у вопроса в опросе */
export enum FeedbackSectionEnum {
  /** Десяти бальная шкала */
  Scale_10 = 'SCALE_10',
  /** Текст */
  Text = 'TEXT'
}

export type FeedbackStatistics = {
  __typename?: 'FeedbackStatistics';
  available: Scalars['Int']['output'];
  details: Array<Maybe<FeedbackStatisticsDetail>>;
  limit: Scalars['Int']['output'];
};

export type FeedbackStatisticsAverageScore = {
  __typename?: 'FeedbackStatisticsAverageScore';
  /** Количество P2P проверок */
  countFeedback: Scalars['Int']['output'];
  /** P2P. Средний балл по фитбэку */
  feedbackAverageScore?: Maybe<Array<Maybe<FeedbackAverageScore>>>;
};

export type FeedbackStatisticsDetail = {
  __typename?: 'FeedbackStatisticsDetail';
  count: Scalars['Int']['output'];
  rating: Scalars['Int']['output'];
};

export type FeedbackSubject = {
  __typename?: 'FeedbackSubject';
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  requiresComment: Scalars['Boolean']['output'];
};

/** Данные о филде события */
export type FieldData = {
  __typename?: 'FieldData';
  /** Имя поля */
  name: Scalars['String']['output'];
  /** Опциональность поля */
  optional: Scalars['Boolean']['output'];
  /** Тип поля */
  type: EventFieldTypeEnum;
};

export type FieldValidationError = {
  __typename?: 'FieldValidationError';
  /** Название поля, которое не прошло валидацию */
  fieldName: Scalars['String']['output'];
  /** Сообщение, которое будет отображено при выделении поля (причина, почему валидацию не прошла успешно) */
  message: Scalars['String']['output'];
};

export type File = {
  __typename?: 'File';
  /** Байты */
  extension: FileExtensionEnum;
  fileName: Scalars['String']['output'];
  fileOrder?: Maybe<Scalars['Int']['output']>;
  filePath: Scalars['String']['output'];
  fileSize: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  /** Файл помечен как удаленный */
  removed: Scalars['Boolean']['output'];
};

export enum FileExtensionEnum {
  Aac = 'AAC',
  Ai = 'AI',
  Avi = 'AVI',
  Bmp = 'BMP',
  Csv = 'CSV',
  Doc = 'DOC',
  Docx = 'DOCX',
  Ev3 = 'EV3',
  Fig = 'FIG',
  Gif = 'GIF',
  Heic = 'HEIC',
  Ipynb = 'IPYNB',
  Jpeg = 'JPEG',
  Jpg = 'JPG',
  Json = 'JSON',
  Key = 'KEY',
  M4A = 'M4A',
  Mka = 'MKA',
  Mov = 'MOV',
  Mp3 = 'MP3',
  Mp4 = 'MP4',
  Mpg = 'MPG',
  Numbers = 'NUMBERS',
  Ods = 'ODS',
  Odt = 'ODT',
  Pages = 'PAGES',
  Pdf = 'PDF',
  Png = 'PNG',
  Ppt = 'PPT',
  Pptx = 'PPTX',
  Psd = 'PSD',
  Py = 'PY',
  Sketch = 'SKETCH',
  Svg = 'SVG',
  Tiff = 'TIFF',
  Txt = 'TXT',
  Wav = 'WAV',
  Xls = 'XLS',
  Xlsx = 'XLSX',
  Xml = 'XML',
  Yaml = 'YAML',
  Yml = 'YML'
}

export type FileInput = {
  /** Байты */
  extension: FileExtensionEnum;
  fileName: Scalars['String']['input'];
  fileOrder?: InputMaybe<Scalars['Int']['input']>;
  filePath: Scalars['String']['input'];
  fileSize: Scalars['Int']['input'];
};

export type FilledChecklist = {
  __typename?: 'FilledChecklist';
  /** Количество минут, затраченное на проверку */
  actualDurationCheck?: Maybe<Scalars['Int']['output']>;
  /** Тип проверки, в рамках которой заполняется чеклист */
  checkType?: Maybe<FilledChecklistCheckType>;
  /** Чек-лист, по которому идет проверка */
  checklist: Checklist;
  /** Идентификатор чек-листа */
  checklistId: Scalars['ID']['output'];
  /** Комментарий */
  comment?: Maybe<Scalars['String']['output']>;
  /** Фактическое время окончания проверки */
  endTimeCheck?: Maybe<Scalars['DateTime']['output']>;
  /** Этап заполненного чек-листа с отзывом */
  filledChecklistStageEnum?: Maybe<FilledChecklistStageEnum>;
  /**
   * Ссылка на проект в gitlab с ответом ученика
   * @deprecated Use solutionInfo.gitlabSolutionInfo.gitlabLink
   */
  gitlabStudentProjectUrl?: Maybe<GitlabLink>;
  /** Идентификатор заполненного чек-листа */
  id: Scalars['ID']['output'];
  /** Информация о проекте */
  moduleInfoP2P?: Maybe<ModuleInfoP2P>;
  /** Информация о видеозаписях проверки */
  onlineReview?: Maybe<OnlineReview>;
  /** Информация о прогрессе прохождения проверок */
  progressCheckInfo?: Maybe<ProgressCheckInfo>;
  /** Быстрое действие */
  quickAction?: Maybe<QuickAction>;
  /** Набранный при проверке процент */
  receivedPercentage?: Maybe<Scalars['Int']['output']>;
  /** Полученнный при проверке балл */
  receivedPoint?: Maybe<Scalars['Int']['output']>;
  /** Данные по фидбэку */
  reviewFeedback?: Maybe<ReviewFeedback>;
  /** Идентификатор проверяющего */
  reviewUserId: Scalars['UUID']['output'];
  /** Проверяющий */
  reviewer: User;
  /** Оценки вопросов чек-листа */
  scoreQuestions: Array<Maybe<ScoreQuestion>>;
  /** Информация о решение в соответствие с типом решения задания */
  solutionInfo?: Maybe<SolutionInfo>;
  /** Фактическое время начала проверки */
  startTimeCheck: Scalars['DateTime']['output'];
  /** Идентификатор проверяемого ответа на задание */
  studentAnswerId: Scalars['ID']['output'];
  /** Информация о проверяемых */
  verifiableUsers?: Maybe<VerifiableUsers>;
};

/** Типы проверки, в рамках которой заполняется челклист */
export enum FilledChecklistCheckType {
  /**
   * Обычная проверка
   * Есть ограничения на кол-во пройденных проверок/кол-во проверок, указанное в конструкторе задания
   */
  Common = 'COMMON',
  /**
   * Экстра проверка
   * По смыслу не отличается от обычной проверки,
   * за исключением отсутствия ограничения по кол-ву проверок в конструкторе задания
   */
  Extra = 'EXTRA',
  /**
   * Приоритетная проверка
   * Является определяющей проверкой при подсчете финальной оценки, т.к при наличии приоритетной проверки,
   * данные по другим проверкам при подсчете не учитываются
   */
  Priority = 'PRIORITY'
}

/**
 * Заполненный чек-лист
 * DEPRECATED - use ChecklistFilledInput
 */
export type FilledChecklistInput = {
  /** Комментарий */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** Идентификатор заполненного чек-листа */
  filledChecklistId: Scalars['ID']['input'];
  /** Флаг быстрого действия */
  quickAction?: InputMaybe<QuickAction>;
  /** Оценки вопросов чек-листа */
  scoreQuestions: Array<ScoreQuestionInput>;
};

/** Этап заполненного чек-листа с отзывом */
export enum FilledChecklistStageEnum {
  /** Пустой чек-лист */
  EmptyChecklist = 'EMPTY_CHECKLIST',
  /** Пустой отзыв, но заполненный чек-лист */
  EmptyFeedback = 'EMPTY_FEEDBACK',
  /** Заполненный отзыв */
  FilledFeedback = 'FILLED_FEEDBACK'
}

export enum FilledChecklistStatusRecordingEnum {
  /** Видео онлайн проверки не требуется */
  FileNotRequired = 'FILE_NOT_REQUIRED',
  /** К чек-листу необходимо подгрузить видео онлайн проверки */
  FileRequired = 'FILE_REQUIRED'
}

export type FillingGapAnswerBody = {
  __typename?: 'FillingGapAnswerBody';
  /** Ответ */
  answers: Array<FillingGapAnswerPair>;
  cards?: Maybe<Array<FillingGapAnswerCard>>;
};

export type FillingGapAnswerBodyInput = {
  /** Ответ на виджет Заполнение пропусков */
  answers: Array<FillingGapAnswerPairInput>;
  cards?: InputMaybe<Array<FillingGapAnswerCardInput>>;
};

/** Карточка виджета "Заполнение пропусков" */
export type FillingGapAnswerCard = {
  __typename?: 'FillingGapAnswerCard';
  /** UUID карточки */
  cardId?: Maybe<Scalars['ID']['output']>;
  /** Правильно/неправильно была расположена карточка */
  correct?: Maybe<Scalars['Boolean']['output']>;
  /** ID пропуска, в котором была расположена карточка */
  gapId?: Maybe<Scalars['ID']['output']>;
};

/** Карточка в виджете "Заполнение пропусков" */
export type FillingGapAnswerCardInput = {
  /** ID карточки */
  cardId?: InputMaybe<Scalars['ID']['input']>;
  /** ID пропуска */
  gapId?: InputMaybe<Scalars['ID']['input']>;
};

export type FillingGapAnswerPair = {
  __typename?: 'FillingGapAnswerPair';
  /** Правильно/неправильно */
  correct: Scalars['Boolean']['output'];
  /** Идентификатор варианта выбора заполнения пропуска */
  gapChoiceId?: Maybe<Scalars['ID']['output']>;
  /** Уникальный идентификатор пропуска */
  gapId: Scalars['ID']['output'];
  /** Значение для пропуска */
  value: Scalars['String']['output'];
};

export type FillingGapAnswerPairInput = {
  /** Идентификатор варианта выбора заполнения пропуска */
  gapChoiceId?: InputMaybe<Scalars['ID']['input']>;
  /** Уникальный идентификатор пропуска */
  gapId: Scalars['ID']['input'];
  /**
   * Режим заполнения пропуска
   * Нужен будет для валидации корректного заполнения самого ответа
   */
  mode?: InputMaybe<GapMode>;
  /** Значение для пропуска */
  value: Scalars['String']['input'];
};

/** Описание фильтра отчета 'Обзор работы учителей' выгрузка в Excel */
export type FilterDescription = {
  filter: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

/** Для фильтра по описаниям заданий */
export type FilterExternalTaskInput = {
  api?: InputMaybe<Scalars['String']['input']>;
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  contentLoadId?: InputMaybe<Scalars['ID']['input']>;
  contentProviderActive?: InputMaybe<Scalars['Boolean']['input']>;
  contentProviderId?: InputMaybe<Scalars['ID']['input']>;
  externalId?: InputMaybe<Scalars['String']['input']>;
  hash?: InputMaybe<Scalars['String']['input']>;
  jsonMeta?: InputMaybe<Scalars['String']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  path?: InputMaybe<Scalars['String']['input']>;
  shortcut?: InputMaybe<Scalars['String']['input']>;
  sortFields?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  stage?: InputMaybe<Scalars['Int']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
  subjectId?: InputMaybe<Scalars['ID']['input']>;
  taskName?: InputMaybe<Scalars['String']['input']>;
  taskType?: InputMaybe<Scalars['String']['input']>;
  taskTypeId?: InputMaybe<Scalars['ID']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
  version?: InputMaybe<Scalars['Float']['input']>;
};

export type FilterTags = {
  /** тип тега для верхнего уровня (например, SUBJECT) */
  upLevelTagType?: InputMaybe<MediatekaTagType>;
};

/** Коды ошибок */
export enum FinalMarkErrorCode {
  /** Аттестационные периоды не найдены */
  NoAttestationPeriodsFound = 'NO_ATTESTATION_PERIODS_FOUND',
  /** Группы студентов не найдены */
  NoStageGroupsFound = 'NO_STAGE_GROUPS_FOUND'
}

export type FinalMarkLesson = {
  __typename?: 'FinalMarkLesson';
  /** Дата урока */
  date: Scalars['Date']['output'];
  /** Время окончания урока */
  lessonEnd: Scalars['Time']['output'];
  /** Время начала урока */
  lessonStart: Scalars['Time']['output'];
};

/** Предметы параллели */
export type FinalMarkStageSubject = {
  __typename?: 'FinalMarkStageSubject';
  /** Идентификатор предмета параллели */
  stageSubjectId: Scalars['ID']['output'];
  /** Наименование предмета */
  subjectName: Scalars['String']['output'];
  /** Наименование тенанта */
  tenantShortName?: Maybe<Scalars['String']['output']>;
};

/** Данные по финальным оценкам */
export type FinalMarksData = {
  __typename?: 'FinalMarksData';
  /** Итоговые оценки по графикам аттестационных периодов */
  attestationPeriodSetMarks: Array<AttestationPeriodSetFinalMarks>;
  /** Типы итоговых оценок */
  markTypes: Array<EJournalFinalStudentMarkType>;
  /** Предметы параллели */
  stageSubjects: Array<FinalMarkStageSubject>;
};

/** Ответ на запрос финальных оценок */
export type FinalMarksDataResponse = {
  __typename?: 'FinalMarksDataResponse';
  /** Данные */
  data?: Maybe<FinalMarksData>;
  /** Ошибки */
  error?: Maybe<FinalMarksError>;
  /** Успешность операции */
  isSuccess: Scalars['Boolean']['output'];
};

/** Модель ошибки */
export type FinalMarksError = {
  __typename?: 'FinalMarksError';
  /** Код ошибки */
  errorCode: FinalMarkErrorCode;
};

export type FinalMarksQueries = {
  __typename?: 'FinalMarksQueries';
  /** Запрос списка академических годов школы */
  getAcademicYears: Array<AcademicYear>;
  /** Запрос текущих оценок */
  getCurrentMarks: CurrentMarksResponse;
  /** Запрос финальных оценок */
  getFinalMarks: FinalMarksDataResponse;
  /** Запрос данных урока */
  getLesson: FinalMarkLesson;
};


export type FinalMarksQueriesGetCurrentMarksArgs = {
  currentMarksRequest: CurrentMarksRequest;
};


export type FinalMarksQueriesGetFinalMarksArgs = {
  finalMarksRequest: FinalMarksRequest;
};


export type FinalMarksQueriesGetLessonArgs = {
  lessonId: Scalars['ID']['input'];
};

/** Модель запроса финальных оценок */
export type FinalMarksRequest = {
  /** Идентификатор учебного года */
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  /** Идентификатор пользователя ребенка */
  childUserId?: InputMaybe<Scalars['ID']['input']>;
  /** Идентификатор предмета параллели */
  stageSubjectId?: InputMaybe<Scalars['ID']['input']>;
};

/** Фильтр периодов, за которые ученикам выставляются итоговые оценки */
export type FinalPeriodFilter = {
  /** Идентификатор периода (бизнес-сущности) */
  periodId: Scalars['ID']['input'];
  /** Тип периода */
  periodType: FinalPeriodType;
};

/** Типы периодов, за которые ученикам выставляются итоговые оценки */
export enum FinalPeriodType {
  /** Академический год */
  AcademicYear = 'ACADEMIC_YEAR',
  /** Аттестационный период */
  AttestationPeriod = 'ATTESTATION_PERIOD',
  /** Учебный период */
  StudyPeriod = 'STUDY_PERIOD'
}

/** Типы итоговой оценки учеников */
export enum FinalStudentMarkType {
  /** Итоговая годовая оценка */
  AcademicYearFinalMark = 'ACADEMIC_YEAR_FINAL_MARK',
  /** Итоговая аттестационная оценка */
  AttestationFinalMark = 'ATTESTATION_FINAL_MARK',
  /** Итоговая оценка за АП */
  AttestationPeriodFinalMark = 'ATTESTATION_PERIOD_FINAL_MARK',
  /** Итоговая экзаменационная оценка */
  ExaminationFinalMark = 'EXAMINATION_FINAL_MARK'
}

export type FindGitlabProjectsResponse = {
  __typename?: 'FindGitlabProjectsResponse';
  gitlabProjects: Array<GitlabProjectShort>;
  totalCount: Scalars['Int']['output'];
};

export type FixDdlResult = {
  __typename?: 'FixDdlResult';
  created: Scalars['Boolean']['output'];
  dropped: Scalars['Boolean']['output'];
  error?: Maybe<Scalars['String']['output']>;
};

export type FixSliceResult = {
  __typename?: 'FixSliceResult';
  fixed: Scalars['Int']['output'];
  processed: Scalars['Int']['output'];
  skipped: Scalars['Int']['output'];
};

export type FixStatus = {
  __typename?: 'FixStatus';
  error?: Maybe<Scalars['String']['output']>;
  fixed: Scalars['Int']['output'];
  skipped: Scalars['Int']['output'];
  tmpTableExist: Scalars['Boolean']['output'];
  wait: Scalars['Int']['output'];
};

/** Типы форм контроля */
export enum FormControlTypeEnum {
  /** Контрольная */
  Control = 'CONTROL',
  /** Текущая */
  Current = 'CURRENT'
}

/** Информация о классном руководителе для публичных профилей */
export type FormMasterPublicData = {
  __typename?: 'FormMasterPublicData';
  avatarUrl?: Maybe<Scalars['String']['output']>;
  firstName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  lastName: Scalars['String']['output'];
  middleName?: Maybe<Scalars['String']['output']>;
  subjects: Array<Subject>;
};

export type FrontConfigurationInput = {
  defaultValue: Scalars['String']['input'];
  propertyCode: Scalars['String']['input'];
};

export type FullAnswerBody = {
  __typename?: 'FullAnswerBody';
  /** Ответ */
  answer: Scalars['String']['output'];
};

export type FullAnswerBodyInput = {
  /** Развернутый ответ */
  answer: Scalars['String']['input'];
};

export type FunctionalRole = {
  __typename?: 'FunctionalRole';
  applicableRole?: Maybe<Scalars['String']['output']>;
  code: Scalars['ID']['output'];
  dateEnd?: Maybe<Scalars['DateTime']['output']>;
  dateStart?: Maybe<Scalars['DateTime']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  froleId?: Maybe<Scalars['UUID']['output']>;
  isDefault?: Maybe<Scalars['Boolean']['output']>;
  isEditable?: Maybe<Scalars['Boolean']['output']>;
  isScopeGlobal?: Maybe<Scalars['Boolean']['output']>;
  isScopeProduct?: Maybe<Scalars['Boolean']['output']>;
  isScopeSchool?: Maybe<Scalars['Boolean']['output']>;
  name: Scalars['String']['output'];
  orgUnitId?: Maybe<Scalars['UUID']['output']>;
  permissions: Array<Permission>;
  schoolId?: Maybe<Scalars['UUID']['output']>;
  tenantId?: Maybe<Scalars['UUID']['output']>;
  userSchoolFunctionalRoleId?: Maybe<Scalars['ID']['output']>;
};

export type FunctionalRoleData = {
  __typename?: 'FunctionalRoleData';
  description: Scalars['String']['output'];
  id: Scalars['String']['output'];
};

export type FunctionalRoleInput = {
  code: Scalars['ID']['input'];
  dateEnd?: InputMaybe<Scalars['String']['input']>;
  dateStart?: InputMaybe<Scalars['String']['input']>;
  isScopeGlobal?: InputMaybe<Scalars['Boolean']['input']>;
  isScopeProduct?: InputMaybe<Scalars['Boolean']['input']>;
  isScopeSchool?: InputMaybe<Scalars['Boolean']['input']>;
  orgUnitId?: InputMaybe<Scalars['UUID']['input']>;
  schoolId?: InputMaybe<Scalars['ID']['input']>;
};

export type FunctionalRoleSet = {
  __typename?: 'FunctionalRoleSet';
  description: Scalars['String']['output'];
  functionalRoleSetId?: Maybe<Scalars['ID']['output']>;
  functionalRoles: Array<FunctionalRole>;
  isScopeGlobal?: Maybe<Scalars['Boolean']['output']>;
  isScopeProduct?: Maybe<Scalars['Boolean']['output']>;
  isScopeSchool?: Maybe<Scalars['Boolean']['output']>;
  name: Scalars['String']['output'];
  orgUnit?: Maybe<OrganizationUnit>;
  orgUnitId?: Maybe<Scalars['UUID']['output']>;
  role?: Maybe<Roles>;
};

export type FunctionalRoleSetFroleInput = {
  froleId: Scalars['UUID']['input'];
  isDefault: Scalars['Boolean']['input'];
};

export type FunctionalRoleSetInput = {
  description: Scalars['String']['input'];
  functionalRoleSetFroles: Array<FunctionalRoleSetFroleInput>;
  functionalRoleSetId?: InputMaybe<Scalars['ID']['input']>;
  isScopeGlobal?: InputMaybe<Scalars['Boolean']['input']>;
  isScopeProduct?: InputMaybe<Scalars['Boolean']['input']>;
  isScopeSchool?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  orgUnitId: Scalars['UUID']['input'];
  role: Roles;
};

/** Коалиция */
export type GameCoalition = {
  __typename?: 'GameCoalition';
  avatarUrl: Scalars['String']['output'];
  backgroundUrl: Scalars['String']['output'];
  backgroundUrlBig: Scalars['String']['output'];
  coalitionBackgroundId: Scalars['Int']['output'];
  color: Scalars['String']['output'];
  /**
   * Текущий турнир, в котором учавствует коалиция
   * {null} если коалиция не учавствует в турнирах
   */
  currentTournament?: Maybe<CoalitionTournament>;
  /** Привязана ли коалиция к турнирам */
  hasTournaments: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  masterAvatarId: Scalars['Int']['output'];
  masterAvatarImgUrl: Scalars['String']['output'];
  masterUser: User;
  masterUserId: Scalars['UUID']['output'];
  memberCount: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  schoolId: Scalars['UUID']['output'];
  stage: Stage;
  stageId: Scalars['Int']['output'];
};

/** Устарело, использовать GameCoalitionInputV2 */
export type GameCoalitionInput = {
  avatarUrl: Scalars['String']['input'];
  backgroundUrl: Scalars['String']['input'];
  color: Scalars['String']['input'];
  id?: InputMaybe<Scalars['ID']['input']>;
  masterUserId: Scalars['UUID']['input'];
  name: Scalars['String']['input'];
  stageId: Scalars['Int']['input'];
};

/** Устарело, использовать GameCoalitionInputV3 */
export type GameCoalitionInputV2 = {
  avatarUrl: Scalars['String']['input'];
  coalitionBackgroundId: Scalars['Int']['input'];
  color: Scalars['String']['input'];
  id?: InputMaybe<Scalars['ID']['input']>;
  masterUserId: Scalars['UUID']['input'];
  name: Scalars['String']['input'];
  stageId: Scalars['Int']['input'];
};

export type GameCoalitionInputV3 = {
  avatarUrl: Scalars['String']['input'];
  coalitionBackgroundId: Scalars['Int']['input'];
  color: Scalars['String']['input'];
  id?: InputMaybe<Scalars['ID']['input']>;
  masterAvatarId: Scalars['Int']['input'];
  masterUserId: Scalars['UUID']['input'];
  name: Scalars['String']['input'];
  stageId: Scalars['Int']['input'];
};

/** Коалиция */
export type GameCoalitionV2 = {
  __typename?: 'GameCoalitionV2';
  avatarUrl: Scalars['String']['output'];
  backgroundUrl: Scalars['String']['output'];
  backgroundUrlBig: Scalars['String']['output'];
  coalitionBackgroundId: Scalars['Int']['output'];
  /** информация о положении дел в текущем турнире(очки, доп. очки и тд.), нуль если текущего турнира нет */
  coalitionTournament?: Maybe<CoalitionTournament>;
  color: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  masterAvatarId: Scalars['Int']['output'];
  masterAvatarImgUrl: Scalars['String']['output'];
  masterUserId: Scalars['UUID']['output'];
  membersCount: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  schoolId: Scalars['UUID']['output'];
  stage: Stage;
  /** информация о турнире, нуль если текущего турнира нет */
  tournament?: Maybe<GameTournament>;
};

/** Турнир */
export type GameTournament = {
  __typename?: 'GameTournament';
  coalitionPoints: Array<CoalitionTournamentRank>;
  daysToEnd?: Maybe<Scalars['Int']['output']>;
  gameCoalitions: Array<GameCoalition>;
  id: Scalars['ID']['output'];
  isActive: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  schoolId: Scalars['UUID']['output'];
  stage?: Maybe<Stage>;
  stageId: Scalars['ID']['output'];
  timeClosed?: Maybe<Scalars['DateTime']['output']>;
  timeEnd: Scalars['DateTime']['output'];
  timeStart: Scalars['DateTime']['output'];
  tournamentAwardDescription?: Maybe<Scalars['String']['output']>;
  tournamentAwardSettings?: Maybe<Array<TournamentAwardSetting>>;
};

export type GameTournamentInput = {
  awardSettings?: InputMaybe<Array<TournamentAwardSettingInput>>;
  gameCoalitionIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
  stageId: Scalars['ID']['input'];
  timeEnd: Scalars['DateTime']['input'];
  timeStart: Scalars['DateTime']['input'];
  tournamentAwardDescription?: InputMaybe<Scalars['String']['input']>;
};

export type GamificationMutations = {
  __typename?: 'GamificationMutations';
  /** Купить аватар(скин) */
  buyAvatar?: Maybe<Scalars['Boolean']['output']>;
  /** Создание нового уровня с константами */
  createNextDeadlineGameLevel: DeadlineGameLevel;
  /** Надеть шмотку */
  dressEquipment: Scalars['Boolean']['output'];
  /** Сохранение результата игры */
  saveDeadlineGameResult: Scalars['Boolean']['output'];
  /** Сохранение ответа пользователя */
  saveUserTestAnswer: UserTestAnswer;
  setExperienceLevelShowed: Scalars['Boolean']['output'];
  /** Установить флаг просмотра достижений за задания */
  setHistoryShowed: Scalars['Boolean']['output'];
  /** Назначить награды за выполнения модулей */
  setModuleAwards: Scalars['Boolean']['output'];
  /** Снять шмотку */
  undressEquipment: Scalars['Boolean']['output'];
  /** Изменить константы для уровня игры "Дедлайн" */
  updateDeadlineGameAttributes: Scalars['Boolean']['output'];
};


export type GamificationMutationsBuyAvatarArgs = {
  avatarId: Scalars['ID']['input'];
};


export type GamificationMutationsCreateNextDeadlineGameLevelArgs = {
  level: DeadlineGameLevelInput;
};


export type GamificationMutationsDressEquipmentArgs = {
  equipmentId: Scalars['ID']['input'];
};


export type GamificationMutationsSaveDeadlineGameResultArgs = {
  result: DeadlineGameResultInput;
};


export type GamificationMutationsSaveUserTestAnswerArgs = {
  answerContent: Scalars['String']['input'];
  testId: Scalars['ID']['input'];
};


export type GamificationMutationsSetHistoryShowedArgs = {
  historyId: Scalars['ID']['input'];
};


export type GamificationMutationsSetModuleAwardsArgs = {
  moduleAwards: Array<ModuleAwardInput>;
  moduleId: Scalars['ID']['input'];
};


export type GamificationMutationsUndressEquipmentArgs = {
  equipmentId: Scalars['ID']['input'];
};


export type GamificationMutationsUpdateDeadlineGameAttributesArgs = {
  attributes: Scalars['String']['input'];
  levelId: Scalars['Int']['input'];
};

export type GamificationQueries = {
  __typename?: 'GamificationQueries';
  /** Справочник уровней наград */
  getAllAwardLevels: Array<AwardLevel>;
  getAvailableAvatars: Array<Avatar>;
  getAvatarGroups: Array<AvatarGroup>;
  getAvatarKinds: Array<AvatarKind>;
  /** Механики назначения наград */
  getAwardAssignmentTypes: Array<AssignmentType>;
  /** Условия выдачи наград системой */
  getAwardConditionTypes: Array<AwardCondition>;
  /** Виды бейджей */
  getBadgeKinds: Array<BadgeKind>;
  /** Запрос конфигурации игры */
  getDeadlineGameConfiguration: DeadlineGameConfiguration;
  /** Запрос констант игры "Дедлайн" для всех уровней */
  getDeadlineGameLevels: Array<DeadlineGameLevel>;
  getExperienceLevelRanges: Array<ExperienceLevelRange>;
  getExperienceTaskTypes: Array<ExperienceTaskType>;
  /** Совокупность наград, полученных учеником за последнее выполнение задания */
  getLastUserHistoryForTask?: Maybe<History>;
  /** Получить последний ответ для учеников в виде JSON по имени типа */
  getLastUserTestAnswerContentByTestTypeName?: Maybe<UserTestAnswerContent>;
  /**
   * Запрос лучшего результата игры пользователя
   * {null} если пользователь еще не играл
   */
  getMyBestDeadlineGameResult?: Maybe<DeadlineGameResult>;
  /**
   * Запрос последнего результата игры пользователя
   * {null} если пользователь еще не играл
   */
  getMyLastDeadlineGameResult?: Maybe<DeadlineGameResult>;
  getSoftSkillTypes: Array<SoftSkillType>;
  /**
   * Возвращает рендомный ID из списка, который задан в конфигурации (deadline.game.test.tasks.id)
   * {null} если список не задан
   */
  getTaskIdForDeadlineGameTest?: Maybe<Scalars['ID']['output']>;
  /** Список наград, полученных учеником за несколько выполнений задания */
  getUserHistoriesForTask: Array<History>;
  /** Получить список параметров тестов для учеников в виде JSON по имени типа */
  getUserTestContentByTypeName?: Maybe<UserTestContent>;
  /** Получить тип теста по имени */
  getUserTestTypeIdByName?: Maybe<UserTestType>;
};


export type GamificationQueriesGetLastUserHistoryForTaskArgs = {
  taskId: Scalars['ID']['input'];
};


export type GamificationQueriesGetLastUserTestAnswerContentByTestTypeNameArgs = {
  testTypeName: Scalars['String']['input'];
};


export type GamificationQueriesGetUserHistoriesForTaskArgs = {
  taskId: Scalars['ID']['input'];
};


export type GamificationQueriesGetUserTestContentByTypeNameArgs = {
  testTypeName: Scalars['String']['input'];
};


export type GamificationQueriesGetUserTestTypeIdByNameArgs = {
  testTypeName: Scalars['String']['input'];
};

/** Перечисляемый тип для режима виджета */
export enum GapMode {
  /** Заполнение пропуска методом перетаскивания */
  DragAndDrop = 'DRAG_AND_DROP',
  /** Заполнение пропуска из выпадающего списка */
  Dropdown = 'DROPDOWN',
  /** Заполнение методом ввода */
  Input = 'INPUT'
}

/** Пол */
export enum Gender {
  Female = 'FEMALE',
  Male = 'MALE',
  Other = 'OTHER'
}

/**
 * Ответ по запросу успеваемости класса
 * Нужен для возможности сообщить об ошибке, если в результате фильтров нет данных, не выбрасывая исключение
 */
export type GetClassSubjectPerformanceResponse = {
  __typename?: 'GetClassSubjectPerformanceResponse';
  /** null, если есть ошибка */
  classSubjectPerformance?: Maybe<ClassSubject>;
  /** null, если данные сагрегировались */
  errorMessage?: Maybe<ClassSubjectPerformanceErrorEnum>;
};

/** Результат запроса групп класса по предмету по фильтрам */
export type GetClassSubjectsByFiltersResponse = {
  __typename?: 'GetClassSubjectsByFiltersResponse';
  /** Группы класса по предмету, подходящие по фильтрам */
  classSubjects: Array<ClassSubject>;
  /** Количество групп класса по предмету, подходящие по фильтрам, вне зависимости от пагинации */
  totalCount: Scalars['Int']['output'];
};

export type GetJournalCellsResponse = {
  __typename?: 'GetJournalCellsResponse';
  cellsMap: Array<JournalCellsMap>;
  lessons: Array<LessonSet>;
  students: Array<Student>;
  studentsInGroup?: Maybe<Array<Maybe<StudentsInGroup>>>;
};

export type GetJournalNotificationsResponseModel = {
  __typename?: 'GetJournalNotificationsResponseModel';
  notificationId?: Maybe<Scalars['ID']['output']>;
  recalculating: Scalars['Boolean']['output'];
};

export type GetModulesResponse = {
  __typename?: 'GetModulesResponse';
  /** количество модулей соответствующих фильтру */
  count: Scalars['Int']['output'];
  /** найденные модули */
  studyModuleModels: Array<StudyModule>;
};

/**
 * Результат работы запроса по списокам регионов, в которых пользователь назначен как проверяющий учитель
 * (фроль Учитель для внешних школ) с сортировкой
 */
export type GetMyRegionsByTeacherTrainingResponse = {
  __typename?: 'GetMyRegionsByTeacherTrainingResponse';
  /** Регионы */
  regions: Array<Region>;
  /** Общее кол-во */
  totalCount: Scalars['Int']['output'];
};

/** Возвращает список школ, в которых пользователь назначен проверяющим учителем (фроль Учитель для внешних школ) с сортировкой */
export type GetMySchoolsByTeacherTrainingResponse = {
  __typename?: 'GetMySchoolsByTeacherTrainingResponse';
  /** Дополнительная информация о школе */
  schoolAdditionalInformation: Array<SchoolAdditionalInformation>;
  /** Школы */
  schools: Array<SafeSchool>;
  /** Общее кол-во */
  totalCount: Scalars['Int']['output'];
};

/** Результат запроса настроек для определенного раздела */
export type GetSchoolSelfConfigurationSectionResponse = {
  __typename?: 'GetSchoolSelfConfigurationSectionResponse';
  /** Данные о разделе настроек */
  data?: Maybe<SchoolSelfConfigurationSection>;
  /** Описание ошибки, возникшей в ходе выполнения запроса */
  error?: Maybe<SchoolSelfConfigurationError>;
  /** Признак успешности выполнения запроса */
  isSuccess: Scalars['Boolean']['output'];
};

export type GetStageSubjectGroupStudentsByYearResponse = {
  __typename?: 'GetStageSubjectGroupStudentsByYearResponse';
  studentWasInGroupMap: Array<StringBooleanMapEntry>;
  studentsInGroup: Array<Maybe<StudentsInGroup>>;
  studyPeriods: Array<Maybe<StudyPeriod>>;
};

export type GetStudentRolesResponse = {
  __typename?: 'GetStudentRolesResponse';
  /** количество ролей соответствующих фильтру */
  count: Scalars['Int']['output'];
  /** найденные роли в контексте студента */
  studentRoles: Array<StudentRole>;
};

export type GetStudentTasksDashboardResponse = {
  __typename?: 'GetStudentTasksDashboardResponse';
  /** количества заданий учеников с группировкой по статусу задания */
  studentTaskQuantity: Array<TaskCardsStatusesWithQuantity>;
  /** найденные Задания в контексте студента */
  studentTasks: Array<StudentTask>;
};

/**
 * Сгруппированные по определенному ключу StudentTask'и
 * Например по студентам: [Абрамов_Лев.stage_subject_subgroup_student_id: [его StudentTask'и], Егорова_Валерия.stage_subject_subgroup_student_id: [ее StudentTask'и]]
 */
export type GetStudentTasksGroupedResponse = {
  __typename?: 'GetStudentTasksGroupedResponse';
  /**
   * количество групп, соответствующих фильтру
   * если группировка NONE, то count = [studentTasks].size()
   */
  count: Scalars['Int']['output'];
  /** сгруппированные по ключу StudentTask'и */
  studentTaskGroups: Array<StudentTaskGroup>;
};

export type GetStudentTasksResponse = {
  __typename?: 'GetStudentTasksResponse';
  /** количество заданий соответствующих фильтру */
  count: Scalars['Int']['output'];
  /** найденные Задания в контексте студента */
  studentTasks: Array<StudentTask>;
};

export type GetVisitJournalRulesResponse = {
  __typename?: 'GetVisitJournalRulesResponse';
  student: Student;
  visitJournalRules: Array<VisitJournalRule>;
};

/** Сообщение GigaChat, отправленное пользователем или полученное в ответ */
export type GigaChatMessageInput = {
  /** текст сообщения */
  content: Scalars['String']['input'];
  /** роль автора сообщения - пользователь или ассистент (GigaChat) */
  role: GigaChatRoleEnum;
};

/** Ответ GigaChat */
export type GigaChatResponse = {
  __typename?: 'GigaChatResponse';
  /** текст ответа */
  content: Scalars['String']['output'];
  /** приложенное изображение (если запрос содержал "нарисуй...") в формате jpeg, закодированное base64, необязательное поле */
  imgData?: Maybe<Scalars['String']['output']>;
};

/** Роль отправителя сообщения GigaChat */
export enum GigaChatRoleEnum {
  /** Ассистент (GigaChat) */
  Assistant = 'ASSISTANT',
  /** Пользователь */
  User = 'USER'
}

/** Тип CI/CD в проекте гитлаба */
export enum GitlabCiCdType {
  /** ci/cd выключен */
  Disabled = 'DISABLED',
  /** ci/cd включен */
  Enabled = 'ENABLED',
  /** приватные пайплайны */
  Private = 'PRIVATE'
}

/** Коммит в репозитории gitlab */
export type GitlabCommit = {
  __typename?: 'GitlabCommit';
  /** Электронный адрес автора коммита в репозитории gitlab */
  authorEmail?: Maybe<Scalars['String']['output']>;
  /** Имя автора коммита в репозитории gitlab */
  authorName?: Maybe<Scalars['String']['output']>;
  /** Дата авторства коммита в репозитории gitlab */
  authoredDate?: Maybe<Scalars['Date']['output']>;
  /** Дата коммита в репозитории gitlab */
  committedDate?: Maybe<Scalars['Date']['output']>;
  /** Электронный адрес коммитера в репозитории gitlab */
  committerEmail?: Maybe<Scalars['String']['output']>;
  /** Имя коммитера в репозитории gitlab */
  committerName?: Maybe<Scalars['String']['output']>;
  /** Дата коммита в репозитории gitlab */
  createAt: Scalars['Date']['output'];
  /** Идентификатор коммита в репозитории gitlab */
  id: Scalars['String']['output'];
  /** Сообщение коммита в репозитории gitlab */
  message: Scalars['String']['output'];
  /** Список родительскиъ коммиитов (по идентификаторам) в репозитории gitlab */
  parentIds?: Maybe<Array<Scalars['String']['output']>>;
  /** Сокращенный идентификатор коммита в репозитории gitlab */
  shortId: Scalars['String']['output'];
  /** Заголовок коммита в репозитории gitlab */
  title?: Maybe<Scalars['String']['output']>;
  /** Ссылка коммита в репозитории gitlab */
  webUrl: Scalars['String']['output'];
};

/** docker image в gitlab */
export type GitlabDockerImage = {
  __typename?: 'GitlabDockerImage';
  /** время, с которого этот образ может быть почищен системой */
  cleanupPolicyTime?: Maybe<Scalars['DateTime']['output']>;
  /** время создания образа */
  createTime: Scalars['DateTime']['output'];
  /** проект к которому привязан данный образ */
  gitlabProjectId: Scalars['ID']['output'];
  /** идентфикатор образа */
  id: Scalars['ID']['output'];
  /** абсолютный путь до образа */
  location: Scalars['String']['output'];
  /** название пакета автотестов */
  name: Scalars['String']['output'];
  /** путь в гитлабе до образа */
  path: Scalars['String']['output'];
};

/** Файл из gitlab репозитория */
export type GitlabFile = {
  __typename?: 'GitlabFile';
  /** Блоб файла в репозитории gitlab */
  blobId?: Maybe<Scalars['String']['output']>;
  /** Идентификатор коммита при котором был загружен файл в репозиторий gitlab */
  commitId?: Maybe<Scalars['String']['output']>;
  /** Контент файла в репозитории gitlab */
  content: Scalars['String']['output'];
  /** Encoding файла в репозитории gitlab */
  encoding: Scalars['String']['output'];
  /** Имя файла в репозитории gitlab */
  fileName: Scalars['String']['output'];
  /** Путь файла в репозитории gitlab */
  filePath: Scalars['String']['output'];
  /** Последний коммит на изменение файла в репозитории gitlab */
  lastCommitId?: Maybe<Scalars['String']['output']>;
  /** Бранча файла в репозитории gitlab */
  reference: Scalars['String']['output'];
  /** Рпзмерп файла в репозитории gitlab */
  size: Scalars['Int']['output'];
};

/** Статус загрузки файла в gitlab репозиторий */
export type GitlabFileCreationStatus = {
  __typename?: 'GitlabFileCreationStatus';
  /** Бранча gitlab в которую загружен файл */
  branch: Scalars['String']['output'];
  /** Путь gitlab по которому загружен файл */
  filePath: Scalars['String']['output'];
};

/** Файловый шаблон в gitlab */
export type GitlabFileTemplate = {
  __typename?: 'GitlabFileTemplate';
  /** ключ шаблона */
  key: Scalars['String']['output'];
  /** "значение" шаблона */
  name: Scalars['String']['output'];
};

/** Ссылки на проект в гитлаб */
export type GitlabLink = {
  __typename?: 'GitlabLink';
  /** Наличие открытых Merge-request в проект */
  hasOpenedMR: Scalars['Boolean']['output'];
  /** HTTP-ссылка для открытия в интерфейсе гитлаб, если проект удален, то будет "" */
  httpsLink: Scalars['String']['output'];
  /** Идентификатор проекта в гитлаб, если проект удален, то будет -1 */
  id: Scalars['Int']['output'];
  /** Удален ли этот проект */
  projectDeleted: Scalars['Boolean']['output'];
  /** Токен для раннеров */
  runnersToken: Scalars['String']['output'];
  /** SSH-ссылка для клонирования, если проект удален, то будет "" */
  sshLink: Scalars['String']['output'];
};

/** Ссылки на проект в гитлаб */
export type GitlabLinkWithStatus = {
  __typename?: 'GitlabLinkWithStatus';
  /** HTTP-ссылка для открытия в интерфейсе гитлаб */
  httpsLink: Scalars['String']['output'];
  /** Идентификатор проекта в гитлаб */
  id: Scalars['Int']['output'];
  /** флаг готовности проекта к клонированию */
  readyToUse: GitlabProjectLinksReadyToUseStatus;
  /** текущее кол-во рестартов форка проекта в гитлабе */
  restartsCounter?: Maybe<Scalars['Int']['output']>;
  /** SSH-ссылка для клонирования */
  sshLink: Scalars['String']['output'];
};

/** Ссылки на проект в гитлаб со статусом готовности проекта */
export type GitlabLinksWithReadinessStatus = {
  __typename?: 'GitlabLinksWithReadinessStatus';
  /** Идентификатор проекта в гитлаб */
  gitlabProjectId?: Maybe<Scalars['Int']['output']>;
  /** текущее кол-во рестартов форка проекта в гитлабе */
  hasOpenedMR?: Maybe<Scalars['Boolean']['output']>;
  /** HTTP-ссылка для открытия в интерфейсе гитлаб */
  httpsLink?: Maybe<Scalars['String']['output']>;
  /** SSH-ссылка для клонирования */
  sshLink?: Maybe<Scalars['String']['output']>;
  /** флаг готовности проекта к клонированию */
  status: GitlabProjectLinksReadyToUseStatus;
  /** Идентификатор студенческого ответа */
  studentAnswerId: Scalars['Int']['output'];
};

/** Неймспейсы в gitlab */
export type GitlabNamespace = {
  __typename?: 'GitlabNamespace';
  /** Тип неймспейса  в gitlab */
  kind?: Maybe<Scalars['String']['output']>;
  /** Ия неймспейса  в gitlab */
  name: Scalars['String']['output'];
  /** Идентификатор неймспейса  в gitlab */
  namespaceId: Scalars['ID']['output'];
  /** Идентификатор родительского неймспейса  в gitlab */
  parentId?: Maybe<Scalars['String']['output']>;
  /** Путь неймспейса  в gitlab */
  path?: Maybe<Scalars['String']['output']>;
};

export type GitlabPipeline = {
  __typename?: 'GitlabPipeline';
  id: Scalars['ID']['output'];
  ref: Scalars['String']['output'];
  status: Scalars['String']['output'];
  url: Scalars['String']['output'];
};

/** Gitlab проект */
export type GitlabProject = {
  __typename?: 'GitlabProject';
  /** Флаг показывающий архивирован ли проект в gitlab */
  archived: Scalars['Boolean']['output'];
  /** Дата создания проекта в gitlab */
  createdAt?: Maybe<Scalars['Date']['output']>;
  /** Дефолтная бранча в gitlab репозитории */
  defaultBranch?: Maybe<Scalars['String']['output']>;
  /** Описание проекта с gitlab */
  description?: Maybe<Scalars['String']['output']>;
  /** Флаг показывающий пустой ли репозиторий в gitlab */
  emptyRepo: Scalars['Boolean']['output'];
  /** Статус экспорта проекта из gitlab (меняется после запуска экспорта) */
  exportStatus?: Maybe<Scalars['String']['output']>;
  /** Ссылки данного проекта в gitlab */
  links?: Maybe<GitlabProjectLink>;
  /** Название проекта в gitlab */
  name: Scalars['String']['output'];
  /** Неймспейс проекта в gitlab */
  namespace?: Maybe<GitlabNamespace>;
  /** Полный путь (url) до проекта в gitlab */
  path: Scalars['String']['output'];
  /** Идентификатор гитлаб проекта */
  projectId: Scalars['ID']['output'];
  /** Видимость проекта */
  visibility?: Maybe<Scalars['String']['output']>;
};

export type GitlabProjectIdsExistenceResponse = {
  __typename?: 'GitlabProjectIdsExistenceResponse';
  foundIds: Array<Scalars['Int']['output']>;
  notFoundIds: Array<Scalars['Int']['output']>;
};

/** Проектные ссылки в gitlab */
export type GitlabProjectLink = {
  __typename?: 'GitlabProjectLink';
  /** Ссылка API (доступная после экспорта проекта из gitlab) */
  apiUrl?: Maybe<Scalars['String']['output']>;
  /** Ссылка на события проекта в gitlab */
  events?: Maybe<Scalars['String']['output']>;
  /** Ссылка на issues проекта в gitlab */
  issues?: Maybe<Scalars['String']['output']>;
  /** Ссылка на labels проекта в gitlab */
  labels?: Maybe<Scalars['String']['output']>;
  /** Ссылка на членов проекта в gitlab */
  members?: Maybe<Scalars['String']['output']>;
  /** Ссылка на ПРы проекта в gitlab */
  mergeRequests?: Maybe<Scalars['String']['output']>;
  /** Ссылка на барнчи проекта в gitlab */
  repoBranches?: Maybe<Scalars['String']['output']>;
  /** Ссылка на проект в gitlab */
  self?: Maybe<Scalars['String']['output']>;
  /** Ссылка WEB (доступная после экспорта проекта из gitlab) */
  webUrl?: Maybe<Scalars['String']['output']>;
};

/** Тип готовности импортированного проекта */
export enum GitlabProjectLinksReadyToUseStatus {
  /** проект удален в гитлабе */
  Deleted = 'DELETED',
  /** импорт провален */
  Failed = 'FAILED',
  /** не готов */
  NotReady = 'NOT_READY',
  /** готов */
  Ready = 'READY',
  /** перезапущен форк */
  Restarted = 'RESTARTED'
}

export type GitlabProjectShort = {
  __typename?: 'GitlabProjectShort';
  createdAt: Scalars['Date']['output'];
  gitlabProjectId: Scalars['Int']['output'];
  goalExecutionTypeId: Scalars['Int']['output'];
  login: Scalars['String']['output'];
  projectName: Scalars['String']['output'];
};

export type GitlabProjectsExcelFile = {
  __typename?: 'GitlabProjectsExcelFile';
  base64Data?: Maybe<Scalars['String']['output']>;
  fileName: Scalars['String']['output'];
  url?: Maybe<Scalars['String']['output']>;
};

/** Тэг репозитория в gitlab */
export type GitlabRepositoryTag = {
  __typename?: 'GitlabRepositoryTag';
  /** Коммит при создании тэга в репе gitlab */
  commit?: Maybe<GitlabCommit>;
  /** Сообщение тэга в репе gitlab */
  message?: Maybe<Scalars['String']['output']>;
  /** Название тэга в репе gitlab */
  name: Scalars['String']['output'];
  /** Флаг скрытости тэга в репе gitlab */
  protectedFlag: Scalars['Boolean']['output'];
  /** Релизная версия тэга в репе gitlab */
  release?: Maybe<Scalars['String']['output']>;
  /** Таргетирование тэга в репе gitlab */
  target: Scalars['String']['output'];
};

/** Респонс с гитлаб API в виде строки */
export type GitlabResponseMessage = {
  __typename?: 'GitlabResponseMessage';
  message: Scalars['String']['output'];
};

export type GitlabSolutionInfo = {
  __typename?: 'GitlabSolutionInfo';
  /** Ссылка на проект в gitlab с ответом ученика */
  gitlabLink: GitlabLink;
};

/** Пользователь gitlab */
export type GitlabUser = {
  __typename?: 'GitlabUser';
  /** Ссылка на картинку профиля поьзователя в gitlab */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Идентификатор пользователя в gitlab */
  id: Scalars['ID']['output'];
  /** Имя пользователя в gitlab */
  name: Scalars['String']['output'];
  /** Статус активности пользователя в gitlab */
  state?: Maybe<Scalars['String']['output']>;
  /** Username пользователя в gitlab */
  username: Scalars['String']['output'];
  /** Ссылка на профайл пользователя в gitlab */
  webUrl: Scalars['String']['output'];
};

export enum GitlabUserAccessLevel {
  Developer = 'DEVELOPER',
  Guest = 'GUEST',
  Maintainer = 'MAINTAINER',
  NoAccess = 'NO_ACCESS',
  Owner = 'OWNER',
  Reporter = 'REPORTER'
}

/** Награждение пользователя */
export type Giving = {
  __typename?: 'Giving';
  /** Комментарий при награждении */
  comment?: Maybe<Scalars['String']['output']>;
  /** Когда наградили */
  date: Scalars['DateTime']['output'];
  /** Кто награждал */
  giverLogin: Scalars['String']['output'];
  /** Если награждали бейджем, тут будет информация о наградах полученных вместе с этим бейджем. */
  givingBadge?: Maybe<GivingBadge>;
  /** Тип награждения */
  givingType: GivingType;
  /** Если награждали коинами или поинтами здесь будет значение(5, 100, -20), если бейджем то будет название бейджа */
  value: Scalars['String']['output'];
};

/** Бейдж выданный пользователю(все числа тянутся из исторических таблиц, а не из текущих настроек) */
export type GivingBadge = {
  __typename?: 'GivingBadge';
  /** Какой уровень ачивки был получен */
  awardLevelName: Scalars['String']['output'];
  /** Какого типа ачивка была получена */
  badgeKindName: Scalars['String']['output'];
  /** Сколько было получено очков коалиций */
  coalitionPoints?: Maybe<Scalars['Int']['output']>;
  /** Сколько было получено игровых монет */
  coins?: Maybe<Scalars['Int']['output']>;
  /** Сколько было получено crp */
  crp?: Maybe<Scalars['Int']['output']>;
  /** Сколько было получено опыта */
  experience?: Maybe<Scalars['Int']['output']>;
  /** Сколько было получено prp */
  prp?: Maybe<Scalars['Int']['output']>;
  /** Сколько и какого навыка было получено */
  softSkills?: Maybe<Array<AwardBountySoftSkillPower>>;
};

/** Типы награждений чем-то, которые может получать пользователь */
export enum GivingType {
  Awards = 'AWARDS',
  CoalitionPoints = 'COALITION_POINTS',
  Coins = 'COINS'
}

/** Глобальный курс */
export type GlobalCourse = {
  __typename?: 'GlobalCourse';
  /** Цели курса */
  courseGoals: Array<GlobalCourseGoal>;
  /** Название курса */
  courseName: Scalars['String']['output'];
  /** Тип курса */
  courseType: CourseType;
  /** Идентификатор глоабльного курса */
  globalCourseId: Scalars['ID']['output'];
  /** Тип настройки весов для проектов в курсе */
  isAutoWeightsSetting?: Maybe<Scalars['Boolean']['output']>;
  /** Статус курса */
  isPublished: Scalars['Boolean']['output'];
  /** Количество проектов */
  projectCount: Scalars['Int']['output'];
  /** Идентификатор предмета */
  subjectId: Scalars['ID']['output'];
};

/** Цели глобального курса */
export type GlobalCourseGoal = {
  __typename?: 'GlobalCourseGoal';
  /** "Начать с ..." */
  beginFrom?: Maybe<Scalars['Int']['output']>;
  /** "Проверка" */
  checkFrom?: Maybe<Scalars['Int']['output']>;
  /** Тип выполнения */
  executionType?: Maybe<ModuleExecutionType>;
  /** Идентификатор цели глобального курса */
  globalCourseGoalId: Scalars['ID']['output'];
  /** Идентификатор цели курса */
  goalId: Scalars['ID']['output'];
  /** Название цели */
  goalName: Scalars['String']['output'];
  /** Просмотр контента */
  isContentAvailable: Scalars['Boolean']['output'];
  /** Ожидаемая трудоемкость в часах */
  laboriousness: Scalars['Int']['output'];
  /** Порядковый номер цели */
  order: Scalars['Int']['output'];
  /** Какие периоды учитываются в проекте */
  periodSettings?: Maybe<PeriodSettings>;
  /** "Часы на проект" */
  projectHours?: Maybe<Scalars['Int']['output']>;
  /** "Регистрация" */
  signUpFrom?: Maybe<Scalars['Int']['output']>;
  /** Имя абстрактного глобального предмета */
  subjectName: Scalars['String']['output'];
};

/** Модель ввода для целей глобального курса */
export type GlobalCourseGoalInput = {
  /** "Начать с ..." */
  beginFrom?: InputMaybe<Scalars['Int']['input']>;
  /** "Проверка" */
  checkFrom?: InputMaybe<Scalars['Int']['input']>;
  /** Идентификатор цели глобального курса */
  globalCourseGoalId?: InputMaybe<Scalars['ID']['input']>;
  /** Идентификатор цели */
  goalId: Scalars['ID']['input'];
  /** Просмотр контента */
  isContentAvailable: Scalars['Boolean']['input'];
  /** Порядковый номер цели */
  order: Scalars['Int']['input'];
  /** Какие периоды учитываются в проекте */
  periodSettings?: InputMaybe<PeriodSettings>;
  /** "Часы на проект" */
  projectHours?: InputMaybe<Scalars['Int']['input']>;
  /** "Регистрация" */
  signUpFrom?: InputMaybe<Scalars['Int']['input']>;
};

/** Результат поиска глобальных курсов по заданным фильтрам */
export type GlobalCourseSearchResult = {
  __typename?: 'GlobalCourseSearchResult';
  /** Количество найденных курсов */
  count: Scalars['Int']['output'];
  /** Список найденных курсов по переданным фильтрам */
  courses?: Maybe<Array<GlobalCourseView>>;
};

/** Представление глобального курса в списке курсов */
export type GlobalCourseView = {
  __typename?: 'GlobalCourseView';
  /**
   * Наименование сущностей, на которые назначен курс, сгруппированных по типу
   * Инициализация происходит только по необходимости в GlobalCourseResolver#getAssignedEntitiesNamesGroupedByType()
   */
  assignedEntitiesNamesGroupedByType: Array<CourseAssignedEntitiesNamesByType>;
  /** Список привязанных к курсу тегов */
  contentTags: Array<ContentTag>;
  /** Тип курса */
  courseType: CourseType;
  /** Максимальный опыт за прохождения курса */
  experience?: Maybe<Scalars['Int']['output']>;
  /** Идентификатор глобального курса */
  globalCourseId: Scalars['ID']['output'];
  /** Признак, является ли курс оцениваемым */
  isGradedCourse?: Maybe<Scalars['Boolean']['output']>;
  /** Признак опубликованности курса */
  isPublished: Scalars['Boolean']['output'];
  /** Количество элементов, которые содержит курс */
  itemCount: Scalars['Int']['output'];
  /** Дата последнего изменения курса */
  lastModifyTime?: Maybe<Scalars['DateTime']['output']>;
  /** Название курса */
  name: Scalars['String']['output'];
};

/** Глобальный план */
export type GlobalPlan = {
  __typename?: 'GlobalPlan';
  /** Идентификатор глоабльного плана */
  globalPlanId: Scalars['ID']['output'];
  /** Статус плана */
  isPublished?: Maybe<Scalars['Boolean']['output']>;
  /** Цели плана */
  planGoals: Array<GlobalPlanGoal>;
  /** Количество проектов */
  projectCount: Scalars['Int']['output'];
  /** Идентификатор параллели */
  stageId: Scalars['ID']['output'];
  /** Название параллели */
  stageName?: Maybe<Scalars['String']['output']>;
  /** Идентификатор предмета */
  subjectId: Scalars['ID']['output'];
  /** Название предмета */
  subjectName?: Maybe<Scalars['String']['output']>;
};

/** Цели глобального плана */
export type GlobalPlanGoal = {
  __typename?: 'GlobalPlanGoal';
  /**
   * Тип проекта ш21 (групповой, индивидуальный)
   * @deprecated Под удаление. Используйте ModuleExecutionType
   */
  assignmentType?: Maybe<TaskAssignmentEnum>;
  /** "Начать с ..." */
  beginFrom: Scalars['Int']['output'];
  /** "Проверка" */
  checkFrom?: Maybe<Scalars['Int']['output']>;
  /** Количество проектов в курсе */
  courseProjectCount?: Maybe<Scalars['Int']['output']>;
  /** Тип курса */
  courseType?: Maybe<CourseType>;
  /** Флаг, указывающий на игнорирование любых дедлайнов для модуля */
  deadlineFree: Scalars['Boolean']['output'];
  /** Тип выполнения */
  executionType?: Maybe<ModuleExecutionType>;
  /** Идентификатор глобального курса */
  globalCourseId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор элемента глобального плана */
  globalPlanGoalId: Scalars['ID']['output'];
  /** Идентификатор цели */
  goalId?: Maybe<Scalars['ID']['output']>;
  /** Название цели */
  goalName?: Maybe<Scalars['String']['output']>;
  /** В курсе есть проект без дедлайнов и со случайным формированием команды */
  hasDeadlineFreeRandomTeam?: Maybe<Scalars['Boolean']['output']>;
  /** Просмотр контента */
  isContentAvailable: Scalars['Boolean']['output'];
  /** Ожидаемая трудоемкость в часах */
  laboriousness?: Maybe<Scalars['Int']['output']>;
  /** Порядковый номер цели */
  order: Scalars['Int']['output'];
  /** Максимальное количество баллов за выполнение проекта */
  point?: Maybe<Scalars['Int']['output']>;
  /** "Часы на проект" */
  projectHours?: Maybe<Scalars['Int']['output']>;
  /** "Регистрация" */
  signUpFrom: Scalars['Int']['output'];
  /** Имя абстрактного глобального предмета */
  subjectName?: Maybe<Scalars['String']['output']>;
  /** Настройки формирования команд */
  teamSettings?: Maybe<TeamSettings>;
};

/** Модель ввода для целей глобального плана */
export type GlobalPlanGoalInput = {
  /** "Начать с ..." */
  beginFrom: Scalars['Int']['input'];
  /** "Проверка" */
  checkFrom?: InputMaybe<Scalars['Int']['input']>;
  /** Флаг, указывающий на игнорирование любых дедлайнов для модуля */
  deadlineFree: Scalars['Boolean']['input'];
  /** Идентификатор глобального курса */
  globalCourseId?: InputMaybe<Scalars['ID']['input']>;
  /** Идентификатор цели глобального плана */
  globalPlanGoalId?: InputMaybe<Scalars['ID']['input']>;
  /** Идентификатор цели */
  goalId?: InputMaybe<Scalars['ID']['input']>;
  /** Просмотр контента */
  isContentAvailable: Scalars['Boolean']['input'];
  /** Порядковый номер цели */
  order: Scalars['Int']['input'];
  /** "Часы на проект" */
  projectHours?: InputMaybe<Scalars['Int']['input']>;
  /** "Регистрация" */
  signUpFrom: Scalars['Int']['input'];
};

export type GlobalSearchQueries = {
  __typename?: 'GlobalSearchQueries';
  /** S21. Глобальный поиск. Подсказки */
  getSearchHistoryTooltips: Array<Maybe<SearchTooltip>>;
  /** Глобальный поиск */
  searchByText: GlobalSearchResult;
};


export type GlobalSearchQueriesSearchByTextArgs = {
  items: Array<InputMaybe<SearchItem>>;
  page: PagingInput;
  searchString: Scalars['String']['input'];
};

/** Результаты глобального поиска */
export type GlobalSearchResult = {
  __typename?: 'GlobalSearchResult';
  /** Профили учеников */
  profiles?: Maybe<ProfilesSearchResult>;
  /** Проекты */
  projects?: Maybe<ProjectsSearchResult>;
  /** Курсы (Курсы + проекты) */
  studentCourses?: Maybe<CoursesSearchResult>;
};

export type GlobalSetting = {
  __typename?: 'GlobalSetting';
  channels: Array<Channel>;
  notificationType: NotificationType;
};

export type GlobalSettingInput = {
  channelActive: Scalars['Boolean']['input'];
  channelId: Scalars['ID']['input'];
  notificationTypeId: Scalars['ID']['input'];
  tenantId?: InputMaybe<Scalars['UUID']['input']>;
};

/** Глобальный план */
export type GlobalStagePlan = {
  __typename?: 'GlobalStagePlan';
  /** не/архивирован */
  active: Scalars['Boolean']['output'];
  /** ФИО автора плана */
  authorFio: Scalars['String']['output'];
  /** путь до файла с обложкой */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Дата создания плана */
  creationDate: Scalars['Date']['output'];
  /** список Учебных Модулей в Плане с привязкой к датам и необходимому для достижения уровню */
  frames: Array<StagePlanFrame>;
  /** Идентификатор в каталоге */
  itemId: Scalars['ID']['output'];
  /** Идентификатор */
  planId: Scalars['ID']['output'];
  /** Параллель, для котоой составлен Учебный План */
  stages: Array<Stage>;
  /** статус Плана */
  status: PlanStatusEnum;
  /** Предмет, по которому составлен План на параллель */
  subjects: Array<Subject>;
  /** название */
  title: Scalars['String']['output'];
};

export type Goal = {
  __typename?: 'Goal';
  goalId: Scalars['ID']['output'];
  goalName: Scalars['String']['output'];
  goalReviewInfo: GoalReviewInfo;
};

/** Модуль для проверки в данный слот */
export type GoalCheck = {
  __typename?: 'GoalCheck';
  /** Идентификатор модуля */
  goalId: Scalars['ID']['output'];
  /** Наименования модуля */
  goalName: Scalars['String']['output'];
  /** Информация по проверкам проекта для отображения в календаре БА */
  goalReviewInfo?: Maybe<GoalReviewInfo>;
};

/** Атрибуты "консистентности" проекта (необходимы для проверки возможности Публикации проекта и отображения ошибок неконсистентности пользователю) */
export type GoalConsistency = {
  __typename?: 'GoalConsistency';
  /** Идентификатор проекта */
  goalId: Scalars['ID']['output'];
  /** Список сопоставлений ("уровень цели" -> Список сопоставлений("ИД задания", "признак консистентности задания"))  для  отображения "признаков консистентности" заданий в проекте (разложенных по уровням) */
  goalLevelToTasksConsistencies?: Maybe<Array<Maybe<GoalLevelToTasksConsistencies>>>;
  /** Признак наличия параметров с количеством попыток выполнения: exam_attempts > 0 И task_attempts > 0 */
  hasExecutionCriterias: Scalars['Boolean']['output'];
  /** Признак наличия только индивидуальных заданий (используется только в Экзаменационных проектах) */
  hasOnlyIndividualTasks: Scalars['Boolean']['output'];
  /** Признак наличия настроек расчета балла за проект */
  hasPointsCalculationParams: Scalars['Boolean']['output'];
  /** Признак отсутствия заданий в проекте */
  hasTasks: Scalars['Boolean']['output'];
  /** Признак консистентности всех заданий проекта */
  isAllTasksConsistent: Scalars['Boolean']['output'];
  /** Признак наличия настроек повторного прохождения */
  isAttemptsNumberNotZero: Scalars['Boolean']['output'];
  /** Признак консистентности проекта */
  isConsistent: Scalars['Boolean']['output'];
  /** Конструкторы для проекта корректны */
  isConstructorsValid?: Maybe<Scalars['Boolean']['output']>;
  /** Признак Экзамена (тип выполнения проекта - Экзамен) */
  isExamProject: Scalars['Boolean']['output'];
  /** Признак Глобальной области видимости проекта */
  isGoalGlobalScoped: Scalars['Boolean']['output'];
  /** Список моделей "консистентности" заданий в проекте */
  taskInModuleConsistencyModels?: Maybe<Array<Maybe<TaskInModuleConsistency>>>;
};

export type GoalDto = {
  __typename?: 'GoalDTO';
  id: Scalars['ID']['output'];
  subjectName: Scalars['String']['output'];
  tasks: Array<Task>;
  title: Scalars['String']['output'];
};

/** Сопоставление учебного модуля(goals.goal_id) и кол-ва дней выделенных на модуль */
export type GoalDurationMap = {
  __typename?: 'GoalDurationMap';
  /** Идентификатор учебного модуля */
  goalId: Scalars['ID']['output'];
  /** Рекомендуемое учебным планом школы кол-во дней выделенных на модуль */
  recommendedDuration: Scalars['Int']['output'];
};

export type GoalElementInfo = {
  __typename?: 'GoalElementInfo';
  /** Чего достигнет Ученик при освоении этого ЭЦ */
  goalElementAchievementDescription: Scalars['String']['output'];
  /** Описание ЭЦ */
  goalElementDescription: Scalars['String']['output'];
  /** ID Элемента Цели (ЭЦ) */
  goalElementId: Scalars['ID']['output'];
  /** ID Уровня Модуля */
  goalLevelId: Scalars['ID']['output'];
  /** Значение Уровня для отображения (х.0) */
  goalLevelValueName: Scalars['String']['output'];
  /** Буква в названии ЭЦ (A, Б1 и тд) */
  letter: Scalars['String']['output'];
  /** Цифра в названии ЭЦ (A1, А2 и тд) */
  number: Scalars['String']['output'];
  /** Количество заданий в ЭЦ (из СЗ) */
  totalGoalElementTaskCount: Scalars['Int']['output'];
};

export type GoalElementInfoAndProgress = {
  __typename?: 'GoalElementInfoAndProgress';
  /** Тип отображения персонального помощника рядом с ЭЦ */
  assistantDisplayType?: Maybe<AssistantDisplayType>;
  /** Чего достигнет Ученик при освоении этого ЭЦ */
  goalElementAchievementDescription: Scalars['String']['output'];
  /** Описание ЭЦ */
  goalElementDescription: Scalars['String']['output'];
  /** ID Элемента Цели (ЭЦ) */
  goalElementId: Scalars['ID']['output'];
  /** Количество заданий в ЭЦ (из Траектории, если она есть, иначе -- минимальное из назначенной или дефолтной СЗ) */
  goalElementTaskCount: Scalars['Int']['output'];
  /** ID Уровня Модуля */
  goalLevelId: Scalars['ID']['output'];
  /** Значение Уровня для отображения (х.0) */
  goalLevelValueName: Scalars['String']['output'];
  /** Буква в названии ЭЦ (A, Б1 и тд) */
  letter: Scalars['String']['output'];
  /** Цифра в названии ЭЦ (A1, А2 и тд) */
  number: Scalars['String']['output'];
  /** Порядковый номер ЭЦ в Уровне */
  orderInLevel: Scalars['Int']['output'];
  /** Количества в разных Статусах */
  statusAndTaskCount: Array<StatusAndTaskCount>;
};

export type GoalElementInfoResponse = {
  __typename?: 'GoalElementInfoResponse';
  /** Тип 3Д ассистента */
  assistantDisplayType3D?: Maybe<AssistantDisplayType3D>;
  /** Информация об Элементе Цели */
  goalElementInfo?: Maybe<GoalElementInfo>;
  /** Находятся ли только обязательные задания в СЗ для этого Элемента Цели */
  isPlaylistHasOnlyMandatoryTasks: Scalars['Boolean']['output'];
  responseCodes: Array<PersonalTrajectoryResponseCode>;
};

export type GoalElementTask = {
  __typename?: 'GoalElementTask';
  /** форма выполнения задания (индивидуально, в парах и тд) */
  assignmentType: TaskAssignmentEnum;
  /** Может ли Ученик просматривать это Задание */
  canRead: Scalars['Boolean']['output'];
  /** Запланированная дата окончания Задания (пока что берется из дат самого Модуля) */
  endDate?: Maybe<Scalars['DateTime']['output']>;
  /** Добавлено ли Задание в Траекторию */
  isInTrajectory: Scalars['Boolean']['output'];
  /** Обязательно ли Задание в СЗ */
  isMandatory: Scalars['Boolean']['output'];
  /** Трудоемкость задания в минутах */
  laboriousness: Scalars['Int']['output'];
  /** Порядковый номер Задания из СЗ */
  order: Scalars['ID']['output'];
  /** Запланированная дата начала Задания (пока что берется из дат самого Модуля) */
  startDate?: Maybe<Scalars['DateTime']['output']>;
  /** типы проверок задания (авто проверк, проверка учителем и тд) */
  taskCheckTypes: Array<TaskCheckEnum>;
  /** Id Задания */
  taskId: Scalars['ID']['output'];
  /** Список Мягких Навыков для этого Задания */
  taskSoftSkills: Array<SoftSkill>;
  /** Статус этого Задания для Ученика (может отсутствовать, если задание еще не было назначено ученику) */
  taskStatus?: Maybe<TaskStatusEnum>;
  /** тип задания (проверочное, мотивационное и тд) */
  taskType: TaskTypeEnum;
  /** Название Задания */
  title: Scalars['String']['output'];
};

export type GoalElementTasksResponse = {
  __typename?: 'GoalElementTasksResponse';
  /** Задания внутри указанного Элемента Цели */
  goalElementTasks: Array<GoalElementTask>;
  /** Минимально необходимое количество Заданий */
  requiredTaskCount: Scalars['Int']['output'];
  /** Минимально необходимое количество Заданий по типам */
  requiredTaskCountByTaskType: Array<RequiredTaskCountByTaskType>;
  responseCodes: Array<PersonalTrajectoryResponseCode>;
};

/** Уровень цели с элементами */
export type GoalElementWithTasks = {
  __typename?: 'GoalElementWithTasks';
  /** Элемент цели */
  goalElement: StudyModuleGoalElement;
  /** Список заданий с колличеством студентов их выполнивших */
  taskWithCompletedByStudentsInGroupAttributes: Array<TaskWithCompletedByStudentsInGroupAttribute>;
};

/** S21 получение списка завершенных проектов с датами завершения */
export type GoalFinished = {
  __typename?: 'GoalFinished';
  /** дата завершения проекта */
  finishDate: Scalars['DateTime']['output'];
  /** id проекта */
  goalId: Scalars['Int']['output'];
  /** название проекта */
  goalName: Scalars['String']['output'];
};

/** Отношение неуспешно переведенных ИД модулей к возникшей ошибке */
export type GoalIdToErrorMapModel = {
  __typename?: 'GoalIdToErrorMapModel';
  /** Причина по которой не был переведен модуль */
  errorMessage: Scalars['String']['output'];
  /** Идентификатор модуля */
  goalId: Scalars['ID']['output'];
  /** Отношение неуспешно переведенных ИД заданий к возникшей ошибке */
  taskIdToErrorMapModels?: Maybe<Array<TaskIdToErrorMapModel>>;
};

/**
 * Краткая информация о модуле в контексте пользователя
 * Если объект запрашивает родитель, то он возвращается в контексте ребенка, по которому родитель
 * запрашивает информацию
 */
export type GoalInfo = {
  __typename?: 'GoalInfo';
  /** Список доступных для перехода статусов */
  availableProductionStatuses?: Maybe<Array<Maybe<ContentEntityProductionStatus>>>;
  /** Может ли текущий пользователь изменять модуль */
  canEdit: Scalars['Boolean']['output'];
  /** Может ли пользователь проходить модуль */
  canExecute: Scalars['Boolean']['output'];
  /**
   * Может ли текущий пользователь читать Модуль, определяется через скоуп модуля,
   * права пользователя и авторство
   */
  canRead: Scalars['Boolean']['output'];
  /** Причина по которой пользователь не может проходить модуль */
  executeDenyReason?: Maybe<Scalars['String']['output']>;
  /** Найдено ли такой модуль в БД */
  found: Scalars['Boolean']['output'];
  /** Скоуп видимости модуля (Приватный, Кастомный, Глобальный) */
  scope: ScopeEnum;
};

export type GoalLevelInfo = {
  __typename?: 'GoalLevelInfo';
  /** Элементы Цели, относящиеся к этому Уровню */
  goalElements: Array<GoalElementInfo>;
  /** Числовое значение Уровня */
  goalLevel: Scalars['Int']['output'];
  /** id Уровня Модуля */
  goalLevelId: Scalars['ID']['output'];
  /** Значение Уровня для отображения (х.0) */
  goalLevelValueName: Scalars['String']['output'];
  /** Рекомендуется ли этот уровень Учителем как целевой в Плане */
  isRecommendedByTeacher: Scalars['Boolean']['output'];
  /** Является ли этот Уровень Целевым */
  isStudentTargetLevel: Scalars['Boolean']['output'];
  /** Трудоемкость Уровня в минутах на основании трудоемкости Заданий в нем */
  laboriousness: Scalars['Int']['output'];
  /**
   * Количество Заданий в Уровне Модуля из Траектории, если она создана,
   * или из назначенной ему Системы Заданий (СЗ) в Модульного Плане,
   * или из Дефолтной СЗ Модуля, если Модуль Внеплановый
   */
  taskCount: Scalars['Int']['output'];
};

export type GoalLevelInfoAndProgress = {
  __typename?: 'GoalLevelInfoAndProgress';
  /** Количество Заданий, которые Ученик прошел в этом Уровне Траектории (статус ACCEPTED) */
  completedTaskCount: Scalars['Int']['output'];
  /** Элементы Цели, относящиеся к этому Уровню */
  goalElements: Array<GoalElementInfoAndProgress>;
  /** Числовое значение Уровня */
  goalLevel: Scalars['Int']['output'];
  /** id Уровня Модуля */
  goalLevelId: Scalars['ID']['output'];
  /** Значение Уровня для отображения (х.0) */
  goalLevelValueName: Scalars['String']['output'];
  /** Зачтен ли этот Уровень (goal_level_achieved_facts) */
  isAchieved: Scalars['Boolean']['output'];
  /** Зачтен ли модуль c помощью Закрывающего Теста(пока возможен только 2.0) */
  isAchievedByLevelTest: Scalars['Boolean']['output'];
  /** Зачтен ли модуль автоматически */
  isAutoAchieved: Scalars['Boolean']['output'];
  /** Входит ли этот уровень в Траекторию (Целевой и ниже) */
  isLevelInTrajectory: Scalars['Boolean']['output'];
  /** Рекомендуется ли этот уровень Учителем как целевой в Плане */
  isRecommendedByTeacher: Scalars['Boolean']['output'];
  /** Является ли этот Уровень Целевым */
  isStudentTargetLevel: Scalars['Boolean']['output'];
  /** Трудоемкость Уровня в минутах на основании трудоемкости Заданий в нем */
  laboriousness: Scalars['Int']['output'];
  /** Количество Заданий, находящихся на проверке (статус NEED_CHECK) */
  needCheckTaskCount: Scalars['Int']['output'];
  /**
   * Количество Заданий в Уровне Модуля из Траектории, если она создана,
   * или из назначенной ему Системы Заданий (СЗ) в Модульном Плане,
   * или из Дефолтной СЗ Модуля, если Модуль Внеплановый
   */
  taskCount: Scalars['Int']['output'];
  /** Комментарий Учителя при зачтении Уровня (пока может быть только один на Модуль) и информация об Учителе */
  teacherCommentInfo?: Maybe<TeacherCommentInfo>;
};

export type GoalLevelPerformance = {
  __typename?: 'GoalLevelPerformance';
  doneTaskCount: Scalars['Int']['output'];
  goalLevel: Scalars['String']['output'];
  requiredTaskCount: Scalars['Int']['output'];
};

export type GoalLevelProgressResponse = {
  __typename?: 'GoalLevelProgressResponse';
  /** Информация об Уровнях Модуля и Прогресс Ученика по ним */
  goalLevels: Array<GoalLevelInfoAndProgress>;
  responseCodes: Array<PersonalTrajectoryResponseCode>;
};

export type GoalLevelResponse = {
  __typename?: 'GoalLevelResponse';
  /** Тип 3Д ассистента */
  assistantDisplayType3D?: Maybe<AssistantDisplayType3D>;
  /** Уровни в Модуле и информация по ним */
  goalLevels: Array<GoalLevelInfo>;
  responseCodes: Array<PersonalTrajectoryResponseCode>;
};

/** Настройки закрывающего теста */
export type GoalLevelTest = {
  __typename?: 'GoalLevelTest';
  /** Необходимая по умолчанию емкость элементов цели внутри уровня */
  defaultRequiredSkillCapacity: Scalars['Int']['output'];
  /** Кол-во зафейленных заданий после которых должен фейлиться тест */
  failedTasksThreshold: Scalars['Int']['output'];
  /** идентификатор модуля */
  goalId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор уровня (goal_levels.goal_level_id) к которому привязан тест */
  goalLevelId: Scalars['ID']['output'];
  /** ID теста */
  id: Scalars['ID']['output'];
  /** Включен ли тест для уровня */
  isActive: Scalars['Boolean']['output'];
  /** Уровень, к которому привязан тест */
  level: Scalars['Float']['output'];
  /** Максимальное кол-во допустимых попыток */
  maxAttemptsNumber: Scalars['Int']['output'];
  /** Максимально кол-во элементов цели, учитываемое в емкости теста */
  recommendedMaxSkillsNumber: Scalars['Int']['output'];
  /** Минимальное кол-во элементов цели, необходимое для формирования теста */
  requiredMinSkillsNumber: Scalars['Int']['output'];
  /** Стратегия выбора заданий */
  taskSelectionStrategy: GoalLevelTestTaskSelectionType;
};

export type GoalLevelTestAttemptOldTask = {
  __typename?: 'GoalLevelTestAttemptOldTask';
  answers?: Maybe<Array<StudentAnswer>>;
  status: TaskStatusEnum;
  taskId: Scalars['ID']['output'];
};

export type GoalLevelTestAttemptTaskWidget = {
  __typename?: 'GoalLevelTestAttemptTaskWidget';
  /**
   * Ответ на виджет
   * @deprecated Для совместимостью с тренажерами, использовать список с ответами по виджету
   */
  answer?: Maybe<GoalLevelTestAttemptTaskWidgetAnswer>;
  /** Ответы по виджету */
  answers?: Maybe<Array<Maybe<GoalLevelTestAttemptTaskWidgetAnswer>>>;
  /** Мета-виджет */
  contentWidget?: Maybe<Widget>;
  /** Идентифкатор виджета в контент-сервисе */
  widgetId: Scalars['ID']['output'];
  /** Текущий статус виджета */
  widgetStatus: TaskWidgetStatusEnum;
};

export type GoalLevelTestAttemptTaskWidgetAnswer = {
  __typename?: 'GoalLevelTestAttemptTaskWidgetAnswer';
  /** Тело ответа */
  answerBody?: Maybe<WidgetAnswerBody>;
  /** Текущий статус ответа */
  answerStatus: TaskWidgetAnswerStatusEnum;
  /** Идентификатор варианта вопроса тренажера */
  variantId?: Maybe<Scalars['String']['output']>;
};

/** Настройки закрывающего теста для уровня модуля */
export type GoalLevelTestInput = {
  /** Включен ли тест для уровня */
  isActive: Scalars['Boolean']['input'];
  /** Для какого уровня включен тест */
  level: Scalars['Float']['input'];
  /** Стратегия выбора заданий для теста */
  taskSelectionStrategy: GoalLevelTestTaskSelectionType;
};

/** Стратегия выбора заданий для закрывающего теста */
export enum GoalLevelTestTaskSelectionType {
  /** Для выборки используются только задания, находящиеся не в терминальном статусе */
  WithoutEndedTasks = 'WITHOUT_ENDED_TASKS',
  /** Для выборки используются задания в любых статусах */
  WithEndedTasks = 'WITH_ENDED_TASKS',
  /** Пройденные задания можно будет проходить повторно */
  WithRetake = 'WITH_RETAKE'
}

/** Тип содержит сопоставление ("уровень цели" -> Список сопоставлений("ИД задания", "признак консистентности задания"))  для  отображения "признаков консистентности" заданий в проекте (разложенных по уровням) */
export type GoalLevelToTasksConsistencies = {
  __typename?: 'GoalLevelToTasksConsistencies';
  /** Порядковый номер уровня */
  goalLevel: Scalars['Int']['output'];
  /** Список сопоставлений ["ИД задания" -> "признак консистентности задания"] */
  taskIdToTaskConsistencies?: Maybe<Array<Maybe<TaskIdToTaskConsistency>>>;
};

/** Задания  группированные по элементам цели для планирования расписания к уроку */
export type GoalLevelWithElements = {
  __typename?: 'GoalLevelWithElements';
  /** Список элементов цели */
  goalElements: Array<GoalElementWithTasks>;
  /** Ид Модуля */
  goalId: Scalars['ID']['output'];
  /** Уровень модуля */
  level: StudyModuleLevel;
};

export type GoalPointInput = {
  globalCourseId?: InputMaybe<Scalars['ID']['input']>;
  globalPlanId: Scalars['ID']['input'];
  goalId?: InputMaybe<Scalars['ID']['input']>;
  point: Scalars['Int']['input'];
};

/** Информация по проверкам проекта для отображения в календаре БА */
export type GoalReviewInfo = {
  __typename?: 'GoalReviewInfo';
  /** Длительность проверки */
  checkDurationMinutes: Scalars['Int']['output'];
  /** Тип выполнения */
  executionType: ModuleExecutionType;
  /** Идентификатор проекта */
  goalId: Scalars['ID']['output'];
  /**
   * Кол-во студентов(для индивидуального проекта)/групп(для группового проекта) локального кампуса,
   * которые завершили выполнение проекта и еще не записались на проверку к сотруднику
   */
  pendingLocalReviews: Scalars['Int']['output'];
  /**
   * Кол-во студентов(для индивидуального проекта)/групп(для группового проекта) при мультикампусности,
   * которые завершили выполнение проекта и еще не записались на проверку к сотруднику
   */
  pendingMulticampusReviews: Scalars['Int']['output'];
};

/** Краткая информация о проекте */
export type GoalShortInfo = {
  __typename?: 'GoalShortInfo';
  /** Идентификатор проекта */
  goalId?: Maybe<Scalars['ID']['output']>;
  /** Название проекта */
  goalName?: Maybe<Scalars['String']['output']>;
};

/** Краткая информация об источнике проекте */
export type GoalSourceShortInfo = {
  __typename?: 'GoalSourceShortInfo';
  /** Идентификатор источника проекта */
  goalSourceId?: Maybe<Scalars['ID']['output']>;
  /** Название источника проекта */
  goalSourceName?: Maybe<Scalars['String']['output']>;
};

/** Типы источников проектов */
export enum GoalSourceTypeEnum {
  Course = 'COURSE',
  StagePlan = 'STAGE_PLAN',
  StudyProgram = 'STUDY_PROGRAM'
}

/** Статус модуля */
export enum GoalStatus {
  /** Пройден */
  Accepted = 'ACCEPTED',
  /** Назначен */
  Assigned = 'ASSIGNED',
  /** Провален */
  Failed = 'FAILED',
  /** В процессе прохождения */
  InProgress = 'IN_PROGRESS',
  /** Зарегистрирован */
  Registered = 'REGISTERED'
}

/** Информация о проекте и количестве студентов в нём */
export type GoalStudentsCount = {
  __typename?: 'GoalStudentsCount';
  /** Наименование проекта */
  goalName: Scalars['String']['output'];
  /** Количество студентов */
  studentsCount: Scalars['Int']['output'];
};

export type GoalTimeFrame = {
  __typename?: 'GoalTimeFrame';
  end: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  start: Scalars['DateTime']['output'];
};

/** Элемент цели с уровнем и подробным описанием */
export type GoalWithLevel = {
  __typename?: 'GoalWithLevel';
  /** Ид элемента цели */
  goalElementId: Scalars['ID']['output'];
  /** Уровень элемента цели */
  goalElementLevel: Scalars['Float']['output'];
  /** Подробное описание элемента цели */
  whatStudentStudied: Scalars['String']['output'];
};

/** Требуемая информация о модулях студентов выполнивших задания в ГКпП для фильтра */
export type GoalsFilter = {
  __typename?: 'GoalsFilter';
  goalId?: Maybe<Scalars['ID']['output']>;
  goalName?: Maybe<Scalars['String']['output']>;
};

/** Способ отображения отметок в системе оценивания */
export enum GovernmentMarkDisplayMethod {
  /** Отображение сокращения */
  Abbreviation = 'ABBREVIATION',
  /** Отображение пиктограммы */
  Icon = 'ICON',
  /** Отображение значения */
  Value = 'VALUE'
}

/** Система оценивания */
export type GovernmentMarkType = {
  __typename?: 'GovernmentMarkType';
  /** Способ отображения отметок в данной системе оценивания */
  governmentMarkDisplayMethod: GovernmentMarkDisplayMethod;
  /** Название системы оценивания */
  governmentMarkTypeName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** Признак того, что система оценивания доступна для использования */
  isActive: Scalars['Boolean']['output'];
  /** Признак системы оценивания по умолчанию */
  isDefault: Scalars['Boolean']['output'];
  /** Признак того, что оценки системы оценивания являются числами */
  isNumeric: Scalars['Boolean']['output'];
};

export type GradingScale = {
  __typename?: 'GradingScale';
  id: Scalars['ID']['output'];
  mark: Scalars['String']['output'];
  percent: Scalars['Int']['output'];
};

export type GradingScaleInput = {
  mark: Scalars['String']['input'];
  percent: Scalars['Int']['input'];
};

/** Статус проекта на графе */
export enum GraphNodeProgressStateEnum {
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Locked = 'LOCKED',
  Unavailable = 'UNAVAILABLE',
  Unlocked = 'UNLOCKED'
}

/** Краткая информация по пользовательской группе */
export type Group = {
  __typename?: 'Group';
  /** Активна ли группа */
  active: Scalars['Boolean']['output'];
  /** Тип пользовательской группы */
  groupType?: Maybe<GroupType>;
  /** Идентификатор пользовательской группе */
  id: Scalars['UUID']['output'];
  /** Наименование пользовательской группы */
  name: Scalars['String']['output'];
};

/** Используется для вызова teacher.getStudentTasks() STUDENT_BY_STUDENT check */
export type GroupCheckInfo = {
  __typename?: 'GroupCheckInfo';
  moduleIds: Array<Scalars['ID']['output']>;
  stageSubjectGroupIds: Array<Scalars['ID']['output']>;
  studentIds: Array<Scalars['UUID']['output']>;
  subjectIds: Array<Scalars['ID']['output']>;
};

/** Результат начисления игровых монет. */
export type GroupCoinsTransactionResponseModel = {
  __typename?: 'GroupCoinsTransactionResponseModel';
  /** Нужно ли отдать пользователю файл с ошибками(если хоть один логин не найден) */
  createFile: Scalars['Boolean']['output'];
  /** Сообщение с логинами и результатом начислений */
  message: Scalars['String']['output'];
};

/** Информация о групповом проекте */
export type GroupProject = {
  __typename?: 'GroupProject';
  /** Команда, в которой состоит студент */
  currentTeam: TeamWithMembers;
  /** Список команд, в которые студент приглашён. Список участников всегда пустой. */
  invitingTeams: Array<TeamWithMembers>;
  /** Модуль проекта */
  module: StudentModule;
};

/** Информация о команде в групповом проекте */
export type GroupProjectInfo = {
  __typename?: 'GroupProjectInfo';
  /** Ид выполняемого командой группового проекта */
  goalId: Scalars['ID']['output'];
  /** Название выполняемого командой группового проекта */
  goalName: Scalars['String']['output'];
  /** Ид команды */
  teamId: Scalars['UUID']['output'];
  /** Название команды */
  teamName: Scalars['String']['output'];
};

/** Статистика по групповому проекту с информацией о командах */
export type GroupProjectStatistics = {
  __typename?: 'GroupProjectStatistics';
  /** Количество команд, успешно завершивших выполнение проекта */
  acceptedTeams: Scalars['Int']['output'];
  /** Количество команд, находящихся в стадии проверки проекта */
  evaluationTeams: Scalars['Int']['output'];
  /** Количество команд, неуспешно завершивших выполнение проекта */
  failedTeams: Scalars['Int']['output'];
  /** Количество команд, завершивших выполнение проекта */
  finishedTeams: Scalars['Int']['output'];
  /** Количество команд, выполняющих проект и ещё не перешедших в стадию проверки */
  inProgressTeams: Scalars['Int']['output'];
};

/** Информация по типу группы пользователя */
export type GroupType = {
  __typename?: 'GroupType';
  /** Описание типа группы пользователя */
  description: Scalars['String']['output'];
  /** Идентификатор события */
  eventTypeId?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  /** Признак системная ли это группа */
  isSystem: Scalars['Boolean']['output'];
};

export type GroupedStudentTaskForTeacher = {
  __typename?: 'GroupedStudentTaskForTeacher';
  /** Конкретные задания на проверке */
  studentsToCheck: Array<StudentToCheck>;
  /** Задание */
  task: Task;
  /** Оценка задания */
  taskMark?: Maybe<Scalars['Int']['output']>;
  /** Статус сгруппированных заданий */
  taskStatus: TaskStatusEnum;
};

/** Совокупность достижений за выполнение задания учеником */
export type History = {
  __typename?: 'History';
  /** Все полученные награды(и бейджи, и экипировка) */
  awards: Array<Award>;
  /** Полученные бейджи */
  badges: Array<Badge>;
  /** Уровень после выполнения задания */
  currentExperienceLevel?: Maybe<ExperienceLevel>;
  /** Опыт после выполнения задания */
  currentExperienceValue?: Maybe<Scalars['Int']['output']>;
  /** Дата награждения */
  date: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  /** Уведомлен ли пользователь о наградах */
  isShown: Scalars['Boolean']['output'];
  /** Следующий уровень */
  nextExperienceLevel?: Maybe<ExperienceLevel>;
  /** Уровень до выполнения задания */
  previousExperienceLevel?: Maybe<ExperienceLevel>;
  /** Опыт до выполнения задания */
  previousExperienceValue?: Maybe<Scalars['Int']['output']>;
};

export enum HolidayAdaptiveImagesEnum {
  L = 'L',
  M = 'M',
  S = 'S',
  Xl = 'XL',
  Xl2 = 'XL2',
  Xl3 = 'XL3',
  Xs = 'XS'
}

/** Модель для банера праздника. */
export type HolidayBanner = {
  __typename?: 'HolidayBanner';
  /** Текст для кнопки с действием на баннере. */
  actionText?: Maybe<Scalars['String']['output']>;
  /** Все размеры изображений */
  bannersImagesModels: Array<HolidayBannersImagesModel>;
  /** Идентификатор банера. */
  id: Scalars['ID']['output'];
  /** Ссылка на изображение для баннера. */
  imageUrl: Scalars['String']['output'];
  /** Ссылка на ресурс, куда будет осуществлен переход в браузере. */
  redirectUrl?: Maybe<Scalars['String']['output']>;
};

export type HolidayBannersImagesModel = {
  __typename?: 'HolidayBannersImagesModel';
  /** Идентификатор баннера */
  bannerId: Scalars['ID']['output'];
  /** Ссылка на изображения баннера */
  bannerUrl: Scalars['String']['output'];
  /** Идентификатор изображения баннера */
  id: Scalars['ID']['output'];
  /** Тип размера изображения */
  sizeType: HolidayAdaptiveImagesEnum;
};

/** Модель для группы стикеров праздника. */
export type HolidayStickerPackGroup = {
  __typename?: 'HolidayStickerPackGroup';
  /** Идентификатор записи в справочнике группы стикерпаков. */
  id: Scalars['ID']['output'];
  /** Ссылки на стикеры. */
  imageUrls: Array<Scalars['String']['output']>;
  /** Название группы стикерпаков. */
  name: Scalars['String']['output'];
};

/** Модель для приветственной страницы праздника. */
export type HolidayWelcomePage = {
  __typename?: 'HolidayWelcomePage';
  /** Контент для приветственной страницы */
  content: Scalars['String']['output'];
  /** Идентификатор приветственной страницы. */
  id: Scalars['ID']['output'];
  /** Ссылка на изображение приветственной страницы. */
  imageUrl: Scalars['String']['output'];
  /** Изображения с адаптивом */
  imagesModels: Array<HolidayWelcomePageImages>;
  /** Страница по умолчанию. */
  isDefault: Scalars['Boolean']['output'];
};

export type HolidayWelcomePageImages = {
  __typename?: 'HolidayWelcomePageImages';
  /** Идентификатор изображения приветственной страницы. */
  id: Scalars['ID']['output'];
  /** Ссылка на изображение. */
  imageUrl: Scalars['String']['output'];
  /** Тип размера изображения */
  sizeType: HolidayAdaptiveImagesEnum;
  /** Идентификатор приветственной страницы. */
  welcomePageId: Scalars['ID']['output'];
};

/** Граф */
export type HolyGraph = {
  __typename?: 'HolyGraph';
  /** Комментарий к версии графа */
  comment?: Maybe<Scalars['String']['output']>;
  /** Дата создания */
  createTs?: Maybe<Scalars['DateTime']['output']>;
  /** Автор */
  createdBy?: Maybe<Scalars['String']['output']>;
  /** Владелец черновика */
  draftUserId?: Maybe<Scalars['UUID']['output']>;
  /** Граф */
  graph?: Maybe<HolyGraphJson>;
  /** Id Графа */
  graphId?: Maybe<Scalars['Int']['output']>;
  /** Идентификатор параллели, для которой действует граф */
  stageId?: Maybe<Scalars['Int']['output']>;
  /** Статус графа (P - опубликованный, A - архивный, D - черновик) */
  status?: Maybe<Scalars['String']['output']>;
  /** Идентификатор продукта, в котором действует граф */
  tenantId?: Maybe<Scalars['UUID']['output']>;
  /** Дата последнего изменения */
  updateTs?: Maybe<Scalars['DateTime']['output']>;
  /** Автор последнего изменения */
  updatedBy?: Maybe<Scalars['String']['output']>;
  /** Номер версии графа в архиве (0 для черновиков и опубликованных) */
  version?: Maybe<Scalars['Int']['output']>;
};

/** Контекст графа по заданным источникам */
export type HolyGraphContentBunch = {
  __typename?: 'HolyGraphContentBunch';
  /** Перечень Id источников проектов */
  contentBunchIds: Array<Scalars['Int']['output']>;
  /** Тип источников проектов */
  contentBunchType: HolyGraphContentBunchTypeEnum;
  /** Учебные модули заданных источников */
  items: Array<HolyGraphContentBunchItem>;
  /** Id параллели */
  stageId?: Maybe<Scalars['Int']['output']>;
};

/** Источник проектов */
export type HolyGraphContentBunchEntity = {
  __typename?: 'HolyGraphContentBunchEntity';
  /** Id источника проектов */
  id: Scalars['Int']['output'];
  /** Наименование источника проектов */
  name?: Maybe<Scalars['String']['output']>;
};

/** Учебные модули глобального плана */
export type HolyGraphContentBunchItem = {
  __typename?: 'HolyGraphContentBunchItem';
  /** Детальная информация о курсе */
  course?: Maybe<HolyGraphItemCourseInfo>;
  /** Ид связанной сущности */
  entityId?: Maybe<Scalars['Int']['output']>;
  /** Тип связанной сущности */
  entityType?: Maybe<HolyGraphItemEntityType>;
  /** Детальная информация о проекте */
  goal?: Maybe<HolyGraphItemGoalInfo>;
  /** Направления обучения (навыки) */
  skills: Array<HolyGraphItemSkill>;
};

export enum HolyGraphContentBunchTypeEnum {
  /** Курс */
  Course = 'COURSE',
  /** Глобальный план */
  GlobalPlan = 'GLOBAL_PLAN',
  /** Учебная программа */
  StudyProgram = 'STUDY_PROGRAM'
}

/** Связи между элементами графа */
export type HolyGraphEdge = {
  __typename?: 'HolyGraphEdge';
  /** Траектория связи */
  data: HolyGraphEdgeData;
  /** Ид связи */
  id: Scalars['String']['output'];
  /** id группы-источника */
  source: Scalars['String']['output'];
  /** id точки выхода */
  sourceHandle: Scalars['String']['output'];
  /** id группы-приемника */
  target: Scalars['String']['output'];
  /** id точки входа */
  targetHandle: Scalars['String']['output'];
  /** Тип связи */
  type: Scalars['String']['output'];
};

/** Траектория связи графа */
export type HolyGraphEdgeData = {
  __typename?: 'HolyGraphEdgeData';
  /** Координаты точек траектории связи */
  points: Array<HolyGraphPointPosition>;
  /** Расстояние до источника */
  sourceGap: Scalars['Int']['output'];
  /** Расстояние до назначения */
  targetGap: Scalars['Int']['output'];
};

/** Детальная информация о курсе */
export type HolyGraphItemCourseInfo = {
  __typename?: 'HolyGraphItemCourseInfo';
  /** Тип выполнения курса */
  courseType?: Maybe<CourseType>;
  /** Продолжительность проекта в часах */
  duration?: Maybe<Scalars['Int']['output']>;
  /** Обязателен ли проект(высчитывается по зависимостям в конструкторах) */
  isMandatory?: Maybe<Scalars['Boolean']['output']>;
  /** ИД локального курса ассоциированного с данным глобальным курсом. */
  localCourseId?: Maybe<Scalars['Int']['output']>;
  /** Дата проекта */
  projectDate?: Maybe<Scalars['DateTime']['output']>;
  /** Описание проекта */
  projectDescription?: Maybe<Scalars['String']['output']>;
  /** Id проекта */
  projectId: Scalars['Int']['output'];
  /** Название проекта */
  projectName: Scalars['String']['output'];
  /** Максимальное количество очков, которые можно получить за проект */
  projectPoints?: Maybe<Scalars['Int']['output']>;
  /** Статус проекта */
  projectState?: Maybe<GraphNodeProgressStateEnum>;
};

export enum HolyGraphItemEntityType {
  Course = 'COURSE',
  Goal = 'GOAL',
  Undefined = 'UNDEFINED'
}

/** Детальная информация о проекте */
export type HolyGraphItemGoalInfo = {
  __typename?: 'HolyGraphItemGoalInfo';
  /** Продолжительность проекта в часах */
  duration?: Maybe<Scalars['Int']['output']>;
  /** Тип выполнения проекта */
  goalExecutionType?: Maybe<ModuleExecutionType>;
  /** Обязателен ли проект(высчитывается по зависимостям в конструкторах) */
  isMandatory?: Maybe<Scalars['Boolean']['output']>;
  /** Дата проекта */
  projectDate?: Maybe<Scalars['DateTime']['output']>;
  /** Описание проекта */
  projectDescription?: Maybe<Scalars['String']['output']>;
  /** Id проекта */
  projectId: Scalars['Int']['output'];
  /** Название проекта */
  projectName: Scalars['String']['output'];
  /** Максимальное количество очков, которые можно получить за проект */
  projectPoints?: Maybe<Scalars['Int']['output']>;
  /** Статус проекта */
  projectState?: Maybe<GraphNodeProgressStateEnum>;
};

/** Направления обучения (навыки) */
export type HolyGraphItemSkill = {
  __typename?: 'HolyGraphItemSkill';
  /** Цвет направления на графе */
  color: Scalars['String']['output'];
  /** id */
  id: Scalars['ID']['output'];
  /** Уникальное наименование направления */
  name: Scalars['String']['output'];
  /** Цвет текста направления на графе */
  textColor?: Maybe<Scalars['String']['output']>;
};

/** Граф (в JSON формате) */
export type HolyGraphJson = {
  __typename?: 'HolyGraphJSON';
  /** Связи элементов графа */
  edges: Array<HolyGraphEdge>;
  /** Группа элементов графа */
  nodes: Array<HolyGraphNode>;
};

export type HolyGraphMutations = {
  __typename?: 'HolyGraphMutations';
  /**
   * Заархивировать опубликованный граф для указанной параллели.
   * Граф переносится в архив и ему присваивается номер архивной версии. Равносильно операции удаления графа
   */
  archiveGraph?: Maybe<HolyGraph>;
  /** Удалить черновик графа для указанной параллели */
  deleteDraft?: Maybe<Scalars['Boolean']['output']>;
  /** Опубликовать граф для указанной параллели */
  publishGraph?: Maybe<HolyGraph>;
  /**
   * Восстановить граф из архивной версии (переопубликовать)
   * Архивная версия публикуется, а текущая опубликованная помещается в архив
   */
  restoreArchivedGraph?: Maybe<HolyGraph>;
  /** Сохранить черновик графа для указанной параллели */
  saveDraft?: Maybe<Scalars['Int']['output']>;
};


export type HolyGraphMutationsArchiveGraphArgs = {
  comment?: InputMaybe<Scalars['String']['input']>;
  stageId: Scalars['Int']['input'];
};


export type HolyGraphMutationsDeleteDraftArgs = {
  stageId: Scalars['Int']['input'];
};


export type HolyGraphMutationsPublishGraphArgs = {
  comment?: InputMaybe<Scalars['String']['input']>;
  contentBunchIds: Array<Scalars['Int']['input']>;
  contentBunchType: HolyGraphContentBunchTypeEnum;
  graph: Scalars['JsonNode']['input'];
  stageId: Scalars['Int']['input'];
};


export type HolyGraphMutationsRestoreArchivedGraphArgs = {
  stageId: Scalars['Int']['input'];
  version: Scalars['Int']['input'];
};


export type HolyGraphMutationsSaveDraftArgs = {
  contentBunchIds?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  contentBunchType?: InputMaybe<HolyGraphContentBunchTypeEnum>;
  graph: Scalars['JsonNode']['input'];
  stageId: Scalars['Int']['input'];
};

/** Группы элементов графа */
export type HolyGraphNode = {
  __typename?: 'HolyGraphNode';
  /** Точки входа/выхода */
  handles: Array<Scalars['String']['output']>;
  /** Ид группы */
  id: Scalars['String']['output'];
  /** Элементы группы */
  items: Array<HolyGraphNodeItem>;
  /** Название группы */
  label: Scalars['String']['output'];
  /** Координаты группы */
  position: HolyGraphNodePosition;
};

/** Элементы групп графа */
export type HolyGraphNodeItem = {
  __typename?: 'HolyGraphNodeItem';
  /** Элементы, которые зависят от текущего */
  childrenNodeCodes: Array<Scalars['String']['output']>;
  /** Код элемента */
  code: Scalars['String']['output'];
  /** Детальная информация о курсе */
  course?: Maybe<HolyGraphItemCourseInfo>;
  /** Ид связанной сущности */
  entityId: Scalars['Int']['output'];
  /** Тип связанной сущности */
  entityType: HolyGraphItemEntityType;
  /** Детальная информация о проекте */
  goal?: Maybe<HolyGraphItemGoalInfo>;
  /** Точки входа/выхода */
  handles: Array<Scalars['String']['output']>;
  /** Ид элемента */
  id: Scalars['String']['output'];
  /** Элементы, от которых зависит текущий */
  parentNodeCodes: Array<Scalars['String']['output']>;
  /** Направления обучения (навыки) */
  skills: Array<HolyGraphItemSkill>;
};

/** Координаты группы */
export type HolyGraphNodePosition = {
  __typename?: 'HolyGraphNodePosition';
  x: Scalars['Int']['output'];
  y: Scalars['Int']['output'];
};

/** Координаты точек траектории связи */
export type HolyGraphPointPosition = {
  __typename?: 'HolyGraphPointPosition';
  x: Scalars['Int']['output'];
  y: Scalars['Int']['output'];
};

export type HolyGraphQueries = {
  __typename?: 'HolyGraphQueries';
  /** Получить архивную версию графа для указанной параллели */
  getArchivedGraph?: Maybe<HolyGraphJson>;
  /** Получить список архивных версий графа для указанной параллели */
  getArchivedGraphVersions: Array<HolyGraphVersion>;
  /** Получить контекст графа по заданным источникам */
  getContentBunchGraph?: Maybe<HolyGraphContentBunch>;
  /** Получить источники проектов по типу */
  getContentBunchesByType: Array<HolyGraphContentBunchEntity>;
  /** Получить черновик графа пользователя */
  getDraftGraph?: Maybe<HolyGraphJson>;
  /** Получить граф по указанному Id */
  getGraph?: Maybe<HolyGraphJson>;
  /** Получить опубликованный граф для указанной параллели */
  getPublishedGraph?: Maybe<HolyGraphJson>;
  /** Получить список параллелей, имеющих опубликованный граф */
  getPublishedGraphStages: Array<HolyGraphStage>;
  /** Получить опубликованный шаблон графа прогресса студента */
  getStudentGraphTemplate?: Maybe<HolyGraphJson>;
  /** Получить граф прогресса студента */
  getStudentStateGraph?: Maybe<HolyGraphJson>;
  /** Обогатить узел графа информацией о статусе прохождения проектов студентом */
  getStudentStateGraphNode?: Maybe<HolyGraphNode>;
  /** Проверить наличие у пользователя черновика графа для параллели */
  isDraftGraphExists?: Maybe<Scalars['Boolean']['output']>;
};


export type HolyGraphQueriesGetArchivedGraphArgs = {
  stageId: Scalars['Int']['input'];
  version: Scalars['Int']['input'];
};


export type HolyGraphQueriesGetArchivedGraphVersionsArgs = {
  stageId: Scalars['Int']['input'];
};


export type HolyGraphQueriesGetContentBunchGraphArgs = {
  contentBunchIds: Array<Scalars['Int']['input']>;
  contentBunchType: HolyGraphContentBunchTypeEnum;
  stageId: Scalars['Int']['input'];
};


export type HolyGraphQueriesGetContentBunchesByTypeArgs = {
  contentBunchType: HolyGraphContentBunchTypeEnum;
  stageId: Scalars['Int']['input'];
};


export type HolyGraphQueriesGetDraftGraphArgs = {
  stageId: Scalars['Int']['input'];
};


export type HolyGraphQueriesGetGraphArgs = {
  graphId: Scalars['Int']['input'];
};


export type HolyGraphQueriesGetPublishedGraphArgs = {
  emptyIfNotExist?: InputMaybe<Scalars['Boolean']['input']>;
  stageId: Scalars['Int']['input'];
};


export type HolyGraphQueriesGetStudentGraphTemplateArgs = {
  stageGroupId?: InputMaybe<Scalars['Int']['input']>;
  studentId?: InputMaybe<Scalars['UUID']['input']>;
};


export type HolyGraphQueriesGetStudentStateGraphArgs = {
  stageGroupId?: InputMaybe<Scalars['Int']['input']>;
  studentId?: InputMaybe<Scalars['UUID']['input']>;
};


export type HolyGraphQueriesGetStudentStateGraphNodeArgs = {
  graphNode: Scalars['JsonNode']['input'];
  stageGroupId?: InputMaybe<Scalars['Int']['input']>;
  studentId?: InputMaybe<Scalars['UUID']['input']>;
};


export type HolyGraphQueriesIsDraftGraphExistsArgs = {
  stageId: Scalars['Int']['input'];
};

/** Связь графа и параллели */
export type HolyGraphStage = {
  __typename?: 'HolyGraphStage';
  /** Комментарий к версии графа */
  comment?: Maybe<Scalars['String']['output']>;
  /** Перечень Id источников проектов */
  contentBunchIds: Array<Scalars['Int']['output']>;
  /** Тип источников проектов */
  contentBunchType: HolyGraphContentBunchTypeEnum;
  /** Id графа */
  graphId: Scalars['Int']['output'];
  /** Id параллели */
  stageId: Scalars['Int']['output'];
  /** Наименование параллели */
  stageName: Scalars['String']['output'];
  /** Дата последнего изменения */
  updateTs?: Maybe<Scalars['DateTime']['output']>;
  /** Автор последнего изменения */
  updatedBy?: Maybe<Scalars['String']['output']>;
};

/** Версия графа */
export type HolyGraphVersion = {
  __typename?: 'HolyGraphVersion';
  /** Комментарий к версии графа */
  comment?: Maybe<Scalars['String']['output']>;
  /** Дата создания */
  createTs?: Maybe<Scalars['DateTime']['output']>;
  /** Автор */
  createdBy?: Maybe<Scalars['String']['output']>;
  /** Id графа */
  graphId: Scalars['Int']['output'];
  /** Id параллели */
  stageId: Scalars['Int']['output'];
  /** Версия графа */
  version: Scalars['Int']['output'];
};

/** Домашняя работа */
export type Homework = {
  __typename?: 'Homework';
  /** Дата и время дедлайна домашней работы */
  deadlineTs: Scalars['DateTime']['output'];
  /** Идентификатор домашней работы */
  homeworkId?: Maybe<Scalars['ID']['output']>;
  /** Задания с идентификатором элемента цели в рамках которого они были добавлены к домашней работе */
  homeworkTasks: Array<HomeworkTaskWithGoalElementId>;
  /** Текстовая заметка к домашней работе */
  note?: Maybe<Scalars['String']['output']>;
  /** Подборки материалов к домашней работе */
  selections: Array<Selection>;
  /** Идентификатор группы в контексте параллели и предмета */
  stageSubjectGroupId: Scalars['ID']['output'];
};

/** Условный статус завершенности Домашней Работы */
export enum HomeworkCalculatedStatus {
  Expired = 'EXPIRED',
  Finished = 'FINISHED',
  NotFinished = 'NOT_FINISHED'
}

/** Информация о Домашней Работе ученика */
export type HomeworkInfo = {
  __typename?: 'HomeworkInfo';
  /** Дата и время дедлайна Домашней Работы (с таймзоной) */
  deadlineTs: Scalars['DateTime']['output'];
  /** Идентификатор Домашней Работы */
  homeworkId: Scalars['ID']['output'];
  /** Задания Домашней Работы */
  homeworkTasks: Array<HomeworkStudentTaskInfo>;
  /** Дополнительная информация о заданиях Домашней Работы - следующее доступное для выполнения итп. */
  homeworkTasksAdditionalInfo?: Maybe<HomeworkTasksAdditionalInfo>;
  /** Идентификатор плана урока, к которому привязана домашняя работа */
  lessonPlanId?: Maybe<Scalars['ID']['output']>;
  /** Текстовая заметка к Домашней Работе */
  note?: Maybe<Scalars['String']['output']>;
  /** Статус завершенности Домашней Работы (сейчас вычисляется на лету) */
  status: HomeworkCalculatedStatus;
  /** Предмет */
  subject: Subject;
};

/** Домашняя работа */
export type HomeworkInput = {
  /** Дата и время дедлайна домашней работы */
  deadlineTs: Scalars['DateTime']['input'];
  /** Идентификатор домашней работы */
  homeworkId?: InputMaybe<Scalars['ID']['input']>;
  /** Задания с идентификатором элемента цели в рамках которого они были добавлены к домашней работе */
  homeworkTasks: Array<HomeworkTaskWithGoalElementIdInput>;
  /** Текстовая заметка к домашней работе */
  note?: InputMaybe<Scalars['String']['input']>;
  /** Идентификатор группы в контексте параллели и предмета */
  stageSubjectGroupId: Scalars['ID']['input'];
};

/** Мета информация о домашней работе для страницы редактирования подборки материалов к ней */
export type HomeworkMeta = {
  __typename?: 'HomeworkMeta';
  /** Дата и время дедлайна домашней работы */
  deadlineTs: Scalars['DateTime']['output'];
  /** Название модуля */
  goalName: Scalars['String']['output'];
  /** Название класса в параллели (6 А) */
  stageGroupName: Scalars['String']['output'];
  /** Название предмета в краткой форме */
  subjectShortName: Scalars['String']['output'];
  /** Идентификатор учителя группы-по-предмету к которой относится данная домашняя работа */
  teacherId: Scalars['UUID']['output'];
};

/** Информация о Задании Ученика, в рамках Домашней Работы */
export type HomeworkStudentTaskInfo = {
  __typename?: 'HomeworkStudentTaskInfo';
  /** Признак завершенности задания (непосредственно или через закрытый Учителем уровень модуля) */
  isFinished: Scalars['Boolean']['output'];
  /** Номер задания по порядку, в рамках Домашней Работы */
  order: Scalars['Int']['output'];
  /** Задание Ученика (может отсутствовать) */
  studentTask?: Maybe<StudentTask>;
  /** Задание (метаданные) */
  task: Task;
};

/** Задание домашней работы с элементом цели */
export type HomeworkTaskWithGoalElementId = {
  __typename?: 'HomeworkTaskWithGoalElementId';
  /** Ид элемента цели */
  goalElementId: Scalars['ID']['output'];
  /** Порядок внутри домашней работы */
  order: Scalars['Int']['output'];
  /** Ид задания */
  taskId: Scalars['ID']['output'];
};

/** Задание домашней работы с элементом цели */
export type HomeworkTaskWithGoalElementIdInput = {
  /** Ид элемента цели */
  goalElementId: Scalars['ID']['input'];
  /** Порядок внутри плана модуля */
  order: Scalars['Int']['input'];
  /** Ид задания */
  taskId: Scalars['ID']['input'];
};

/** Дополнительная информация о заданиях Домашней Работы - следующее доступное для выполнения итп. */
export type HomeworkTasksAdditionalInfo = {
  __typename?: 'HomeworkTasksAdditionalInfo';
  /** Следующее доступное для выполнения задание в рамках ДР */
  nextTaskToComplete?: Maybe<Task>;
  /** Кол-во заданий в рамках ДР, отправленных на проверку */
  tasksBeingCheckedCount: Scalars['Int']['output'];
};

export type HonorRatingMutations = {
  __typename?: 'HonorRatingMutations';
  /** Cохранить отзыв студента для "Доски почёта" */
  saveStudentHonorRatings: Array<StudentHonorRatingModel>;
};


export type HonorRatingMutationsSaveStudentHonorRatingsArgs = {
  studentHonorRatings: Array<StudentHonorRatingInput>;
};

export type HonorRatingQueries = {
  __typename?: 'HonorRatingQueries';
  /** Поиск одноклассников студента */
  getClassmates: Array<User>;
  /** Проверка, необходимо ли выводить форму запроса о героях/антигероях */
  isHonorRatingNeeded: Scalars['Boolean']['output'];
};


export type HonorRatingQueriesGetClassmatesArgs = {
  textSearch?: InputMaybe<Scalars['String']['input']>;
};

export enum HttpStatus {
  /** 403 */
  Forbidden = 'FORBIDDEN',
  /** 404 */
  NotFound = 'NOT_FOUND',
  /** 200 */
  Ok = 'OK'
}

export type IProject = {
  branch: Branch;
  branchOtherDesc?: Maybe<Scalars['String']['output']>;
  country: Country;
  customer: Customer;
  customerOtherDesc?: Maybe<Scalars['String']['output']>;
  description: Scalars['String']['output'];
  files?: Maybe<Array<Maybe<ProjectFile>>>;
  id: Scalars['UUID']['output'];
  logotypeUrl?: Maybe<Scalars['String']['output']>;
  modifiedAt: Scalars['DateTime']['output'];
  name: Scalars['String']['output'];
  parentId?: Maybe<Scalars['UUID']['output']>;
  region?: Maybe<Region>;
  shortName: Scalars['String']['output'];
  state: ProjectState;
  teamId: Scalars['UUID']['output'];
  technology: Technology;
  technologyOtherDesc?: Maybe<Scalars['String']['output']>;
};

/** Контекст входящего ответа по Заданию, с дополнительной информацией */
export type IncomingAnswerContextInput = {
  /** ID закрывающего теста, в контексте которого выполняется задание */
  goalLevelTestId?: InputMaybe<Scalars['ID']['input']>;
  /** ИД Домашней Работы, в контексте которой выполняется данное Задание */
  homeworkId?: InputMaybe<Scalars['ID']['input']>;
};

/** Показатели настройки (опыт, вес) страницы экзаменационного теста */
export type IndicatorsSettingExamTestPageModel = {
  __typename?: 'IndicatorsSettingExamTestPageModel';
  /** Опыт, начисляемый за прохождение страницы (всех виджетов на странице) */
  pageExperience: Scalars['Int']['output'];
  /** Идентификатор страницы */
  pageId: Scalars['UUID']['output'];
  /** Вес страницы */
  pageWeight: Scalars['Float']['output'];
};

export type InnopolisDigitalContent = {
  __typename?: 'InnopolisDigitalContent';
  createTs: Scalars['DateTime']['output'];
  /** Описание для подборок и заданий */
  innopolisCourseDescription?: Maybe<Scalars['String']['output']>;
  /** Название учебного материала. Для подборок, модулей и заданий */
  innopolisCourseName?: Maybe<Scalars['String']['output']>;
  /** тип материала 0 – цок, 1 – раздел, 3 – учебный материал. Иннополис поддерживает еще тип 2 - Тема, но он не используется */
  innopolisCourseTypeId?: Maybe<Scalars['Int']['output']>;
  /** Неизменяемый ID, который будет передаваться в Иннополис */
  innopolisExternalContentId: Scalars['ID']['output'];
  /** Ссылка на сущность внутри Сберкласса. */
  innopolisExternalLink?: Maybe<Scalars['String']['output']>;
  /** Массив классов, которым доступен учебный материал. (1 – 1 класс общеобразовательной школы; 2 – 2 класс общеобразовательной школы; ….; 11 – 11 класс общеобразовательной школы; 12 – 1 курс; 13 – 2 курс; 14 – 3 курс; 15 – 4 курс; 16 – 5 курс */
  innopolisGrades?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** id родительского элемента из этой таблицы. Применимо для модулей (в этом случае родитель - цок (подборка, план) и для заданий (родитель - модуль) */
  innopolisParentContentId?: Maybe<Scalars['ID']['output']>;
  /** Массив тегов для Иннополиса. содержит UUID тегов из API Иннополиса */
  innopolisTags?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** ID сущности для internalEntityType */
  sberclassEntityId?: Maybe<Scalars['String']['output']>;
  /** Внутренний тип, используемые для хранения сущности. Например, подборка из Медиатеки или План. Допстимые значения MEDIATEKA_SELECTION, GOAL, TASK */
  sberclassEntityType?: Maybe<Scalars['String']['output']>;
  updateTs: Scalars['DateTime']['output'];
};

export type InnopolisDigitalContentFilter = {
  /** Тип контента в Иннополисе.0 – цок (план, подборка), 1 – раздел(модуль), 3 – учебный материал (задание). */
  innopolisCourseTypeIds?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Внешние id, которые передаются в Иннополис */
  innopolisExternalContentIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /** ID, используются в сочетании с internalType. */
  sberclassEntityIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Внутренний тип, используемый в Сберклассе. Например, подборки (MEDIATEKA_SELECTION) или планы. */
  sberclassEntityType?: InputMaybe<Scalars['String']['input']>;
};

export type InnopolisTeacher = {
  __typename?: 'InnopolisTeacher';
  firstName: Scalars['String']['output'];
  lastName: Scalars['String']['output'];
  middleName?: Maybe<Scalars['String']['output']>;
  schoolId: Scalars['ID']['output'];
  teacherId: Scalars['ID']['output'];
};

/** S21. Информации о стажировке */
export type InternshipStudentInfo = {
  __typename?: 'InternshipStudentInfo';
  /** Дата/время окончания стажировки */
  internshipCompletionTime?: Maybe<Scalars['DateTime']['output']>;
  /** Дата/время начала стажировки */
  internshipStartTime?: Maybe<Scalars['DateTime']['output']>;
  /** Ссылка на аппликант для загрузки документов */
  link?: Maybe<Scalars['String']['output']>;
};

/** S21. Обратная связь от ментора для студента */
export type InternshipStudentReview = {
  __typename?: 'InternshipStudentReview';
  /** Комментарий к оценке наставника */
  commentMentorReview?: Maybe<Scalars['String']['output']>;
  /** Фактическая дата/время обратной связи наставника */
  factTimeMentorReview?: Maybe<Scalars['DateTime']['output']>;
  /** Оценка наставника */
  percentageMentorReview?: Maybe<Scalars['Float']['output']>;
  /** Планируемая дата/время обратной связи наставника */
  planTimeMentorReview?: Maybe<Scalars['DateTime']['output']>;
  /** Порядковый номер ревью */
  reviewOrderNumber?: Maybe<Scalars['Int']['output']>;
  /** порог прохождения */
  threshold?: Maybe<Scalars['Int']['output']>;
};

/** S21. Обратная связь от ментора разбитую по попыткам */
export type InternshipStudentReviewInfo = {
  __typename?: 'InternshipStudentReviewInfo';
  /** Список обратных связей от наставника */
  internshipStudentReviewList?: Maybe<Array<Maybe<InternshipStudentReviewList>>>;
};

/** S21. Обратная связь от ментора по попытке */
export type InternshipStudentReviewList = {
  __typename?: 'InternshipStudentReviewList';
  /** количество проверок обратной связи */
  numberReview?: Maybe<Scalars['Int']['output']>;
  /** Список обратных связей наставника */
  reviewModelList?: Maybe<Array<Maybe<InternshipStudentReview>>>;
  /** id попытки */
  studentProgressInternshipId?: Maybe<Scalars['Int']['output']>;
};

/** Статус приглашения в команду для группового задания */
export enum InvitationStatusEnum {
  /** Пользователь, доступный для приглашения в команду */
  Candidate = 'CANDIDATE',
  /** Приглашенный в команду пользователь */
  Invited = 'INVITED',
  /** Отказавшийся от приглашения пользователь */
  Refused = 'REFUSED'
}

export type InviteRequestInput = {
  inviteReasonDescription: Scalars['String']['input'];
  inviteUserId: Scalars['UUID']['input'];
  vacancyId: Scalars['UUID']['input'];
};

export type InviteRequestModel = {
  __typename?: 'InviteRequestModel';
  captain?: Maybe<User>;
  inviteDate: Scalars['Date']['output'];
  inviteId?: Maybe<Scalars['UUID']['output']>;
  inviteReasonDescription: Scalars['String']['output'];
  inviteStatus: Scalars['String']['output'];
  resume?: Maybe<ResumeModel>;
  vacancyId: Scalars['UUID']['output'];
  vacancyName: Scalars['String']['output'];
};

export type IsSelfAssessmentTestComplete = {
  __typename?: 'IsSelfAssessmentTestComplete';
  finishDate: Scalars['DateTime']['output'];
  isComplete: Scalars['Boolean']['output'];
  startDate: Scalars['DateTime']['output'];
  testId: Scalars['ID']['output'];
};

export type IssuedCertificateModel = {
  __typename?: 'IssuedCertificateModel';
  /**
   * ID шаблона сертификата
   * @deprecated Под удаление.
   */
  certificateId: Scalars['ID']['output'];
  certificateInfo: CertificateOfParticipation;
  /** Плановая дата начала траектории */
  dateEnd: Scalars['Date']['output'];
  /** Плановая дата окнчания траектории */
  dateStart: Scalars['Date']['output'];
  /** ID записи */
  issuedId: Scalars['ID']['output'];
  /** Дата выдачи */
  issuedTs?: Maybe<Scalars['Date']['output']>;
  /** Студент */
  student: Student;
};

/** Сертификат в формате pdf */
export type IssuedCertificatePdf = {
  __typename?: 'IssuedCertificatePdf';
  /** Файл в base64 */
  base64Data: Scalars['String']['output'];
  /** Имя файла */
  fileName: Scalars['String']['output'];
};

/** Результат переключения статуса избранного для материала */
export type ItemBatchResult = {
  __typename?: 'ItemBatchResult';
  /** статус нахождения в избранном */
  errors: Array<ItemFailure>;
  /** целевой идентификатор каталога */
  processed?: Maybe<Array<Scalars['UUID']['output']>>;
};

/** Результат переключения статуса избранного для материала */
export type ItemBookmarkStatus = {
  __typename?: 'ItemBookmarkStatus';
  /** целевой идентификатор каталога */
  itemId: Scalars['UUID']['output'];
  /** актуальная статистика с учетом текущего статуса */
  meta: BookmarkStatistics;
  /** статус нахождения в избранном */
  status: Scalars['Boolean']['output'];
};

/** Категория элементов каталога */
export type ItemCategory = {
  __typename?: 'ItemCategory';
  /**
   * @deprecated Переход от AdditionalContentStage к идентификаторам параллелей из Stage.
   * Использовать categoryItemsV2, будет удалено после 01.09.2021
   */
  categoryItems: CategoryItemPage;
  categoryItemsV2: CategoryItemPage;
  /** Уникальный статический ключ категории */
  categoryKey: Scalars['String']['output'];
  /** Название категории (читаемое) */
  categoryName: Scalars['String']['output'];
  /** Список дочерних категорий */
  childCategories: Array<ItemCategory>;
  /** ID */
  itemCategoryId: Scalars['ID']['output'];
};


/** Категория элементов каталога */
export type ItemCategoryCategoryItemsArgs = {
  contentFormat?: InputMaybe<AdditionalContentFormat>;
  contentTypes: Array<MediatekaContentType>;
  endDate?: InputMaybe<Scalars['Date']['input']>;
  isEducationalMaterial?: InputMaybe<Scalars['Boolean']['input']>;
  page: PagingInput;
  regionIds: Array<Scalars['UUID']['input']>;
  stages: Array<AdditionalContentStage>;
  startDate?: InputMaybe<Scalars['Date']['input']>;
  subjectIds: Array<Scalars['ID']['input']>;
};


/** Категория элементов каталога */
export type ItemCategoryCategoryItemsV2Args = {
  filter?: InputMaybe<MediatekaItemsFilter>;
  page: PagingInput;
};


/** Категория элементов каталога */
export type ItemCategoryChildCategoriesArgs = {
  childCategoryId?: InputMaybe<Scalars['ID']['input']>;
};

/** Результат переключения статуса избранного для материала */
export type ItemFailure = {
  __typename?: 'ItemFailure';
  /** статус нахождения в избранном */
  errorMessage: Scalars['String']['output'];
  /** целевой идентификатор каталога */
  itemId: Scalars['UUID']['output'];
};

/** Флаги управления элементами каталога в рамках медиатеки (комбинация прав доступа и фича-флагов) */
export type ItemManagementProperties = {
  __typename?: 'ItemManagementProperties';
  /** Доступность архивации элемента (мутация archiveItem) */
  archiveItem: Scalars['Boolean']['output'];
  /** Доступность создания элемента (мутация createItem) */
  createItem: Scalars['Boolean']['output'];
  /** Доступность публикации эламента (мутация publishItem) */
  publishItem: Scalars['Boolean']['output'];
  /** Доступность разархивации элемента (мутация unarchiveItem) */
  unarchiveItem: Scalars['Boolean']['output'];
  /** Доступность обновления категорий элемента (мутация updateItem, свойство categoryIds) */
  updateCategories: Scalars['Boolean']['output'];
  /** Доступность обновления элемента (мутация updateItem) */
  updateItem: Scalars['Boolean']['output'];
};

/** Страница с результатами поиска материалов */
export type ItemPageModel = {
  __typename?: 'ItemPageModel';
  /** Найденные элементы */
  content: Array<ContentItem>;
  /** Номер запрошенной страницы (начиная с 0) */
  pageNumber: Scalars['Int']['output'];
  /** Размер запрошенной страницы */
  pageSize: Scalars['Int']['output'];
  /**
   * Общее число элементов, совпавших с фильтром
   * @deprecated Переход от Page к Slice
   */
  totalItems: Scalars['Int']['output'];
};

export type JoinTeamRequest = {
  __typename?: 'JoinTeamRequest';
  createdTs: Scalars['DateTime']['output'];
  declineReason?: Maybe<DeclineReason>;
  declineReasonDescription?: Maybe<Scalars['String']['output']>;
  id: Scalars['UUID']['output'];
  inviteDate?: Maybe<Scalars['Date']['output']>;
  inviteId?: Maybe<Scalars['UUID']['output']>;
  lastModifiedTs: Scalars['DateTime']['output'];
  project?: Maybe<Project>;
  read: Scalars['Boolean']['output'];
  requestReason?: Maybe<Scalars['String']['output']>;
  resume?: Maybe<ResumeModel>;
  state: RequestState;
  teamId: Scalars['UUID']['output'];
  user?: Maybe<User>;
  vacancy?: Maybe<ProjectRole>;
};

export type JoinTeamRequestAdd = {
  __typename?: 'JoinTeamRequestAdd';
  currentUser?: Maybe<User>;
  inviteDate?: Maybe<Scalars['Date']['output']>;
  inviteId?: Maybe<Scalars['UUID']['output']>;
  joinTeamRequest?: Maybe<JoinTeamRequest>;
  resume?: Maybe<ResumeModel>;
};

export type JournalCell = {
  __typename?: 'JournalCell';
  /** Комментарий учителя к уроку для ученика */
  journalStudentComment?: Maybe<JournalStudentComment>;
  marks: Array<JournalCellMark>;
  visitJournalCellComment?: Maybe<Scalars['String']['output']>;
  visitJournalCellId?: Maybe<Scalars['UUID']['output']>;
  visitJournalCellValue?: Maybe<VisitJournalCellValueEnum>;
  wasInGroup?: Maybe<Scalars['Boolean']['output']>;
};

export type JournalCellMark = {
  __typename?: 'JournalCellMark';
  comment?: Maybe<Scalars['String']['output']>;
  initialWeight: Scalars['Float']['output'];
  learningActivityId: Scalars['ID']['output'];
  lessonLearningActivityId: Scalars['ID']['output'];
  markId?: Maybe<Scalars['ID']['output']>;
  needMark?: Maybe<Scalars['Boolean']['output']>;
  position: Scalars['Int']['output'];
  studentJournalMarkId: Scalars['ID']['output'];
};

export type JournalCellsMap = {
  __typename?: 'JournalCellsMap';
  key: Scalars['String']['output'];
  value?: Maybe<JournalCell>;
};

/** Итоговые оценки для электронного журнала */
export type JournalFinalStudentMark = {
  __typename?: 'JournalFinalStudentMark';
  /** Ид учебного года */
  academicYearId: Scalars['ID']['output'];
  /** средняя оценка */
  averageMark?: Maybe<Scalars['String']['output']>;
  /** комментарий к итоговой оценке */
  comment?: Maybe<Scalars['String']['output']>;
  /** идентификатор итоговой оценки */
  id: Scalars['ID']['output'];
  /** ИД оценки */
  markId?: Maybe<Scalars['ID']['output']>;
  /** Ид группы по предмету */
  stageSubjectGroupId: Scalars['ID']['output'];
  /** идентификатор студента */
  studentId: Scalars['UUID']['output'];
  /** Ид учебного периода(четверть) */
  studyPeriodId?: Maybe<Scalars['ID']['output']>;
  /** средневзвешенная оценка за учебный период */
  weightedAverageMark?: Maybe<Scalars['String']['output']>;
};

/** Итоговые оценки по изучаемому предмету */
export type JournalFinalStudentMarkByStageSubject = {
  __typename?: 'JournalFinalStudentMarkByStageSubject';
  marks?: Maybe<Array<Maybe<JournalFinalStudentMark>>>;
  studentStageSubject?: Maybe<StudentStageSubject>;
};

/** Тип отчета для электронного журнала */
export enum JournalReportTypeEnum {
  /** посещаемость */
  Attendance = 'ATTENDANCE',
  /** успеваемость */
  Performance = 'PERFORMANCE'
}

/** Тип для комментария учителя к уроку для ученика */
export type JournalStudentComment = {
  __typename?: 'JournalStudentComment';
  /** Комментарий учителя к уроку для ученика */
  comment: Scalars['String']['output'];
  /** Учитель создавший комментарий */
  createTeacherId: Scalars['UUID']['output'];
  /** Дата создания комментария */
  createTime: Scalars['DateTime']['output'];
  /** Идентификатор комментария учителя к уроку для ученика */
  id: Scalars['ID']['output'];
  /** Идентификатор урока */
  lessonId: Scalars['ID']['output'];
  /** Идентификатор ученика */
  studentId: Scalars['UUID']['output'];
  /** Учитель последний раз изменивший комментарий */
  updateTeacherId?: Maybe<Scalars['UUID']['output']>;
  /** Дата последнего изменения комментария */
  updateTime?: Maybe<Scalars['DateTime']['output']>;
};

export type JournalStudentMark = {
  __typename?: 'JournalStudentMark';
  comment?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  lessonLearningActivityId: Scalars['String']['output'];
  markId?: Maybe<Scalars['String']['output']>;
  markTeacher?: Maybe<User>;
  markTeacherId: Scalars['ID']['output'];
  needMark?: Maybe<Scalars['Boolean']['output']>;
  studentId: Scalars['String']['output'];
};

export type KandinskyQueries = {
  __typename?: 'KandinskyQueries';
  /** возвращает id запроса для получения результата */
  checkGenerationStatus: KandinskyResponse;
  generateImage: Scalars['String']['output'];
};


export type KandinskyQueriesCheckGenerationStatusArgs = {
  requestId: Scalars['String']['input'];
};


export type KandinskyQueriesGenerateImageArgs = {
  height: Scalars['Int']['input'];
  query: Scalars['String']['input'];
  width: Scalars['Int']['input'];
};

/** Результат генерирования картинки */
export type KandinskyResponse = {
  __typename?: 'KandinskyResponse';
  /** Сгенерированные картинки закодированные в base64 */
  images?: Maybe<Array<Scalars['String']['output']>>;
  isFinished: Scalars['Boolean']['output'];
};

/**
 * Простое отображение внутреннего идентификатора к его читаемому значению
 * Требуется для построения на фронте выпадающего списка доступных значений
 */
export type KeyValue = {
  __typename?: 'KeyValue';
  /** Ключ, например '23', '00000000-0000-0000-0001-000000001001' */
  key: Scalars['String']['output'];
  /** Значение, например "Student Experience", "Киселев В." */
  value: Scalars['String']['output'];
};

/** Справочник категории секции */
export type KindQuestion = {
  __typename?: 'KindQuestion';
  /** Содержит название категории */
  description: Scalars['String']['output'];
  /** Содержит флаг основной ли тип секции */
  isPrimary: Scalars['Boolean']['output'];
  /** Содержит вид категории */
  kindQuestionId: Scalars['ID']['output'];
};

/**
 * Шаблон лендинга
 * Simplified in EDU-69256
 */
export type LandingTemplate = {
  __typename?: 'LandingTemplate';
  id: Scalars['ID']['output'];
  title: Scalars['String']['output'];
};

/** Справочники с языками */
export enum LanguageCodeType {
  Aa = 'AA',
  Ab = 'AB',
  Ae = 'AE',
  Af = 'AF',
  Ak = 'AK',
  Am = 'AM',
  An = 'AN',
  Ar = 'AR',
  As = 'AS',
  Av = 'AV',
  Ay = 'AY',
  Az = 'AZ',
  Ba = 'BA',
  Be = 'BE',
  Bg = 'BG',
  Bi = 'BI',
  Bm = 'BM',
  Bn = 'BN',
  Bo = 'BO',
  Br = 'BR',
  Bs = 'BS',
  Ca = 'CA',
  Ce = 'CE',
  Ch = 'CH',
  Co = 'CO',
  Cr = 'CR',
  Cs = 'CS',
  Cu = 'CU',
  Cv = 'CV',
  Cy = 'CY',
  Da = 'DA',
  De = 'DE',
  Dv = 'DV',
  Dz = 'DZ',
  Ee = 'EE',
  El = 'EL',
  En = 'EN',
  Eo = 'EO',
  Es = 'ES',
  Et = 'ET',
  Eu = 'EU',
  Fa = 'FA',
  Ff = 'FF',
  Fi = 'FI',
  Fj = 'FJ',
  Fo = 'FO',
  Fr = 'FR',
  Fy = 'FY',
  Ga = 'GA',
  Gd = 'GD',
  Gl = 'GL',
  Gn = 'GN',
  Gu = 'GU',
  Gv = 'GV',
  Ha = 'HA',
  He = 'HE',
  Hi = 'HI',
  Ho = 'HO',
  Hr = 'HR',
  Ht = 'HT',
  Hu = 'HU',
  Hy = 'HY',
  Hz = 'HZ',
  Ia = 'IA',
  Id = 'ID',
  Ie = 'IE',
  Ig = 'IG',
  Ii = 'II',
  Ik = 'IK',
  Io = 'IO',
  Is = 'IS',
  It = 'IT',
  Iu = 'IU',
  Ja = 'JA',
  Jv = 'JV',
  Ka = 'KA',
  Kg = 'KG',
  Ki = 'KI',
  Kj = 'KJ',
  Kk = 'KK',
  Kl = 'KL',
  Km = 'KM',
  Kn = 'KN',
  Ko = 'KO',
  Kr = 'KR',
  Ks = 'KS',
  Ku = 'KU',
  Kv = 'KV',
  Kw = 'KW',
  Ky = 'KY',
  La = 'LA',
  Lb = 'LB',
  Lg = 'LG',
  Li = 'LI',
  Ln = 'LN',
  Lo = 'LO',
  Lt = 'LT',
  Lu = 'LU',
  Lv = 'LV',
  Mg = 'MG',
  Mh = 'MH',
  Mi = 'MI',
  Mk = 'MK',
  Ml = 'ML',
  Mn = 'MN',
  Mr = 'MR',
  Ms = 'MS',
  Mt = 'MT',
  My = 'MY',
  Na = 'NA',
  Nb = 'NB',
  Nd = 'ND',
  Ne = 'NE',
  Ng = 'NG',
  Nl = 'NL',
  Nn = 'NN',
  No = 'NO',
  Nr = 'NR',
  Nv = 'NV',
  Ny = 'NY',
  Oc = 'OC',
  Oj = 'OJ',
  Om = 'OM',
  Or = 'OR',
  Os = 'OS',
  Pa = 'PA',
  Pi = 'PI',
  Pl = 'PL',
  Ps = 'PS',
  Pt = 'PT',
  Qu = 'QU',
  Rm = 'RM',
  Rn = 'RN',
  Ro = 'RO',
  Ru = 'RU',
  Rw = 'RW',
  Sa = 'SA',
  Sc = 'SC',
  Sd = 'SD',
  Se = 'SE',
  Sg = 'SG',
  Si = 'SI',
  Sk = 'SK',
  Sl = 'SL',
  Sm = 'SM',
  Sn = 'SN',
  So = 'SO',
  Sq = 'SQ',
  Sr = 'SR',
  Ss = 'SS',
  St = 'ST',
  Su = 'SU',
  Sv = 'SV',
  Sw = 'SW',
  Ta = 'TA',
  Te = 'TE',
  Tg = 'TG',
  Th = 'TH',
  Ti = 'TI',
  Tk = 'TK',
  Tl = 'TL',
  Tn = 'TN',
  To = 'TO',
  Tr = 'TR',
  Ts = 'TS',
  Tt = 'TT',
  Tw = 'TW',
  Ty = 'TY',
  Ug = 'UG',
  Uk = 'UK',
  Ur = 'UR',
  Uz = 'UZ',
  Ve = 'VE',
  Vi = 'VI',
  Vo = 'VO',
  Wa = 'WA',
  Wo = 'WO',
  Xh = 'XH',
  Yi = 'YI',
  Yo = 'YO',
  Za = 'ZA',
  Zh = 'ZH',
  Zu = 'ZU'
}

export type LeaderBoardInfo = {
  __typename?: 'LeaderBoardInfo';
  /** Признак вкл/выкл */
  active: Scalars['Boolean']['output'];
  /** Название борда */
  boardName: Scalars['String']['output'];
  /** Время создания */
  createTime: Scalars['DateTime']['output'];
  /** Код пользователя, создавшего борд */
  createUserId: Scalars['ID']['output'];
  /** PK */
  id: Scalars['ID']['output'];
  /** список метрик, входящих в лидерборд */
  metrics: Array<Metric>;
  /** Время модификации */
  modifyTime?: Maybe<Scalars['DateTime']['output']>;
  /** Код пользователя, внесшего последние правки */
  modifyUserId?: Maybe<Scalars['ID']['output']>;
  /** Период действия борда (дата от) */
  periodFrom: Scalars['Date']['output'];
  /** Период действия борда (дата по) */
  periodTo: Scalars['Date']['output'];
  /** Коды пользователей, по которым строится лидерборд */
  userIds: Array<Scalars['ID']['output']>;
};

export type LeaderBoardMutations = {
  __typename?: 'LeaderBoardMutations';
  /** Добавление пользователя в лидерборд */
  addUsersToLeaderBoard: Scalars['Boolean']['output'];
  /** обнулить лидерборд */
  clearLeaderBoard: Scalars['Boolean']['output'];
  /** создание нового борда */
  createLeaderBoard: LeaderBoardInfo;
  /** Исключения отдельного человека из отдельного лидерборда */
  removeUsersFromLeaderBoard: Scalars['Boolean']['output'];
  /** установить/снять флаг активности для лидерборда */
  setActiveFlagForLeaderBoard: Scalars['Boolean']['output'];
  /** переопределение списка метрик, по которым строится таблица лидеров */
  setMetricsForLeaderBoard: Scalars['Boolean']['output'];
  /** переопределение списка пользователей, по которым строится таблица лидеров */
  setUsersForLeaderBoard: Scalars['Boolean']['output'];
};


export type LeaderBoardMutationsAddUsersToLeaderBoardArgs = {
  leaderBoardId: Scalars['ID']['input'];
  userIds: Array<Scalars['UUID']['input']>;
};


export type LeaderBoardMutationsClearLeaderBoardArgs = {
  leaderBoardId: Scalars['ID']['input'];
};


export type LeaderBoardMutationsCreateLeaderBoardArgs = {
  boardName: Scalars['String']['input'];
  metrics: Array<Metric>;
  periodFrom: Scalars['Date']['input'];
  periodTo: Scalars['Date']['input'];
  userIds: Array<Scalars['UUID']['input']>;
};


export type LeaderBoardMutationsRemoveUsersFromLeaderBoardArgs = {
  leaderBoardId: Scalars['ID']['input'];
  userIds: Array<Scalars['UUID']['input']>;
};


export type LeaderBoardMutationsSetActiveFlagForLeaderBoardArgs = {
  flag: Scalars['Boolean']['input'];
  leaderBoardId: Scalars['ID']['input'];
};


export type LeaderBoardMutationsSetMetricsForLeaderBoardArgs = {
  leaderBoardId: Scalars['ID']['input'];
  metrics: Array<Metric>;
};


export type LeaderBoardMutationsSetUsersForLeaderBoardArgs = {
  leaderBoardId: Scalars['ID']['input'];
  userIds: Array<Scalars['UUID']['input']>;
};

export type LeaderBoardQueries = {
  __typename?: 'LeaderBoardQueries';
  /** Место и ряд текущего пользователя в лидерборде */
  getCurrentUserRankAndRow: UserRankAndRow;
  /** получение заполненного лидерборда (после вызова prepareLeaderBoard) */
  getFilledLeaderBoard: Array<LeaderBoardRow>;
  /** получение метаинформации по лидерборду */
  getLeaderBoardInfo: LeaderBoardInfo;
  /** получение списка лидербордов по флагу активности */
  getLeaderBoardsByFlag: Array<Scalars['ID']['output']>;
  /** получение списка лидербордов, в которые входит пользователь */
  getLeaderBoardsByUserId: Array<LeaderBoardInfo>;
  /** получение метаинформации по метрикам */
  getMetricsInfo: Array<MetricInfo>;
  /** Место и ряд пользователя в лидерборде */
  getUserRankAndRow: UserRankAndRow;
};


export type LeaderBoardQueriesGetCurrentUserRankAndRowArgs = {
  leaderBoardId: Scalars['ID']['input'];
};


export type LeaderBoardQueriesGetFilledLeaderBoardArgs = {
  leaderBoardId: Scalars['ID']['input'];
  limit: Scalars['Int']['input'];
  offset: Scalars['Int']['input'];
};


export type LeaderBoardQueriesGetLeaderBoardInfoArgs = {
  leaderBoardId: Scalars['ID']['input'];
};


export type LeaderBoardQueriesGetLeaderBoardsByFlagArgs = {
  isActive: Scalars['Boolean']['input'];
};


export type LeaderBoardQueriesGetLeaderBoardsByUserIdArgs = {
  isActive: Scalars['Boolean']['input'];
  userId: Scalars['UUID']['input'];
};


export type LeaderBoardQueriesGetMetricsInfoArgs = {
  metrics: Array<Metric>;
};


export type LeaderBoardQueriesGetUserRankAndRowArgs = {
  leaderBoardId: Scalars['ID']['input'];
  userId: Scalars['UUID']['input'];
};

/** строка таблицы лидеров */
export type LeaderBoardRow = {
  __typename?: 'LeaderBoardRow';
  /** аватар пользователя */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Максимальное место, которое занимал пользователь в этом лидерборде */
  bestRank: Scalars['Int']['output'];
  /** Дата и время самого первого раза, когда попал на максимальное место */
  bestRankDateTime: Scalars['DateTime']['output'];
  /** Текущее место */
  currentRank: Scalars['Int']['output'];
  /** Значения метрик входящих в лидерборд */
  metricValues: Array<MetricValue>;
  /** Итоговое значение баллов по всем метрикам */
  scores: Scalars['Int']['output'];
  /** программа обучения (класс/группа) */
  studyProgram: Scalars['String']['output'];
  /** имя пользователя */
  userFirstName: Scalars['String']['output'];
  /** ФИО пользователя */
  userFullName: Scalars['String']['output'];
  userId: Scalars['ID']['output'];
  /** фамилия пользователя */
  userLastName: Scalars['String']['output'];
  /** отчество пользователя */
  userSurName: Scalars['String']['output'];
};

/** Учебная активность */
export type LearningActivity = {
  __typename?: 'LearningActivity';
  /** Сокращенное название учебной активности */
  abbreviation?: Maybe<Scalars['String']['output']>;
  /** Последовательность/позиция учебных активностей в электронном журнале */
  defaultPosition?: Maybe<Scalars['Int']['output']>;
  /** Вес активности по умолчанию */
  defaultWeight: Scalars['Float']['output'];
  /** Тип формы контроля */
  formControlType: FormControlTypeEnum;
  /** Система оценивания */
  governmentMarkType: GovernmentMarkType;
  /** ID учебной активности */
  id: Scalars['ID']['output'];
  learningActivityId: Scalars['ID']['output'];
  /** Наименование учебной активности */
  name: Scalars['String']['output'];
  /** Идентификатор образовательного учреждения(школы) */
  orgUnitId: Scalars['UUID']['output'];
  /**
   * Идентификатор связанной настройки формы контроля для уровня образования и учебного предмета контекстной школы.
   * Заполняется при наличии контекста (школы, уровня образования и учебного предмета)
   */
  studyStepSubjectLearningActivityId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор "тенанта" продуктового уровня, к которому привязана учебная активность. */
  tenantId: Scalars['UUID']['output'];
  /** Вес активности */
  weight: Scalars['Float']['output'];
};

export type LearningActivityInput = {
  /** Сокращенное название учебной активности */
  abbreviation?: InputMaybe<Scalars['String']['input']>;
  /** Последовательность/позиция учебных активностей в электронном журнале */
  defaultPosition?: InputMaybe<Scalars['Int']['input']>;
  /** Тип формы контроля */
  formControlType?: InputMaybe<FormControlTypeEnum>;
  /** Система оценивания */
  governmentMarkTypeId?: InputMaybe<Scalars['ID']['input']>;
  /** ID учебной активности */
  learningActivityId: Scalars['ID']['input'];
  /** Наименование учебной активности */
  name: Scalars['String']['input'];
  /** Идентификатор образовательного учреждения(школы) */
  orgUnitId?: InputMaybe<Scalars['UUID']['input']>;
  /** Идентификатор "тенанта" продуктового уровня, к которому привязана учебная активность. */
  tenantId?: InputMaybe<Scalars['UUID']['input']>;
  /** Вес активности */
  weight: Scalars['Float']['input'];
};

/** Набор форм контроля */
export type LearningActivitySet = {
  __typename?: 'LearningActivitySet';
  /** Идентификатор набора форм контроля */
  id: Scalars['ID']['output'];
  /** Элементы набора форм контроля */
  learningActivitySetElements: Array<LearningActivitySetElement>;
  /** Наименование набора форм контроля */
  name: Scalars['String']['output'];
};

/** Элемент набора форм контроля */
export type LearningActivitySetElement = {
  __typename?: 'LearningActivitySetElement';
  /** Тип формы контроля */
  formControlType: FormControlTypeEnum;
  /** Система оценивания */
  governmentMarkType: GovernmentMarkType;
  /** Идентификатор элемента набора форм контроля */
  id: Scalars['ID']['output'];
  /** Форма контроля */
  learningActivity: LearningActivity;
  /** Вес формы контроля */
  weight: Scalars['Float']['output'];
};

/** Элемент набора форм контроля */
export type LearningActivitySetElementInput = {
  /** Тип формы контроля */
  formControlType: FormControlTypeEnum;
  /** Система оценивания */
  governmentMarkTypeId: Scalars['ID']['input'];
  /** Идентификатор элемента набора форм контроля */
  id: Scalars['ID']['input'];
  /** Форма контроля */
  learningActivity: LearningActivityInput;
  /** Вес формы контроля */
  weight: Scalars['Float']['input'];
};

/** Набор форм контроля */
export type LearningActivitySetInput = {
  /** Идентификатор набора форм контроля */
  id: Scalars['ID']['input'];
  /** Элементы набора форм контроля */
  learningActivitySetElements: Array<LearningActivitySetElementInput>;
  /** Наименование набора форм контроля */
  name: Scalars['String']['input'];
};

/** Типы групп учебных сущностей */
export enum LearningEntityGroupType {
  /** Глобальный курс */
  GlobalCourse = 'GLOBAL_COURSE',
  /** Глобальный учебный план */
  GlobalPlan = 'GLOBAL_PLAN',
  /** Локальный курс */
  LocalCourse = 'LOCAL_COURSE',
  /** Учебный план на группу по предмету (класс) */
  StageSubjectGroupPlan = 'STAGE_SUBJECT_GROUP_PLAN',
  /** Учебный план на параллель конкретной школы по конкретному предмету */
  StageSubjectPlan = 'STAGE_SUBJECT_PLAN'
}

/** Программа обучения */
export type LearningProgram = {
  __typename?: 'LearningProgram';
  /** Список администраторов программы */
  administrators: Array<User>;
  /** Дата создания программы */
  createDateTime: Scalars['DateTime']['output'];
  /** Список направлений программы */
  learningDirections: Array<LearningProgramDirection>;
  /** Идентификатор программы */
  learningProgramId: Scalars['ID']['output'];
  /** Текущий статус программы */
  learningProgramStatus: LearningProgramStatus;
  /** Дата изменения программы */
  modifyDateTime: Scalars['DateTime']['output'];
  /** Полное наименование программы */
  name: Scalars['String']['output'];
  /** Идентификатор организации-организатора программы */
  organizerSchoolId: Scalars['UUID']['output'];
  /** Информация о группе асинхронных задач публикации программы */
  publicationData?: Maybe<AsyncExecutionData>;
  /**
   * Отчет о публикации программы
   * @deprecated не используется
   */
  publicationReport: Array<Scalars['String']['output']>;
  /** Текущий статус публикации программы */
  publicationStatus: PublicationStatus;
  /** Список региональных групп проверяющих программы */
  regionVerifierGroups: Array<RegionVerifierGroup>;
  /** Короткое наименование программы */
  shortName: Scalars['String']['output'];
  /**
   * Тип программы
   * Возможны только EXTERNAL_LEARNING, COMPETITION и EXTERNAL_COMPETITION
   */
  type: LearningTypeEnum;
  /** Типы неопубликованных изменений программы */
  unpublishedChanges: Array<UnpublishedChangesType>;
  /**
   * Отчет о валидации программы
   * @deprecated не используется
   */
  validationReport: Array<Scalars['String']['output']>;
};

/** Направление программы */
export type LearningProgramDirection = {
  __typename?: 'LearningProgramDirection';
  /** Дата создания направления программы */
  createDateTime: Scalars['DateTime']['output'];
  /** Идентификатор направления обучения */
  learningProgramDirectionId: Scalars['ID']['output'];
  /** Идентификатор программы обучения, к которой относится направление */
  learningProgramId: Scalars['ID']['output'];
  /** Дата последнего изменения направления */
  modifyDateTime: Scalars['DateTime']['output'];
  /**
   * Идентификатор драфтового учебного плана направления.
   * Будет спущен на школы-участницы при следующей публикации программы или направления
   */
  patternGlobalPlanId: Scalars['ID']['output'];
  /** Информация о группе задач публикации, в которую входит задача на публикацию этого направления */
  publicationData?: Maybe<AsyncExecutionData>;
  /** Идентификатор действующего/опубликованного учебного плана направления */
  publishedGlobalPlanId: Scalars['ID']['output'];
  /** Идентификатор(номер) параллели, которой будет доступно направление обучения */
  stageId?: Maybe<Scalars['Int']['output']>;
  /** Текущий статус направления */
  status: LearningProgramDirectionStatus;
  /** Идентификатор учебного предмета направления */
  subjectId: Scalars['ID']['output'];
  /** Список ролей, которым будет обучение по направлению */
  userRoles: Array<Roles>;
};

/** Направление программы */
export type LearningProgramDirectionInput = {
  /** Идентификатор программы обучения */
  learningProgramId: Scalars['ID']['input'];
  /** Идентификатор параллели, которой будет доступно направление обучения */
  stageId: Scalars['Int']['input'];
  /** Идентификатор учебного предмета */
  subjectId: Scalars['ID']['input'];
  /** Список ролей, которым будет доступно направление обучения */
  userRoles: Array<Roles>;
};

export enum LearningProgramDirectionStatus {
  /** Изменена после публикации */
  Changed = 'CHANGED',
  /** Не опубликован */
  NotPublished = 'NOT_PUBLISHED',
  /** План отсутствует */
  NoPlan = 'NO_PLAN',
  /** Опубликовано в части школ */
  PartiallyPublished = 'PARTIALLY_PUBLISHED',
  /** Опубликован */
  Published = 'PUBLISHED'
}

export type LearningProgramDirectionViewForReport = {
  __typename?: 'LearningProgramDirectionViewForReport';
  learningProgramDirectionId: Scalars['ID']['output'];
  learningProgramId: Scalars['ID']['output'];
  learningProgramName: Scalars['String']['output'];
  subjectId: Scalars['ID']['output'];
  subjectName: Scalars['String']['output'];
};

/** Информация о программе внешнего обучения */
export type LearningProgramInfo = {
  __typename?: 'LearningProgramInfo';
  /** идентификатор проверочной корзины (пока что только для Внешнего Конкурса) */
  checkBucketId?: Maybe<Scalars['UUID']['output']>;
  /** Id программы */
  learningProgramId: Scalars['ID']['output'];
  /** Статус программы обучение */
  learningProgramStatus: LearningProgramStatus;
  /** Наименование программы */
  name: Scalars['String']['output'];
  /** Id школы-организатора */
  organizerSchoolId: Scalars['UUID']['output'];
  /** Статус публикации */
  publicationStatus: PublicationStatus;
  /** Короткое наименование программы */
  shortName: Scalars['String']['output'];
};

/** Школа в учебной програме, с дополнительной информацией */
export type LearningProgramSchool = {
  __typename?: 'LearningProgramSchool';
  /**
   * Фактическая дата, с которой программа активна в школе,
   * зафиксированная при тиражировании планов программы
   */
  actualDateEnable?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Дата, с которой программа активна в школе
   * Является точкой отсчета начала учебных планов
   */
  dateEnable?: Maybe<Scalars['DateTime']['output']>;
  /** Флаг, показывающий, назначены ли школьные проверяющие */
  isSchoolVerifier: Scalars['Boolean']['output'];
  /** Флаг, показывающий, есть ли изменения в группах "приоритетных" проверяющих */
  isVerifierChanged: Scalars['Boolean']['output'];
  /** Идентификатор программы */
  learningProgramId: Scalars['ID']['output'];
  /** Id школы как участницы программы */
  learningProgramSchoolId: Scalars['ID']['output'];
  /** Идентификатор региона школы */
  regionId: Scalars['UUID']['output'];
  /** Название региона школы */
  regionName: Scalars['String']['output'];
  /** Id школы */
  schoolId: Scalars['UUID']['output'];
  /** Идентификатор школы. Пример - "00-00055" */
  schoolIdentifier: Scalars['String']['output'];
  /** Краткое наименование школы */
  schoolName: Scalars['String']['output'];
  /** Текущий статус школы в программе */
  status: LearningProgramSchoolStatus;
};

/** Фильтр выбора школ для внешнего обучения */
export type LearningProgramSchoolInput = {
  /** Информация об идентификаторе программы */
  learningProgramId: Scalars['ID']['input'];
  /** Фильтр региона школы */
  regionName?: InputMaybe<Scalars['String']['input']>;
  /** Фильтр идентификатора школы */
  schoolIdentifier?: InputMaybe<Scalars['String']['input']>;
  /** Фильтр короткого имени школы */
  schoolShortName?: InputMaybe<Scalars['String']['input']>;
  /** Фильтр тега школы */
  schoolTag?: InputMaybe<Scalars['String']['input']>;
};

export type LearningProgramSchoolList = {
  __typename?: 'LearningProgramSchoolList';
  /** Список школ, с учетом пагинации */
  learningProgramSchools: Array<SchoolForLearningProgram>;
  /** Общее кол-во школ, пагинация не учитывается */
  schoolsCount: Scalars['Int']['output'];
};

export enum LearningProgramSchoolStatus {
  /** Добавлена */
  Added = 'ADDED',
  /** Отключена */
  Disabled = 'DISABLED',
  /** Подключена */
  Enabled = 'ENABLED'
}

/** Модель для страницы со списком школ */
export type LearningProgramSchoolsPage = {
  __typename?: 'LearningProgramSchoolsPage';
  /** Количество школ добавляемых в программу */
  addedSchoolsCount: Scalars['Int']['output'];
  /** Количество школ исключаемых из программы */
  disabledSchoolsCount: Scalars['Int']['output'];
  /** Количество школ включенных в программу */
  enabledSchoolsCount: Scalars['Int']['output'];
  /** Список школ */
  schools: Array<LearningProgramSchool>;
};

/** Краткая информация о программе (Внешнего обучения, Конкурса, Внешнего конкурса) */
export type LearningProgramSimply = {
  __typename?: 'LearningProgramSimply';
  /** идентификатор программы */
  learningProgramId: Scalars['ID']['output'];
  /** наименование программы */
  name: Scalars['String']['output'];
  /** id школы-организатора программы */
  organizerSchoolId: Scalars['UUID']['output'];
  /** короткое наименование программы */
  shortName: Scalars['String']['output'];
  /** тип программы */
  type: LearningTypeEnum;
};

export enum LearningProgramStatus {
  /** Действует */
  Active = 'ACTIVE',
  /** Закрыта */
  Closed = 'CLOSED',
  /** Подготовка */
  Preparation = 'PREPARATION',
  /** Идет публикация */
  PublicationInProgress = 'PUBLICATION_IN_PROGRESS'
}

export enum LearningStatusEnum {
  /** Обучение успешно завершено */
  Completed = 'COMPLETED',
  /** Обучение завершено с ошибкой */
  CompletionFailed = 'COMPLETION_FAILED',
  /** Завершение обучения */
  CompletionInProgress = 'COMPLETION_IN_PROGRESS',
  /** Обучение начато */
  Started = 'STARTED'
}

export enum LearningTypeEnum {
  /** Основное обучение */
  BaseLearning = 'BASE_LEARNING',
  /** Конкурс */
  Competition = 'COMPETITION',
  /** Внешний конкурс */
  ExternalCompetition = 'EXTERNAL_COMPETITION',
  /** Внешнее обучение */
  ExternalLearning = 'EXTERNAL_LEARNING',
  /** Внутреннее обучение */
  InternalLearning = 'INTERNAL_LEARNING',
  /** Эталон */
  LearningModel = 'LEARNING_MODEL'
}

/** Урок для Учителя и БА */
export type Lesson = {
  __typename?: 'Lesson';
  /** Идентификатор здания */
  buildingId?: Maybe<Scalars['ID']['output']>;
  /** Группа по предмету, для которого проводится Урок */
  classSubject: ClassSubject;
  /** Идентификатор классной комнаты */
  classroomId?: Maybe<Scalars['ID']['output']>;
  /** Дата и время проведения Урока */
  date: Scalars['DateTime']['output'];
  /**
   * Крайний срок достижении цели
   * @deprecated Field no longer supported
   */
  goalEndDate: Scalars['DateTime']['output'];
  /**
   * Название цели
   * @deprecated Field no longer supported
   */
  goalName: Scalars['String']['output'];
  /** Есть ли хотя бы одна активная оценка по уроку */
  hasLessonLearningActivities: Scalars['Boolean']['output'];
  /** Есть ли план урока */
  hasLessonPlans: Scalars['Boolean']['output'];
  /** Есть ли отметки о посещаемости по уроку */
  hasVisitJournalCells: Scalars['Boolean']['output'];
  /** Идентификатор (timetables.timetable_id) */
  id: Scalars['ID']['output'];
  /** Идентификатор урока */
  lessonId: Scalars['ID']['output'];
  /** @deprecated Field no longer supported */
  methodics: Array<File>;
  /** заметка к плану урока */
  noteToLessonPlan?: Maybe<LessonNoteToLessonPlan>;
  /** онлайн-урок к плану урока */
  onlineLessonToLessonPlan?: Maybe<OnlineLessonToLessonPlan>;
  /** Дата окончания повторения (для цепочки уроков) */
  repeatEndDate?: Maybe<Scalars['Date']['output']>;
  /** Дата начала повторения (для цепочки уроков) */
  repeatStartDate?: Maybe<Scalars['Date']['output']>;
  /** Группа классов параллели */
  stageGroupId: Scalars['ID']['output'];
  /** Идентификатор интервала времени, в который проводится урок */
  timeslotId: Scalars['ID']['output'];
  /** Тема к плану урока */
  topicToLessonPlan?: Maybe<LessonTopicToLessonPlan>;
};

/** Драфт урока */
export type LessonDraft = {
  /** Идентификатор кабинета */
  classroomId: Scalars['ID']['input'];
  /** Порядковый день недели */
  dayOrderNumber: Scalars['Int']['input'];
  /** Null в случае нового урока */
  lessonDraftId?: InputMaybe<Scalars['ID']['input']>;
  /** Номер урока */
  lessonNumber: Scalars['Int']['input'];
  /**
   * Идентификатор класса
   * deprecated(reason: "Filled in StageGroupTimetableDraftInput")
   */
  stageGroupId?: InputMaybe<Scalars['ID']['input']>;
  /** Идентификтор ГКпП */
  stageSubjectGroupId: Scalars['ID']['input'];
  /** Идентификатор предмета */
  subjectId: Scalars['ID']['input'];
  /** Идентификатор учителя */
  teacherId: Scalars['UUID']['input'];
};

/** Драфт урока по ГКпП */
export type LessonDraftV2 = {
  __typename?: 'LessonDraftV2';
  /** Идентификатор здания */
  buildingId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор кабинета */
  classroomId?: Maybe<Scalars['ID']['output']>;
  /** Наименование кабинета */
  classroomName?: Maybe<Scalars['String']['output']>;
  /** Номер дня */
  dayNumber?: Maybe<Scalars['Int']['output']>;
  /** Является ли группа межклассовой */
  isStageGroupIsIntergroup: Scalars['Boolean']['output'];
  /** Идентификатор драфта урока */
  lessonDraftId: Scalars['ID']['output'];
  /** Время окончания урока */
  lessonEndTime?: Maybe<Scalars['Time']['output']>;
  /** Номер урока */
  lessonNumber?: Maybe<Scalars['Int']['output']>;
  /** Время начала урока */
  lessonStartTime?: Maybe<Scalars['Time']['output']>;
  /** Идентификатор интервала времени, в который проводится урок */
  lessonTimeslotId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор класса */
  stageGroupId: Scalars['ID']['output'];
  /** Наименование класса */
  stageGroupName: Scalars['String']['output'];
  /** Идентификатор параллели, к которой относится группа */
  stageId: Scalars['ID']['output'];
  /** Идентификатор ГКпП */
  stageSubjectGroupId: Scalars['ID']['output'];
  /** Наименование ГКпП */
  stageSubjectGroupName: Scalars['String']['output'];
  /** Идентификатор предмета */
  subjectId: Scalars['ID']['output'];
  /** Наименование предмета */
  subjectName: Scalars['String']['output'];
  /** Идентификатор учителя и его идентификатор пользователя */
  teacher: TeacherUserInfo;
};

export enum LessonDraftVersion {
  Draft = 'DRAFT',
  Original = 'ORIGINAL',
  Saved = 'SAVED'
}

/** Драфт расписания по классам */
export type LessonDraftsByStageGroup = {
  __typename?: 'LessonDraftsByStageGroup';
  /** Сортированный список уроков: номер урока - день - предмет */
  lessonDrafts: Array<LessonDraftV2>;
  /** класс */
  stageGroup: StageGroupCommonInfo;
};

/** Карточки уроков, группированные по предмету */
export type LessonDraftsBySubject = {
  __typename?: 'LessonDraftsBySubject';
  /** Карточки уроков, группированные по классу */
  lessonDraftsByStageGroups: Array<LessonDraftsByStageGroup>;
  subject: SubjectCommonInfo;
};

/** Карточки уроков, группированные по учителю */
export type LessonDraftsByTeacher = {
  __typename?: 'LessonDraftsByTeacher';
  /** Карточки уроков, группированные по предмету */
  lessonDraftsBySubjects: Array<LessonDraftsBySubject>;
  /** Учитель */
  teacher: TeacherUserInfo;
};

/** Для редактирования урока */
export type LessonInput = {
  /** Идентификатор классной комнаты */
  classRoomId?: InputMaybe<Scalars['ID']['input']>;
  /** Дата проведения урока */
  date: Scalars['DateTime']['input'];
  /** Идентификатор урока */
  lessonId?: InputMaybe<Scalars['ID']['input']>;
  /** Идентификатор интервала времени, в который проводится урок */
  lessonTimeslotId: Scalars['ID']['input'];
  /** Идентфикатор группы класса по предмету */
  stageSubjectGroupId: Scalars['ID']['input'];
  /** Идентификатор предмета */
  subjectId: Scalars['ID']['input'];
  /** Идентификатор учителя */
  teacherId: Scalars['UUID']['input'];
};

export type LessonLearningActivity = {
  __typename?: 'LessonLearningActivity';
  learningActivity: LearningActivity;
  lessonId: Scalars['ID']['output'];
  lessonLearningActivityId: Scalars['ID']['output'];
  position: Scalars['Int']['output'];
  stageSubjectGroupId: Scalars['ID']['output'];
};

export type LessonLengthType = {
  __typename?: 'LessonLengthType';
  id: Scalars['ID']['output'];
  length?: Maybe<Scalars['Int']['output']>;
  lessonLengthType: Scalars['String']['output'];
};

export type LessonMarkInputModel = {
  /** Дата и время первичного проставления оценки */
  createdTs: Scalars['DateTime']['input'];
  /** Идентификатор оценки */
  governmentMarkId: Scalars['Int']['input'];
  /** Идентификатор формы контроля, за которую проставлена оценка */
  learningActivityId: Scalars['ID']['input'];
  /** Идентификатор урока */
  lessonId: Scalars['ID']['input'];
  /** Точка? Временная оценка */
  temporaryMarkDate?: InputMaybe<Scalars['Date']['input']>;
};

/** Заметка с данными урока */
export type LessonNoteExtended = {
  __typename?: 'LessonNoteExtended';
  /** Уникальный идентификатор заметки. Например, LessonNote#getLessonNoteId */
  id: Scalars['ID']['output'];
  /** Дата окончания урока */
  lessonEndDate: Scalars['DateTime']['output'];
  /** Номер урока */
  lessonNumber: Scalars['Int']['output'];
  /** Дата начала урока */
  lessonStartDate: Scalars['DateTime']['output'];
  /** Форматированный текст заметки урока, например "[название предмета]: [тект заметки]" */
  text: Scalars['String']['output'];
};

/** Заметка к плану урока */
export type LessonNoteToLessonPlan = {
  __typename?: 'LessonNoteToLessonPlan';
  /** Идентифкатор Заметки (lesson_notes.lesson_note_id) */
  id: Scalars['ID']['output'];
  /** Идентификатор плана урока */
  lessonPlanId: Scalars['ID']['output'];
  /** Текст Заметки (lesson_notes.note) */
  text: Scalars['String']['output'];
};

export type LessonNoteToLessonPlanInput = {
  lessonNoteId?: InputMaybe<Scalars['ID']['input']>;
  lessonPlanId?: InputMaybe<Scalars['ID']['input']>;
  text: Scalars['String']['input'];
};

/** План урока */
export type LessonPlan = {
  __typename?: 'LessonPlan';
  /** идентификатор Группы по Предмету (stage_subject_groups.stage_subject_group_id) */
  classSubjectId: Scalars['ID']['output'];
  /** У модуля поменяли даты и план теперь в него не входит */
  datesNotInModule: Scalars['Boolean']['output'];
  /** Ид модуля */
  goalId: Scalars['ID']['output'];
  /** Домашняя работа */
  homework?: Maybe<Homework>;
  /** Урок закончен */
  isFinished: Scalars['Boolean']['output'];
  /** Урок связанный с данным планом был удален */
  isInvalidated: Scalars['Boolean']['output'];
  /** Ид урока */
  lessonId?: Maybe<Scalars['ID']['output']>;
  /** заметка к плану урока */
  lessonNoteToLessonPlan?: Maybe<LessonNoteToLessonPlan>;
  /** Ид плана урока */
  lessonPlanId: Scalars['ID']['output'];
  /** Список заданий с элементами цели */
  lessonPlanTasks?: Maybe<Array<LessonPlanTaskWithGoalElementId>>;
  /** Ид таймслота урока */
  lessonTimeslotId?: Maybe<Scalars['ID']['output']>;
  /** Тема к плану урока */
  lessonTopicToLessonPlan?: Maybe<LessonTopicToLessonPlan>;
  /** онлайн-урок к плану урока */
  onlineLessonToLessonPlan?: Maybe<OnlineLessonToLessonPlan>;
  /** Подборки материалов к уроку */
  selections: Array<Selection>;
};

/** Модель ошибок плана урока */
export type LessonPlanError = {
  __typename?: 'LessonPlanError';
  /** Текстовый код ошибки */
  errorCode: LessonPlanErrorCode;
  /** Текст сообщения */
  errorMessage: Scalars['String']['output'];
};

/** Текстовый код ошибки учебного плана */
export enum LessonPlanErrorCode {
  /** Даты модуля изменены */
  GoalDatesChanged = 'GOAL_DATES_CHANGED',
  /** Модуль удален */
  GoalDeleted = 'GOAL_DELETED',
  /** Урок удален */
  LessonDeleted = 'LESSON_DELETED',
  /** Материал удален */
  MaterialDeleted = 'MATERIAL_DELETED',
  /** Любая другая ошибка, когда в ответе нужен только текст */
  Other = 'OTHER',
  /** Группа по предмету удалена */
  SsgDeleted = 'SSG_DELETED',
  /** Задание удалено */
  TaskDeleted = 'TASK_DELETED'
}

export type LessonPlanInput = {
  /** идентификатор Группы по Предмету (stage_subject_groups.stage_subject_group_id) */
  classSubjectId: Scalars['ID']['input'];
  /** Ид модуля */
  goalId: Scalars['ID']['input'];
  /** Домашняя работа */
  homework?: InputMaybe<HomeworkInput>;
  /** Ид урока */
  lessonId?: InputMaybe<Scalars['ID']['input']>;
  /** Заметка к плану урока */
  lessonNote?: InputMaybe<LessonNoteToLessonPlanInput>;
  /** Ид плана урока */
  lessonPlanId?: InputMaybe<Scalars['ID']['input']>;
  /** Список заданий с элементами цели */
  lessonPlanTasks?: InputMaybe<Array<LessonPlanTaskWithGoalElementIdInput>>;
  /** Ид таймслота урока */
  lessonTimeslotId?: InputMaybe<Scalars['ID']['input']>;
  /** Тема к плану урока */
  lessonTopic?: InputMaybe<LessonTopicToLessonPlanInput>;
  /** Ссылка на онлайн-урок */
  onlineLesson?: InputMaybe<OnlineLessonToLessonPlanInput>;
};

/** Блок материала плана урока */
export type LessonPlanMaterial = {
  __typename?: 'LessonPlanMaterial';
  /** Идентификатор item-а каталога */
  catalogItemId?: Maybe<Scalars['UUID']['output']>;
  /** Имя контента */
  contentName?: Maybe<Scalars['String']['output']>;
  /** Тип контента */
  contentType?: Maybe<AdditionalContentType>;
  /** Признак материала для домашней работы */
  isHomeWork: Scalars['Boolean']['output'];
  /** Признак того, что материал удален */
  isMaterialDeleted: Scalars['Boolean']['output'];
  /** Идентификатор урока */
  lessonId?: Maybe<Scalars['ID']['output']>;
  /**
   * Идентификатор плана на урок, с которым связан материал
   * Фактически поле является non-nullable. Добавлено как nullable из-за ограничений расширения gql-схемы
   */
  lessonPlanId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор блока материала */
  lessonPlanMaterialId: Scalars['ID']['output'];
  /** Время начала урока */
  lessonStart?: Maybe<Scalars['DateTime']['output']>;
  /** Порядок блока */
  order: Scalars['Int']['output'];
  /** URL предпросмотра */
  previewUrl?: Maybe<Scalars['String']['output']>;
};

export type LessonPlanMaterialInput = {
  /** Идентификатор материала в сервисе каталога */
  catalogItemId: Scalars['UUID']['input'];
  /** Идентификатор урока */
  lessonId?: InputMaybe<Scalars['ID']['input']>;
  /** Идентификатор блока материала */
  lessonPlanMaterialId?: InputMaybe<Scalars['ID']['input']>;
  /** Порядок блока в плане */
  order: Scalars['Int']['input'];
};

/** Мета информация о плане к уроку для страницы редактирования подборки материалов к нему */
export type LessonPlanMeta = {
  __typename?: 'LessonPlanMeta';
  /** Название модуля */
  goalName: Scalars['String']['output'];
  /** Название класса в параллели (6 А) */
  stageGroupName: Scalars['String']['output'];
  /** Дата и время начала урока */
  start?: Maybe<Scalars['DateTime']['output']>;
  /** Название предмета в краткой форме */
  subjectShortName: Scalars['String']['output'];
  /** Идентификатор учителя группы-по-предмету к которой относится данный план к уроку */
  teacherId: Scalars['UUID']['output'];
};

/** Блок заметки плана урока */
export type LessonPlanNote = {
  __typename?: 'LessonPlanNote';
  /** Признак заметки для домашней работы (заметка для студента) */
  isHomeWork: Scalars['Boolean']['output'];
  /** Идентификатор урока */
  lessonId?: Maybe<Scalars['ID']['output']>;
  /**
   * Идентификатор плана на урок, с которым связана заметка
   * Фактически поле является non-nullable. Добавлено как nullable из-за ограничений расширения gql-схемы
   */
  lessonPlanId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор блока заметки */
  lessonPlanNoteId: Scalars['ID']['output'];
  /** Тип заметки */
  lessonPlanNoteType: LessonPlanNoteType;
  /** Время начала урока */
  lessonStart?: Maybe<Scalars['DateTime']['output']>;
  /** Текст заметки */
  note: Scalars['String']['output'];
  /** Порядок блока */
  order: Scalars['Int']['output'];
};

export type LessonPlanNoteInput = {
  /** Идентификатор урока */
  lessonId?: InputMaybe<Scalars['ID']['input']>;
  /** Идентификатор заметки плана */
  lessonPlanNoteId?: InputMaybe<Scalars['ID']['input']>;
  /** Тип заметки */
  lessonPlanNoteType: LessonPlanNoteType;
  /** Текст заметки */
  note: Scalars['String']['input'];
  /** Порядок блока в плане */
  order: Scalars['Int']['input'];
};

/** Тип заметки для плана урока */
export enum LessonPlanNoteType {
  /** Заметка учителя */
  PersonalNote = 'PERSONAL_NOTE',
  /** Заметка для студента */
  StudentNote = 'STUDENT_NOTE'
}

/** Результат публикации плана урока */
export type LessonPlanPublishingResult = {
  __typename?: 'LessonPlanPublishingResult';
  /** Признак успешной публикации */
  isSuccess: Scalars['Boolean']['output'];
  /** План урока */
  lessonPlan: LessonPlanV4;
};

/** Рекомендация к поурочному планированию */
export type LessonPlanRecommendation = {
  __typename?: 'LessonPlanRecommendation';
  id: Scalars['ID']['output'];
  /** Уроки в рекомендации */
  lessonRecommendations: Array<LessonRecommendation>;
  /** Идентификатор Учебного Модуля */
  moduleId: Scalars['ID']['output'];
};

/** Рекомендация к поурочному планированию */
export type LessonPlanRecommendationInput = {
  /** Уроки в рекомендации */
  lessonRecommendations: Array<LessonRecommendationInput>;
  /** Идентификатор Учебного Модуля */
  moduleId: Scalars['ID']['input'];
};

/** Блок задания плана урока */
export type LessonPlanTask = {
  __typename?: 'LessonPlanTask';
  /** Формат выполнения (Групповой/Индивидуальный) */
  assignmentType?: Maybe<TaskAssignmentEnum>;
  /** Типы проверки задания (Онлайн/Оффлайн) */
  checkTypes?: Maybe<Array<TaskCheckEnum>>;
  /** Идентификатор элемента цели */
  goalElementId: Scalars['ID']['output'];
  /** Идентификатор модуля */
  goalId?: Maybe<Scalars['ID']['output']>;
  /** Признак задания для домашней работы */
  isHomeWork: Scalars['Boolean']['output'];
  /** Признак того, что задание удалено */
  isTaskDeleted: Scalars['Boolean']['output'];
  /** Трудоемкость (в минутах) */
  laboriousness?: Maybe<Scalars['Int']['output']>;
  /** Идентификатор урока */
  lessonId?: Maybe<Scalars['ID']['output']>;
  /**
   * Идентификатор плана на урок, с которым связано задание
   * Фактически поле является non-nullable. Добавлено как nullable из-за ограничений расширения gql-схемы
   */
  lessonPlanId: Scalars['ID']['output'];
  /** Идентификатор блока задания */
  lessonPlanTaskId: Scalars['ID']['output'];
  /** Время начала урока */
  lessonStart?: Maybe<Scalars['DateTime']['output']>;
  /** Порядок блока */
  order: Scalars['Int']['output'];
  /** Текущий статус задания */
  status?: Maybe<TaskStatusEnum>;
  /** Дедлайн задания (для заданий по ВНЕплановым модулям дедлайном является окончание учебного года, isHardDeadline: false) */
  taskDeadline?: Maybe<TaskDeadline>;
  /** Идентификатор задания */
  taskId: Scalars['ID']['output'];
  /** Оценка по заданию */
  taskMark?: Maybe<SchoolMark>;
  /** Список комментов по заданию */
  taskMessages?: Maybe<Array<Maybe<TaskMessage>>>;
  /** Наименование */
  title?: Maybe<Scalars['String']['output']>;
  /** Тип задания */
  type?: Maybe<TaskTypeEnum>;
};

export type LessonPlanTaskInput = {
  /** Идентификатор элемента цели */
  goalElementId: Scalars['ID']['input'];
  /** Идентификатор урока */
  lessonId?: InputMaybe<Scalars['ID']['input']>;
  /** Идентификатор задания плана */
  lessonPlanTaskId?: InputMaybe<Scalars['ID']['input']>;
  /** Порядок блока в плане */
  order: Scalars['Int']['input'];
  /** Идентификатор задания */
  taskId: Scalars['ID']['input'];
};

/** Задание с элементом цели */
export type LessonPlanTaskWithGoalElementId = {
  __typename?: 'LessonPlanTaskWithGoalElementId';
  /** Ид элемента цели */
  goalElementId: Scalars['ID']['output'];
  /** Порядок внутри плана модуля */
  order?: Maybe<Scalars['Int']['output']>;
  /** Заданий в контексте студента с персональной информацией о прохождении */
  studentTask?: Maybe<StudentTask>;
  /** Ид задания */
  taskId: Scalars['ID']['output'];
};

/** Задание с элементом цели */
export type LessonPlanTaskWithGoalElementIdInput = {
  /** Ид элемента цели */
  goalElementId: Scalars['ID']['input'];
  /** Порядок внутри плана модуля */
  order?: InputMaybe<Scalars['Int']['input']>;
  /** Ид задания */
  taskId: Scalars['ID']['input'];
};

/** План урока для V4 */
export type LessonPlanV4 = {
  __typename?: 'LessonPlanV4';
  /** ФИО автора плана */
  authorName: Scalars['String']['output'];
  /** Идентификатор пользователя автора плана */
  authorUserId: Scalars['UUID']['output'];
  /** Список ошибок плана урока */
  errors: Array<LessonPlanError>;
  /** Планируемая дата достижения изучения Учебного Модуля */
  goalEndDate?: Maybe<Scalars['Date']['output']>;
  /** Идентификатор модуля */
  goalId?: Maybe<Scalars['ID']['output']>;
  /** Название модуля */
  goalName?: Maybe<Scalars['String']['output']>;
  /** Планируемая дата начала изучения Учебного Модуля */
  goalStartDate?: Maybe<Scalars['Date']['output']>;
  /** Домашнее задание к следующему уроку */
  homework?: Maybe<Scalars['String']['output']>;
  /** Признак архивного плана */
  isArchived: Scalars['Boolean']['output'];
  /** Признак опубликованного плана */
  isPublished: Scalars['Boolean']['output'];
  /** Признак расшаренного плана */
  isShared: Scalars['Boolean']['output'];
  /** Признак видео урока */
  isVideoLesson: Scalars['Boolean']['output'];
  /** Время конца урока */
  lessonEnd?: Maybe<Scalars['DateTime']['output']>;
  /** Идентификатор урока */
  lessonId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор плана урока */
  lessonPlanId: Scalars['ID']['output'];
  /** Блоки материалов */
  lessonPlanMaterials: Array<LessonPlanMaterial>;
  /** Блоки заметок */
  lessonPlanNotes: Array<LessonPlanNote>;
  /** Блоки заданий */
  lessonPlanTasks: Array<LessonPlanTask>;
  /** Время начала урока */
  lessonStart?: Maybe<Scalars['DateTime']['output']>;
  /** Тема урока */
  lessonTopic?: Maybe<Scalars['String']['output']>;
  /** Идентификатор группы по предмету */
  stageSubjectGroupId?: Maybe<Scalars['ID']['output']>;
  /** Имя группы по предмету */
  stageSubjectGroupName?: Maybe<Scalars['String']['output']>;
  /** Идентификатор предмета */
  subjectId?: Maybe<Scalars['ID']['output']>;
  /** Название предмета */
  subjectName?: Maybe<Scalars['String']['output']>;
  /** Дата изменения */
  updateTs: Scalars['DateTime']['output'];
  /** Ссылка на видео урок */
  videoLessonLink?: Maybe<Scalars['String']['output']>;
  /** Тип видеоконференции */
  videoconferenceType?: Maybe<VideoconferenceType>;
};

export type LessonPlanV4Input = {
  /** Идентификатор модуля по которому составляется план */
  goalId?: InputMaybe<Scalars['ID']['input']>;
  /** Домашнее задание к следующему уроку */
  homework?: InputMaybe<Scalars['String']['input']>;
  /** Признак видео урока */
  isVideoLesson: Scalars['Boolean']['input'];
  /** Идентификатор урока */
  lessonId?: InputMaybe<Scalars['ID']['input']>;
  /** Идентификатор плана урока */
  lessonPlanId?: InputMaybe<Scalars['ID']['input']>;
  /** Тема урока */
  lessonTopic?: InputMaybe<Scalars['String']['input']>;
  /** Блоки материалов для удаления */
  materialsToRemove?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Блоки материалов новые и измененные */
  materialsToUpdate?: InputMaybe<Array<LessonPlanMaterialInput>>;
  /** Блоки заметок для удаления */
  notesToRemove?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Блоки заметок новые и измененные */
  notesToUpdate?: InputMaybe<Array<LessonPlanNoteInput>>;
  /** Идентификатор группы по предмету */
  stageSubjectGroupId?: InputMaybe<Scalars['ID']['input']>;
  /** Идентификатор предмета */
  subjectId?: InputMaybe<Scalars['ID']['input']>;
  /** Блоки заданий для удаления */
  tasksToRemove?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Блоки заданий новые и измененные */
  tasksToUpdate?: InputMaybe<Array<LessonPlanTaskInput>>;
  /** Ссылка на видео урок */
  videoLessonLink?: InputMaybe<Scalars['String']['input']>;
  /** Тип видеоконференции */
  videoconferenceType?: InputMaybe<VideoconferenceType>;
};

/** План урока для V4 */
export type LessonPlanV4Response = {
  __typename?: 'LessonPlanV4Response';
  errorMessage?: Maybe<Scalars['String']['output']>;
  lessonPlan?: Maybe<LessonPlanV4>;
  responseStatus: HttpStatus;
};

export enum LessonProgressStatus {
  /** Ученику назначен урок */
  Assigned = 'ASSIGNED',
  /** Ученик сделал или выполнил все задания в уроке */
  Done = 'DONE'
}

/** Урок в рекомендации к поурочному планированию Учебного Модуля */
export type LessonRecommendation = {
  __typename?: 'LessonRecommendation';
  id: Scalars['ID']['output'];
  /** Порядок урока внутри рекомендации */
  lessonOrder: Scalars['Int']['output'];
  /** Задания в Уроке */
  lessonRecommendationTasks: Array<LessonRecommendationTask>;
};

/** Урок в рекомендации к поурочному планированию Учебного Модуля */
export type LessonRecommendationInput = {
  /** Порядок урока внутри рекомендации */
  lessonOrder: Scalars['Int']['input'];
  /** Задания в Уроке */
  lessonRecommendationTasks: Array<LessonRecommendationTaskInput>;
};

/** Задание в уроке в рекомендации к поурочному планированию */
export type LessonRecommendationTask = {
  __typename?: 'LessonRecommendationTask';
  id: Scalars['ID']['output'];
  /** Задания */
  task: Task;
  /** Идентифкатор задания */
  taskId: Scalars['ID']['output'];
  /** Порядок задания внутри урока */
  taskOrder: Scalars['Int']['output'];
};

/** Задание в уроке в рекомендации к поурочному планированию */
export type LessonRecommendationTaskInput = {
  /** Идентифкатор задания */
  taskId: Scalars['ID']['input'];
  /** Порядок задания внутри урока */
  taskOrder: Scalars['Int']['input'];
};

export type LessonSet = {
  __typename?: 'LessonSet';
  /** признак что урок в будущем */
  isLessonInFuture?: Maybe<Scalars['Boolean']['output']>;
  lessonDate: Scalars['DateTime']['output'];
  lessonId: Scalars['ID']['output'];
  lessonPlanId?: Maybe<Scalars['ID']['output']>;
};

export type LessonShort = {
  __typename?: 'LessonShort';
  /** Дата урока */
  date: Scalars['Date']['output'];
  /** идентификатор урока */
  id: Scalars['ID']['output'];
};

/** Тема к плану урока */
export type LessonTopicToLessonPlan = {
  __typename?: 'LessonTopicToLessonPlan';
  /** Идентифкатор темы (lesson_topic.lesson_topic_id) */
  id: Scalars['ID']['output'];
  /** Идентификатор плана урока */
  lessonPlanId: Scalars['ID']['output'];
  /** Тема (lesson_topic.topic) */
  topic: Scalars['String']['output'];
};

export type LessonTopicToLessonPlanInput = {
  lessonPlanId?: InputMaybe<Scalars['ID']['input']>;
  lessonTopicId?: InputMaybe<Scalars['ID']['input']>;
  topic: Scalars['String']['input'];
};

/**
 * В результате проверки цепочки уроков на возможность редактирования
 * некоторые уроки должны быть:
 * - удалены (сокращение периода ряда уроков/отредактированная дата урока ранее текущей даты/другой академ. год/дубли уроков)
 * - досозданы (увеличение периода ряда уроков)
 * - отредактированы
 * Этот enum содержит коды выполняемых операций над уроками.
 */
export enum LessonTransferOperationCode {
  /**
   * Создание урока(ов). В результате редактирования периода ряда уроков
   * возникла необходимость досоздать уроки до даты повторения
   */
  Create = 'CREATE',
  /**
   * В результате редактирования ряда уроков были найдены дубликаты.
   * Дубликаты уроков необходимо удалить.
   */
  DeleteDuplicates = 'DELETE_DUPLICATES',
  /**
   * В результате редактирования периода ряда уроков
   * дата урока становится ранее текущей даты. Урок необходимо удалить.
   */
  DeleteLessonsBeforeCurrentDate = 'DELETE_LESSONS_BEFORE_CURRENT_DATE',
  /**
   * В результате редактирования периода ряда уроков
   * дата урока переносится на другой академический год. Урок необходимо удалить.
   */
  DeleteLessonsInAnotherAcademicYear = 'DELETE_LESSONS_IN_ANOTHER_ACADEMIC_YEAR',
  /**
   * В результате сокращения периода ряда уроков
   * дата урока выходит за окончание даты повторения. Урок необходимо удалить.
   */
  DeleteLessonsReducedRowDateRange = 'DELETE_LESSONS_REDUCED_ROW_DATE_RANGE',
  /**
   * Обновление урока(ов). В результате редактирования цепочки уроков
   * необходимо обновить уроки
   */
  Update = 'UPDATE'
}

/** Результат проверки редактирования цепочки уроков */
export type LessonTransferValidationResult = {
  __typename?: 'LessonTransferValidationResult';
  /** Даты, для которых должны быть созданы уроки. Null если это не операция создания */
  lessonCreateOnDate?: Maybe<Array<Scalars['Date']['output']>>;
  /** Уроки, над которыми должно быть произведено действие (удаление/редактирование). Null если это операция создания */
  lessonsToModify?: Maybe<Array<Lesson>>;
  /** Код выполняемой операции над уроком */
  validationCode: LessonTransferOperationCode;
  /** Детальное сообщение о выполняемой операции над уроком */
  validationMessage: Scalars['String']['output'];
};

/** Уроки, пересекающиеся по времени,  сгруппированные по периоду */
export type LessonsByPeriod = {
  __typename?: 'LessonsByPeriod';
  lessons: Array<ExtendedLesson>;
  period: Period;
};

/** уроки и заданные для них учебные активности */
export type LessonsWithLearningActivities = {
  __typename?: 'LessonsWithLearningActivities';
  lesson: Lesson;
  lessonLearningActivities: Array<Maybe<LessonLearningActivity>>;
  lessonPlanId?: Maybe<Scalars['ID']['output']>;
};

export type LevelModule = {
  __typename?: 'LevelModule';
  /** Идентификатор уровня */
  id: Scalars['ID']['output'];
  level: Scalars['String']['output'];
  /** Статус закрытого/выполненного уровня */
  levelStatus: Scalars['Boolean']['output'];
  /** Целевой уровень выбранный студентом */
  studentTargetGoalLevel: Scalars['Boolean']['output'];
  /** Задания уровня */
  tasks: Array<TaskLevelModule>;
};

/** Успеваемость учеников по уровням системы заданий модуля */
export type LevelPerformance = {
  __typename?: 'LevelPerformance';
  /** Численное обозначение уровня учебного модуля */
  level: Scalars['Float']['output'];
  /** Идентификатор уровня */
  levelId: Scalars['ID']['output'];
  /** задания уровня */
  levelTasks: Array<LevelTask>;
  /** прогресс учеников по уровню */
  studentLevelPerformance: Array<StudentLevelPerformance>;
};

/** Задания уровня */
export type LevelTask = {
  __typename?: 'LevelTask';
  /** Информация об элементе цели к которому привязано задание в рамках системы заданий модуля */
  goalElementInfo?: Maybe<LinkedGoalElementInfo>;
  /** статусы задания */
  studentStatuses: Array<StudentTaskStatus>;
  /** Задание */
  task: Task;
};

export type License = {
  __typename?: 'License';
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

export type LineConnectorAnswerBody = {
  __typename?: 'LineConnectorAnswerBody';
  /** Ответ */
  answer: Array<LineConnectorAnswerCardPair>;
};

export type LineConnectorAnswerBodyInput = {
  answer: Array<LineConnectorAnswerCardPairInput>;
};

export type LineConnectorAnswerCardPair = {
  __typename?: 'LineConnectorAnswerCardPair';
  /** Правильно/неправильно */
  correct: Scalars['Boolean']['output'];
  /** Идентификатор карточки */
  leftCardId: Scalars['ID']['output'];
  /** Идентификатор пары */
  rightCardId: Scalars['ID']['output'];
};

export type LineConnectorAnswerCardPairInput = {
  /** Идентификатор левой карточки */
  leftCardId: Scalars['ID']['input'];
  /** Идентификатор правой карточки */
  rightCardId: Scalars['ID']['input'];
};

export type LinkModuleAndLevelInput = {
  level: Scalars['Float']['input'];
  studyModuleId: Scalars['ID']['input'];
};

export type LinkSlotInput = {
  /** флаг обязательности Заадния в Слоте */
  mandatory: Scalars['Boolean']['input'];
  /** Сквозной порядковый номер задания в модуле */
  order: Scalars['ID']['input'];
  /** идентификатор Слота, к которому будет привязываться Задание */
  slotId: Scalars['ID']['input'];
  /** Тип Набора Заданий, к которому принадлежит Слот */
  taskSetType: PlaylistType;
};

/** Информация о Элементе Цели, к которому привязано Задание */
export type LinkedGoalElementInfo = {
  __typename?: 'LinkedGoalElementInfo';
  /** Идентификатор (skill.skill_id) */
  id: Scalars['ID']['output'];
  /** Буква Элемента Цели */
  letter?: Maybe<Scalars['String']['output']>;
  /** Буква Элемента Цели */
  number?: Maybe<Scalars['String']['output']>;
  /** Описание Элемента Цели. */
  studentDescription: Scalars['String']['output'];
  /** Пример достижения Элемента Цели (Я могу...) */
  studentExample: Scalars['String']['output'];
};

/** Локальный курс */
export type LocalCourse = {
  __typename?: 'LocalCourse';
  /** Идентификатор сущности, на которую назначен курс */
  assignedEntityId?: Maybe<Scalars['String']['output']>;
  /** Название сущности, на которую назначен курс */
  assignedEntityName?: Maybe<Scalars['String']['output']>;
  /** Тип сущности, на которую назначен курс */
  assignedEntityType?: Maybe<LocalCourseAssignedEntityType>;
  /** Название курса */
  courseName?: Maybe<Scalars['String']['output']>;
  /** Тип выполнения */
  courseType?: Maybe<CourseType>;
  /** Дата/время окончания регистрации на курс */
  endRegisterDate?: Maybe<Scalars['DateTime']['output']>;
  /** Флаг, указывающий на эквивалентность правил для конструктора локального и глобального курса */
  equivalentConstructors?: Maybe<Scalars['Boolean']['output']>;
  /** Глобальный курс */
  globalCourse?: Maybe<GlobalCourse>;
  /** Признак отсутствия (игнорирования) выставленных периодов для курса */
  isDeadlineFree?: Maybe<Scalars['Boolean']['output']>;
  /** Признак, является ли курс оцениваемым */
  isGradedCourse?: Maybe<Scalars['Boolean']['output']>;
  /** Флаг, показывающий, доступен ли курс студентам для прохождения */
  isPublished?: Maybe<Scalars['Boolean']['output']>;
  /** Проекты курса */
  localCourseGoals?: Maybe<Array<LocalCourseGoal>>;
  /** Идентификатор локального курса */
  localCourseId?: Maybe<Scalars['ID']['output']>;
  /** Количество проектов */
  projectCount?: Maybe<Scalars['Int']['output']>;
  /** Идентификатор плана, к которому опционально может быть привязан курс (для обратной совместимости) */
  stageSubjectGroupPlanId?: Maybe<Scalars['ID']['output']>;
  /** Дата/время начала курса */
  startDate?: Maybe<Scalars['DateTime']['output']>;
  /** Дата/время начала регистрации на курс */
  startRegisterDate?: Maybe<Scalars['DateTime']['output']>;
};

/** Типы сущностей, на которые можно назначить курс */
export enum LocalCourseAssignedEntityType {
  /** Группа класса по предмету */
  StageSubjectGroup = 'STAGE_SUBJECT_GROUP',
  /** Группа класса по предмету в плане */
  StageSubjectGroupInPlan = 'STAGE_SUBJECT_GROUP_IN_PLAN'
}

/** Модель для получения данных по всем попыткам курса и всем гибким навыкам */
export type LocalCourseAttemptsSoftSkills = {
  __typename?: 'LocalCourseAttemptsSoftSkills';
  attempts: Array<StudentCourseAttemptInfo>;
  courseResultMeta?: Maybe<CourseResultMeta>;
  finalPercentage?: Maybe<Scalars['Int']['output']>;
  finalPoint?: Maybe<Scalars['Int']['output']>;
  studentCourseId: Scalars['ID']['output'];
};

export type LocalCourseCompareGlobalCourseResult = {
  __typename?: 'LocalCourseCompareGlobalCourseResult';
  /** локальный и глобальный курс имеют один и тот же набор конструкторов и их значения одинаковы */
  moduleConstructorEquals: Scalars['Boolean']['output'];
  /** локальный и глобальный курс имеют один и тот же набор модулей */
  moduleEquals: Scalars['Boolean']['output'];
};

/** Цели локального курса */
export type LocalCourseGoal = {
  __typename?: 'LocalCourseGoal';
  /** Тип проекта (групповой, индивидуальный) */
  assignmentType?: Maybe<TaskAssignmentEnum>;
  /** "Начало выполнения" */
  beginDate?: Maybe<Scalars['DateTime']['output']>;
  /** "Проверка" */
  checkDate?: Maybe<Scalars['DateTime']['output']>;
  /** "Дедлайн" */
  deadlineDate?: Maybe<Scalars['DateTime']['output']>;
  /** Флаг, указывающий на эквивалентность правил для конструктора в глобальном и локальном курсах */
  equivalentConstructors?: Maybe<Scalars['Boolean']['output']>;
  /** Тип выполнения */
  executionType?: Maybe<ModuleExecutionType>;
  /** Идентификатор цели */
  goalId: Scalars['ID']['output'];
  /** Название цели */
  goalName: Scalars['String']['output'];
  /** Просмотр контента */
  isContentAvailable: Scalars['Boolean']['output'];
  /** Идентификатор цели локального курса */
  localCourseGoalId?: Maybe<Scalars['ID']['output']>;
  /** Порядковый номер */
  order?: Maybe<Scalars['Int']['output']>;
  /** Какие периоды учитываются в проекте */
  periodSettings?: Maybe<PeriodSettings>;
  /** Правила подсчета даты и времени изменённого модуля/проекта */
  rules: LocalCourseRules;
  /** "Регистрация" */
  signUpDate?: Maybe<Scalars['DateTime']['output']>;
  /** Настройки команд */
  teamSettings?: Maybe<TeamSettings>;
};

/** Информация по цели локального курса в окне Projects */
export type LocalCourseGoalInformation = {
  __typename?: 'LocalCourseGoalInformation';
  /** "Начало выполнения" */
  beginDate?: Maybe<Scalars['DateTime']['output']>;
  /** "Проверка" */
  checkDate?: Maybe<Scalars['DateTime']['output']>;
  /** Максимальное количество баллов, которые мог набрать студент в курсе по указанному проекту */
  courseGoalTotalPoint?: Maybe<Scalars['Int']['output']>;
  /** "Дедлайн" */
  deadlineDate?: Maybe<Scalars['DateTime']['output']>;
  /** Описание цели */
  description: Scalars['String']['output'];
  /** Тип выполнения */
  executionType: ModuleExecutionType;
  /** Процент выполнения цели */
  finalPercentage: Scalars['Int']['output'];
  /** Очки опыта за выполнение цели */
  finalPoint: Scalars['Int']['output'];
  /** Идентификатор цели */
  goalId: Scalars['ID']['output'];
  /** Название цели */
  goalName: Scalars['String']['output'];
  /** статус проекта */
  goalStatus?: Maybe<GoalStatus>;
  /** Просмотр контента */
  isContentAvailable: Scalars['Boolean']['output'];
  /** Идентификатор цели локального курса */
  localCourseGoalId: Scalars['ID']['output'];
  /** Настройки периодов в проекте глобального курса */
  periodSettings?: Maybe<PeriodSettings>;
  /** Часы на проект */
  projectHours: Scalars['Int']['output'];
  /** Количество использованных попыток выполнения */
  retriesUsed?: Maybe<Scalars['Int']['output']>;
  /** Всего количество попыток выполнения на модуль */
  retrySettings?: Maybe<ModuleAttemptsSettings>;
  /** "Регистрация" */
  signUpDate?: Maybe<Scalars['DateTime']['output']>;
  /** Статус цели */
  status: DisplayedGoalStatus;
  /** Дата изменения статуса */
  statusUpdateDate?: Maybe<Scalars['DateTime']['output']>;
  /** Список попыток прохождения проекта */
  studentGoalAttempts?: Maybe<Array<StudentGoalAttemptShortInfo>>;
  /** ID проекта студента */
  studentGoalId: Scalars['ID']['output'];
};

export type LocalCourseGoalInput = {
  /** "Начало выполнения" */
  beginDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** "Проверка" */
  checkDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** "Дедлайн" */
  deadlineDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Идентификатор модуля */
  goalId: Scalars['ID']['input'];
  /** Идентификатор цели локального курса */
  localCourseGoalId?: InputMaybe<Scalars['ID']['input']>;
  /** Порядковый номер цели */
  order: Scalars['ID']['input'];
  /** Какие периоды учитываются в проекте */
  periodSettings?: InputMaybe<PeriodSettings>;
  /** "Регистрация" */
  signUpDate?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Информация по локальному курсу в окне Projects */
export type LocalCourseGoals = {
  __typename?: 'LocalCourseGoals';
  /** Название предмета */
  courseName: Scalars['String']['output'];
  /** Тип выполнения */
  courseType: CourseType;
  /** Вычисляемый статус курса */
  displayedCourseStatus?: Maybe<DisplayedCourseStatus>;
  /** Идентификатор глобального курса */
  globalCourseId: Scalars['ID']['output'];
  /** Цели локального курса */
  localCourseGoals?: Maybe<Array<LocalCourseGoalInformation>>;
  /** Идентификатор локального курса */
  localCourseId: Scalars['ID']['output'];
};

export type LocalCourseInput = {
  /** Идентификатор сущности, на которую назначен курс */
  assignedEntityId: Scalars['String']['input'];
  /** Тип сущности, на которую назначен курс */
  assignedEntityType: LocalCourseAssignedEntityType;
  /** Дата/время окончания регистрации на курс */
  endRegisterDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Идентификатор глобального курса */
  globalCourseId: Scalars['ID']['input'];
  /** Признак отсутствия (игнорирования) выставленных периодов для курса */
  isDeadlineFree?: InputMaybe<Scalars['Boolean']['input']>;
  /** Флаг, показывающий, доступен ли курс студентам для прохождения */
  isPublished?: InputMaybe<Scalars['Boolean']['input']>;
  /** Цели плана */
  localCourseGoals: Array<LocalCourseGoalInput>;
  /** Идентификатор локального курса */
  localCourseId?: InputMaybe<Scalars['ID']['input']>;
  /** Дата/время начала плана */
  startDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Дата/время начала регистрации на курс */
  startRegisterDate?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Правила подсчета дат для проекта */
export type LocalCourseRules = {
  __typename?: 'LocalCourseRules';
  /** Какие периоды учитываются в проекте */
  periodSettings: PeriodSettings;
  /** "Начать с ..." */
  ruleBeginFrom?: Maybe<Scalars['Int']['output']>;
  /** "Проверка" */
  ruleCheckFrom?: Maybe<Scalars['Int']['output']>;
  /** "Часы на проект" */
  ruleProjectHours?: Maybe<Scalars['Int']['output']>;
  /** "Регистрация" */
  ruleSignUpFrom?: Maybe<Scalars['Int']['output']>;
};

/** Модель для отображения процесса сохранения локального курса */
export type LocalCourseS21SavingProgress = {
  __typename?: 'LocalCourseS21SavingProgress';
  /** Является ли процесс сохранения возвращением к предыдущей версии */
  isRollback: Scalars['Boolean']['output'];
  /** Курс находится в процессе сохранения */
  isSavingInProgress: Scalars['Boolean']['output'];
  /** Всего студентов для обновления локального курса */
  studentsTotal: Scalars['Int']['output'];
  /** Кол-во студентов с ошибкой обновления */
  studentsUpdatedFail: Scalars['Int']['output'];
  /** Кол-во успешно обновленных студентов */
  studentsUpdatedSuccess: Scalars['Int']['output'];
};

/** Критерии поиска локальных курсов */
export type LocalCourseSearchCriteriaInput = {
  /** Тип сущности, на которую назначен курс */
  assignedEntityType?: InputMaybe<LocalCourseAssignedEntityType>;
  /** Название глобального курса */
  globalCourseName?: InputMaybe<Scalars['String']['input']>;
  /** Параметры пагинации */
  paging?: InputMaybe<PagingInput>;
  /** Параметры сортировки */
  sortingFields?: InputMaybe<Array<SortingField>>;
  /** Идентификатор параллели */
  stageId?: InputMaybe<Scalars['ID']['input']>;
  /** Массив идентификаторов классов, на которые назначен курс */
  stageSubjectGroupIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Результат поиска локальных курсов */
export type LocalCourseSearchResult = {
  __typename?: 'LocalCourseSearchResult';
  /** Общее количество найденных локальных курсов */
  count: Scalars['Int']['output'];
  /** Найденные локальные курсы с учетом пагинации */
  localCourses: Array<LocalCourse>;
};

/** Инфромация о локальных настройках мультикампусности, о всех параллелях и классах для текущей школы */
export type LocalMulticampusSettingAndAllStagesAndStageSubjectGroups = {
  __typename?: 'LocalMulticampusSettingAndAllStagesAndStageSubjectGroups';
  /** Настройки мультикампусности для кампуса */
  multicampusSetting: MulticampusSetting;
  /** Массив классов (групп классов по предмету) */
  stageSubjectGroups: Array<Maybe<StageSubjectGroup>>;
  /** Массив параллелей */
  stages: Array<Stage>;
};

/** Тип медиатеки с локализированым названием */
export type LocalizedTagType = {
  __typename?: 'LocalizedTagType';
  /** Локализированное название */
  localizedName: Scalars['String']['output'];
  /** Тип */
  type: MediatekaTagType;
};

/** Возможные локации команды для группового задания */
export enum LocationEnum {
  /** Параллель */
  Campus = 'CAMPUS',
  /** Глобальная */
  Global = 'GLOBAL',
  /** Класс */
  Stage = 'STAGE'
}

export type LoggingMetrics = {
  __typename?: 'LoggingMetrics';
  attendance: Scalars['String']['output'];
  coverage: Scalars['String']['output'];
  logging: Scalars['String']['output'];
  planning: Scalars['String']['output'];
};

/** Типы логических соединений */
export enum LogicalLinkTypeEnum {
  And = 'AND',
  Or = 'OR'
}

/** Результат валидации логинов пользователей */
export type LoginValidationResponse = {
  __typename?: 'LoginValidationResponse';
  /**
   * Логины которые не прошли валидацию(либо дубликаты либо не найдены)
   * Может содержать несколько одинаковых значений
   */
  errorLogins: Array<Scalars['String']['output']>;
  /** Если хотя бы один логин задублирован тут будет true */
  hasDuplicates: Scalars['Boolean']['output'];
  /** Если хотя бы один логин не был найден тут будет true */
  hasNotFound: Scalars['Boolean']['output'];
  /** Логины прошли валидацию, здесь не может быть повторяющихся значений */
  validLogins: Array<Scalars['String']['output']>;
};

/** Результат валидации логинов пользователей */
export type LoginValidationResponseV2 = {
  __typename?: 'LoginValidationResponseV2';
  /** Логины которые встречаются несколько раз,здесь могут быть повторяющихся значений */
  duplicateLogins: Array<Scalars['String']['output']>;
  /** Логины у которых нет активного турнира, здесь не может быть повторяющихся значений */
  notActiveTournamentLogins: Array<Scalars['String']['output']>;
  /** Логина которые ненайдены, здесь не может быть повторяющихся значений */
  notFoundLogins: Array<Scalars['String']['output']>;
  /** Логины которые не состоят в коалиции, здесь не может быть повторяющихся значений */
  notInCoalitionLogins: Array<Scalars['String']['output']>;
  /** Логины из других кампусов, здесь не может быть повторяющихся значений */
  otherCampusesLogins: Array<Scalars['String']['output']>;
  /** Логины прошли валидацию, здесь не может быть повторяющихся значений */
  validLogins: Array<Scalars['String']['output']>;
  /** Валидные логины для начисления коинов, здесь не может быть повторяющихся значений */
  validLoginsForCoalitionsPoints: Array<Scalars['String']['output']>;
};

export type LogoPass = {
  __typename?: 'LogoPass';
  login: Scalars['String']['output'];
  password: Scalars['String']['output'];
};

export type ManageUserGroupsInput = {
  /** Идентификаторы групп */
  groups: Array<Scalars['ID']['input']>;
  /** Множество пользователй для добавления или удаления из группы */
  users: Array<Scalars['UUID']['input']>;
};

/** Показатели для карты региона */
export type MapMetrics = {
  __typename?: 'MapMetrics';
  attendance?: Maybe<Scalars['Int']['output']>;
  diaries?: Maybe<Scalars['Int']['output']>;
  logging?: Maybe<Scalars['Int']['output']>;
  planning?: Maybe<Scalars['Int']['output']>;
};

/** Показатели по административной единице для карты региона */
export type MapMetricsByAdministrativeUnit = {
  __typename?: 'MapMetricsByAdministrativeUnit';
  administrativeUnitId: Scalars['Int']['output'];
  administrativeUnitName: Scalars['String']['output'];
  mapMetrics: MapMetrics;
};

export type MarkEntry = {
  __typename?: 'MarkEntry';
  endDate?: Maybe<Scalars['Date']['output']>;
  markValue?: Maybe<Scalars['String']['output']>;
  periodName: Scalars['String']['output'];
  startDate?: Maybe<Scalars['Date']['output']>;
};

export type MarkHistory = {
  __typename?: 'MarkHistory';
  eJournalStudentMark?: Maybe<EJournalStudentMark>;
  lesson?: Maybe<Lesson>;
};

/** Модель описывает асинхронную задачу на перевод классов в другой учебный год */
export type MassTransferTask = {
  __typename?: 'MassTransferTask';
  /** Модель асинхронной задачи */
  asyncTask: AsyncTask;
  /** Набор некритичных ошибок, возникших в процессе перевода */
  result?: Maybe<Array<Scalars['String']['output']>>;
};

/** Курса для массового назначения на класс */
export type MassiveLocalCourseAssignInput = {
  /** Дата/время окончания регистрации на курс */
  endRegisterDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Идентификатор глобального курса */
  globalCourseId: Scalars['ID']['input'];
  /** Дата/время начала плана */
  startDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Дата/время начала регистрации на курс */
  startRegisterDate?: InputMaybe<Scalars['DateTime']['input']>;
};

/** Ответ с бэка на виджет "Таблица (выбор одного)" */
export type MatrixAnswerBody = {
  __typename?: 'MatrixAnswerBody';
  /** Строка с json-структурой внутри */
  answer?: Maybe<Scalars['String']['output']>;
};

/** Отправляемый ответ на виджет "Таблица (выбор одного)" */
export type MatrixAnswerBodyInput = {
  /** Строка с json-структурой внутри */
  answer?: InputMaybe<Scalars['String']['input']>;
};

/** Ответ с бэка на виджет "Таблица (множественный выбор)" */
export type MatrixDropdownAnswerBody = {
  __typename?: 'MatrixDropdownAnswerBody';
  /** Строка с json-структурой внутри */
  answer?: Maybe<Scalars['String']['output']>;
};

/** Отправляемый ответ на виджет "Таблица (множественный выбор)" */
export type MatrixDropdownAnswerBodyInput = {
  /** Строка с json-структурой внутри */
  answer?: InputMaybe<Scalars['String']['input']>;
};

export enum MediatekaContentType {
  /** Информационный материал (учусь учиться) */
  InformationalMaterial = 'INFORMATIONAL_MATERIAL',
  /** Межпредметный материал (привязанный к нескольким предметам) */
  InterdisciplinaryMaterial = 'INTERDISCIPLINARY_MATERIAL',
  /** Подготовительный материал (для подготовки к олимпиадам) */
  PreparativeMaterial = 'PREPARATIVE_MATERIAL'
}

export type MediatekaContentTypeFilter = {
  /** Тип материала */
  contentType: AdditionalContentType;
  /** Идентификаторы подтипов материала */
  subtypeIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Теги полученные по фильтру и общее количество */
export type MediatekaFilteredTagsWithCount = {
  __typename?: 'MediatekaFilteredTagsWithCount';
  /** Коллекция тегов */
  tags: Array<MediatekaTag>;
  /** Общее количество */
  totalCount: Scalars['Int']['output'];
};

/** Сортировка айтемов */
export type MediatekaItemSorting = {
  /** Тип сортировки */
  name: MediatekaItemSortingName;
  /** Направление сортировки */
  order: MediatekaItemSortingOrder;
};

/** Типы сортировки */
export enum MediatekaItemSortingName {
  /** дата создания */
  CreateDate = 'CREATE_DATE',
  /** дата изменения */
  ModifyDate = 'MODIFY_DATE',
  /** название */
  Name = 'NAME',
  /** лучшее совпадение */
  Relevance = 'RELEVANCE'
}

/** Направление сортировки */
export enum MediatekaItemSortingOrder {
  /** по возрастанию */
  Asc = 'ASC',
  /** по убыванию */
  Desc = 'DESC'
}

/** Статус элемента */
export enum MediatekaItemStatus {
  /** черновик */
  Draft = 'DRAFT',
  /** опубликован */
  Publish = 'PUBLISH'
}

/** Параметры фильтрации элементов каталога */
export type MediatekaItemsFilter = {
  /**
   * Фильтр по признаку активности/неактивности (архивности) материала
   * Значение по умолчанию true
   */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Фильтр по формату проведения мероприятия */
  contentFormat?: InputMaybe<AdditionalContentFormat>;
  /**
   * Фильтр по типу материалов. deprecated, нужно использовать extendedContentTypeFilter.
   * При использовании значения будут конвертироваться в extendedContentTypeFilter с пустыми подтипами
   */
  contentTypes?: InputMaybe<Array<AdditionalContentType>>;
  /** Фильтр по создателям */
  creatorsIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
  /** Фильтр по верхней границе даты начала мероприятия/айтема (работает только при включенном эластике) */
  endDate?: InputMaybe<Scalars['Date']['input']>;
  /** Фильтр по подборкам которые надо исключить */
  excludeSelectionIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
  /**
   * Фильтр по типам материалов и их подтипам. Рекомендуется явно устаналивать. Если не установить явно, то будут использованы
   * типы по умолчанию: [AUDIO, VIDEO, PAPER, LINK, BOOK, COURSE, DOCUMENT, PRESENTATION, IMAGE, OLYMPIAD, CONTEST, CLUB]
   */
  extendedContentTypeFilter?: InputMaybe<Array<MediatekaContentTypeFilter>>;
  /**
   * Для поиска itemId по goalId иди taskId
   *  Для поиска goalId должен быть префикс GOAL. пример GOAL.123
   *  Для поиска taskId должен быть префикс TASK. пример TASK.456
   */
  externalContentIds?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Фильтр по мете "Добрые дела" */
  goodAffairMeta?: InputMaybe<Scalars['String']['input']>;
  /**
   * Фильтр по добавлению материала в закладки. true - материал должен быть в закладках у текущего
   * пользователя, false/null - игнорировать (работает только при включенном эластике)
   */
  isBookmarkedForCurrentUser?: InputMaybe<Scalars['Boolean']['input']>;
  /** Фильтр по учебным материалам (учебникам) */
  isEducationalMaterial?: InputMaybe<Scalars['Boolean']['input']>;
  /** Фильтр по типу материалов медиатеки */
  mediatekaContentTypes?: InputMaybe<Array<MediatekaContentType>>;
  /** Родительская категория для фильтрации (с учетом потомков) */
  parentCategoryId?: InputMaybe<Scalars['ID']['input']>;
  preparative?: InputMaybe<Scalars['Boolean']['input']>;
  /** Фильтр по статусу верификации */
  productionStatuses?: InputMaybe<Array<InputMaybe<ContentEntityProductionStatus>>>;
  /** Фильтр по регионам */
  regionIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
  /** Фильтр по подборке */
  selectionId?: InputMaybe<Scalars['UUID']['input']>;
  /** Фильтр по мягким навыкам */
  softSkillIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Сортировка айтемов */
  sorting?: InputMaybe<MediatekaItemSorting>;
  /** Фильтр по учебным параллелям (Stage) */
  stageIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Фильтр по учебным параллелям */
  stages?: InputMaybe<Array<AdditionalContentStage>>;
  /** Фильтр по нижней границе даты начала мероприятия/айтема (работает только при включенном эластике) */
  startDate?: InputMaybe<Scalars['Date']['input']>;
  /** Фильтр по статусу айтема (опубликованный или черновик), если передан пустой список, то выводятся только опубликованные */
  statuses?: InputMaybe<Array<MediatekaItemStatus>>;
  /** Фильтр по предметам */
  subjectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Выбор оператора для фильтра тегов, если true, то OR, иначе AND */
  tagFilterUnion?: InputMaybe<Scalars['Boolean']['input']>;
  /** Фильтр по тегам */
  tagIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Тип задания */
  taskTypes?: InputMaybe<Array<TaskTypeEnum>>;
  /** Полнотекстовый поиск */
  textSearch?: InputMaybe<Scalars['String']['input']>;
  visibilityScopes?: InputMaybe<Array<ScopeEnum>>;
};

/** Параметры фильтрации элементов каталога (Иннополис) */
export type MediatekaItemsInnopolisFilter = {
  /**
   * Фильтр по добавлению материала в закладки. true - материал должен быть в закладках у текущего
   * пользователя, false/null - игнорировать (работает только при включенном эластике)
   */
  isBookmarkedForCurrentUser?: InputMaybe<Scalars['Boolean']['input']>;
  /** Фильтр по материалам */
  itemIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
  /** Фильтр модулей в планах у Ученика */
  plannedModulesOnly?: InputMaybe<Scalars['Boolean']['input']>;
  /** Фильтр по подборке */
  selectionId?: InputMaybe<Scalars['UUID']['input']>;
  /** Сортировка айтемов */
  sorting?: InputMaybe<MediatekaItemSorting>;
  /** Фильтр по учебным параллелям (Stage) */
  stageIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Фильтр назначенных на класс (группу) модулей для Учителя */
  stageSubjectGroupId?: InputMaybe<Scalars['ID']['input']>;
  /** Фильтр по статусу модуля у Ученика */
  studentModuleStates?: InputMaybe<Array<StudentModuleState>>;
  /** Фильтр по предметам */
  subjectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Полнотекстовый поиск */
  textSearch?: InputMaybe<Scalars['String']['input']>;
};

/** Связанные с текущим тегом теги */
export type MediatekaLinkedTags = {
  __typename?: 'MediatekaLinkedTags';
  /** Двунаправленная связь */
  bidirectional: Array<MediatekaTag>;
  /** Дети */
  children: Array<MediatekaTag>;
  /** Родители */
  parents: Array<MediatekaTag>;
  /** Тег для которого агрерированы связи */
  tag: MediatekaTag;
};

export type MediatekaMutations = {
  __typename?: 'MediatekaMutations';
  /** добавить в избранное материал */
  addBookmark: ItemBookmarkStatus;
  /** архивация элемента каталога */
  archiveItem: Scalars['UUID']['output'];
  /** Архивация списка item'ов */
  batchArchive: ItemBatchResult;
  /** Восстановить список item'ом */
  batchUnarchive: ItemBatchResult;
  /** создает новый элемент каталога */
  createItem: ContentItem;
  /** fix catalog item's meta: create tmp table for queue */
  fixCreateTmp: FixDdlResult;
  /** fix catalog item's meta: drop tmp table for queue */
  fixDropTmp: FixDdlResult;
  /** fix catalog item's meta: run fix */
  fixMeta: FixSliceResult;
  /** публикация ранее неопубликованного (черновика) материала */
  publishItem: Scalars['UUID']['output'];
  /** убрать из избранного материал */
  removeBookmark: ItemBookmarkStatus;
  /** восстановление элемента каталога */
  unarchiveItem: Scalars['UUID']['output'];
  /**
   * обновляет существующий элемента каталога
   * @deprecated Переход от AdditionalContentStage к Stage. Использовать updateItemV2, будет удалено после 01.09.2021
   */
  updateItem: ContentItem;
  /** обновляет существующий элемента каталога */
  updateItemV2: ContentItem;
};


export type MediatekaMutationsAddBookmarkArgs = {
  itemId: Scalars['UUID']['input'];
};


export type MediatekaMutationsArchiveItemArgs = {
  catalogItemId: Scalars['UUID']['input'];
};


export type MediatekaMutationsBatchArchiveArgs = {
  itemIds: Array<Scalars['UUID']['input']>;
};


export type MediatekaMutationsBatchUnarchiveArgs = {
  itemIds: Array<Scalars['UUID']['input']>;
};


export type MediatekaMutationsCreateItemArgs = {
  itemSpec: SubjectContentInput;
  publishAfterCreate: Scalars['Boolean']['input'];
};


export type MediatekaMutationsFixMetaArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type MediatekaMutationsPublishItemArgs = {
  itemId?: InputMaybe<Scalars['UUID']['input']>;
};


export type MediatekaMutationsRemoveBookmarkArgs = {
  itemId: Scalars['UUID']['input'];
};


export type MediatekaMutationsUnarchiveItemArgs = {
  catalogItemId: Scalars['UUID']['input'];
};


export type MediatekaMutationsUpdateItemArgs = {
  itemId: Scalars['UUID']['input'];
  itemSpec: ContentItemUpdateInput;
};


export type MediatekaMutationsUpdateItemV2Args = {
  itemId: Scalars['UUID']['input'];
  itemSpec: ContentItemUpdateInputV2;
};

export type MediatekaProperties = {
  __typename?: 'MediatekaProperties';
  /** Добавление модулей/тем в план под ролью Учитель */
  addModuleToPlanEnabled: Scalars['Boolean']['output'];
  /** Доступ к дополнительным материалам */
  additionalMaterialsEnabled: Scalars['Boolean']['output'];
  /** Отображение заданий для роли Ученик */
  displayTaskEnabled: Scalars['Boolean']['output'];
  /** Включен ли режим полнотекстового поиска */
  fullTextSearchEnabled: Scalars['Boolean']['output'];
  /** доступность мутаций управления элементами каталога */
  itemManagement: ItemManagementProperties;
  /** Отображение раздела медиатеки "Учусь учиться" */
  learnLearningEnabled: Scalars['Boolean']['output'];
  /** Включен ли режим Лайт (флаг edu.service.catalog.lite.enabled) */
  liteEnabled: Scalars['Boolean']['output'];
  moduleSelections: ModuleSelectionsProperties;
  /**
   * Есть ли доступ к разделу "Моя мастерская"
   * (фича флаг включения "Моей мастерской" + включение режима ПМО в медиатеке)
   */
  myWorkroomEnabled: Scalars['Boolean']['output'];
  /** Включен ли режим ПМО (флаг edu.service.catalog.pmo.enabled) */
  pmoEnabled: Scalars['Boolean']['output'];
  /** Настройки платных материалов */
  purchase: PurchaseProperties;
  /** рекомендуемые материалы включены */
  recommendedMaterialsEnabled: Scalars['Boolean']['output'];
  selectionManagement: SelectionsManagementProperties;
  subjectChipListEnabled: Scalars['Boolean']['output'];
  /** Отображение раздела медиатеки "Учителю" */
  teacherAidsEnabled: Scalars['Boolean']['output'];
};

export type MediatekaQueries = {
  __typename?: 'MediatekaQueries';
  countItems: Scalars['Int']['output'];
  countItemsInnopolis: Scalars['Int']['output'];
  countRecommendedMaterials: Scalars['Int']['output'];
  /** catalog item's meta fix status */
  fixStatus: FixStatus;
  /** Получение доступных для создания материала уровней видимости */
  getAvailableScopesForCreating: Array<ScopeEnum>;
  /** Получение доступных для обновления материала уровней видимости */
  getAvailableScopesForUpdating: Array<ScopeEnum>;
  /** Получение содержимого книги в медиатеке (Лайт) */
  getBookContents: Array<ContentItem>;
  /** Получение списка типов книг */
  getBookTypes: Array<ContentSubtype>;
  /**
   * Получение категории, соответствующей указанному типу контента.
   * Может быть null, если не существует категории, подходящий под указанный тип
   */
  getCategoryForContentType: Array<ItemCategory>;
  /** Получение айтемов по их идентификаторам */
  getContentItemsByIds: Array<ContentItem>;
  /** Получение подборки материала */
  getContentSelection?: Maybe<ContentSelection>;
  /** Получение подборок для медиатеки */
  getContentSelectionSet: Array<ContentSelection>;
  /**
   * Получить идентификатор тенанта, в рамках которого работает текущий пользователь. Это может быть
   * его школа (для пользователей, работающих в рамках школы, вроде учителей, БА, учеников)
   * или значение заголовка tenant (если у пользователя есть соответствующая фроль)
   */
  getCurrentTenant?: Maybe<Scalars['ID']['output']>;
  /** Получение плоского списка категорий, не в виде дерева */
  getFlatItemCategories: Array<ItemCategory>;
  getInnopolisDigitalContent: Array<InnopolisDigitalContent>;
  /** Получение списка категорий элементов каталога */
  getItemCategories: Array<ItemCategory>;
  /** получить список типов тегов с локализацией типы тегов */
  getLocalizedTagTypes: Array<LocalizedTagType>;
  /** Получение списка мягких навыков */
  getMediatekaSoftSkills: Array<SoftSkill>;
  /** получить предметы для медиатеки */
  getMediatekaSubjects: Array<Subject>;
  /** получить облако тегов (с иерархией по фильтру) */
  getMediatekaTags: Array<TagHierarchyElement>;
  /** получить облако тегов */
  getMediatekaTagsWithLinks: MediatekaTagsWithLinks;
  /** Получение сводную информацию пользователя по его ибранному */
  getPersonalBookmarkStatistics: BookmarkStatistics;
  /** Получить набор прав для Медиатеки */
  getProperties: MediatekaProperties;
  /** Получение рекомендованных материалов для студента */
  getRecommendedMaterials: ItemPageModel;
  /** получить родственников для конкретного тега с фильтрацией */
  getTagRelativesWithFiltering: MediatekaLinkedTags;
  /** получить теги используя фильтр */
  getTagsByFilter: MediatekaFilteredTagsWithCount;
  /** получить родственников для конкретных тегов с фильтрацией */
  getTagsRelativesWithFiltering: Array<MediatekaLinkedTags>;
  /** Получение списка типов заданий */
  getTaskTypes: Array<TaskType>;
  getVisibilityScopes: Array<ScopeEnum>;
  /** Поиск элементов каталога по заданным фильтрам */
  searchItems: ItemPageModel;
  /** Поиск элементов каталога по заданным фильтрам */
  searchItemsInnopolis: ItemPageModel;
};


export type MediatekaQueriesCountItemsArgs = {
  filter?: InputMaybe<MediatekaItemsFilter>;
};


export type MediatekaQueriesCountItemsInnopolisArgs = {
  filter?: InputMaybe<MediatekaItemsInnopolisFilter>;
};


export type MediatekaQueriesGetBookContentsArgs = {
  itemId: Scalars['ID']['input'];
  page?: InputMaybe<PagingInput>;
};


export type MediatekaQueriesGetCategoryForContentTypeArgs = {
  contentType: AdditionalContentType;
};


export type MediatekaQueriesGetContentItemsByIdsArgs = {
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  itemIds: Array<Scalars['ID']['input']>;
};


export type MediatekaQueriesGetContentSelectionArgs = {
  selectionId: Scalars['UUID']['input'];
};


export type MediatekaQueriesGetContentSelectionSetArgs = {
  page: PagingInput;
  selectionType?: InputMaybe<SelectionType>;
};


export type MediatekaQueriesGetInnopolisDigitalContentArgs = {
  filter: InnopolisDigitalContentFilter;
};


export type MediatekaQueriesGetItemCategoriesArgs = {
  childCategoryId?: InputMaybe<Scalars['ID']['input']>;
  parentCategory?: InputMaybe<Scalars['ID']['input']>;
};


export type MediatekaQueriesGetMediatekaTagsArgs = {
  filter?: InputMaybe<FilterTags>;
};


export type MediatekaQueriesGetMediatekaTagsWithLinksArgs = {
  tenant: Scalars['UUID']['input'];
};


export type MediatekaQueriesGetRecommendedMaterialsArgs = {
  page: PagingInput;
};


export type MediatekaQueriesGetTagRelativesWithFilteringArgs = {
  filter: MediatekaTagsWithLinksFilter;
};


export type MediatekaQueriesGetTagsByFilterArgs = {
  filter: MediatekaTagsFilter;
  page: PagingInput;
};


export type MediatekaQueriesGetTagsRelativesWithFilteringArgs = {
  filter: MediatekaTagsWithLinksFilter;
};


export type MediatekaQueriesSearchItemsArgs = {
  filter?: InputMaybe<MediatekaItemsFilter>;
  page: PagingInput;
};


export type MediatekaQueriesSearchItemsInnopolisArgs = {
  filter?: InputMaybe<MediatekaItemsInnopolisFilter>;
  page: PagingInput;
};

/** Тег медиатеки */
export type MediatekaTag = {
  __typename?: 'MediatekaTag';
  /** Идентификатор */
  id: Scalars['ID']['output'];
  /** Локализированый тега */
  localizedTagType: LocalizedTagType;
  /** Текст */
  name: Scalars['String']['output'];
  /** Тенанты к которым относится тег */
  tenants: Array<Scalars['UUID']['output']>;
  /** Тип */
  type: MediatekaTagType;
};

export enum MediatekaTagLinkDirection {
  /** Двунаправленная связь */
  Bidirectional = 'BIDIRECTIONAL',
  /** Ребенок */
  Child = 'CHILD',
  /** Родитель */
  Parent = 'PARENT'
}

/** Связь между тегами в облаке */
export type MediatekaTagToTagLink = {
  __typename?: 'MediatekaTagToTagLink';
  /** Идентификатор */
  id: Scalars['ID']['output'];
  /** Тег от которого идет связь */
  tagFromId: Scalars['ID']['output'];
  /** Тег к которому идет связь */
  tagToId: Scalars['ID']['output'];
  /** Тип связи между тегами */
  type: MediatekaTagToTagLinkType;
};

/** Тип связи между тегами */
export enum MediatekaTagToTagLinkType {
  /** Иерархическая */
  Hierarchic = 'HIERARCHIC',
  /** Горизонтальная */
  SameLevel = 'SAME_LEVEL'
}

/** Тип тега в медиатеке */
export enum MediatekaTagType {
  /** Элемент */
  Element = 'ELEMENT',
  /** Секция */
  Section = 'SECTION',
  /** Группа подборок */
  SelectionGroup = 'SELECTION_GROUP',
  /** Предмет */
  Subject = 'SUBJECT',
  /** Тег старого образца */
  TagsOld = 'TAGS_OLD',
  /** Тема */
  Topic = 'TOPIC'
}

/** Фильтр тегов медиатеки */
export type MediatekaTagsFilter = {
  /** Строка поиска */
  searchString?: InputMaybe<Scalars['String']['input']>;
  /** Тенант для которого нужно искать теги */
  tenant?: InputMaybe<Scalars['UUID']['input']>;
  /** Тип искомого тега */
  types: Array<MediatekaTagType>;
};

/** Облако тегов со связями между тегами */
export type MediatekaTagsWithLinks = {
  __typename?: 'MediatekaTagsWithLinks';
  /** Связи между тегами */
  links: Array<MediatekaTagToTagLink>;
  /** Теги */
  tags: Array<MediatekaTag>;
};

/** Фильтр тегов и связей медиатеки */
export type MediatekaTagsWithLinksFilter = {
  /** Направление поиска */
  directions: Array<MediatekaTagLinkDirection>;
  /** Тип связи для которой происходит поиск */
  linkType: MediatekaTagToTagLinkType;
  /** Айди тега для поиска по тегу */
  tagId?: InputMaybe<Scalars['ID']['input']>;
  /** Айди тегов для поиска по тегам */
  tagIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Тенант для которого нужно искать теги */
  tenant?: InputMaybe<Scalars['UUID']['input']>;
};

export type MentorCheckInput = {
  orderNumber: Scalars['Int']['input'];
  percentage: Scalars['Int']['input'];
};

export type MentorFeedBacksPercentage = {
  __typename?: 'MentorFeedBacksPercentage';
  orderNumber: Scalars['Int']['output'];
  percentage: Scalars['Int']['output'];
};

export type Message = {
  __typename?: 'Message';
  /** Автор сообщения */
  author: User;
  /** Дата создания сообщения */
  creationTime: Scalars['DateTime']['output'];
  /** Идентификатор сообщения */
  id: Scalars['ID']['output'];
  /** Дата изменения сообщения */
  modifyTime: Scalars['DateTime']['output'];
  /** Сообщение текущего пользователя */
  ownMe: Scalars['Boolean']['output'];
  /** Сообщение ребенка текущего пользователя */
  ownMyChild: Scalars['Boolean']['output'];
  /** Сообщение не редактирумое */
  readOnly: Scalars['Boolean']['output'];
  /** Сообщение помечено как удаленное */
  removed: Scalars['Boolean']['output'];
  /** Текст Сообщения */
  text: Scalars['String']['output'];
};

/** Источник сообщения к Заданию */
export enum MessageSource {
  /** Сообщение создано внешней системой */
  ExternalSystem = 'EXTERNAL_SYSTEM',
  /** Сообщение создано под ролью Студента */
  Student = 'STUDENT',
  /** Сообщение создано под ролью Учителя */
  Teacher = 'TEACHER'
}

/** поддерживаемые метрики */
export enum Metric {
  /** Количество всех пройденных модулей выше целевого */
  CompletedModuleAbovePlanLevelQuantity = 'COMPLETED_MODULE_ABOVE_PLAN_LEVEL_QUANTITY',
  /** Количество всех пройденных модулей */
  CompletedModuleQuantity = 'COMPLETED_MODULE_QUANTITY',
  /** Количество выполненных заданий */
  CompletedTaskQuantity = 'COMPLETED_TASK_QUANTITY',
  /** Количество пройденных модулей выше целевого после окончания обучения */
  PostGraduateCompletedModuleAbovePlanLevelQuantity = 'POST_GRADUATE_COMPLETED_MODULE_ABOVE_PLAN_LEVEL_QUANTITY',
  /** Количество пройденных модулей после окончания обучения */
  PostGraduateCompletedModuleQuantity = 'POST_GRADUATE_COMPLETED_MODULE_QUANTITY',
  /** Количество проверенных заданий */
  ReviewedTaskQuantity = 'REVIEWED_TASK_QUANTITY'
}

/** тип сравнения значений метрик */
export enum MetricComparatorType {
  /** тип сравнения значения метрики - чем больше, тем лучше */
  GreaterIsBetter = 'GREATER_IS_BETTER',
  /** тип сравнения значения метрики - чем меньше, тем лучше */
  LowerIsBetter = 'LOWER_IS_BETTER'
}

export type MetricInfo = {
  __typename?: 'MetricInfo';
  id: Scalars['ID']['output'];
  metric: Metric;
  metricComparatorType: MetricComparatorType;
  metricDescription: Scalars['String']['output'];
};

/** значение метрики для периода и типа метрики */
export type MetricValue = {
  __typename?: 'MetricValue';
  metric: Metric;
  /** баллы */
  score: Scalars['Int']['output'];
  /** количество */
  value: Scalars['Int']['output'];
};

export type MigrationToCatalogResult = {
  __typename?: 'MigrationToCatalogResult';
  errors: Scalars['Int']['output'];
  processed: Array<Scalars['UUID']['output']>;
  total: Scalars['Int']['output'];
};

export type MigrationToCatalogResultV2 = {
  __typename?: 'MigrationToCatalogResultV2';
  errors: Scalars['Int']['output'];
  processed: Array<Scalars['ID']['output']>;
  total: Scalars['Int']['output'];
};

export type MilestoneReport = {
  __typename?: 'MilestoneReport';
  /** Время и дата ответа */
  answerDateTime?: Maybe<Scalars['DateTime']['output']>;
  /** Ссылка на ответы (список файлов) */
  answerFiles?: Maybe<Array<AnswerFile>>;
  /** Статус прохождения */
  grade?: Maybe<AcceleratorProjectGrade>;
  /** Список участников проекта */
  memberModelList?: Maybe<Array<Maybe<TeamMember>>>;
  /** Этап */
  milestone?: Maybe<Scalars['String']['output']>;
  /** Дата и время изменения */
  modifiedTs?: Maybe<Scalars['DateTime']['output']>;
  /** Идентификатор пользователя, который внес изменения */
  modifiedUserId?: Maybe<Scalars['UUID']['output']>;
  /** Данные проекта */
  project: Project;
  /** Балл */
  score?: Maybe<Scalars['Int']['output']>;
  /** Наименование ТБ */
  terbank?: Maybe<Scalars['String']['output']>;
};

export type MilestoneReportFilter = {
  /** Признак загрузки презентации */
  addFile?: InputMaybe<Scalars['Boolean']['input']>;
  /** Дата ответа */
  answerDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Дата с загрузки презентации */
  answerDateFrom?: InputMaybe<Scalars['DateTime']['input']>;
  /** Дата по загрузки презентации */
  answerDateTo?: InputMaybe<Scalars['DateTime']['input']>;
  /** Строка поиска по имени ответа */
  answerName?: InputMaybe<Scalars['String']['input']>;
  /** Статус прохождения */
  grade?: InputMaybe<AcceleratorProjectGrade>;
  /** Этап */
  milestone?: InputMaybe<Scalars['String']['input']>;
  /** Строка поиска по имени проекта */
  nameSearch?: InputMaybe<Scalars['String']['input']>;
  /** Школа */
  orgUnitId?: InputMaybe<Scalars['UUID']['input']>;
  /** Массив ID проектных потоков */
  projectFlow?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  /** Проектный поток */
  projectFlowId?: InputMaybe<Scalars['UUID']['input']>;
  /** Массив id проектов */
  projectId?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  /** Массив ID регионов проекта */
  region?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  /** Балл */
  score?: InputMaybe<Scalars['Int']['input']>;
  /** ID ТБ */
  terbank?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
};

export type MisprintExportFilterInput = {
  /** Фильтры по дате создания жалобы */
  dateFrom?: InputMaybe<Scalars['DateTime']['input']>;
  dateTo?: InputMaybe<Scalars['DateTime']['input']>;
  /** Фильтр по статусу жалоб */
  filterStatus?: InputMaybe<ComplaintAndSystemErrorStatus>;
  /** Фильтр по идентификатору модуля */
  moduleId?: InputMaybe<Scalars['ID']['input']>;
  /** Фильтр по идентификатору предмета */
  subjectId?: InputMaybe<Scalars['ID']['input']>;
  /** Фильтр по идентификатору задания */
  taskId?: InputMaybe<Scalars['ID']['input']>;
  /** Строка поиска по почте и комментарию */
  textSearch?: InputMaybe<Scalars['String']['input']>;
};

export type MisprintFilterInput = {
  /** Фильтры по дате создания жалобы */
  dateFrom?: InputMaybe<Scalars['DateTime']['input']>;
  dateTo?: InputMaybe<Scalars['DateTime']['input']>;
  /** Фильтр по статусу жалоб */
  filterStatus?: InputMaybe<ComplaintAndSystemErrorStatus>;
  /** Фильтр по идентификатору модуля */
  moduleId?: InputMaybe<Scalars['ID']['input']>;
  /** Параметры пагинации */
  paging?: InputMaybe<PagingInput>;
  /** Фильтр по идентификатору задания */
  taskId?: InputMaybe<Scalars['ID']['input']>;
  /** Строка поиска */
  textSearch?: InputMaybe<Scalars['String']['input']>;
};

/** Причина ошибки в тексте задания */
export type MisprintReason = {
  __typename?: 'MisprintReason';
  /** Идентифкатор причины */
  id: Scalars['ID']['output'];
  /** Название ошибки */
  name: Scalars['String']['output'];
};

/** Сообщение пользователя об ошибке в тексте задания */
export type MisprintReport = {
  __typename?: 'MisprintReport';
  /** Школа пользователя. */
  School?: Maybe<School>;
  /** Исправление, которое предложил пользователь. */
  correctText: Scalars['String']['output'];
  /** Дата и время сообщения об ошибке в тексте в UTC. */
  createTs: Scalars['DateTime']['output'];
  /** Комментарий исполнителя */
  executorComment?: Maybe<Scalars['String']['output']>;
  /** Идентификатор сообщения */
  id: Scalars['ID']['output'];
  /** url страницы, на которую была написана жалоба */
  pageUrl?: Maybe<Scalars['String']['output']>;
  /** Причины опечатки */
  reasonIds: Array<Scalars['ID']['output']>;
  /** путь к скриншоту в файлохранилище */
  screenshotUrl?: Maybe<Scalars['String']['output']>;
  /** Длина выделенного текста опечатки. */
  selectionLength: Scalars['Int']['output'];
  /** С какого символа начинается опечатка. */
  selectionStart: Scalars['Int']['output'];
  /** Статус жалобы */
  status: ComplaintAndSystemErrorStatus;
  /** В каком задании содержится ошибка в тексте. */
  task?: Maybe<Task>;
  /** Текст в котором содержится ошибка в тексте. */
  text: Scalars['String']['output'];
  /** Пользователь, оставивиший сообщение об ошибку в тексте. */
  user: User;
  /** Роль пользователя. */
  userRole?: Maybe<Roles>;
};

/** Сообщение пользователя об ошибке в тексте задания */
export type MisprintReportBtc = {
  __typename?: 'MisprintReportBTC';
  /** Школа пользователя. */
  School?: Maybe<School>;
  /** Исправление, которое предложил пользователь. */
  correctText: Scalars['String']['output'];
  /** Дата и время сообщения об ошибке в тексте в UTC. */
  createTs: Scalars['DateTime']['output'];
  /** Комментарий исполнителя */
  executorComment?: Maybe<Scalars['String']['output']>;
  /** Идентификатор сообщения */
  id: Scalars['ID']['output'];
  /** В каком модуле содержится ошибка в тексте или находится задание с ошибкой. */
  module?: Maybe<StudyModule>;
  /** url страницы, на которую была написана жалоба */
  pageUrl?: Maybe<Scalars['String']['output']>;
  /** Причины опечатки */
  reasonIds: Array<Scalars['ID']['output']>;
  /** путь к скриншоту в файлохранилище */
  screenshotUrl?: Maybe<Scalars['String']['output']>;
  /** Длина выделенного текста опечатки. */
  selectionLength: Scalars['Int']['output'];
  /** С какого символа начинается опечатка. */
  selectionStart: Scalars['Int']['output'];
  /** Класс создателя жалобы */
  stageGroup?: Maybe<Scalars['String']['output']>;
  /** Статус жалобы */
  status: ComplaintAndSystemErrorStatus;
  /** В каком задании содержится ошибка в тексте. */
  task?: Maybe<Task>;
  /** Текст в котором содержится ошибка в тексте. */
  text: Scalars['String']['output'];
  /** Пользователь, оставивиший сообщение об ошибку в тексте. */
  user: User;
  /** Роль пользователя. */
  userRole?: Maybe<Roles>;
};

export type MisprintReportInput = {
  correctText: Scalars['String']['input'];
  moduleId?: InputMaybe<Scalars['ID']['input']>;
  pageUrl?: InputMaybe<Scalars['String']['input']>;
  reasonIds: Array<Scalars['ID']['input']>;
  screenshotUrl?: InputMaybe<Scalars['String']['input']>;
  selectionLength: Scalars['Int']['input'];
  selectionStart: Scalars['Int']['input'];
  taskId?: InputMaybe<Scalars['ID']['input']>;
  text: Scalars['String']['input'];
  userRole?: InputMaybe<Roles>;
  userSchoolId?: InputMaybe<Scalars['ID']['input']>;
};

export type MobilePhoneEditInfo = {
  __typename?: 'MobilePhoneEditInfo';
  /** Сколько попыток осталось */
  attemptsRemain: Scalars['Int']['output'];
  /**
   * Номер телефона, который мы хотим подтвердить, пусто если мы не находимся
   * в состоянии подтверждения
   */
  mobileNumberForVerification?: Maybe<Scalars['String']['output']>;
  /** Сколько секунд до посылки нового кода */
  secondsRemain: Scalars['Int']['output'];
  /** Включена ли смс верификация  при редактировании телефона */
  smsVerificationEnabled: Scalars['Boolean']['output'];
};

/** Параметры сотрудника, которые изменяются через заявку */
export type ModifiedUserData = {
  __typename?: 'ModifiedUserData';
  /** Почта сотрудника */
  email?: Maybe<Scalars['String']['output']>;
  /** Имя сотрудника */
  firstName?: Maybe<Scalars['String']['output']>;
  /** Фамилия сотрудника */
  lastName?: Maybe<Scalars['String']['output']>;
  /** Отчество сотрудника */
  middleName?: Maybe<Scalars['String']['output']>;
  /** Список профилей доступа */
  userFroleSets?: Maybe<Array<ModifiedUserFroleSet>>;
};

/** Параметры сотрудника, которые изменяются через заявку */
export type ModifiedUserDataInput = {
  /** Почта сотрудника */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Имя сотрудника */
  firstName: Scalars['String']['input'];
  /** Фамилия сотрудника */
  lastName: Scalars['String']['input'];
  /** Отчество сотрудника */
  middleName?: InputMaybe<Scalars['String']['input']>;
  /** Список профилей доступа */
  userFroleSets: Array<ModifiedUserFroleSetInput>;
};

/** Параметры сотрудника, которые изменяются через заявку */
export type ModifiedUserDataResult = {
  __typename?: 'ModifiedUserDataResult';
  newModifiedUserData: ModifiedUserData;
  oldModifiedUserData?: Maybe<ModifiedUserData>;
};

/** Параметры профилей доступа сотрудника, которые изменяются через заявку */
export type ModifiedUserFroleSet = {
  __typename?: 'ModifiedUserFroleSet';
  /** Идентификатор профиля доступа */
  functionalRoleSetId: Scalars['ID']['output'];
  /** Наименование профиля доступа и продукта/кампуса */
  functionalRoleSetWithCampusName?: Maybe<Scalars['String']['output']>;
  /** Идентификатор продукта/кампуса */
  orgUnitId: Scalars['ID']['output'];
  /** Подробная информация о профиле доступа и продукте/кампусе */
  userFroleSet: UserFroleSet;
};

/** Параметры профилей доступа сотрудника, которые изменяются через заявку */
export type ModifiedUserFroleSetInput = {
  /** Идентификатор профиля доступа */
  functionalRoleSetId: Scalars['ID']['input'];
  /** Идентификатор продукта/кампуса */
  orgUnitId: Scalars['ID']['input'];
};

export type ModularPlanningQueries = {
  __typename?: 'ModularPlanningQueries';
  /**
   * по идентификатору Предмета (subjects.subject_id) и идентифкатору параллели (stages.stage_id)
   * только те группы, в которых учитель преподает
   */
  getClassSubjectsTaughtByTeacherBySubjectIdAndStageId: Array<ClassSubject>;
  /** Получение информации о модулях из дефолтных Систем заданий */
  getModuleDetails: ModuleDetailsResponse;
  /** Получение информации о модулях в Персональном Плане или Плане на Класс */
  getPlanModuleDetails: ModuleDetailsResponse;
  /** Получение информации о модулях в Плане на Параллель */
  getStagePlanModuleDetails: ModuleDetailsResponse;
};


export type ModularPlanningQueriesGetClassSubjectsTaughtByTeacherBySubjectIdAndStageIdArgs = {
  stageId: Scalars['ID']['input'];
  subjectId: Scalars['ID']['input'];
};


export type ModularPlanningQueriesGetModuleDetailsArgs = {
  moduleIds: Array<Scalars['ID']['input']>;
  stageSubjectGroupId: Scalars['ID']['input'];
};


export type ModularPlanningQueriesGetPlanModuleDetailsArgs = {
  stageSubjectGroupId: Scalars['ID']['input'];
  studentInSubgroupId?: InputMaybe<Scalars['ID']['input']>;
};


export type ModularPlanningQueriesGetStagePlanModuleDetailsArgs = {
  stageSubjectGroupId: Scalars['ID']['input'];
};

/** Информация о всех достиженияx Ученика в рамках Учебного Модуля */
export type ModuleAchieveInfo = {
  __typename?: 'ModuleAchieveInfo';
  /** Дата и Время достижения */
  date?: Maybe<Scalars['Date']['output']>;
  /** Флаг - достигнут/не достигнут */
  isAchieved: Scalars['Boolean']['output'];
  /** информация по прогрессу достижений всех Уровней в рамках Учебного Модуля */
  levelsAchieveInfo: Array<ModuleLevelAchieveInfo>;
  /** дробное значение максимально достигнутого Уровня Учебного Модуля */
  maxAchievedLevel: Scalars['Float']['output'];
};

/** Настройки повторного прохождения проекта */
export type ModuleAttemptsSettings = {
  __typename?: 'ModuleAttemptsSettings';
  /** Формула подсчета финальной оценки с учетом пройденных попыток */
  attemptCountingFormula: AttemptCountingFormulaEnum;
  /** Флаг неограниченного кол-ва попыток */
  isUnlimitedAttempts: Scalars['Boolean']['output'];
  /** Максимальное Кол-во попыток прохождения проекта */
  maxModuleAttempts?: Maybe<Scalars['Int']['output']>;
};

/** Настройки повторного прохождения проекта для сохранения */
export type ModuleAttemptsSettingsInput = {
  /** Формула подсчета финальной оценки с учетом пройденных попыток */
  attemptCountingFormula: AttemptCountingFormulaEnum;
  /** Флаг неограниченного кол-ва попыток */
  isUnlimitedAttempts: Scalars['Boolean']['input'];
  /** Максимальное Кол-во попыток прохождения проекта */
  maxModuleAttempts?: InputMaybe<Scalars['Int']['input']>;
};

/** Награда, которая выдается за закрытие модуля */
export type ModuleAward = {
  __typename?: 'ModuleAward';
  /** Награда */
  award: Award;
  /** ID модуля, за закрытие которого выдается награда */
  goalId: Scalars['ID']['output'];
  /** module_award_id */
  id: Scalars['ID']['output'];
  /** При каком условие выдается */
  moduleAwardType: ModuleAwardTypeEnum;
  /** Сколько наград выдается */
  power: Scalars['Int']['output'];
};

/** Награда за выполения модуля на целевом или выше уровне */
export type ModuleAwardInput = {
  awardId: Scalars['ID']['input'];
  moduleAwardType: ModuleAwardTypeEnum;
};

/** При каком условии награда выдается за модуль */
export enum ModuleAwardTypeEnum {
  /** Закрытие выше целевого уровня модуля */
  GreaterThanPlannedModuleLvl = 'GREATER_THAN_PLANNED_MODULE_LVL',
  /** Закрытие целевого уровня модуля */
  PlannedModuleLvl = 'PLANNED_MODULE_LVL'
}

/** Информация на обложке проекта для студента */
export type ModuleCoverInformation = {
  __typename?: 'ModuleCoverInformation';
  currentStudentCount: Scalars['Int']['output'];
  finishedCount: Scalars['Int']['output'];
  /**
   * Информация по p2p проверкам: кол-во от студента/сотрудника  (для экзамена - null)
   * @deprecated Use p2pChecksInfo
   */
  groupReviewCountInfo?: Maybe<TaskReviewCountInfo>;
  /** Информация по p2p проверкам: длительность и стоимость (для экзамена - null) */
  groupReviewDetails?: Maybe<StudentTaskAdditionalAttributes>;
  /**
   * Является ли текущий пользовать тимлидом  (для экзамена - null)
   * @deprecated Use projectStatistics
   */
  isCurrentUserTeamlead?: Maybe<Scalars['Boolean']['output']>;
  /** Отображается ли студенту его собственный таймлайн проекта */
  isOwnStudentTimeline?: Maybe<Scalars['Boolean']['output']>;
  /** Полная информация по проекту */
  moduleInfo: StudentModule;
  /** Информация по проверкам проекта */
  p2pChecksInfo?: Maybe<P2PChecksInfo>;
  /** Статистика по проекту */
  projectStatistics?: Maybe<ProjectStatistics>;
  /** Информация об участниках  (для экзамена - null) */
  projectTeamMembers?: Maybe<ProjectTeamMembers>;
  /** Кол-во попыток прохождения проекта */
  retriesCount: Scalars['Int']['output'];
  /**
   * Кол-во попыток прохождения проекта текущими пользователями
   * @deprecated Use projectStatistics
   */
  retriesOfCurrentStudents: Scalars['Int']['output'];
  /** Список гибких навыков с макс. кол-вом очков за все задания этого проекта */
  softSkills: Array<SoftSkillPoint>;
  /** Тип решения проекта */
  solutionType?: Maybe<TaskSolutionTypeEnum>;
  /** Кол-во команд ожидающих проверки по групповому проектам (для экзамена - null) */
  teamsWaitingEvaluationCount?: Maybe<Scalars['Int']['output']>;
  /**
   * Timeline проекта, список этапов прохождения проекта со статусами и опциональными датами начала/окончания
   * каждого этапа
   */
  timeline: Array<ProjectTimelineItem>;
  /** Текущий накопленный опыт пользователя */
  userExperience: UserExperience;
};

export type ModuleDetails = {
  __typename?: 'ModuleDetails';
  /** Уровень, на котором Учебный Модуль объявляется достигнутым учеником */
  achieveLevel: Scalars['Float']['output'];
  /** Плейлисты, которые доступны для этого модуля */
  availablePlaylists: Array<TaskSet>;
  /** Ожидаемое число дней изучения данной цели в Плане на параллель */
  countOfDays: Scalars['Int']['output'];
  /** Текущий плейлист модуля (Система заданий) */
  currentPlaylist: TaskSet;
  /** запланированная дата достижения Учебного Модуля */
  endDate?: Maybe<Scalars['DateTime']['output']>;
  /** id модуля в плане */
  id?: Maybe<Scalars['ID']['output']>;
  /** Является ли дедлайн жестким */
  isHardEndDate: Scalars['Boolean']['output'];
  /** Трудоемкость Учебного Модуля в часах в рамках текущего Плана */
  laboriousness: Scalars['Int']['output'];
  /** Уровни учебного модуля */
  levels: Array<StudyModuleLevel>;
  /** Флаг обязательности Учебного Модуля в рамках конкретного учебного Плана */
  mandatory: Scalars['Boolean']['output'];
  /** id модуля */
  moduleId: Scalars['ID']['output'];
  /** тип модуля */
  moduleType: ModuleType;
  /** Рекомендуемое учебным планом школы кол-во дней выделенных на модуль */
  recommendedDuration: Scalars['Int']['output'];
  /** Рекомендуемая трудоемкость Учебного Модуля в часах из GoalDTO */
  recommendedLaboriousness: Scalars['Int']['output'];
  /** запланированная дата начала изучения Учебного Модуля */
  startDate?: Maybe<Scalars['DateTime']['output']>;
  /** Количество заданий в текущем плейлисте учебного модуля */
  taskCount: Scalars['Int']['output'];
  /** название модуля */
  title: Scalars['String']['output'];
};

export type ModuleDetailsResponse = {
  __typename?: 'ModuleDetailsResponse';
  /** Признак успешно выполненного назначения Плейлистов */
  isSuccess: Scalars['Boolean']['output'];
  modulesDetails: Array<ModuleDetails>;
};

/** Информация о всех достиженияx Ученика в рамках Элемента Учебного Модуля */
export type ModuleElementAchieveInfo = {
  __typename?: 'ModuleElementAchieveInfo';
  /** Дата и Время достижения */
  achieveDateTime?: Maybe<Scalars['DateTime']['output']>;
  /** Флаг - достигнут/не достигнут */
  achieved: Scalars['Boolean']['output'];
  /** описание Элемента для Учителя */
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** идентификатор Элемента Учебного Модуля (skills.skill_id) */
  moduleElementId: Scalars['ID']['output'];
};

/** тип выполнения модуля */
export enum ModuleExecutionType {
  /** Экзаменационный модуль (используется S21) */
  Exam = 'EXAM',
  /** Модуль/Проект экзаменационного теста (используется S21) */
  ExamTest = 'EXAM_TEST',
  /** Групповой проект (используется S21) */
  Group = 'GROUP',
  /** Индивидуальный проект (используется S21) */
  Individual = 'INDIVIDUAL',
  /** Модуль/Проект стажировка (используется S21) */
  Internship = 'INTERNSHIP',
  /** Lite модуль (строго с одни уровнем цели и одним элементом цели внутри уровня) */
  Lite = 'LITE',
  /** Учебный модуль */
  Simple = 'SIMPLE'
}

/** Модель типов моделя */
export type ModuleExecutionTypeModel = {
  __typename?: 'ModuleExecutionTypeModel';
  /** Описание типа модуля */
  description: Scalars['String']['output'];
  /** Идентификатор типа модуля */
  id: Scalars['ID']['output'];
};

export type ModuleInfo = {
  __typename?: 'ModuleInfo';
  moduleId: Scalars['ID']['output'];
  moduleName: Scalars['String']['output'];
};

export type ModuleInfoForPersonalTrajectory = {
  __typename?: 'ModuleInfoForPersonalTrajectory';
  /** Аватар Модуля */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Дата окончания Учебного Модуля из Плана */
  endDate?: Maybe<Scalars['Date']['output']>;
  /** Id Модуля */
  goalId: Scalars['ID']['output'];
  /** Уровни Учебного Модуля и описания навыков в них */
  goalLevels: Array<GoalLevelInfoAndProgress>;
  /** Статус Модуля для Ученика. Если он пустой -- значит Ученик с Модулем еще не взаимодействовал */
  goalStatus?: Maybe<GoalStatus>;
  /** Идея Модуля */
  idea: Scalars['String']['output'];
  /** Зачтен ли Ученику Уровень выше его Целевого уровня (сравниваются целые значения) */
  isAchievedLevelHigherThanTarget: Scalars['Boolean']['output'];
  /** Пройден ли модуль для Ученика (зачтены все уровни до и включая целевой) */
  isGoalCompleted: Scalars['Boolean']['output'];
  /** Является ли дедлайн жестким. После истечения жесткого дедлайна нельзя отправлять задания модуля на проверку */
  isHardEndDate: Scalars['Boolean']['output'];
  /** Входит ли Mодуль в Большой вызов для Студента (проверяется по id предмета модуля) */
  isInBigChallengeForStudent: Scalars['Boolean']['output'];
  /** В Модуле нет Заданий */
  isNoTasksInModule: Scalars['Boolean']['output'];
  /** Изменялась ли СЗ Модуля с момента последнего редактирования Траектории */
  isPlaylistChanged: Scalars['Boolean']['output'];
  /** Пройдена ли рефлексия */
  isReflectionPassed: Scalars['Boolean']['output'];
  /** Зачтен ли Ученику его Целевой Уровень */
  isTargetGoalLevelAchieved: Scalars['Boolean']['output'];
  /** Нужно ли дополнить траекторию (нужно сгенерировать заново в новой мутации) */
  isTrajectoryNeedsCompletion: Scalars['Boolean']['output'];
  /** Создана ли у Ученика полная/валидная Траектория по этому Модулю */
  isValidTrajectoryCreated: Scalars['Boolean']['output'];
  /** Трудоемкость Учебного Модуля в часах из Плана или из GoalDTO, если Плана нет */
  laboriousness: Scalars['Int']['output'];
  /** Обложка Модуля */
  landingUrl?: Maybe<Scalars['String']['output']>;
  /** Максимально зачтенный Ученику Уровень */
  maxAchievedGoalLevel?: Maybe<Scalars['Float']['output']>;
  /** Минут до окончания Учебного Модуля из Плана (заполняется, когда приближается endDate) */
  minutesLeft?: Maybe<Scalars['Int']['output']>;
  /** Тип Модуля */
  moduleType: ModuleType;
  /** Мотивационные Задания модуля (сейчас только одно) */
  motivationTasks: Array<GoalElementTask>;
  /** Id следующего задания для выполнения в Траектории, если Модуль еще не завершился */
  nextTaskIdInTrajectory?: Maybe<Scalars['ID']['output']>;
  /** Id Учебного Плана, если он есть для этого Модуля и Ученика */
  planId?: Maybe<Scalars['ID']['output']>;
  /** Id Модуля в Учебном Плане, если он есть для этого Модуля и Ученика */
  planModuleId?: Maybe<Scalars['ID']['output']>;
  /** Тип Учебного Плана, если он есть для этого Модуля и Ученика */
  planType: PlanTypeEnum;
  /**
   * Мягкие Навыки в Модуле и количество Заданий в них в соответствии с Заданиями из Траектории Ученика,
   * или из минимально необходимого набора заданий назначенной ему Системы Заданий (СЗ) в Модульного Плане,
   * или из минимально необходимого набора заданий Дефолтной СЗ Модуля, если Модуль Внеплановый
   */
  softSkillCounts: Array<SoftSkillCount>;
  /** Id Параллели, к которой относится Модуль */
  stageId: Scalars['ID']['output'];
  /** Название Параллели, к которой относится Модуль */
  stageName: Scalars['String']['output'];
  /** Дата начала Учебного Модуля из Плана */
  startDate?: Maybe<Scalars['Date']['output']>;
  /** Id Предмета, к которому относится Модуль */
  subjectId: Scalars['ID']['output'];
  /** Название Предмета, к которому относится Модуль */
  subjectName: Scalars['String']['output'];
  /** Выбранный Учеником Целевой Уровень */
  targetGoalLevel?: Maybe<Scalars['Float']['output']>;
  /** UserId Учителя для планового модуля */
  teacherUserId?: Maybe<Scalars['UUID']['output']>;
  /** Название Модуля */
  title: Scalars['String']['output'];
  /**
   * Максимально зачтенный Ученику Уровень Модуля по правилам Траектории.
   * Значение максимально зачтенного Уровня, при котором зачтены и все нижестоящие Уровни,
   * содержащие Задания в Системе Заданий
   */
  trajectoryMaxAchievedLevel?: Maybe<Scalars['Float']['output']>;
};

/** Информацию о проекте для p2p-проверки */
export type ModuleInfoP2P = {
  __typename?: 'ModuleInfoP2P';
  /** Тип выполнения */
  executionType?: Maybe<ModuleExecutionType>;
  /** Идентификатор проекта */
  moduleId: Scalars['ID']['output'];
  /** Название проекта */
  moduleName: Scalars['String']['output'];
  /** Продолжительность p2p-проверки */
  periodOfVerification: Scalars['Int']['output'];
};

export type ModuleInfoResponse = {
  __typename?: 'ModuleInfoResponse';
  /** Тип 3Д ассистента */
  assistantDisplayType3D?: Maybe<AssistantDisplayType3D>;
  /** Общая информация по Модулю */
  moduleInfo?: Maybe<ModuleInfoForPersonalTrajectory>;
  /** Код результата */
  responseCodes: Array<PersonalTrajectoryResponseCode>;
};

/** Информация о всех достиженияx Ученика в рамках Уровня Учебного Модуля */
export type ModuleLevelAchieveInfo = {
  __typename?: 'ModuleLevelAchieveInfo';
  /** Дата и Время достижения */
  achieveDateTime?: Maybe<Scalars['DateTime']['output']>;
  /** Флаг - достигнут/не достигнут */
  achieved: Scalars['Boolean']['output'];
  /** информация по прогрессу достижений всех Элементов в рамках Элемента Учебного Модуля */
  elementsAchieveInfo: Array<ModuleElementAchieveInfo>;
  id: Scalars['ID']['output'];
  /** дробное значение Уровня */
  level: Scalars['Float']['output'];
  /** идентификатор Уровня Учебного Модуля (goal_levels.goal_level_id) */
  moduleLevelId: Scalars['ID']['output'];
  /** Процент зачтенных заданий уровня */
  performance?: Maybe<Scalars['Int']['output']>;
};

export type ModuleSelectionsProperties = {
  __typename?: 'ModuleSelectionsProperties';
  /** назначение подборки на предмет */
  assignMaterialToSubject: Scalars['Boolean']['output'];
  editMaterialToModule: Scalars['Boolean']['output'];
  /** Доступ к вкладке подборок пользователя при прикреплении материалов в шторке глоб. материалов 2.0 */
  userSelectionsGlobalMaterialsCurtainEnabled: Scalars['Boolean']['output'];
  viewMaterialToModule: Scalars['Boolean']['output'];
};

export type ModuleStatistics = {
  __typename?: 'ModuleStatistics';
  avgDaysConsumedBySchool: Scalars['Int']['output'];
  avgDaysConsumedTotal: Scalars['Int']['output'];
  avgPassedTasksBySchool: Scalars['Int']['output'];
  avgPassedTasksTotal: Scalars['Int']['output'];
  avgPlannedTasksBySchool: Scalars['Int']['output'];
  avgPlannedTasksTotal: Scalars['Int']['output'];
  levelName: Scalars['String']['output'];
  negativeFeedbacksBySchool: Scalars['Int']['output'];
  negativeFeedbacksTotal: Scalars['Int']['output'];
  positiveFeedbacksBySchool: Scalars['Int']['output'];
  positiveFeedbacksTotal: Scalars['Int']['output'];
  studentsMaxLevelBySchool: Scalars['Int']['output'];
  studentsMaxLevelBySchoolPercent: Scalars['Float']['output'];
  studentsMaxLevelTotal: Scalars['Int']['output'];
  studentsMaxLevelTotalPercent: Scalars['Float']['output'];
  studentsTryModuleBySchool: Scalars['Int']['output'];
  studentsTryModuleTotal: Scalars['Int']['output'];
  studentsWithoutAnyLevBySchool: Scalars['Int']['output'];
  studentsWithoutAnyLevBySchoolPercent: Scalars['Float']['output'];
  studentsWithoutAnyLevTotal: Scalars['Int']['output'];
  studentsWithoutAnyLevTotalPercent: Scalars['Float']['output'];
};

/** Наличие заданий в модуле */
export enum ModuleTaskAvailabilityEnum {
  /** Все */
  All = 'ALL',
  /** Без заданий */
  WithoutTasks = 'WITHOUT_TASKS',
  /** С заданиями */
  WithTasks = 'WITH_TASKS'
}

/** Количество заданий с определенным статусом в модуле */
export type ModuleTaskStatusWithQuantity = {
  __typename?: 'ModuleTaskStatusWithQuantity';
  /** идентификатор Учебного Модуля (goals.goal_id) */
  moduleId: Scalars['ID']['output'];
  /** Количество заданий с определенным статусом */
  statusQuantity: Array<TaskStatusWithQuantity>;
};

/** тип модуля */
export enum ModuleType {
  /** Кастомизированный внешний модуль */
  PmoCustom = 'PMO_CUSTOM',
  /** Обычный модуль ПМО, созданный через стандартный конструктор */
  PmoSimple = 'PMO_SIMPLE'
}

/** Данные для отчета "Прогресс_прохождения_модулей_предмет_параллель" */
export type ModulesProgressBySubjectAndStage = {
  __typename?: 'ModulesProgressBySubjectAndStage';
  modulesAccepted: Scalars['Int']['output'];
  modulesAcceptedPercent: Scalars['Float']['output'];
  modulesNotStarted: Scalars['Int']['output'];
  modulesNotStartedPercent: Scalars['Float']['output'];
  modulesPartPassed: Scalars['Int']['output'];
  modulesPartPassedPercent: Scalars['Float']['output'];
  modulesPlanned: Scalars['Int']['output'];
  modulesSomeTasksExecuted: Scalars['Int']['output'];
  modulesSomeTasksExecutedPercent: Scalars['Float']['output'];
  stageGroupName: Scalars['String']['output'];
  stageId: Scalars['Int']['output'];
  stageSubjectGroupId: Scalars['Int']['output'];
  stageSubjectGroupName: Scalars['String']['output'];
  studentsCount: Scalars['Int']['output'];
  studentsDetails?: Maybe<Array<ModulesProgressStudentDetails>>;
  subject: Scalars['String']['output'];
  subjectId: Scalars['Int']['output'];
  teacherId: Scalars['UUID']['output'];
  teacherName: Scalars['String']['output'];
};

export type ModulesProgressStudentDetails = {
  __typename?: 'ModulesProgressStudentDetails';
  modulesAccepted: Scalars['Int']['output'];
  modulesNotStarted: Scalars['Int']['output'];
  modulesPartPassed: Scalars['Int']['output'];
  modulesPlanned: Scalars['Int']['output'];
  modulesSomeTasksExecuted: Scalars['Int']['output'];
  stageSubjectSubgroupStudentId: Scalars['Int']['output'];
  studentInfo: StudentUserInfo;
};

export type ModulesReportFilter = {
  beginDate: Scalars['Date']['input'];
  endDate: Scalars['Date']['input'];
  noNameRegion: Scalars['Boolean']['input'];
  noNameTerbank: Scalars['Boolean']['input'];
  regions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  stageGroupIds: Array<InputMaybe<Scalars['Int']['input']>>;
  terbanks?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Мотивационный блок */
export type MotivationBlock = {
  __typename?: 'MotivationBlock';
  /** Базовая идея */
  baseIdea?: Maybe<Scalars['String']['output']>;
  /** Идентификатор модуля (goals.goal_id) */
  goalId: Scalars['ID']['output'];
  /** Идентификатор (motivation_blocks.motivation_block_id) */
  id: Scalars['UUID']['output'];
  /** Секции внутри мотивационного блока */
  motivationBlockSections: Array<MotivationBlockSection>;
  /** Все мотивационные задания модуля */
  motivationTasks: Array<Task>;
  /** Проблемный вопрос */
  problematicIssue: Scalars['String']['output'];
};

export enum MotivationBlockElementType {
  Audio = 'AUDIO',
  Banner = 'BANNER',
  BaseIdea = 'BASE_IDEA',
  Gallery = 'GALLERY',
  MiniTest = 'MINI_TEST',
  MotivationTask = 'MOTIVATION_TASK',
  ProblematicIssue = 'PROBLEMATIC_ISSUE',
  Text = 'TEXT',
  Top_5 = 'TOP_5',
  Video = 'VIDEO'
}

/** Мотивационный блок */
export type MotivationBlockInput = {
  /** Базовая идея */
  baseIdea?: InputMaybe<Scalars['String']['input']>;
  /** Идентификатор модуля (goals.goal_id) */
  goalId: Scalars['ID']['input'];
  /** Идентификатор (motivation_blocks.motivation_block_id) */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Секции внутри мотивационного блока */
  motivationBlockSections: Array<MotivationBlockSectionInput>;
  /** Проблемный вопрос */
  problematicIssue?: InputMaybe<Scalars['String']['input']>;
};

/** Секция внутри мотивационного блока */
export type MotivationBlockSection = {
  __typename?: 'MotivationBlockSection';
  /** Количество блоков внутри секции */
  blocksCount: Scalars['Int']['output'];
  /** Блоки внутри мотивационной секции */
  elements: Array<MotivationBlockSectionElement>;
  /** Идентификатор (motivation_sections.motivation_section_id) */
  id: Scalars['UUID']['output'];
  /** Идентификатор мотивационного блока (motivation_blocks.motivation_block_id) */
  motivationBlockId: Scalars['UUID']['output'];
  /** Позиция внутри мотивационного блока */
  position: Scalars['Int']['output'];
  /** Стиль секции */
  sectionStyle?: Maybe<Scalars['String']['output']>;
  /** Тип шаблона */
  templateType: SectionType;
};

/** Блок данных внутри секции мотивационного блока */
export type MotivationBlockSectionElement = {
  __typename?: 'MotivationBlockSectionElement';
  /** Контент внутри мотивационного элемента */
  content?: Maybe<Scalars['String']['output']>;
  /** Тип контента внутри мотивационнного блока */
  elementType: MotivationBlockElementType;
  /** Идентификатор секции (motivation_sections.motivation_section_id) */
  motivationSectionId: Scalars['UUID']['output'];
  /** Позиция внутри секции */
  position: Scalars['Int']['output'];
};

/** Элемент секции мотивационного блока */
export type MotivationBlockSectionElementInput = {
  /** Контент внутри мотивационного элемента */
  content: Scalars['String']['input'];
  /** Тип контента внутри мотивационнного блока */
  elementType: MotivationBlockElementType;
  /** Идентификатор секции (motivation_sections.motivation_section_id) */
  motivationSectionId?: InputMaybe<Scalars['UUID']['input']>;
  /** Позиция внутри секции */
  position: Scalars['Int']['input'];
};

/** Секция мотивационного блока */
export type MotivationBlockSectionInput = {
  /** Количество блоков внутри секции */
  blocksCount: Scalars['Int']['input'];
  /** Блоки данных внутри мотивационной секции */
  elements: Array<MotivationBlockSectionElementInput>;
  /** Идентификатор (motivation_sections.motivation_section_id) */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Идентификатор мотивационного блока (motivation_blocks.motivation_block_id) */
  motivationBlockId?: InputMaybe<Scalars['UUID']['input']>;
  /** Позиция внутри секции */
  position: Scalars['Int']['input'];
  /** Стиль секции */
  sectionStyle?: InputMaybe<Scalars['String']['input']>;
  /** Тип шаблона */
  templateType: SectionType;
};

/** Настройки мультикампусности для кампуса */
export type MulticampusSetting = {
  __typename?: 'MulticampusSetting';
  /** включена/выключена настройка мультикампусности */
  isActive: Scalars['Boolean']['output'];
  /** id кампуса */
  schoolId: Scalars['UUID']['output'];
  /** имя кампуса */
  schoolName: Scalars['String']['output'];
  /** настройки мультикампусности для параллелей */
  stageDependencies: Array<StageDependency>;
};

/** Ответ с бэка на виджет "Множественный выбор текста" */
export type MultipleTextAnswerBody = {
  __typename?: 'MultipleTextAnswerBody';
  /** Строка с json-структурой внутри */
  answer?: Maybe<Scalars['String']['output']>;
};

/** Отправляемый ответ на виджет "Множественный выбор текста" */
export type MultipleTextAnswerBodyInput = {
  /** Строка с json-структурой внутри */
  answer?: InputMaybe<Scalars['String']['input']>;
};

export type Mutation = {
  __typename?: 'Mutation';
  ASAP?: Maybe<AsapMutations>;
  accelerator?: Maybe<AcceleratorMutations>;
  apiMigration?: Maybe<ApiMigrationMutations>;
  asyncReport?: Maybe<AsyncReportMutations>;
  attestationPeriodMark?: Maybe<AttestationPeriodMarkMutations>;
  attestationPeriods?: Maybe<AttestationPeriodMutations>;
  award?: Maybe<AwardMutations>;
  bigChallenge?: Maybe<BigChallengeMutations>;
  businessAdmin?: Maybe<BusinessAdminMutations>;
  calendarEvent?: Maybe<CalendarEventMutations>;
  content?: Maybe<ContentMutations>;
  contentTags?: Maybe<ContentTagsMutations>;
  course?: Maybe<CourseMutations>;
  eJournal?: Maybe<EJournalMutations>;
  event?: Maybe<EventMutations>;
  eventGenerator?: Maybe<EventGeneratorMutations>;
  externalContent?: Maybe<ExternalContentMutations>;
  externalLearning?: Maybe<ExternalLearningMutations>;
  gamification?: Maybe<GamificationMutations>;
  holyGraph?: Maybe<HolyGraphMutations>;
  honorRating?: Maybe<HonorRatingMutations>;
  leaderBoard?: Maybe<LeaderBoardMutations>;
  mediateka: MediatekaMutations;
  notificationConfiguration?: Maybe<NotificationConfigurationMutations>;
  parent?: Maybe<ParentMutation>;
  penalty?: Maybe<PenaltyMutations>;
  personalTrajectory?: Maybe<PersonalTrajectoryMutations>;
  planning?: Maybe<PlanningMutations>;
  proforntUiElement?: Maybe<ProforntUiElementMutations>;
  regionalDashboard?: Maybe<RegionalDashboardMutations>;
  s21Exam?: Maybe<S21ExamMutations>;
  s21Plan?: Maybe<S21PlanMutations>;
  s21StudyProgram?: Maybe<S21StudyProgramMutations>;
  sc21BaCalendar?: Maybe<Sc21BaCalendarMutations>;
  sc21BaTaskCheck?: Maybe<Sc21BaTaskCheckMutations>;
  sc21ProjectFlow?: Maybe<Sc21ProjectFlowMutations>;
  sc21StudentTaskCheck?: Maybe<Sc21StudentTaskCheckMutations>;
  school21?: Maybe<School21Mutations>;
  schoolSelfConfiguration?: Maybe<SchoolSelfConfigurationMutations>;
  selection: SelectionMutations;
  stageGroupMassCreation?: Maybe<StageGroupMassCreationMutations>;
  statisticReport?: Maybe<StatisticReportMutations>;
  student?: Maybe<StudentMutations>;
  systemAdmin?: Maybe<SystemAdminMutations>;
  tariffs?: Maybe<TariffsMutations>;
  teacher?: Maybe<TeacherMutations>;
  team?: Maybe<TeamMutations>;
  trajectory?: Maybe<TrajectoryMutations>;
  user?: Maybe<UserMutations>;
  userChangeRequest?: Maybe<UserChangeRequestMutations>;
  userProfile?: Maybe<UserProfileMutations>;
  visitJournal?: Maybe<VisitJournalMutations>;
  workshop?: Maybe<WorkshopMutations>;
};

/** Информация о текущих и завершенных Домашних Работах ученика */
export type NonExpiredStudentHomeworksInfo = {
  __typename?: 'NonExpiredStudentHomeworksInfo';
  /** Признак наличия не завершенных в сорк Домашних Работ */
  expiredHomeworksExist: Scalars['Boolean']['output'];
  /** Список Домашних Работ для Ученика, разбитый по датам (в зоне школы) */
  homeworksByDate: Array<StudentHomeworksByDate>;
};

export type Note = {
  __typename?: 'Note';
  /** Признак завершен ли пункт */
  completed: Scalars['Boolean']['output'];
  /** Время создания заметки */
  createTime: Scalars['DateTime']['output'];
  /** Идентификатор заметки */
  noteId: Scalars['ID']['output'];
  /** Время планирования заметки */
  scheduledTime: Scalars['DateTime']['output'];
  /** Текст заметки */
  text: Scalars['String']['output'];
  /** Время обновления заметки */
  updateTime: Scalars['DateTime']['output'];
  /** Идентификатор пользователя которому принадлежит заметка */
  userId: Scalars['UUID']['output'];
};

export type NoteInput = {
  /** Признак завершен ли пункт */
  completed?: InputMaybe<Scalars['Boolean']['input']>;
  /** Идентификатор заметки */
  noteId?: InputMaybe<Scalars['ID']['input']>;
  /** Время планирования заметки */
  scheduledTime?: InputMaybe<Scalars['DateTime']['input']>;
  /** Текст заметки */
  text?: InputMaybe<Scalars['String']['input']>;
  /** Идентификатор пользователя которому принадлежит заметка */
  userId: Scalars['UUID']['input'];
};

export type Notification = {
  __typename?: 'Notification';
  /** Дополнительная информация по уведомлению (JSON) */
  additionalInfo: Scalars['String']['output'];
  author: User;
  goalName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  message: Scalars['String']['output'];
  /** Флаг Выставляется, когда нотификация приходит студенту для взаимопроверки */
  review: Scalars['Boolean']['output'];
  /** Идентификатор ученика, выполняющего задание и отправившего его на ревью */
  reviewInitiatorStudentId?: Maybe<Scalars['ID']['output']>;
  studentId: Scalars['ID']['output'];
  taskId: Scalars['ID']['output'];
  time: Scalars['DateTime']['output'];
  type: NotificationEnum;
  wasRead: Scalars['Boolean']['output'];
};

export type NotificationConfigurationMutations = {
  __typename?: 'NotificationConfigurationMutations';
  /** Метод включения канала уведомлений */
  activateNotificationChannel: Scalars['Boolean']['output'];
  /** Метод отключения канала уведомлений */
  deactivateNotificationChannel: Scalars['Boolean']['output'];
  /** Метод изменяет активность каналов уведомлений для школ */
  editNotificationChannelsForSchools: Scalars['Boolean']['output'];
  saveNotificationGlobalSettings: Scalars['Boolean']['output'];
  saveNotificationUserSettings: Scalars['Boolean']['output'];
};


export type NotificationConfigurationMutationsActivateNotificationChannelArgs = {
  channelId: Scalars['ID']['input'];
};


export type NotificationConfigurationMutationsDeactivateNotificationChannelArgs = {
  channelId: Scalars['ID']['input'];
};


export type NotificationConfigurationMutationsEditNotificationChannelsForSchoolsArgs = {
  schoolChannelsList: Array<InputMaybe<SchoolChannelsInput>>;
};


export type NotificationConfigurationMutationsSaveNotificationGlobalSettingsArgs = {
  globalSettingModels: Array<GlobalSettingInput>;
};


export type NotificationConfigurationMutationsSaveNotificationUserSettingsArgs = {
  settings: Array<NotificationUserSettingInput>;
};

export type NotificationConfigurationQueries = {
  __typename?: 'NotificationConfigurationQueries';
  getChannelsByOrgUnitId: Array<Channel>;
  getChannelsBySchoolIds: Array<SchoolChannels>;
  getEmailNotificationStatusCount: Array<StatusCount>;
  getGlobalSettings: Array<GlobalSetting>;
  getNotificationReadInterval: Scalars['String']['output'];
  getNotificationUserSettings: Array<NotificationUserSetting>;
};


export type NotificationConfigurationQueriesGetChannelsByOrgUnitIdArgs = {
  schoolId: Scalars['UUID']['input'];
};


export type NotificationConfigurationQueriesGetChannelsBySchoolIdsArgs = {
  schoolIds: Array<Scalars['UUID']['input']>;
};


export type NotificationConfigurationQueriesGetEmailNotificationStatusCountArgs = {
  relatedObjectId: Scalars['String']['input'];
  relatedObjectType: Scalars['String']['input'];
};

export enum NotificationEnum {
  Award = 'AWARD',
  ByAcceptedTask = 'BY_ACCEPTED_TASK',
  ByAchievementCreate = 'BY_ACHIEVEMENT_CREATE',
  ByAfterControlWorkCreated = 'BY_AFTER_CONTROL_WORK_CREATED',
  ByAfterTaskAcceptByClassmate = 'BY_AFTER_TASK_ACCEPT_BY_CLASSMATE',
  ByAfterTaskAcceptBySystem = 'BY_AFTER_TASK_ACCEPT_BY_SYSTEM',
  ByAfterTaskFailByClassmate = 'BY_AFTER_TASK_FAIL_BY_CLASSMATE',
  ByAsyncReportTaskCompleted = 'BY_ASYNC_REPORT_TASK_COMPLETED',
  ByAvatarUpdate = 'BY_AVATAR_UPDATE',
  ByBadgeNotification = 'BY_BADGE_NOTIFICATION',
  ByChangeGroupStudentAddInClassGroupBySubject = 'BY_CHANGE_GROUP_STUDENT_ADD_IN_CLASS_GROUP_BY_SUBJECT',
  ByChangeGroupStudentRemoveFromClassGroupBySubject = 'BY_CHANGE_GROUP_STUDENT_REMOVE_FROM_CLASS_GROUP_BY_SUBJECT',
  ByChangeSchedule = 'BY_CHANGE_SCHEDULE',
  ByCommentCreate = 'BY_COMMENT_CREATE',
  ByCookiesAdd = 'BY_COOKIES_ADD',
  ByDeleteLessonPlanClass = 'BY_DELETE_LESSON_PLAN_CLASS',
  ByDeleteLessonPlanMaterialsFromMediateka = 'BY_DELETE_LESSON_PLAN_MATERIALS_FROM_MEDIATEKA',
  ByDeleteLessonPlanModule = 'BY_DELETE_LESSON_PLAN_MODULE',
  ByDeleteLessonPlanModuleDateChange = 'BY_DELETE_LESSON_PLAN_MODULE_DATE_CHANGE',
  ByDeleteLessonPlanSchedule = 'BY_DELETE_LESSON_PLAN_SCHEDULE',
  ByDeleteLessonPlanTasks = 'BY_DELETE_LESSON_PLAN_TASKS',
  ByGlobalNotification = 'BY_GLOBAL_NOTIFICATION',
  ByGovermentMarkStudyPeriod = 'BY_GOVERMENT_MARK_STUDY_PERIOD',
  ByMessageTask = 'BY_MESSAGE_TASK',
  ByModuleAchieving = 'BY_MODULE_ACHIEVING',
  ByModuleCancellationAchieving = 'BY_MODULE_CANCELLATION_ACHIEVING',
  ByModuleCommentAdded = 'BY_MODULE_COMMENT_ADDED',
  ByModuleCommentChanged = 'BY_MODULE_COMMENT_CHANGED',
  ByModuleLevelAchieving = 'BY_MODULE_LEVEL_ACHIEVING',
  ByModulePlaylistChanged = 'BY_MODULE_PLAYLIST_CHANGED',
  ByNeedCheckTask = 'BY_NEED_CHECK_TASK',
  ByPersonalObjectiveCompleted = 'BY_PERSONAL_OBJECTIVE_COMPLETED',
  ByPlanChanged = 'BY_PLAN_CHANGED',
  ByReactionCreate = 'BY_REACTION_CREATE',
  ByReviewerFound = 'BY_REVIEWER_FOUND',
  ByS21Notification = 'BY_S21_NOTIFICATION',
  ByStudyPeriodDatesChange = 'BY_STUDY_PERIOD_DATES_CHANGE',
  BySystemUpdate = 'BY_SYSTEM_UPDATE',
  ByTaskFailed = 'BY_TASK_FAILED',
  ByTaskNeedCorrection = 'BY_TASK_NEED_CORRECTION',
  ByTimeToEndModule = 'BY_TIME_TO_END_MODULE',
  ByTimeToPassReflection = 'BY_TIME_TO_PASS_REFLECTION',
  ByTimeToStartControlWork = 'BY_TIME_TO_START_CONTROL_WORK',
  ByTimeToStartModule = 'BY_TIME_TO_START_MODULE',
  Coins = 'COINS',
  DocumentResigningIntrusive = 'DOCUMENT_RESIGNING_INTRUSIVE',
  DocumentResigningRegular = 'DOCUMENT_RESIGNING_REGULAR',
  Event = 'EVENT',
  Invitations = 'INVITATIONS',
  Profile = 'PROFILE',
  Project = 'PROJECT',
  TaskDownloadDocument = 'TASK_DOWNLOAD_DOCUMENT',
  TimeToStartAnxietyTest = 'TIME_TO_START_ANXIETY_TEST',
  Tribes = 'TRIBES'
}

export type NotificationType = {
  __typename?: 'NotificationType';
  description?: Maybe<Scalars['String']['output']>;
  groupId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  locked: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  tunable?: Maybe<Scalars['Boolean']['output']>;
};

export type NotificationUserSetting = {
  __typename?: 'NotificationUserSetting';
  channelActive?: Maybe<Scalars['Boolean']['output']>;
  channelActiveSystem: Scalars['Boolean']['output'];
  channelId: Scalars['ID']['output'];
  channelLockedSystem: Scalars['Boolean']['output'];
  channelName: Scalars['String']['output'];
  groupTypeId: Scalars['ID']['output'];
  groupTypeName: Scalars['String']['output'];
  isMutable?: Maybe<Scalars['Boolean']['output']>;
  typeCode?: Maybe<Scalars['String']['output']>;
  typeId: Scalars['ID']['output'];
  typeName: Scalars['String']['output'];
};

export type NotificationUserSettingInput = {
  channelActive?: InputMaybe<Scalars['Boolean']['input']>;
  channelId: Scalars['ID']['input'];
  typeId: Scalars['ID']['input'];
};

/** Сопоставление типа и количества Уведомлений */
export type NotificationsCountByTypeMap = {
  __typename?: 'NotificationsCountByTypeMap';
  /** Тип Уведомления */
  notificationType: NotificationEnum;
  /** Количество доступных Уведомлений данного типа */
  notificationsCount: Scalars['Int']['output'];
};

export type NtoScore = {
  __typename?: 'NtoScore';
  availableToSend: Scalars['Boolean']['output'];
  dateSendScoreModuleNto?: Maybe<Scalars['Date']['output']>;
  dateSendScoreProjectNto?: Maybe<Scalars['Date']['output']>;
  firstName: Scalars['String']['output'];
  lastName: Scalars['String']['output'];
  middleName?: Maybe<Scalars['String']['output']>;
  scoreModuleAcc: Scalars['Float']['output'];
  scoreModuleNto: Scalars['Float']['output'];
  scoreProjectAcc: Scalars['Int']['output'];
  scoreProjectNto: Scalars['Int']['output'];
  stageGroupName: Scalars['String']['output'];
  statusScoreModule?: Maybe<Scalars['Boolean']['output']>;
  statusScoreProject?: Maybe<Scalars['Boolean']['output']>;
  talantId?: Maybe<Scalars['String']['output']>;
  userId: Scalars['UUID']['output'];
};

export type NtoScoreResponse = {
  __typename?: 'NtoScoreResponse';
  academicYear: Scalars['String']['output'];
  countUserActivities: Scalars['Int']['output'];
  data: Array<Maybe<NtoScore>>;
  schoolName: Scalars['String']['output'];
};

export type NtoSendScoreResponse = {
  __typename?: 'NtoSendScoreResponse';
  errorCount: Scalars['Int']['output'];
  errorEvents: Array<Maybe<Scalars['UUID']['output']>>;
  total: Scalars['Int']['output'];
};

export type NtoWidget = {
  __typename?: 'NtoWidget';
  scoreModuleAcc: Scalars['Float']['output'];
  scoreProjectAcc: Scalars['Int']['output'];
  status: Scalars['String']['output'];
  totalScoreNto: Scalars['Float']['output'];
};

export type Onboarding = {
  __typename?: 'Onboarding';
  /** Идентификатор шага в сценарии онбординга, на котором остановился юзер */
  currentStepId: Scalars['ID']['output'];
  /** Время завершения онбординга */
  finishedTs?: Maybe<Scalars['DateTime']['output']>;
  /** Завершил ли юзер сценарий онбординга */
  isFinished: Scalars['Boolean']['output'];
  /** Статус связывания УЗ */
  isLinkedSuccess?: Maybe<Scalars['Boolean']['output']>;
  onboardingId: Scalars['ID']['output'];
  /** Тип онбординга */
  onboardingType?: Maybe<OnboardingType>;
  /** Идентификатор сценария онбординга */
  scriptId: Scalars['ID']['output'];
};

/** Тип онбординга */
export enum OnboardingType {
  /** Онбординг конфигуратора системы */
  BaOnboarding = 'BA_ONBOARDING',
  /** Онбординг для показа уведомления о проверке рекомендуемой оценки в Проверке Заданий Учителем */
  CheckMark = 'CHECK_MARK',
  /** Онбродинг для показа уведомления о подтверждении оценивания в Проверке Заданий Учителем */
  ConfirmCheck = 'CONFIRM_CHECK',
  /** Онбординг критериального оценивания */
  Criterial = 'CRITERIAL',
  /** Онбординг для критериального оценивания (модальное окно) */
  CriterialModal = 'CRITERIAL_MODAL',
  /** Онбординг для показа уведомления о добавлении информации по ЭЖД в Проверке Заданий Учителем */
  EjInfo = 'EJ_INFO',
  /** Онбординг иннополиса */
  InnoOnboarding = 'INNO_ONBOARDING',
  /** Онбординг для показа уведомлений об успешном связывании SberID */
  SberidLinked = 'SBERID_LINKED',
  /** Онбординг для тренажёров */
  Training = 'TRAINING'
}

/** Информация по возвращенному календарному событию */
export type OnlineCalendarEvent = {
  __typename?: 'OnlineCalendarEvent';
  /** Признак активности события */
  active: Scalars['Boolean']['output'];
  /** Признак события на весь день */
  allDayEvent: Scalars['Boolean']['output'];
  /** Файл для календаря пользователя в формате Base64 */
  base64Data?: Maybe<Scalars['String']['output']>;
  /** Категория события */
  calendarEventCategory?: Maybe<CalendarEventCategory>;
  /** Время создания события */
  createdTs: Scalars['DateTime']['output'];
  /** Идентификатор пользователя (userId), создавшего событие */
  creatorId: Scalars['UUID']['output'];
  /** Описание события */
  description?: Maybe<Scalars['String']['output']>;
  /** Дата и время окончания события */
  endTime: Scalars['DateTime']['output'];
  /** Тип календарного события */
  eventType: CalendarEventType;
  /** Имя файла для передачи пользователю */
  fileName?: Maybe<Scalars['String']['output']>;
  /**
   * Тип пользовательской группы участников события
   * @deprecated Have to be changed into nullable field, use participantGroupTypeId field instead. Will be removed in r/32.0.0 version
   */
  groupTypeId: Scalars['Int']['output'];
  /** Идентификатор события */
  id: Scalars['UUID']['output'];
  /** Место проведения/ссылка на онлайн событие */
  location: Scalars['String']['output'];
  /** Время модификации события */
  modifiedTs?: Maybe<Scalars['DateTime']['output']>;
  /** Наименование события */
  name: Scalars['String']['output'];
  /**
   * Идентификатор основного повторяющегося события (CalendarEvent#id)
   * для события-исключения из правила
   */
  parentCalendarEventId?: Maybe<Scalars['UUID']['output']>;
  /** Тип пользовательской группы участников события */
  participantGroupTypeId?: Maybe<Scalars['Int']['output']>;
  /** Участники события */
  participants: Array<CalendarEventParticipant>;
  /** До какого числа действует правило для повторяющегося события */
  recurrenceEndTs?: Maybe<Scalars['DateTime']['output']>;
  /** Правило для повторяющегося события */
  recurrenceRule?: Maybe<Scalars['String']['output']>;
  /** Дата и время начала события */
  startTime: Scalars['DateTime']['output'];
};

/** Используют Accelerator. Событие в календе, без поддержания правил повторения. */
export type OnlineCalendarEventInput = {
  /** Признак активности события */
  active: Scalars['Boolean']['input'];
  /** Описание события */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Дата и время окончания события */
  endTime: Scalars['DateTime']['input'];
  /** Тип события (например: 5 - Мои события) */
  eventTypeId: Scalars['Int']['input'];
  /** Признак необходимости выгрузить для пользовательского календаря событие */
  exportICalendar?: InputMaybe<Scalars['Boolean']['input']>;
  /**
   * Идентификатор типа пользовательской группы,
   * которые могут быть участниками события (например: 2 - индивидуальная группа пользователей)
   */
  groupTypeId: Scalars['Int']['input'];
  /** Идентификатор события */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Место проведения/ссылка на онлайн событие */
  location: Scalars['String']['input'];
  /** Наименование события */
  name: Scalars['String']['input'];
  /** Идентификатор пользовательной группы организатора события */
  organizerGroupId?: InputMaybe<Scalars['UUID']['input']>;
  /** Дата и время начала события */
  startTime: Scalars['DateTime']['input'];
};

/** Онлайн-урок */
export type OnlineLessonToLessonPlan = {
  __typename?: 'OnlineLessonToLessonPlan';
  /** Идентификатор плана урока */
  lessonPlanId: Scalars['ID']['output'];
  /** Идентификатор онлайн-урока(timetableId) */
  onlineLessonId: Scalars['ID']['output'];
  /** Ссылка на онлайн-урок */
  onlineLessonLink: Scalars['String']['output'];
  /** Тип видеоконференции для онлайн урока */
  videoconferenceType: VideoconferenceType;
};

export type OnlineLessonToLessonPlanInput = {
  lessonPlanId?: InputMaybe<Scalars['ID']['input']>;
  onlineLessonId?: InputMaybe<Scalars['ID']['input']>;
  onlineLessonLink: Scalars['String']['input'];
  videoconferenceType: VideoconferenceType;
};

export type OnlineReview = {
  __typename?: 'OnlineReview';
  /** Флаг показывающий тип онлайн/офлайн */
  isOnline: Scalars['Boolean']['output'];
  /** Информация о видеозаписях проверки */
  videos?: Maybe<Array<OnlineReviewVideo>>;
};

export type OnlineReviewVideo = {
  __typename?: 'OnlineReviewVideo';
  /** Размер файла */
  fileSize: Scalars['Int']['output'];
  /** Ссылка на видеозапись проверки */
  link: Scalars['String']['output'];
  /** Идентификатор видео */
  onlineVideoId: Scalars['ID']['output'];
  /** Статус загрузки */
  status: StudyProcessFileStatusEnum;
  /** Описание статуса */
  statusDetails?: Maybe<Scalars['String']['output']>;
  /** Дата создания/обновления */
  updateDateTime: Scalars['DateTime']['output'];
};

export type OrgUnit = {
  __typename?: 'OrgUnit';
  /** Идентификатор образовательного учреждения */
  id: Scalars['UUID']['output'];
  /** Наименование образовательного учреждения */
  name: Scalars['String']['output'];
};

/** уровни тенантов */
export enum OrganizationHierarchyType {
  /** образовательные учреждения */
  EducationalInstitution = 'EDUCATIONAL_INSTITUTION',
  /** глобальные */
  Global = 'GLOBAL',
  /** продуктовые */
  Product = 'PRODUCT'
}

export enum OrganizationType {
  Acc = 'ACC',
  Bootcamp = 'BOOTCAMP',
  Educont = 'EDUCONT',
  School = 'SCHOOL',
  School21 = 'SCHOOL21',
  University = 'UNIVERSITY',
  Unknown = 'UNKNOWN'
}

export type OrganizationUnit = {
  __typename?: 'OrganizationUnit';
  /** Полное название орг.единицы */
  fullName: Scalars['String']['output'];
  /** Ид организационной единицы */
  id: Scalars['UUID']['output'];
  /** Необязательный параметр. Для школы - идентификатор, для других орг.единиц не определён */
  identifier?: Maybe<Scalars['String']['output']>;
  /** Короткое название орг.единицы */
  shortName: Scalars['String']['output'];
  /** Тип организационной единицы */
  type: OrganizationUnitType;
};

export enum OrganizationUnitType {
  EducationalInstitution = 'EDUCATIONAL_INSTITUTION',
  Global = 'GLOBAL',
  Product = 'PRODUCT'
}

export type OverallProgress = {
  __typename?: 'OverallProgress';
  /** Прогресс в процентах */
  percentProgress: PercentProgressInfo;
  /** Прогресс в баллах */
  progress: ProgressInfo;
};

/** Общая статистика посещаемости */
export type OverallVisitStat = {
  __typename?: 'OverallVisitStat';
  /** Общее кол-во уроков */
  lessonsNumber: Scalars['Int']['output'];
  /** Кол-во пропущенных уроков */
  missedLessons: Scalars['Int']['output'];
  /** Процент пропуска уроков */
  missedPercentage: Scalars['Float']['output'];
};

/** Информация о проверках проекта */
export type P2PChecksInfo = {
  __typename?: 'P2PChecksInfo';
  /** Количество PRP, требуемое для проверки проекта */
  cookiesCount: Scalars['Int']['output'];
  /** Продолжительность проверки проекта */
  periodOfVerification: Scalars['Int']['output'];
  /** Информация о количестве проверок в проекте */
  projectReviewsInfo: ProjectReviewsInfo;
};

/** Информация о p2p проверке по проекту */
export type P2PEvaluationInfo = {
  __typename?: 'P2PEvaluationInfo';
  /** Заполненный чеклист, если проверка была проведена */
  checklist?: Maybe<FilledChecklist>;
  /** Статус проверки */
  status: ProjectEvaluationStatus;
};

export type P2pCheckDetailInfo = {
  __typename?: 'P2pCheckDetailInfo';
  /** Протокол подсчета оценки за p2p (json) */
  assessmentProtocolMeta?: Maybe<Scalars['String']['output']>;
  /** Версия протокола подсчета оценки за p2p */
  assessmentProtocolVersion?: Maybe<Scalars['Int']['output']>;
  /** Комментарий к чек-листу */
  comment?: Maybe<Scalars['String']['output']>;
  /** Идентификатор заполненного чек-листа */
  filledChecklistId: Scalars['ID']['output'];
  /** Информация о видеозаписи проверки */
  onlineReview: OnlineReview;
  /** Проверяющий пользователь */
  verifier: User;
};

/** Информация о p2p блоке проверок */
export type P2pCheckInfo = {
  __typename?: 'P2pCheckInfo';
  /** Формула p2p. Может быть null, если формула на момент завершения проверки не сохранялась */
  formula?: Maybe<P2pFormulasType>;
  /** Экземпляры P2p-проверок */
  p2pInstances: Array<P2pInstance>;
  /** Требуемое количество проверок. Может быть null, если формула на момент завершения проверки не сохранялась */
  requiredCheckCount?: Maybe<Scalars['Int']['output']>;
};

/** Общая статистика по слотам студента */
export type P2pCommonStatistic = {
  __typename?: 'P2pCommonStatistic';
  /** Общее количество созданных слотов */
  eventCount: Scalars['Int']['output'];
  /** Общее количество назначенных, но не завершенных проверок */
  scheduledNotCompletedCheck: Scalars['Int']['output'];
  /** Общее количество назначенных проверок, на которые проверяющий не явился */
  scheduledVerifierIsAbsenceCheck: Scalars['Int']['output'];
  /** Общее количество успешно завершенных проверок */
  successfullyCompletedCheck: Scalars['Int']['output'];
  /** Общее количество времени, занятое записью на проверку */
  timeWithCheck: Scalars['Int']['output'];
  /** Общее количество времени, не занятое записью на проверку */
  timeWithoutCheck: Scalars['Int']['output'];
};

export enum P2pFormulasType {
  Avg = 'AVG',
  Max = 'MAX',
  Min = 'MIN'
}

/** Данные для одного часа тепловой карты */
export type P2pHeatCoeffByDayOfWeekByHour = {
  __typename?: 'P2pHeatCoeffByDayOfWeekByHour';
  /** День недели от 1 до 7, где 1 - Понедельник */
  dayOfWeekNumber: Scalars['Int']['output'];
  /** Коэффициент интенсивности цвета на тепловой карте в указанный день и час (от 0 до 5) */
  heatCoefficient: Scalars['Int']['output'];
  /** Конкретный час выбранного дня недели */
  hourOfDay: Scalars['Int']['output'];
};

/** Данные для тепловой карты по статистике событий студента */
export type P2pHeatMapWithMean = {
  __typename?: 'P2pHeatMapWithMean';
  /** Набор значений коэффициентов тепловой карты по дням недели и часам */
  heatCoeffByDayOfWeekByHour: Array<P2pHeatCoeffByDayOfWeekByHour>;
  /** Среднее значение минут в таймслотах */
  meanMinutes: Scalars['Int']['output'];
};

/** Данные для тепловой карты по статистике событий студента */
export type P2pHeatMapWithMedian = {
  __typename?: 'P2pHeatMapWithMedian';
  /** Набор значений коэффициентов тепловой карты по дням недели и часам */
  heatCoeffByDayOfWeekByHour: Array<P2pHeatCoeffByDayOfWeekByHour>;
  /** Медиана минут в событиях */
  medianMinutes: Scalars['Int']['output'];
};

/** Модель экземпляра p2p-проверки */
export type P2pInstance = {
  __typename?: 'P2pInstance';
  /** Тип проверки */
  checkType: FilledChecklistCheckType;
  /** Идентификатор заполненного чек-листа */
  id: Scalars['ID']['output'];
  /** Флаг - была ли проведена проверка */
  isCompleted: Scalars['Boolean']['output'];
  /** Набранный при проверке процент */
  receivedPercentage?: Maybe<Scalars['Int']['output']>;
  /** Дата и время начала проверки */
  resultDate: Scalars['DateTime']['output'];
  /** Логин проверяющего студента */
  reviewerLogin: Scalars['String']['output'];
};

export type PagingInput = {
  limit: Scalars['Int']['input'];
  offset: Scalars['Int']['input'];
};

export type ParamValue = {
  __typename?: 'ParamValue';
  description: Scalars['String']['output'];
  name: Scalars['String']['output'];
  val?: Maybe<Scalars['String']['output']>;
  value: Scalars['String']['output'];
};

export type ParentMutation = {
  __typename?: 'ParentMutation';
  /** Создать факты прочтения комментариев */
  createTaskMessageReadFacts: Array<TaskMessageReadFact>;
};


export type ParentMutationCreateTaskMessageReadFactsArgs = {
  messageIds: Array<Scalars['ID']['input']>;
};

/** Информация о родителе для публичных профилей */
export type ParentPublicData = {
  __typename?: 'ParentPublicData';
  avatarUrl?: Maybe<Scalars['String']['output']>;
  firstName: Scalars['String']['output'];
  lastName: Scalars['String']['output'];
  middleName?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
};

/** Публичный профиль родителя */
export type ParentPublicProfile = {
  __typename?: 'ParentPublicProfile';
  avatarUrl?: Maybe<Scalars['String']['output']>;
  children: Array<StudentPublicProfile>;
  contacts: Array<ContactData>;
  firstName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  lastName: Scalars['String']['output'];
  middleName?: Maybe<Scalars['String']['output']>;
  work?: Maybe<Scalars['String']['output']>;
};

export type ParentQueries = {
  __typename?: 'ParentQueries';
  /** Отчет "Успеваемость по эл.журналу" выгрузка в Excel успеваемости по аттестационным периодам */
  downloadChildAcademicPerformanceByAttestationPeriodExpandedExcel: ReportExcelFile;
  /** Статистика. Успеваемость ученика для родителей. Выгрузка в Excel */
  downloadChildAcademicPerformanceExcel: ReportExcelFile;
  /**
   * Статистика. Успеваемость ученика для родителе расширенная. Выгрузка в Excel.
   * @deprecated Под удаление. EDU-48885
   */
  downloadChildAcademicPerformanceExpandedExcel: ReportExcelFile;
  /** Отчет "Успеваемость по аттестационным периодам" выгрузка в Excel успеваемости по модулям за год */
  downloadChildModulePerformanceByAttestationPeriodExcel: ReportExcelFile;
  /** Отчет "Успеваемость по эл.журналу" выгрузка в Excel успеваемости по модулям за год */
  downloadChildModulePerformanceExcel: ReportExcelFile;
  /** Отчет "Успеваемость по эл.журналу" выгрузка в Excel */
  downloadStudentJournalPerformanceExcel: ReportExcelFile;
  /** Отчет "Итоговые оценки. Детальный" с датами Выгрузка в Excel */
  downloadStudentsMarksResultDetailedExcel: ReportExcelFile;
  /** Возвращает список академических лет школы. Если не передать schoolId, выдаст по текущей */
  getAcademicYears: Array<AcademicYear>;
  /** Возвращает агрегированные данные для диаграммы Радар (Паутинка) */
  getAggregatedStudentRadarChartData: AggregatedStudentRadarChart;
  getAllPlannedModules: Array<StudentModule>;
  getAvatarHistoryById: Array<UserAvatarHistory>;
  getAwardHistories: Array<UserAwardHistory>;
  getAwardHistoryById: Array<UserAwardHistory>;
  getBadgeHistories: Array<UserBadgeAwardHistory>;
  getBadgeHistoryById: Array<UserBadgeAwardHistory>;
  getBadges?: Maybe<Array<UserBadgeAward>>;
  /** Получение одноклассников детей, у которых день рождения в переданную дату */
  getBirthdayClassmates: Array<User>;
  getCalendar: Calendar;
  /**
   * Статистика. Успеваемость ученика для родителей
   * @deprecated Использовать getChildAcademicPerformanceExpandedV2
   */
  getChildAcademicPerformance: Array<StudentAcademicPerformance>;
  /** Отчет "Успеваемость" по Аттестационным периодам */
  getChildAcademicPerformanceByAttestationPeriod: Array<StudentAcademicPerformance>;
  /** Отчет "Успеваемость" по Аттестационным периодам расширенный */
  getChildAcademicPerformanceByAttestationPeriodExpanded: Array<StudentAcademicPerformanceExpandedV2>;
  getChildAcademicPerformanceExpanded: Array<StudentAcademicPerformanceExpanded>;
  getChildAcademicPerformanceExpandedV2: Array<StudentAcademicPerformanceExpandedV2>;
  /** Отчет "Успеваемость по эл.журналу" */
  getChildJournalPerformance: Array<StudentJournalPerformance>;
  /** Получение информации о плановых и фактических трудозатратах студента и его прогрессе за текущий учебный период */
  getChildPerformanceDetails: StudentPerformanceDetails;
  getChildProfile: Student;
  /** Возвращает информацию о Гибких навыках с примерами заданий ученика */
  getChildSoftSkillsAbout: Array<StudentSoftSkillAbout>;
  /** Получение информации о состоянии прогресса ученика по предмету */
  getChildSubjectProgressState: StudentSubjectProgressState;
  /**
   * Получение детальной информации о состоянии прогресса ученика по предмету (с понедельным планом или детальной информацией по цели)
   * Выводится детальная информация о цели по отстающему предмету в случае ее наличия или понедельный план с данными по заданиям
   */
  getChildSubjectProgressStateWithDetails: StudentSubjectProgressState;
  /** Возвращает лист родителей одноклассников ребенка */
  getClassParent: Array<Maybe<ParentPublicProfile>>;
  /** Возвращает количество непрочитанных текущим пользователем комментариев по заданию. Комментарии пользователя не учитываются */
  getCountUnreadMessages: Scalars['Int']['output'];
  getCurrentAcademicYearStudyPeriods: Array<StudyPeriod>;
  /** Возвращает информацию о Предметах Ученика в рамках данного Учебного Года */
  getCurrentAcademicYearSubjects: AcademicYearSubjects;
  /** Возвращает урок в контексте конкретного студента с сокращенной персональной информацией. */
  getCurrentStudentLesson: StudentLessonCompact;
  getCurrentTasksForCalendar: Array<StudentTask>;
  getDaySchedule: Array<Event>;
  /** Аналог getNotifications возвращающий только те нотификации, которые имеют привязку к предмету */
  getDeckWidgetNotificationsByTypes: Array<DeckWidgetNotification>;
  /** Аналог getNotifications возвращающий только те нотификации, которые имеют привязку к предмету и текущему учебному году */
  getDeckWidgetNotificationsForCurrentAcademicYear: Array<DeckWidgetNotification>;
  getExperience: UserExperience;
  getExperienceHistory: Array<Maybe<UserExperienceHistory>>;
  /** Возвращает информацию о не завершенных в сорк Домашних Работах ученика */
  getExpiredStudentHomeworks: ExpiredStudentHomeworksInfo;
  getGridOfModulesBySubjectID: Array<StudentModule>;
  getGridOfModulesBySubjectIDAndStudyPeriodIds: Array<StudentModule>;
  /**
   * Возвращает информацию о Домашней Работе Ученика или null в случае,
   * когда Домашняя Работа не содержит доступных в данный момент для данного Ученика заданий, или текстовой заметки
   */
  getHomeworkInfoById?: Maybe<HomeworkInfo>;
  getLastBadges: Array<UserBadgeAward>;
  getLastUserAwards: Array<UserAward>;
  /** Возвращает заметки к уроку для ученика на следующий учебный день (может совпадать с переданной датой) */
  getLessonNotesForNextSchoolDay: Array<LessonNoteExtended>;
  /**
   * Получение статистики для dashboard (виджет Чанки-Лайт) на дату.
   * Если дата null, то на текущую дату
   * Если userId null, то для текущего пользователя
   */
  getLightTaskStatistics?: Maybe<StudentTaskLightStatisticsModel>;
  getModuleById: StudentModule;
  getModules: Array<StudentModulesInSubjectContext>;
  /** Возвращает информацию о текущих и завершенных Домашних Работах ученика */
  getNonExpiredStudentHomeworks: NonExpiredStudentHomeworksInfo;
  getNotifications: Array<Notification>;
  getNotificationsCount: Scalars['Int']['output'];
  /** Получить родителей ребёнка */
  getParentsByChildId: Array<User>;
  /** Возвращает Персональную Контрольную Работу по идентификатору для ребенка */
  getPersonalControlWorkById: PersonalControlWork;
  getPersonalTrajectory?: Maybe<PersonalTrajectory>;
  getPlaylist: Playlist;
  /** Возвращает список Уведомлений ученика, по его заданиям */
  getRecentStudentTaskNotifications: RecentTaskNotifications;
  getSchedule: Schedule;
  /** набор оценок, принятых в школе */
  getSchoolMarks: Array<SchoolMark>;
  getSoftSkillTypeProgress: Array<UserSoftSkillTypeProgress>;
  /** Возвращает результаты по тестам с начала года и с конца, сгруппировав по софт скилам */
  getStudentAssessmentsTestsResults: SelfAssessmentAllTestsResults;
  /** Получение посещаемости студента */
  getStudentAttendance: Array<Maybe<StudentAttendanceBySubject>>;
  /** Получить классные и домашние работы по id урока */
  getStudentCurrentLessonCWorkHWorkByLessonId: StudentCurrentLessonCWorkHWork;
  getStudentDashboard: StudentDashboard;
  /** Неагрегированый вариант getStudentDashboard */
  getStudentDashboardParts: StudentDashboard;
  /** Возвращает данные для построения дневника ученика */
  getStudentDiary: StudentDiary;
  /** Возвращает данные для построения дневника ученика за период с учетом временной зоны */
  getStudentDiaryByPeriod: StudentDiary;
  /**
   * Запрос наиболее длительной домашней работы из дневника за период.
   * Если возвращает null, значит нет длительной домашней работы.
   * Длительная домашняя работы та, у которой время выполнения более 20 минут.
   */
  getStudentDiaryLengthyHomework?: Maybe<StudentDiaryLengthyHomework>;
  /** Получение реальной оценки трудоемкости задания */
  getStudentEffortEstimation?: Maybe<StudentEffortEstimation>;
  /** Получить фидбек ребёнка по опредлённому заданию или null если его нет */
  getStudentFeedback?: Maybe<Feedback>;
  /** Получение рефлексии по итогам модуля */
  getStudentGoalReflection: StudentGoalReflection;
  /** Загрузить информацию о итогах модуля. */
  getStudentGoalSummary: StudentGoalSummary;
  /** Возвращает урок в контексте конкретного студента с персональной информацией. */
  getStudentLessonById: StudentLesson;
  /** Данные для виджета оценок ученика(Лайт) */
  getStudentLightMarks?: Maybe<Array<StudentLightMarkModel>>;
  /** Получение Персональных Целей ученика с определёнными статусами */
  getStudentPersonalObjectivesByStatuses: Array<PersonalObjective>;
  /** Получение цели по ее id */
  getStudentPersonalObjectivesDetailedById?: Maybe<PersonalObjective>;
  getStudentPersonalObjectivesDetailedByStatuses: Array<PersonalObjective>;
  /** PMO Возвращает итоговую оценку ученика по предмету для учебных периодов */
  getStudentPmoStudyPeriodFinalMark: Array<Maybe<StudentStudyPeriodFinalMark>>;
  /** Возвращает данные для диаграммы Радар (Паутинка) */
  getStudentRadarChartData: Array<StudentRadarChart>;
  /** Данные для виджет Рейтинг ученика */
  getStudentRating: Array<Maybe<StudentRatingBySubjectModel>>;
  /** Возвращает агрегированные данные по навыкам для диаграммы Радар (Паутинка) */
  getStudentSkillRadarChartData: AggregatedSkillStudentRadarChart;
  /** Возвращает класс ребенка */
  getStudentStageGroup?: Maybe<StageGroup>;
  /** Вернуть всю персональную информацию по предмету ученика */
  getStudentStageSubjectBySubjectId: StudentStageSubject;
  /** Возвращает изучаемые предметы с персональной информацией родителю по идентификатору ребенка исходя из текущей даты */
  getStudentStageSubjects: Array<StudentStageSubject>;
  /** Возвращает итоговую оценку ученика по предмету для учебных периодов */
  getStudentStudyPeriodFinalMark: Array<Maybe<StudentStudyPeriodFinalMark>>;
  /** Получение успеваемости ребенка по периодам */
  getStudentStudyPeriodsPerformance: Array<StudentStudyPeriodsPerformanceResponse>;
  /** Вернуть данные по прогрессу рубенка до указанной даты */
  getStudentSubjectInfo: Array<StudentStageSubject>;
  /** Возвращает Задания в контексте студента по фильтрам */
  getStudentTasks: GetStudentTasksResponse;
  /** Возвращает Задания и нотификации о взаимопроверках в контексте студента по фильтрам */
  getStudentTasksByFilters: GetStudentTasksDashboardResponse;
  /** Получение задач ребенка по идентификаторам задач */
  getStudentTasksByIds?: Maybe<Array<Maybe<StudentTask>>>;
  /** Возвращает Задания в контексте студента по фильтрам */
  getStudentTasksByTaskStatus: GetStudentTasksResponse;
  /** Получить список заданий с трудоемкостью и гибкими навыками для попапа на странице "Предметы" */
  getStudentTasksForCurrentModulePopup: Array<StudentModuleWithTasksModel>;
  /** Получение всей информации для градусников ПМО */
  getStudentThermometerPMO?: Maybe<StudentThermometerPmo>;
  /** Возвращает полную информацию о студенте по userId */
  getStudentsInfo: Array<Student>;
  getStudentsMarksSubjectsDetailed: StudentFinalMarkSubjectsModel;
  /** Отчет "Итоговые оценки. Детальный" по ученику и всем предметам с датами */
  getStudentsMarksSubjectsDetailedByDates: StudentFinalMarkSubjectsModel;
  /** Получение данных для виджета Градусник Light */
  getSubjectsFinalMarks: Array<Maybe<SubjectFinalMarkModel>>;
  /** Вернуть предметы изучаемые учеником в текущем учебном году для урока на заданную дату */
  getSubjectsForLesson: Array<StudentStageSubject>;
  /** Получить желаемый целевой уровень модуля */
  getTargetGoalLevel?: Maybe<StudentTargetGoalLevel>;
  /** получение списка отправленных ответов на задание ребенка */
  getTaskAnswers: Array<StudentAnswer>;
  /** Получение всех возможных критериев */
  getTaskCriteria: Array<Criteria>;
  /** Получить соответствия критериям */
  getTaskCriteriaValues: Array<StudentCriteriaValue>;
  getTaskMessages: Array<TaskMessage>;
  /**
   * Получение статистики по заданиям для dashboard (виджет Чанки-ПМО) облегченная версия метода,
   * возвращает только идентификаторы заданий вместо самих заданий
   */
  getTaskStatisticsIds?: Maybe<StudentTaskPmoStatisticsLightweightModel>;
  getTasksByIds?: Maybe<Array<Maybe<StudentTask>>>;
  getUserAwards: Array<UserAward>;
};


export type ParentQueriesDownloadChildAcademicPerformanceByAttestationPeriodExpandedExcelArgs = {
  childUserId: Scalars['UUID']['input'];
  closeModuleDate: Scalars['Date']['input'];
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  reportDateTime: Scalars['String']['input'];
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type ParentQueriesDownloadChildAcademicPerformanceExcelArgs = {
  childUserId: Scalars['UUID']['input'];
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  reportDateTime: Scalars['String']['input'];
  startDate: Scalars['DateTime']['input'];
};


export type ParentQueriesDownloadChildAcademicPerformanceExpandedExcelArgs = {
  childUserId: Scalars['UUID']['input'];
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  reportDateTime: Scalars['String']['input'];
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type ParentQueriesDownloadChildModulePerformanceByAttestationPeriodExcelArgs = {
  childUserId: Scalars['UUID']['input'];
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  reportDateTime: Scalars['String']['input'];
  startDate: Scalars['DateTime']['input'];
};


export type ParentQueriesDownloadChildModulePerformanceExcelArgs = {
  childUserId: Scalars['UUID']['input'];
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  reportDateTime: Scalars['String']['input'];
  startDate: Scalars['DateTime']['input'];
};


export type ParentQueriesDownloadStudentJournalPerformanceExcelArgs = {
  studentJournalPerformanceExcelInput: StudentJournalPerformanceExcelInput;
};


export type ParentQueriesDownloadStudentsMarksResultDetailedExcelArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  childUserId?: InputMaybe<Scalars['UUID']['input']>;
  currentRole?: InputMaybe<Scalars['String']['input']>;
  periodEndDate: Scalars['Date']['input'];
  periodStartDate: Scalars['Date']['input'];
  reportDateTime: Scalars['String']['input'];
};


export type ParentQueriesGetAcademicYearsArgs = {
  schoolId?: InputMaybe<Scalars['ID']['input']>;
};


export type ParentQueriesGetAggregatedStudentRadarChartDataArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  childUserId: Scalars['UUID']['input'];
  studyPeriodId?: InputMaybe<Scalars['ID']['input']>;
};


export type ParentQueriesGetAllPlannedModulesArgs = {
  childUserId: Scalars['ID']['input'];
};


export type ParentQueriesGetAvatarHistoryByIdArgs = {
  avatarId: Scalars['ID']['input'];
  childUserId: Scalars['ID']['input'];
};


export type ParentQueriesGetAwardHistoriesArgs = {
  childUserId: Scalars['ID']['input'];
};


export type ParentQueriesGetAwardHistoryByIdArgs = {
  awardId: Scalars['ID']['input'];
  childUserId: Scalars['ID']['input'];
};


export type ParentQueriesGetBadgeHistoriesArgs = {
  childUserId: Scalars['ID']['input'];
};


export type ParentQueriesGetBadgeHistoryByIdArgs = {
  badgeId: Scalars['ID']['input'];
  childUserId: Scalars['ID']['input'];
};


export type ParentQueriesGetBadgesArgs = {
  userId: Scalars['ID']['input'];
};


export type ParentQueriesGetBirthdayClassmatesArgs = {
  filterBirthday: Scalars['Date']['input'];
};


export type ParentQueriesGetCalendarArgs = {
  childUserId: Scalars['ID']['input'];
  weekEnd: Scalars['String']['input'];
  weekStart: Scalars['String']['input'];
};


export type ParentQueriesGetChildAcademicPerformanceArgs = {
  childUserId: Scalars['UUID']['input'];
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type ParentQueriesGetChildAcademicPerformanceByAttestationPeriodArgs = {
  childUserId: Scalars['UUID']['input'];
  closeModuleDate: Scalars['Date']['input'];
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type ParentQueriesGetChildAcademicPerformanceByAttestationPeriodExpandedArgs = {
  childUserId: Scalars['UUID']['input'];
  closeModuleDate: Scalars['Date']['input'];
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type ParentQueriesGetChildAcademicPerformanceExpandedArgs = {
  childUserId: Scalars['UUID']['input'];
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  startDate: Scalars['DateTime']['input'];
};


export type ParentQueriesGetChildAcademicPerformanceExpandedV2Args = {
  childUserId: Scalars['UUID']['input'];
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type ParentQueriesGetChildJournalPerformanceArgs = {
  childUserId: Scalars['UUID']['input'];
  stageId: Scalars['Int']['input'];
  studyPeriodId: Scalars['Int']['input'];
};


export type ParentQueriesGetChildPerformanceDetailsArgs = {
  childUserId: Scalars['ID']['input'];
};


export type ParentQueriesGetChildProfileArgs = {
  userId: Scalars['ID']['input'];
};


export type ParentQueriesGetChildSoftSkillsAboutArgs = {
  childUserId: Scalars['ID']['input'];
};


export type ParentQueriesGetChildSubjectProgressStateArgs = {
  childUserId: Scalars['ID']['input'];
  subjectId: Scalars['ID']['input'];
};


export type ParentQueriesGetChildSubjectProgressStateWithDetailsArgs = {
  childUserId: Scalars['ID']['input'];
  subjectId: Scalars['ID']['input'];
};


export type ParentQueriesGetClassParentArgs = {
  childUserId: Scalars['UUID']['input'];
};


export type ParentQueriesGetCountUnreadMessagesArgs = {
  studentId: Scalars['UUID']['input'];
  taskId: Scalars['ID']['input'];
};


export type ParentQueriesGetCurrentAcademicYearStudyPeriodsArgs = {
  childUserId: Scalars['ID']['input'];
};


export type ParentQueriesGetCurrentAcademicYearSubjectsArgs = {
  childUserId: Scalars['ID']['input'];
};


export type ParentQueriesGetCurrentStudentLessonArgs = {
  childUserId: Scalars['UUID']['input'];
  lessonId: Scalars['ID']['input'];
};


export type ParentQueriesGetCurrentTasksForCalendarArgs = {
  childUserId: Scalars['ID']['input'];
};


export type ParentQueriesGetDayScheduleArgs = {
  childUserId: Scalars['ID']['input'];
  date: Scalars['String']['input'];
};


export type ParentQueriesGetDeckWidgetNotificationsByTypesArgs = {
  childUserId: Scalars['ID']['input'];
  paging?: InputMaybe<PagingInput>;
  typeIds: Array<Scalars['ID']['input']>;
  wasReadIncluded?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ParentQueriesGetDeckWidgetNotificationsForCurrentAcademicYearArgs = {
  childUserId: Scalars['ID']['input'];
  paging?: InputMaybe<PagingInput>;
  typeIds: Array<Scalars['ID']['input']>;
  wasReadIncluded?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ParentQueriesGetExperienceArgs = {
  userId: Scalars['ID']['input'];
};


export type ParentQueriesGetExperienceHistoryArgs = {
  userId: Scalars['ID']['input'];
};


export type ParentQueriesGetExpiredStudentHomeworksArgs = {
  childUserId: Scalars['ID']['input'];
  paging: PagingInput;
  sorting: Array<SortingField>;
  subjectId?: InputMaybe<Scalars['ID']['input']>;
};


export type ParentQueriesGetGridOfModulesBySubjectIdArgs = {
  childUserId: Scalars['ID']['input'];
  subjectId: Scalars['ID']['input'];
};


export type ParentQueriesGetGridOfModulesBySubjectIdAndStudyPeriodIdsArgs = {
  childUserId: Scalars['ID']['input'];
  studyPeriodIds: Array<Scalars['Int']['input']>;
  subjectId: Scalars['ID']['input'];
};


export type ParentQueriesGetHomeworkInfoByIdArgs = {
  childUserId: Scalars['ID']['input'];
  homeworkId?: InputMaybe<Scalars['ID']['input']>;
};


export type ParentQueriesGetLastBadgesArgs = {
  limit: Scalars['Int']['input'];
  userId: Scalars['ID']['input'];
};


export type ParentQueriesGetLastUserAwardsArgs = {
  awardType?: InputMaybe<AwardTypeEnum>;
  limit: Scalars['Int']['input'];
  userId: Scalars['ID']['input'];
};


export type ParentQueriesGetLessonNotesForNextSchoolDayArgs = {
  childUserId: Scalars['ID']['input'];
  lessonsDate: Scalars['Date']['input'];
};


export type ParentQueriesGetLightTaskStatisticsArgs = {
  atDate?: InputMaybe<Scalars['Date']['input']>;
  childUserId?: InputMaybe<Scalars['UUID']['input']>;
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
};


export type ParentQueriesGetModuleByIdArgs = {
  childUserId: Scalars['ID']['input'];
  goalId: Scalars['ID']['input'];
};


export type ParentQueriesGetModulesArgs = {
  childUserId: Scalars['ID']['input'];
};


export type ParentQueriesGetNonExpiredStudentHomeworksArgs = {
  childUserId: Scalars['ID']['input'];
  deadlineFromDate: Scalars['Date']['input'];
  deadlineToDate: Scalars['Date']['input'];
  subjectId?: InputMaybe<Scalars['ID']['input']>;
};


export type ParentQueriesGetNotificationsArgs = {
  childUserId: Scalars['ID']['input'];
  paging?: InputMaybe<PagingInput>;
  wasReadIncluded?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ParentQueriesGetNotificationsCountArgs = {
  childUserId: Scalars['ID']['input'];
  wasReadIncluded?: InputMaybe<Scalars['Boolean']['input']>;
};


export type ParentQueriesGetParentsByChildIdArgs = {
  userId?: InputMaybe<Scalars['UUID']['input']>;
};


export type ParentQueriesGetPersonalControlWorkByIdArgs = {
  childUserId: Scalars['ID']['input'];
  personalControlWorkId: Scalars['ID']['input'];
};


export type ParentQueriesGetPersonalTrajectoryArgs = {
  childUserId: Scalars['ID']['input'];
  goalId?: InputMaybe<Scalars['ID']['input']>;
  taskId?: InputMaybe<Scalars['ID']['input']>;
};


export type ParentQueriesGetPlaylistArgs = {
  childUserId: Scalars['ID']['input'];
  goalId: Scalars['ID']['input'];
};


export type ParentQueriesGetRecentStudentTaskNotificationsArgs = {
  childUserId: Scalars['ID']['input'];
  notificationTypes: Array<NotificationEnum>;
  paging: PagingInput;
};


export type ParentQueriesGetScheduleArgs = {
  childUserId: Scalars['ID']['input'];
  lessonsFromDate: Scalars['Date']['input'];
  lessonsToDate: Scalars['Date']['input'];
  personalControlWorksFromTime: Scalars['DateTime']['input'];
  personalControlWorksToTime: Scalars['DateTime']['input'];
};


export type ParentQueriesGetSoftSkillTypeProgressArgs = {
  softSkillTypeId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};


export type ParentQueriesGetStudentAssessmentsTestsResultsArgs = {
  studentId: Scalars['ID']['input'];
};


export type ParentQueriesGetStudentAttendanceArgs = {
  currentPeriodId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
  studyPeriodIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  subjectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type ParentQueriesGetStudentCurrentLessonCWorkHWorkByLessonIdArgs = {
  childUserId: Scalars['UUID']['input'];
  lessonId: Scalars['ID']['input'];
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
};


export type ParentQueriesGetStudentDashboardArgs = {
  childUserId: Scalars['ID']['input'];
  date: Scalars['DateTime']['input'];
};


export type ParentQueriesGetStudentDashboardPartsArgs = {
  childUserId: Scalars['ID']['input'];
  date: Scalars['DateTime']['input'];
};


export type ParentQueriesGetStudentDiaryArgs = {
  childUserId: Scalars['UUID']['input'];
  fromDate: Scalars['Date']['input'];
  toDate: Scalars['Date']['input'];
};


export type ParentQueriesGetStudentDiaryByPeriodArgs = {
  childUserId: Scalars['UUID']['input'];
  fromDateTime: Scalars['DateTime']['input'];
  toDateTime: Scalars['DateTime']['input'];
};


export type ParentQueriesGetStudentDiaryLengthyHomeworkArgs = {
  childUserId?: InputMaybe<Scalars['ID']['input']>;
  fromDate: Scalars['Date']['input'];
  toDate: Scalars['Date']['input'];
};


export type ParentQueriesGetStudentEffortEstimationArgs = {
  childUserId: Scalars['UUID']['input'];
  studentTaskId: Scalars['ID']['input'];
};


export type ParentQueriesGetStudentFeedbackArgs = {
  childUserId: Scalars['UUID']['input'];
  taskId: Scalars['ID']['input'];
};


export type ParentQueriesGetStudentGoalReflectionArgs = {
  childUserId: Scalars['UUID']['input'];
  goalId: Scalars['ID']['input'];
};


export type ParentQueriesGetStudentGoalSummaryArgs = {
  childUserId: Scalars['ID']['input'];
  goalId: Scalars['ID']['input'];
};


export type ParentQueriesGetStudentLessonByIdArgs = {
  childUserId: Scalars['UUID']['input'];
  lessonId: Scalars['ID']['input'];
};


export type ParentQueriesGetStudentLightMarksArgs = {
  studentId: Scalars['ID']['input'];
  studyPeriodId: Scalars['ID']['input'];
};


export type ParentQueriesGetStudentPersonalObjectivesByStatusesArgs = {
  childUserId: Scalars['ID']['input'];
  statuses: Array<PersonalObjectiveStatusEnum>;
};


export type ParentQueriesGetStudentPersonalObjectivesDetailedByIdArgs = {
  childUserId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
};


export type ParentQueriesGetStudentPersonalObjectivesDetailedByStatusesArgs = {
  childUserId: Scalars['ID']['input'];
  statuses: Array<PersonalObjectiveStatusEnum>;
};


export type ParentQueriesGetStudentPmoStudyPeriodFinalMarkArgs = {
  childUserId: Scalars['UUID']['input'];
  studyPeriodIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  subjectId?: InputMaybe<Scalars['ID']['input']>;
};


export type ParentQueriesGetStudentRadarChartDataArgs = {
  atDate?: InputMaybe<Scalars['Date']['input']>;
  childUserId: Scalars['UUID']['input'];
};


export type ParentQueriesGetStudentRatingArgs = {
  childUserId?: InputMaybe<Scalars['UUID']['input']>;
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  studyPeriodIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  subjectIds: Array<InputMaybe<Scalars['ID']['input']>>;
};


export type ParentQueriesGetStudentSkillRadarChartDataArgs = {
  childUserId: Scalars['ID']['input'];
  softSkillId?: InputMaybe<Scalars['ID']['input']>;
};


export type ParentQueriesGetStudentStageGroupArgs = {
  childUserId: Scalars['ID']['input'];
};


export type ParentQueriesGetStudentStageSubjectBySubjectIdArgs = {
  childUserId: Scalars['UUID']['input'];
  currentDate: Scalars['Date']['input'];
  subjectId: Scalars['ID']['input'];
};


export type ParentQueriesGetStudentStageSubjectsArgs = {
  childUserId: Scalars['UUID']['input'];
  currentDate: Scalars['Date']['input'];
};


export type ParentQueriesGetStudentStudyPeriodFinalMarkArgs = {
  childUserId: Scalars['UUID']['input'];
  studyPeriodIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  subjectId?: InputMaybe<Scalars['ID']['input']>;
};


export type ParentQueriesGetStudentStudyPeriodsPerformanceArgs = {
  attestationPeriodIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  childUserId: Scalars['UUID']['input'];
  studyPeriodIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type ParentQueriesGetStudentSubjectInfoArgs = {
  childUserId: Scalars['UUID']['input'];
  currentDate: Scalars['Date']['input'];
};


export type ParentQueriesGetStudentTasksArgs = {
  childUserId: Scalars['UUID']['input'];
  moduleIds: Array<Scalars['ID']['input']>;
  paging: PagingInput;
  sorting: Array<SortingField>;
  stageSubjectGroupIds: Array<Scalars['ID']['input']>;
  statuses: Array<TaskStatusEnum>;
  studentIds: Array<Scalars['UUID']['input']>;
  subjectIds: Array<Scalars['ID']['input']>;
  taskTypes: Array<TaskTypeEnum>;
};


export type ParentQueriesGetStudentTasksByFiltersArgs = {
  checkTypes?: InputMaybe<Array<TaskCheckEnum>>;
  childUserId: Scalars['UUID']['input'];
  haveComments?: InputMaybe<Scalars['Boolean']['input']>;
  moduleDebt?: InputMaybe<Scalars['Boolean']['input']>;
  paging: PagingInput;
  sorting?: InputMaybe<Array<SortingField>>;
  statuses?: InputMaybe<Array<TaskStatusEnum>>;
  subjectIds: Array<Scalars['ID']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};


export type ParentQueriesGetStudentTasksByIdsArgs = {
  childUserId?: InputMaybe<Scalars['ID']['input']>;
  tasksIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type ParentQueriesGetStudentTasksByTaskStatusArgs = {
  childUserId?: InputMaybe<Scalars['ID']['input']>;
  paging: PagingInput;
  statuses: Array<TaskStatusEnum>;
};


export type ParentQueriesGetStudentTasksForCurrentModulePopupArgs = {
  childUserId: Scalars['UUID']['input'];
  currentDate: Scalars['Date']['input'];
};


export type ParentQueriesGetStudentThermometerPmoArgs = {
  childUserId: Scalars['UUID']['input'];
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
};


export type ParentQueriesGetStudentsInfoArgs = {
  userId: Array<Scalars['UUID']['input']>;
};


export type ParentQueriesGetStudentsMarksSubjectsDetailedArgs = {
  childUserId: Scalars['UUID']['input'];
  studyPeriodId: Scalars['Int']['input'];
};


export type ParentQueriesGetStudentsMarksSubjectsDetailedByDatesArgs = {
  childUserId: Scalars['UUID']['input'];
  currentRole?: InputMaybe<Scalars['String']['input']>;
  periodEndDate: Scalars['Date']['input'];
  periodStartDate: Scalars['Date']['input'];
};


export type ParentQueriesGetSubjectsFinalMarksArgs = {
  atDate?: InputMaybe<Scalars['Date']['input']>;
  childUserId?: InputMaybe<Scalars['UUID']['input']>;
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  studyPeriodId?: InputMaybe<Scalars['ID']['input']>;
};


export type ParentQueriesGetSubjectsForLessonArgs = {
  childUserId: Scalars['UUID']['input'];
  currentDate: Scalars['Date']['input'];
};


export type ParentQueriesGetTargetGoalLevelArgs = {
  childUserId: Scalars['UUID']['input'];
  goalId: Scalars['ID']['input'];
};


export type ParentQueriesGetTaskAnswersArgs = {
  childUserId: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
};


export type ParentQueriesGetTaskCriteriaArgs = {
  taskId: Scalars['ID']['input'];
};


export type ParentQueriesGetTaskCriteriaValuesArgs = {
  isConfirmed?: InputMaybe<Scalars['Boolean']['input']>;
  studentId: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
};


export type ParentQueriesGetTaskMessagesArgs = {
  childUserId: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
};


export type ParentQueriesGetTaskStatisticsIdsArgs = {
  childUserId?: InputMaybe<Scalars['UUID']['input']>;
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  subjectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};


export type ParentQueriesGetTasksByIdsArgs = {
  childUserId: Scalars['ID']['input'];
  ids: Array<Scalars['ID']['input']>;
};


export type ParentQueriesGetUserAwardsArgs = {
  awardType?: InputMaybe<AwardTypeEnum>;
  userId: Scalars['ID']['input'];
};

export type ParentRole = {
  __typename?: 'ParentRole';
  /** основная информация по детям */
  childUserInfo: Array<ChildUserInfo>;
  /** список юзеров - детей */
  children: Array<User>;
  /** дата деактивации роли */
  dateEnd?: Maybe<Scalars['DateTime']['output']>;
  /** дата активации роли */
  dateStart?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  /** является ли роль дефолтной при входе пользователя в приложение */
  isDefault: Scalars['Boolean']['output'];
  orgUnitId?: Maybe<Scalars['ID']['output']>;
  productId?: Maybe<Scalars['ID']['output']>;
  /** название роли */
  role: Roles;
  school: SafeSchool;
  schoolId: Scalars['ID']['output'];
  status: RoleStatus;
};

export type ParentRoleInput = {
  children?: InputMaybe<Array<Scalars['ID']['input']>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  schoolId: Scalars['ID']['input'];
  status?: InputMaybe<RoleStatus>;
  temporaryRoleInput?: InputMaybe<TemporaryRoleInput>;
};

export type ParentThemesQueries = {
  __typename?: 'ParentThemesQueries';
  /** Получить модуль лайт по айди модуля и айди ребенка */
  getModuleLightById: StudentModuleLight;
  /** Вернуть учебные периоды с темами */
  getStudentStudyPeriodWithSubjectThemesBySubjectId: Array<StudentStudyPeriodWithSubjectThemes>;
  /** Вернуть учебные периоды с темами с учетом фильтра по названию тем */
  getStudentStudyPeriodWithSubjectThemesByTextSearch: Array<StudentStudyPeriodWithSubjectThemes>;
};


export type ParentThemesQueriesGetModuleLightByIdArgs = {
  childUserId: Scalars['ID']['input'];
  goalId: Scalars['ID']['input'];
};


export type ParentThemesQueriesGetStudentStudyPeriodWithSubjectThemesBySubjectIdArgs = {
  childUserId: Scalars['ID']['input'];
  subjectId: Scalars['ID']['input'];
};


export type ParentThemesQueriesGetStudentStudyPeriodWithSubjectThemesByTextSearchArgs = {
  childUserId: Scalars['ID']['input'];
  onlyCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  subjectId?: InputMaybe<Scalars['ID']['input']>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};

/** Информация о родителе */
export type ParentUserInfo = {
  __typename?: 'ParentUserInfo';
  /** ссылка на аватар родителя, как пользователя */
  avatarUrl: Scalars['String']['output'];
  /** имя родителя */
  firstName: Scalars['String']['output'];
  /** Идентификатор родителя, как пользователя */
  id: Scalars['ID']['output'];
  /** фамилия родителя */
  lastName: Scalars['String']['output'];
  /** отчество родителя */
  middleName?: Maybe<Scalars['String']['output']>;
};

/** Комментарий к мероприятию от участника */
export type ParticipantEventComment = {
  __typename?: 'ParticipantEventComment';
  /** Комментарий */
  comment: Scalars['String']['output'];
  /** Время создания */
  createTs: Scalars['DateTime']['output'];
  /** Тип (от участника/ от админа) */
  type: ParticipantEventCommentType;
};

export enum ParticipantEventCommentType {
  Admin = 'ADMIN',
  Participant = 'PARTICIPANT'
}

export enum ParticipantEventStatus {
  Approved = 'APPROVED',
  CanceledByStudent = 'CANCELED_BY_STUDENT',
  PendingApproval = 'PENDING_APPROVAL',
  Rejected = 'REJECTED'
}

/** Статус участника события */
export enum ParticipantStatus {
  Organizer = 'ORGANIZER',
  Participant = 'PARTICIPANT'
}

export type PedagogicalTechnique = {
  __typename?: 'PedagogicalTechnique';
  author?: Maybe<Scalars['String']['output']>;
  description: Scalars['String']['output'];
  file?: Maybe<File>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  softSkillTypes?: Maybe<Array<SoftSkillType>>;
  studentHint: Scalars['String']['output'];
  teacherHint: Scalars['String']['output'];
};

/** Штраф Ш21 */
export type Penalty = {
  __typename?: 'Penalty';
  /** Конфигуратор, создавший штраф */
  adminUser?: Maybe<User>;
  /** Комментарий */
  comment?: Maybe<Scalars['String']['output']>;
  /** Время создания */
  createTime: Scalars['DateTime']['output'];
  /** Продолжительность */
  duration: Scalars['Int']['output'];
  /** Идентификатор штрафа */
  id?: Maybe<Scalars['ID']['output']>;
  /** Слот отработки */
  penaltySlot?: Maybe<PenaltySlot>;
  /** Идентификатор причины штрафа */
  reasonId: Scalars['ID']['output'];
  /** Время начала отработки */
  startTime?: Maybe<Scalars['DateTime']['output']>;
  /** Статус */
  status: Scalars['String']['output'];
  /** Оштрафованный пользователь */
  user?: Maybe<User>;
};

export type PenaltyInput = {
  /** Комментарий */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** Продолжительность в часах 2/4/8 */
  duration: Scalars['Int']['input'];
  /** Идентификатор причины штрафа */
  reasonId: Scalars['ID']['input'];
  /** Идентификатор пользователя блокируемого студента */
  studentUserId: Scalars['UUID']['input'];
};

export type PenaltyMutations = {
  __typename?: 'PenaltyMutations';
  /**
   * -----------------------------Запросы админа-----------------------------
   *  Создание штрафа в Ш21
   */
  createPenalty: Penalty;
  /** Создание слотов отработки штрафов, возвращает количество успешно созданных слотов */
  createPenaltySlots: Scalars['Int']['output'];
  /** Удаление штрафа в Ш21 */
  deletePenalty: Penalty;
  /** Удаление слота отработки */
  deletePenaltySlot?: Maybe<Scalars['Boolean']['output']>;
  /** Завершение штрафа в Ш21 */
  donePenalty: Penalty;
  /** Удвоение штрафа в Ш21 */
  doublePenalty: Penalty;
  /**
   * -----------------------------Запросы студента-----------------------------
   *  Запись студента на отработку штрафа, возвращает номер букинга
   */
  setPenaltyBooking: Scalars['ID']['output'];
  /** Редактирование штрафа в Ш21 */
  updatePenalty: Penalty;
  /** Редактирование слота отработки штрафа */
  updatePenaltySlot: PenaltySlot;
};


export type PenaltyMutationsCreatePenaltyArgs = {
  input: PenaltyInput;
};


export type PenaltyMutationsCreatePenaltySlotsArgs = {
  slots: Array<PenaltySlotInput>;
};


export type PenaltyMutationsDeletePenaltyArgs = {
  penaltyId: Scalars['ID']['input'];
};


export type PenaltyMutationsDeletePenaltySlotArgs = {
  penaltySlotId: Scalars['ID']['input'];
};


export type PenaltyMutationsDonePenaltyArgs = {
  penaltyId: Scalars['ID']['input'];
};


export type PenaltyMutationsDoublePenaltyArgs = {
  penaltyId: Scalars['ID']['input'];
};


export type PenaltyMutationsSetPenaltyBookingArgs = {
  penaltyId: Scalars['ID']['input'];
  slotId: Scalars['ID']['input'];
};


export type PenaltyMutationsUpdatePenaltyArgs = {
  input: UpdatePenaltyInput;
};


export type PenaltyMutationsUpdatePenaltySlotArgs = {
  slot: PenaltySlotInput;
  slotId: Scalars['ID']['input'];
};

export type PenaltyQueries = {
  __typename?: 'PenaltyQueries';
  /** S21. Получение количества штрафов, привязанных к студенту */
  countMyPenalties: Scalars['Int']['output'];
  /** Получить количество штрафов */
  countPenalties: Scalars['Int']['output'];
  /** S21. Получение количество свободных слотов для отработки штрафа */
  countPenaltyFreeSlots: Scalars['Int']['output'];
  /** Получить количество слотов отработки штрафов */
  countPenaltySlots: Scalars['Int']['output'];
  /** S21. Получение списка штрафов, привязанных к студенту */
  getMyPenalties: Array<Penalty>;
  /**
   * -----------------------------Запросы админа-----------------------------
   *  Получить штрафы
   */
  getPenalties: Array<Penalty>;
  /** Получить штраф по идентификатору */
  getPenaltyById: Penalty;
  /**
   * -----------------------------Запросы студента-----------------------------
   * S21. Получение списка свободных слотов для отработки штрафа
   */
  getPenaltyFreeSlots: Array<PenaltySlot>;
  /**
   * -----------------------------Общие запросы------------------------------
   *  Получить справочник причин для штрафа
   */
  getPenaltyReasons: Array<Maybe<PenaltyReason>>;
  /** Получить слот отработки штрафа по идентификатору */
  getPenaltySlotById: PenaltySlot;
  /** Получить слоты отработки штрафов */
  getPenaltySlots: Array<PenaltySlot>;
};


export type PenaltyQueriesCountMyPenaltiesArgs = {
  from?: InputMaybe<Scalars['DateTime']['input']>;
  statuses: Array<InputMaybe<Scalars['String']['input']>>;
  to?: InputMaybe<Scalars['DateTime']['input']>;
};


export type PenaltyQueriesCountPenaltiesArgs = {
  from?: InputMaybe<Scalars['DateTime']['input']>;
  statuses: Array<InputMaybe<Scalars['String']['input']>>;
  studentUserId?: InputMaybe<Scalars['UUID']['input']>;
  to?: InputMaybe<Scalars['DateTime']['input']>;
};


export type PenaltyQueriesCountPenaltyFreeSlotsArgs = {
  duration: Scalars['Int']['input'];
};


export type PenaltyQueriesCountPenaltySlotsArgs = {
  duration?: InputMaybe<Scalars['Int']['input']>;
  from: Scalars['DateTime']['input'];
  onlyFree?: InputMaybe<Scalars['Boolean']['input']>;
  penaltyId?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
};


export type PenaltyQueriesGetMyPenaltiesArgs = {
  from?: InputMaybe<Scalars['DateTime']['input']>;
  page: PagingInput;
  sorting?: InputMaybe<Array<InputMaybe<SortingField>>>;
  statuses: Array<InputMaybe<Scalars['String']['input']>>;
  to?: InputMaybe<Scalars['DateTime']['input']>;
};


export type PenaltyQueriesGetPenaltiesArgs = {
  from?: InputMaybe<Scalars['DateTime']['input']>;
  page: PagingInput;
  sorting?: InputMaybe<Array<InputMaybe<SortingField>>>;
  statuses: Array<InputMaybe<Scalars['String']['input']>>;
  studentUserId?: InputMaybe<Scalars['UUID']['input']>;
  to?: InputMaybe<Scalars['DateTime']['input']>;
};


export type PenaltyQueriesGetPenaltyByIdArgs = {
  penaltyId: Scalars['ID']['input'];
};


export type PenaltyQueriesGetPenaltyFreeSlotsArgs = {
  duration: Scalars['Int']['input'];
  page: PagingInput;
  sorting?: InputMaybe<Array<InputMaybe<SortingField>>>;
};


export type PenaltyQueriesGetPenaltySlotByIdArgs = {
  penaltySlotId: Scalars['ID']['input'];
};


export type PenaltyQueriesGetPenaltySlotsArgs = {
  duration?: InputMaybe<Scalars['Int']['input']>;
  from: Scalars['DateTime']['input'];
  onlyFree?: InputMaybe<Scalars['Boolean']['input']>;
  page: PagingInput;
  penaltyId?: InputMaybe<Scalars['Int']['input']>;
  sorting?: InputMaybe<Array<InputMaybe<SortingField>>>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
};

/** Причина штрафа */
export type PenaltyReason = {
  __typename?: 'PenaltyReason';
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

/** Слот отработки штрафа Ш21 */
export type PenaltySlot = {
  __typename?: 'PenaltySlot';
  /** Текущая заполненность */
  currentStudentsCount?: Maybe<Scalars['Int']['output']>;
  /** Описание */
  description?: Maybe<Scalars['String']['output']>;
  /** Продолжительность в часах (2,4,8) */
  duration?: Maybe<Scalars['Int']['output']>;
  /** Время окончания */
  endTime?: Maybe<Scalars['DateTime']['output']>;
  /** Идентификатор слота */
  id: Scalars['ID']['output'];
  /** Максимальная емкость слота */
  maxStudentsCount?: Maybe<Scalars['Int']['output']>;
  /** Список параллелей */
  stages: Array<Stage>;
  /** Время начала */
  startTime?: Maybe<Scalars['DateTime']['output']>;
};

export type PenaltySlotInput = {
  /** Описание */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Продолжительность слота в часах */
  duration: Scalars['Int']['input'];
  /** Время окончания */
  endTime: Scalars['DateTime']['input'];
  /** Максимальное число студентов */
  maxStudentsCount: Scalars['Int']['input'];
  /** Список идентификаторов параллелей */
  stageIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Время начала */
  startTime: Scalars['DateTime']['input'];
};

export type PercOfActiveStudentsMetrics = {
  __typename?: 'PercOfActiveStudentsMetrics';
  activeStudentsCount: Scalars['Int']['output'];
  activeStudentsPercent: Scalars['Int']['output'];
  stage: Scalars['Int']['output'];
  totalStudentsCount: Scalars['Int']['output'];
};

export type PercentProgressInfo = {
  __typename?: 'PercentProgressInfo';
  /** Текущий прогресс по активности в процентах */
  percentProgress: Scalars['Float']['output'];
  /** Прогресс по активности за текущую неделю в процентах */
  percentProgressCurrentWeek: Scalars['Float']['output'];
  /** Текущий прогресс по активности без учета результатов текущей недели в процентах */
  percentProgressWithoutCurrentWeek: Scalars['Float']['output'];
};

/** Период времени, включающий время начала и время окончания какого либо события */
export type Period = {
  __typename?: 'Period';
  periodEndTime: Scalars['DateTime']['output'];
  periodStartTime: Scalars['DateTime']['output'];
};

export type PeriodInfo = {
  __typename?: 'PeriodInfo';
  /** Конец периода */
  endTimestamp: Scalars['Int']['output'];
  /** Название периода */
  periodName: BigChallengePeriod;
  /** Начало периода */
  startTimestamp: Scalars['Int']['output'];
};

/** Период для создания планов уроков */
export type PeriodLessonPlan = {
  __typename?: 'PeriodLessonPlan';
  /** Дата окончания периода */
  endDate: Scalars['Date']['output'];
  /** Признак активности/неактивности периода */
  isActive?: Maybe<Scalars['Boolean']['output']>;
  /** Признак видео-урока */
  isVideoLesson?: Maybe<Scalars['Boolean']['output']>;
  /** Идентификатор дистанционного периода */
  periodLessonPlanId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор группы класса по предмету */
  stageSubjectGroupId?: Maybe<Scalars['ID']['output']>;
  /** Дата начала периода */
  startDate: Scalars['Date']['output'];
};

/** Сопоставление периода для создания планов уроков c его вычисляемым статусом */
export type PeriodLessonPlanExtended = {
  __typename?: 'PeriodLessonPlanExtended';
  /** Идентификатор учебного года */
  academicYearId?: Maybe<Scalars['ID']['output']>;
  /** Признак того, что период был сокращен при редактировании */
  isReducingInterval?: Maybe<Scalars['Boolean']['output']>;
  /** Период для создания планов уроков */
  periodLessonPlan: PeriodLessonPlan;
  /** Cтатус периода планирования уроков */
  periodStatus: Scalars['Int']['output'];
  /** Идентификатор класса */
  stageGroupId?: Maybe<Scalars['ID']['output']>;
  /** Название класса */
  stageGroupName?: Maybe<Scalars['String']['output']>;
  /** Идентификатор параллели */
  stageId?: Maybe<Scalars['ID']['output']>;
  /** Название параллели */
  stageName?: Maybe<Scalars['String']['output']>;
  /** Название группы класса по предмету */
  stageSubjectGroupName?: Maybe<Scalars['String']['output']>;
  /** Статус соответствующей задачи обновления дистанционного периода из таблицы period_lesson_plan_tasks */
  taskStatus?: Maybe<Scalars['String']['output']>;
};

export type PeriodLessonPlanInput = {
  dates: Array<DatePeriodLessonPlanInput>;
  isVideoLesson: Scalars['Boolean']['input'];
  periodLessonPlanId?: InputMaybe<Scalars['ID']['input']>;
  stageSubjectGroupIds: Array<Scalars['ID']['input']>;
  timeZone: Scalars['String']['input'];
};

/** настройки периодов проектов в курсе */
export enum PeriodSettings {
  /** Аналог марафона */
  ExecutionAndDuration = 'EXECUTION_AND_DURATION',
  /** Периоды выключены */
  Off = 'OFF',
  /** Все периоды включены */
  On = 'ON',
  /** Только период регистрации */
  OnlyRegistration = 'ONLY_REGISTRATION'
}

export type Permission = {
  __typename?: 'Permission';
  description: Scalars['String']['output'];
  permissionId: Scalars['String']['output'];
};

/** Персональнализированная Контрольная Работа назначенная на Студента в Подгруппе */
export type PersonalControlWork = {
  __typename?: 'PersonalControlWork';
  /** Контрольная Работа */
  classSubjectControlWork: ClassSubjectControlWork;
  /** Дата и время конца Контрольной Работы UTC!!!!! */
  closeTime?: Maybe<Scalars['DateTime']['output']>;
  /** Продолжительность Контрольной в минутах */
  duration: Scalars['Int']['output'];
  /** Идентификатор (personal_control_work.personal_control_work_id) */
  id: Scalars['ID']['output'];
  /** Оценка за Конрольную Работу */
  mark?: Maybe<SchoolMark>;
  /** Время когда учитель выставил оценку по контрольной */
  markTime?: Maybe<Scalars['DateTime']['output']>;
  /** Учебный Модуль, по которому проводится Контрольная Работа */
  module: StudyModule;
  permissionStatus?: Maybe<Scalars['Boolean']['output']>;
  /** Дата и Время, в которые Учитель планирует начать Контрольную Работу UTC!!!!! */
  planTime?: Maybe<Scalars['DateTime']['output']>;
  /** Дата и время начала Контрольной Работы UTC!!!!! */
  startTime?: Maybe<Scalars['DateTime']['output']>;
  /** Статус Контрольной */
  status: ControlWorkStatus;
  /** Идентификатор студента в подгруппе */
  studentInSubgroupId: Scalars['ID']['output'];
  /** Вариант Контрольной назначенный на ученика */
  variant: PersonalControlWorkVariant;
  /** Показывается ли содержимое Контрольной Работы ученику */
  visible: Scalars['Boolean']['output'];
};

/** Персонализированный Вариант Контрольной Работы */
export type PersonalControlWorkVariant = {
  __typename?: 'PersonalControlWorkVariant';
  /**
   * Идентификатор Варианта выбранного учеником в Контрольную Работу (
   * (stage_subject_group_control_work_variants.stage_subject_group_control_work_variant_id)
   */
  classSubjectControlWorkVariantId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  /** Номер варианта */
  number?: Maybe<Scalars['Int']['output']>;
  /** Задания Студента, входящие в вариант с персональной информацией о Задании в контексте студента */
  tasks: Array<StudentTask>;
};

export type PersonalGoal = {
  __typename?: 'PersonalGoal';
  acceptedTasks: Scalars['Int']['output'];
  /** title: String! */
  achievedLevel: Scalars['Float']['output'];
  /** added */
  goal: GoalDto;
  /** Признак доступности */
  hasAccess: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  isAchieved: Scalars['Boolean']['output'];
  /** Ученик проходит модуль вне плана */
  outOfPlan: Scalars['Boolean']['output'];
  playlistName: Scalars['String']['output'];
  timeFrame: GoalTimeFrame;
  totalTasks: Scalars['Int']['output'];
};

/** Персональная Цель ученика */
export type PersonalObjective = {
  __typename?: 'PersonalObjective';
  /** Тип Отрезка Персональной Цели (напр. День) */
  chunkType: PersonalObjectiveChunkTypeEnum;
  /**
   * Длина (в минутах) рабочего времени в рамках Отрезка Персональной Цели (напр. 45мин в день, если Отрезок представляет день)
   * (если применимо)
   */
  chunkWorkTimeLengthMin?: Maybe<Scalars['Int']['output']>;
  /** Список Отрезков данной Персональной Цели (напр. Дней) */
  chunks: Array<PersonalObjectiveChunk>;
  /** Дата и время фактического завершения Персональной Цели (в зоне UTC) */
  completeTime?: Maybe<Scalars['DateTime']['output']>;
  /** Дата окончания Персональной Цели */
  endDate?: Maybe<Scalars['Date']['output']>;
  /** Идентификатор Персональной Цели */
  objectiveId?: Maybe<Scalars['ID']['output']>;
  /** Статус Персональной Цели */
  objectiveStatus: PersonalObjectiveStatusEnum;
  /** Тип Персональной Цели */
  objectiveType: PersonalObjectiveTypeEnum;
  /** Дата начала Персональной Цели */
  startDate: Scalars['Date']['output'];
  /** Идентификатор Ученика */
  studentId: Scalars['ID']['output'];
  /**
   * Предмет Персональной Цели
   * (если применимо)
   */
  subject?: Maybe<Subject>;
};

/** Вариант новой Персональной Цели ученика, распланированный для определённого набора желаемых характеристик */
export type PersonalObjectiveCandidate = {
  __typename?: 'PersonalObjectiveCandidate';
  /** Длинна рабочего времени в рамках Отрезка Персональной Цели в минутах (напр. 30мин в день) */
  chunkWorkTimeLengthMin?: Maybe<Scalars['Int']['output']>;
  /** Кол-во Отрезков, необходимое для завершения Персональной Цели (напр. 5 дней) */
  chunksToCompleteObjective?: Maybe<Scalars['Int']['output']>;
  /** Дата окончания Персональной Цели */
  endDate?: Maybe<Scalars['Date']['output']>;
  /** Признак невозможности запланировать Персональную Цель для данного набора характеристик */
  failedToPlanObjective: Scalars['Boolean']['output'];
  /** Признак выхода данной Персональной Цели за пределы текущего Учебного Периода */
  planExceedsStudyPeriod: Scalars['Boolean']['output'];
  /** Дата начала Персональной Цели */
  startDate?: Maybe<Scalars['Date']['output']>;
};

/** Набор вариантов новой Персональной Цели ученика, распланированных в зависимости от желаемых характеристик */
export type PersonalObjectiveCandidates = {
  __typename?: 'PersonalObjectiveCandidates';
  /** Тип Отрезка Персональной Цели (напр. День) */
  chunkType: PersonalObjectiveChunkTypeEnum;
  /** Лимит разрешенного кол-ва Отрезков для завершения Персональной Цели (напр. макс 14 дней) */
  objectiveChunksLimit?: Maybe<Scalars['Int']['output']>;
  /** Варианты Персональной Цели, распланированные для разных желаемых характеристик */
  objectivePlanCandidates: Array<PersonalObjectiveCandidate>;
  /** Тип Персональной Цели */
  objectiveType: PersonalObjectiveTypeEnum;
  /** Идентификатор Учебного Периода (если применимо) */
  studyPeriodId?: Maybe<Scalars['ID']['output']>;
  /** Предмет (если применимо) */
  subjectId?: Maybe<Scalars['ID']['output']>;
};

/** Отрезок Персональной Цели ученика (напр. представляет День) */
export type PersonalObjectiveChunk = {
  __typename?: 'PersonalObjectiveChunk';
  /** Список Элементов данного Отрезка Персональной Цели (напр. Заданий ученика) */
  chunkElements: Array<PersonalObjectiveChunkElement>;
  /** Идентификатор Отрезка Персональной Цели */
  chunkId?: Maybe<Scalars['ID']['output']>;
  /** Дата окончания отрезка */
  endDate: Scalars['Date']['output'];
  /** Идентификатор Персональной Цели к которой относится данный Отрезок */
  objectiveId?: Maybe<Scalars['ID']['output']>;
  /** Дата начала отрезка */
  startDate: Scalars['Date']['output'];
};

/** Элемент Отрезка Персональной Цели ученика (напр. Задание ученика) */
export type PersonalObjectiveChunkElement = {
  __typename?: 'PersonalObjectiveChunkElement';
  /** Идентификатор Элемента Отрезка Персональной Цели */
  chunkElementId?: Maybe<Scalars['ID']['output']>;
  /** Длина данного Элемента Отрезка Персональной Цели (напр. трудоёмкость Задания ученика) */
  chunkElementLengthMin?: Maybe<Scalars['Int']['output']>;
  /** Тип данного Элемента Отрезка Персональной Цели (напр. Задание ученика) */
  chunkElementType: PersonalObjectiveChunkElementTypeEnum;
  /** Идентификатор Отрезка Персональной Цели к которому относится данный Элемент */
  chunkId?: Maybe<Scalars['ID']['output']>;
  /** Признак завершенности данного Элемента Отрезка цели */
  isFinished: Scalars['Boolean']['output'];
  /** Порядковый номер данного Элемента Отрезка цели в рамках отрезка цели */
  orderNumber: Scalars['Int']['output'];
  /**
   * Задание Ученика (применимо только для Элемента типа "Задание ученика")
   * (если применимо)
   */
  studentTask?: Maybe<StudentTask>;
  /**
   * Идентификатор задания Ученика (применимо только для Элемента типа "Задание ученика")
   * (если применимо)
   */
  studentTaskId?: Maybe<Scalars['ID']['output']>;
};

/** Тип Элемента Отрезка Персональной Цели ученика (напр. Задание ученика) */
export enum PersonalObjectiveChunkElementTypeEnum {
  /** Если Элемент Отрезка цели является Заданием ученика */
  StudentTask = 'STUDENT_TASK'
}

/** Тип Отрезка Персональной Цели ученика (напр. День) */
export enum PersonalObjectiveChunkTypeEnum {
  /** Если Отрезок Персональной Цели представляет собой "день" */
  Day = 'DAY'
}

/** Код текущего состояния Персональной Цели (в динамике отправки/зачёта заданий) */
export enum PersonalObjectiveCurrentProgressStateEnum {
  /**
   * Пользователь отправил на проверку посленее не отправленное задание из запланированных вплоть до будущего дня Х
   * (все запланированные задания на все дни до Х включительно теперь статусах "Зачтено", "Требуется проверка")
   */
  AllTasksSentForFutureDay = 'ALL_TASKS_SENT_FOR_FUTURE_DAY',
  /**
   * Пользователь отправил на проверку посленее не отправленное задание из запланированных в рамках Персональной Цели
   * (все запланированные задания в рамках Персональной Цели теперь статусах "Зачтено", "Требуется проверка")
   */
  AllTasksSentForPersonalObjective = 'ALL_TASKS_SENT_FOR_PERSONAL_OBJECTIVE',
  /**
   * Пользователь отправил на проверку посленее не отправленное задание из запланированных на сегодня
   * (все запланированные задания на сегодня теперь статусах "Зачтено", "Требуется проверка")
   */
  AllTasksSentForToday = 'ALL_TASKS_SENT_FOR_TODAY',
  /**
   * Пользователь отправил на проверку посленее не отправленное задание из запланированных на сегодня
   * (все запланированные задания на сегодня теперь статусах "Зачтено", "Требуется проверка"),
   * и сегодня - последний день Персональной Цели
   */
  AllTasksSentForTodayThatIsALastDay = 'ALL_TASKS_SENT_FOR_TODAY_THAT_IS_A_LAST_DAY',
  /**
   * Пользователь отправил на проверку задание запланированное в рамках Персональной Цели но оно НЕ являлось
   * последним не отправленным в рамках дня на который оно запланировано
   */
  NotAllTasksSent = 'NOT_ALL_TASKS_SENT'
}

/** Информация о текущем состоянии связанной с Заданием Персональной Цели */
export type PersonalObjectiveProgressInfo = {
  __typename?: 'PersonalObjectiveProgressInfo';
  /** Код текущего состояния Персональной Цели (в динамике отправки/зачёта заданий) */
  currentProgressState: PersonalObjectiveCurrentProgressStateEnum;
  /** Кол-во дней, оставшихся до ожидаемого закрытия Цели (начиная с завтрашнего) */
  daysLeft: Scalars['Int']['output'];
  /** Персональная Цель ученика */
  personalObjective: PersonalObjective;
};

/** Статус Персональной Цели ученика */
export enum PersonalObjectiveStatusEnum {
  Cancelled = 'CANCELLED',
  Completed = 'COMPLETED',
  Failed = 'FAILED',
  InProgress = 'IN_PROGRESS',
  Prepared = 'PREPARED'
}

/** Тип Персональной Цели ученика */
export enum PersonalObjectiveTypeEnum {
  /** Если Цель направлена на сокращение отставания по заданиям в рамках предмета */
  CatchUpOnSubjectTasks = 'CATCH_UP_ON_SUBJECT_TASKS'
}

/** Персональная Цель ученика с метаданными генерации Цели */
export type PersonalObjectiveWithBuildInfo = {
  __typename?: 'PersonalObjectiveWithBuildInfo';
  /** Признак невозможности запланировать Персональную Цель для данного набора характеристик */
  failedToPlanObjective: Scalars['Boolean']['output'];
  /** Персональная Цель ученика. Будет пустой в случае ошибки при создании */
  personalObjective?: Maybe<PersonalObjective>;
  /** Признак выхода данной Персональной Цели за пределы текущего Учебного Периода */
  planExceedsStudyPeriod: Scalars['Boolean']['output'];
};

export type PersonalPerformance = {
  __typename?: 'PersonalPerformance';
  status: PersonalPerformanceEnum;
  value: Scalars['Float']['output'];
};

export enum PersonalPerformanceEnum {
  /** Идет по плану */
  AccordingToPlan = 'ACCORDING_TO_PLAN',
  /** Опережает план */
  AheadOfPlan = 'AHEAD_OF_PLAN',
  /** Отстает от плана */
  BehindThePlan = 'BEHIND_THE_PLAN'
}

/** тип Персонального Плана обучения, по которому будет идти учебный процесс ученика */
export type PersonalPlan = {
  __typename?: 'PersonalPlan';
  /** Дата создания плана */
  createTime: Scalars['DateTime']['output'];
  /** Плановая дата окончания обучения */
  endDate?: Maybe<Scalars['Date']['output']>;
  /** список Учебных Модулей в Плане с привязкой к датам и необходимому для достижения уровню */
  frames: Array<PersonalPlanFrame>;
  id: Scalars['ID']['output'];
  /** Дата изменения плана */
  modifyTime: Scalars['DateTime']['output'];
  /** Плановая дата начала обучения */
  startDate?: Maybe<Scalars['Date']['output']>;
  /** статус Плана */
  status: PlanStatusEnum;
};

export type PersonalPlanChangeResponse = {
  __typename?: 'PersonalPlanChangeResponse';
  isSuccess: Scalars['Boolean']['output'];
  plan?: Maybe<PersonalPlan>;
};

/** Учебный Модуль внутри Персонального Плана */
export type PersonalPlanFrame = {
  __typename?: 'PersonalPlanFrame';
  /** Уровень, на котором Учебный Модуль объявляется достигнутым учеником */
  achieveLevel: Scalars['Float']['output'];
  /**
   * Идентификатор Базового Плейлиста,
   * назначенного по Учебному Модулю в рамках персонального Плана (base_playlists.base_playlist_id)
   */
  basePlaylistId?: Maybe<Scalars['ID']['output']>;
  /** Условия прохождения учебного модуля в плане */
  conditions: Array<PlanFrameCondition>;
  /** Запланированная дата достижения Учебного Модуля */
  endDate: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  /** Является ли дедлайл жестким. После истечения жесткого дедлайна нельзять отправлять задания модуля на проверку */
  isHardEndDate: Scalars['Boolean']['output'];
  /** Примерная трудоемкость Учебного Модуля в часах в рамках текущего Плана */
  laboriousness: Scalars['Int']['output'];
  /** Флаг обязательности Учебного Модуля в рамках конкретного Персонального Плана */
  mandatory: Scalars['Boolean']['output'];
  /** Учебный Модуль */
  module: StudyModule;
  /** Идентификатор Учебного Модуля (goals.goal_id) */
  moduleId: Scalars['ID']['output'];
  /**
   * Плейлист назначенный по Учебному Модулю в рамках классового Плана
   * (teacher_playlists.teacher_playlist_id или base_playlists.base_playlist_id)
   */
  playlist: TaskSet;
  /** Запланированная дата начала изучения Учебного модуля */
  startDate: Scalars['DateTime']['output'];
  /**
   * Идентификатор Учительского Плейлиста,
   * назначенного по Учебному Модулю в рамках персонального Плана (teacher_playlists.teacher_playlist_id)
   */
  teacherPlaylistId?: Maybe<Scalars['ID']['output']>;
};

export type PersonalPlanFrameInput = {
  /** Уровень, на котором Учебный Модуль объявляется достигнутым учеником */
  achieveLevel: Scalars['Float']['input'];
  /** Идентификатор Базового Плейлиста (base_playlists.base_playist_id) */
  basePlaylistId?: InputMaybe<Scalars['ID']['input']>;
  /** Условия прохождения Учебного Модуля */
  conditions: Array<PlanFrameConditionInput>;
  /** Запланированная дата достижения Учебного Модуля */
  endDate: Scalars['String']['input'];
  /** Является ли дедлайл жестким. После истечения жесткого дедлайна нельзять отправлять задания модуля на проверку */
  isHardEndDate: Scalars['Boolean']['input'];
  /** Примерная трудоемкость Учебного Модуля в часах в рамках текущего Плана */
  laboriousness: Scalars['Int']['input'];
  /** Флаг обязательности Учебного Модуля в рамках конкретного Персонального Плана */
  mandatory: Scalars['Boolean']['input'];
  /** Учебный Модуль */
  moduleId: Scalars['ID']['input'];
  /** Запланированная дата начала изучения Учебного модуля */
  startDate: Scalars['String']['input'];
  /** Идентификатор Учительского Плейлиста (teacher_playlists.teacher_playlist_id) */
  teacherPlaylistId?: InputMaybe<Scalars['ID']['input']>;
};

/** Модули версии перонального плана на класс */
export type PersonalPlanFrameVersion = {
  __typename?: 'PersonalPlanFrameVersion';
  /** Уровень, на котором Учебный Модуль объявляется достигнутым учеником */
  achieveLevel: Scalars['Float']['output'];
  /**
   * Идентификатор Базового Плейлиста,
   * назначенного по Учебному Модулю в рамках персонального Плана (base_playlists.base_playlist_id)
   */
  basePlaylistId?: Maybe<Scalars['ID']['output']>;
  /** Запланированная дата достижения Учебного Модуля */
  endDate: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  /** Является ли дедлайл жестким. После истечения жесткого дедлайна нельзять отправлять задания модуля на проверку */
  isHardEndDate: Scalars['Boolean']['output'];
  /** Примерная трудоемкость Учебного Модуля в часах в рамках текущего Плана */
  laboriousness: Scalars['Int']['output'];
  /** Флаг обязательности Учебного Модуля в рамках конкретного Персонального Плана */
  mandatory: Scalars['Boolean']['output'];
  /** Идентификатор Учебного Модуля (goals.goal_id) */
  moduleId: Scalars['ID']['output'];
  /** Запланированная дата начала изучения Учебного модуля */
  startDate: Scalars['DateTime']['output'];
  /**
   * Идентификатор Учительского Плейлиста,
   * назначенного по Учебному Модулю в рамках персонального Плана (teacher_playlists.teacher_playlist_id)
   */
  teacherPlaylistId?: Maybe<Scalars['ID']['output']>;
};

/** Версия персонального плана */
export type PersonalPlanVersion = {
  __typename?: 'PersonalPlanVersion';
  frames: Array<PersonalPlanFrameVersion>;
  id: Scalars['ID']['output'];
  versionCreateTime: Scalars['DateTime']['output'];
  versionCreateUser: User;
};

/** Траектория студента по Учебному Модулю */
export type PersonalTrajectory = {
  __typename?: 'PersonalTrajectory';
  /** Идентификатор (personal_trajectories.personal_trajectory_id) */
  id: Scalars['ID']['output'];
  /** Флаг - достаточна ли Траектория для закрытия Уровня Учебного Модуля */
  isEnoughForAchieve: Scalars['Boolean']['output'];
  /** Флаг - была ли измененна СЗ после формирования Траектории */
  isPlaylistChanged: Scalars['Boolean']['output'];
  /** Уровни Учебного Модуля внутри Траектории */
  levels: Array<PersonalTrajectoryLevel>;
  /** Дата и время изменения траектории */
  modifyTime?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Задачи, по которым Студент проявлял активность вне Траектории
   * @deprecated Field no longer supported
   */
  pointsOutOfTrajectory: Array<StudentTask>;
  /** Количество Заданий в Траектории */
  taskCount: Scalars['Int']['output'];
};

/** Элементы Цели внутри Траектории */
export type PersonalTrajectoryGoalElement = {
  __typename?: 'PersonalTrajectoryGoalElement';
  /** Флаг - закрыт ли Элемент Цели */
  achieved: Scalars['Boolean']['output'];
  /** Название Элемента Цели */
  goalELementName: Scalars['String']['output'];
  /** Идентификатор (skills.skill_id) */
  id: Scalars['ID']['output'];
  /** Флаг - достаточна ли Траектория для закрытия Уровня Учебного Модуля */
  isEnoughForAchieve: Scalars['Boolean']['output'];
  /** Задания внутри Траектории, относящиеся к Элементу Цели */
  points: Array<PersonalTrajectoryPoint>;
};

/** Уровни Учебного Модуля внутри Траектории */
export type PersonalTrajectoryLevel = {
  __typename?: 'PersonalTrajectoryLevel';
  /** Флаг - закрыт ли Уровень Учебного Модуля */
  achieved: Scalars['Boolean']['output'];
  /** Элементы Цели внутри Учебного Модуля внутри Траектории */
  goalElements: Array<PersonalTrajectoryGoalElement>;
  /** Идентификатор (goal_levels.goal_level_id) */
  id: Scalars['ID']['output'];
  /** Доступно ли прохождение закрывающего теста */
  isAvailableGoalLevelTest: Scalars['Boolean']['output'];
  /** Флаг - достаточна ли Траектория для закрытия Уровня Учебного Модуля */
  isEnoughForAchieve: Scalars['Boolean']['output'];
  /** Числовое значение Уровня Учебного Модуля */
  level: Scalars['Float']['output'];
  /** @deprecated Field no longer supported */
  points: Array<PersonalTrajectoryPoint>;
  /** Прогресс студента по закрывающему тесту */
  studentGoalLevelTest?: Maybe<StudentGoalLevelTest>;
};

export type PersonalTrajectoryMutations = {
  __typename?: 'PersonalTrajectoryMutations';
  /** изменение Заданий Элемента цели в Траектории */
  changeTrajectoryPoints: GoalElementTasksResponse;
  /** автогенерация Траектории без смены уровня */
  generateTrajectory: PersonalTrajectoryResponse;
  /** автогенерация Траектории со сменой уровня */
  saveTargetLevelAndGenerateTrajectory: PersonalTrajectoryResponse;
};


export type PersonalTrajectoryMutationsChangeTrajectoryPointsArgs = {
  goalId: Scalars['ID']['input'];
  pointsToSave: Array<PersonalTrajectoryPointInput>;
};


export type PersonalTrajectoryMutationsGenerateTrajectoryArgs = {
  goalId: Scalars['ID']['input'];
};


export type PersonalTrajectoryMutationsSaveTargetLevelAndGenerateTrajectoryArgs = {
  goalId: Scalars['ID']['input'];
  targetGoalLevel: Scalars['Float']['input'];
};

export type PersonalTrajectoryPoint = {
  __typename?: 'PersonalTrajectoryPoint';
  /** Идентификатор Элемента Цели внутри Траектории (skills.skill_id) */
  goalElementId: Scalars['ID']['output'];
  /** Идентификатор (personal_trajectory_points.personal_trajectory_point_id) */
  id: Scalars['ID']['output'];
  /** Идентификатор Уровня Цели внутри Траектории (goal_levels.goal_level_id) */
  levelId: Scalars['ID']['output'];
  /** Сквозной порядковый номер задания в плэйлисте */
  order: Scalars['ID']['output'];
  /** Задание внутри Траектории */
  studentTask: StudentTask;
  taskDeadline?: Maybe<TaskDeadline>;
};

export type PersonalTrajectoryPointInput = {
  /** Идентификатор Элемента Цели внутри Траектории (skills.skill_id) */
  goalElementId: Scalars['ID']['input'];
  /** Идентификатор Уровня Цели внутри Траектории (goal_levels.goal_level_id) */
  levelId: Scalars['ID']['input'];
  /** Идентификатор Задания добавляемого в Траектории(tasks.task_id) */
  taskId: Scalars['ID']['input'];
};

export type PersonalTrajectoryQueries = {
  __typename?: 'PersonalTrajectoryQueries';
  /** Информация об Элементе Цели из контента */
  getGoalElementInfo: GoalElementInfoResponse;
  /** Задания из Системы Заданий, которые доступны для добавления для определенного Элемента Цели в Траектории */
  getGoalElementTasksInPlaylist: GoalElementTasksResponse;
  /**
   * Задания, которые были добавлены в Элемент Цели в Траектории,
   * или Задания, которые могут быть добавлены туда
   */
  getGoalElementTasksInTrajectory: GoalElementTasksResponse;
  /** Информация по Уровням Модуля и Элементам Цели в них без отображения Прогресса и без Первого уровня */
  getGoalLevelInfo: GoalLevelResponse;
  /** информация по Модулю из контента */
  getModuleInfoById: ModuleInfoResponse;
  /**
   * Информация и прогресс ученика по Уровням Модуля и Элементам Цели в них
   * если Траектория ученика не сформирована, Прогресс будет пустым
   */
  getStudentGoalLevelInfoAndProgress: GoalLevelProgressResponse;
};


export type PersonalTrajectoryQueriesGetGoalElementInfoArgs = {
  childUserId?: InputMaybe<Scalars['UUID']['input']>;
  goalElementId?: InputMaybe<Scalars['ID']['input']>;
  goalId: Scalars['ID']['input'];
};


export type PersonalTrajectoryQueriesGetGoalElementTasksInPlaylistArgs = {
  goalElementId?: InputMaybe<Scalars['ID']['input']>;
  goalId: Scalars['ID']['input'];
};


export type PersonalTrajectoryQueriesGetGoalElementTasksInTrajectoryArgs = {
  childUserId?: InputMaybe<Scalars['UUID']['input']>;
  goalElementId?: InputMaybe<Scalars['ID']['input']>;
  goalId: Scalars['ID']['input'];
};


export type PersonalTrajectoryQueriesGetGoalLevelInfoArgs = {
  goalId: Scalars['ID']['input'];
};


export type PersonalTrajectoryQueriesGetModuleInfoByIdArgs = {
  childUserId?: InputMaybe<Scalars['UUID']['input']>;
  goalId: Scalars['ID']['input'];
};


export type PersonalTrajectoryQueriesGetStudentGoalLevelInfoAndProgressArgs = {
  childUserId?: InputMaybe<Scalars['UUID']['input']>;
  goalId: Scalars['ID']['input'];
};

export type PersonalTrajectoryResponse = {
  __typename?: 'PersonalTrajectoryResponse';
  responseCodes: Array<PersonalTrajectoryResponseCode>;
};

export enum PersonalTrajectoryResponseCode {
  /** Попытка сохранить 0 заданий в Элементе Цели */
  AttemptToSaveNoTasks = 'ATTEMPT_TO_SAVE_NO_TASKS',
  /** Попытка изменить Задания в незапланированном уровне (т.е. до формирования Траектории для этого уровня) */
  ChangingTasksInUnplannedLevel = 'CHANGING_TASKS_IN_UNPLANNED_LEVEL',
  /** Попытка изменить задания без обновления СЗ */
  ChangingTasksWithoutPlaylistUpdate = 'CHANGING_TASKS_WITHOUT_PLAYLIST_UPDATE',
  /** Фича флаг для нового варианта Траектории выключен для этого пользователя */
  FunctionalityNotAvailable = 'FUNCTIONALITY_NOT_AVAILABLE',
  /** Нет прав на чтение Модуля */
  GoalReadAccessDenied = 'GOAL_READ_ACCESS_DENIED',
  /** Недостаточно Заданий для зачтения -- Траектория не будет сформирована */
  NotEnoughTasksForAchieve = 'NOT_ENOUGH_TASKS_FOR_ACHIEVE',
  /** Попытка перегенерировать Траекторию при отсутствии изменений в СЗ или уровне */
  NoChangeDetected = 'NO_CHANGE_DETECTED',
  /** Попытка сохранить тот же набор заданий */
  NoChangeInTasks = 'NO_CHANGE_IN_TASKS',
  /** В Элементе Цели нет заданий -- нужна ли такая ошибка? */
  NoTaskFoundInGoalElement = 'NO_TASK_FOUND_IN_GOAL_ELEMENT',
  /** На уровне нет заданий --его нельзя выбирать целевым */
  NoTaskFoundInLevel = 'NO_TASK_FOUND_IN_LEVEL',
  /** В Траектории нет заданий -- нужна ли такая ошибка? */
  NoTaskFoundInTrajectory = 'NO_TASK_FOUND_IN_TRAJECTORY',
  /** У пользователя нет Родительского доступа к переданному Ученику */
  ParentAccessDenied = 'PARENT_ACCESS_DENIED',
  /** Попытка перегенерировать Траекторию, не изменив целевой уровень */
  SameTargetGoalLevel = 'SAME_TARGET_GOAL_LEVEL',
  Success = 'SUCCESS',
  /** Указанный Целевой уровень Ученика не найден -- невероятно маловероятный случай с рассинхроном данных в наших БД, не думаю, что нужна текстовка */
  TargetLevelNotFound = 'TARGET_LEVEL_NOT_FOUND',
  /** У Ученика нет Целевого уровня */
  TargetLevelNotSet = 'TARGET_LEVEL_NOT_SET',
  /** Не найдена Траектории -- для страниц, которые могут быть доступны только после создания Траектории */
  TrajectoryNotFound = 'TRAJECTORY_NOT_FOUND',
  /** Несоответствие переданного Модуля и Элемента Цели */
  UnmatchedGoalAndGoalElement = 'UNMATCHED_GOAL_AND_GOAL_ELEMENT',
  /** Несоответствие переданного Уровня и Элемента Цели */
  UnmatchedGoalLevelAndGoalElement = 'UNMATCHED_GOAL_LEVEL_AND_GOAL_ELEMENT'
}

export type PersonalizeStudentModuleAndChangeTeacherTaskSetsRequest = {
  /** Созданный Учительский Плейлист назначенный Ученику в рамках этого Учебного Модуля */
  assignedPlaylist?: InputMaybe<TaskSetInput>;
  /**
   * Идентификатор назначенного на студента Плейлиста по Учебному Модулю
   * (нужно передавать только в случае если Плейлист Ученика был изменен на уже существующий)
   */
  assignedPlaylistId?: InputMaybe<Scalars['ID']['input']>;
  /**
   * Тип назначенного на Студента Плейлиста по Учебному Модулю
   * (нужно передавать только в случае если Плейлист Ученика был изменен)
   */
  assignedPlaylistType?: InputMaybe<PlaylistType>;
  /** Измененные Плейлисты Учителя */
  changedTeacherTaskSets: Array<TaskSetInput>;
  /** Созданные Плейлисты Учителя */
  createdTeacherTaskSet: Array<TaskSetInput>;
  /** Массив идентификаторов, удаленных Плейлистов Учителя */
  deletedTeacherTaskSetIds: Array<Scalars['ID']['input']>;
  /** Измененная запланированная дата закрытия Учебного Модуля */
  endDate?: InputMaybe<Scalars['String']['input']>;
  /** Измененный Уровень закрытия Учебного Модуля */
  goalLevelForAchieve?: InputMaybe<Scalars['Float']['input']>;
  /** Является ли дедлайл жестким. После истечения жесткого дедлайна нельзять отправлять задания модуля на проверку */
  isHardEndDate: Scalars['Boolean']['input'];
  /**
   * в случае isNeedToCheckAffecting = true модуль будет персонализирован только если не изменился целевой уровень модуля к
   * выполнению которого приступил ученик, при isNeedToCheckAffecting = false модуль будет персонализирован в любом случае
   */
  isNeedToCheckAffecting: Scalars['Boolean']['input'];
  /** Измененная трудоемкость */
  laboriousness?: InputMaybe<Scalars['Int']['input']>;
  /** Идентификатор Учебного Модуля (goals.goal_id) */
  moduleId: Scalars['ID']['input'];
  /** Флаг означающий, что Учебный Модуль был персонализирован в контексте Студента */
  modulePersonalized: Scalars['Boolean']['input'];
  /** Измененная запланированная дата начала выполнения Учебного Модуля */
  startDate?: InputMaybe<Scalars['String']['input']>;
  /** Идентификатор Студента (students.student_id) */
  studentId: Scalars['UUID']['input'];
};

export type PersonalizeStudentModuleAndChangeTeacherTaskSetsResponse = {
  __typename?: 'PersonalizeStudentModuleAndChangeTeacherTaskSetsResponse';
  /** успешено ли выполнение запроса (пройдены ли все проверки) */
  isSuccess: Scalars['Boolean']['output'];
  /** Персонализированный Учебный Модуль */
  module?: Maybe<StudentModule>;
  /** Все Плейлисты доступные Учителю по этому Учебному Модулю, как Учительские так и Базовые */
  taskSets?: Maybe<Array<TaskSet>>;
};

/** Соответствие % выполнения плана к отметке */
export type PlanCompletingToMarkRelation = {
  __typename?: 'PlanCompletingToMarkRelation';
  /** Идентификатор отметки */
  markId: Scalars['ID']['output'];
  /** Кол-во % завершенности плана для получения отметки */
  planCompetingPercentCount: Scalars['Int']['output'];
  /** Идентификатор соответствия % выполнения плана к отметке */
  planCompletingToMarkRelationId: Scalars['ID']['output'];
  /** Идентификатор конфигурации оценивания к которой относится данное соотношение */
  schoolStageRatingConfigurationId: Scalars['ID']['output'];
};

export type PlanCompletingToMarkRelationInput = {
  /** Идентификатор отметки */
  markId: Scalars['ID']['input'];
  /** Кол-во % завершенности плана для получения отметки */
  planCompetingPercentCount: Scalars['Int']['input'];
};

/** Условия прохождения учебного модуля в плане */
export type PlanFrameCondition = {
  __typename?: 'PlanFrameCondition';
  /** Мета-информация для определенного условия */
  conditionMeta?: Maybe<Scalars['String']['output']>;
  /** Тип условия */
  conditionType: ConditionType;
  id: Scalars['ID']['output'];
};

/** Входящие условия прохождения учебного модуля в плане */
export type PlanFrameConditionInput = {
  /** Мета-информация для определенного условия */
  conditionMeta?: InputMaybe<Scalars['String']['input']>;
  /** Тип условия */
  conditionType: ConditionType;
};

/** Типы сущностей в плане */
export enum PlanItemType {
  /** Курс */
  Course = 'COURSE',
  /** Проект в курсе */
  CourseProject = 'COURSE_PROJECT',
  /** Проект */
  Project = 'PROJECT'
}

export enum PlanStatusEnum {
  /** Черновик, не сохранен */
  Draft = 'DRAFT',
  /** Опубликован, ученики его используют */
  Published = 'PUBLISHED'
}

export enum PlanTypeEnum {
  /** на класс */
  Class = 'CLASS',
  /** вне плана */
  OutOfPlan = 'OUT_OF_PLAN',
  /** персональный */
  Personal = 'PERSONAL',
  /** на параллель */
  Stage = 'STAGE'
}

/** Типы планов */
export enum PlanTypeForCondition {
  /** План на класс */
  Class = 'CLASS',
  /** Глобальный план */
  Global = 'GLOBAL',
  /** Глобальный курс вне плана */
  GlobalCourseOutOfPlan = 'GLOBAL_COURSE_OUT_OF_PLAN',
  /** Локальный курс вне плана */
  LocalCourse = 'LOCAL_COURSE',
  /** План на параллель */
  Stage = 'STAGE'
}

export type PlanningMutations = {
  __typename?: 'PlanningMutations';
  /** Копирование тематического плана */
  copyThematicPlan: ThematicPlan;
  /** Создание календарно-тематического плана */
  createCalendarThematicPlan: CalendarThematicPlan;
  /** Создание тематического плана */
  createThematicPlan: ThematicPlan;
  /** Удаление календарно-тематического плана */
  deleteCalendarThematicPlan: Scalars['Boolean']['output'];
  /** Удаление тематического плана */
  deleteThematicPlan: Scalars['Boolean']['output'];
  /** Синхронизация календарно-тематического плана и расписания */
  syncCalendarThematicPlan: CalendarThematicPlan;
  /** Редактирование календарно-тематического плана */
  updateCalendarThematicPlan: CalendarThematicPlan;
  /** Технический метод, Нужен для того, чтобы создался вложенный класс thematicPlanTopicLessonInput */
  updateCalendarThematicPlanTopicLesson: Scalars['Boolean']['output'];
  /** Редактирование тематического плана */
  updateThematicPlan: ThematicPlan;
  /** Технический метод, Нужен для того, чтобы создался вложенный класс thematicPlanTopicLessonInput */
  updateThematicPlanTopicLesson: Scalars['Boolean']['output'];
};


export type PlanningMutationsCopyThematicPlanArgs = {
  thematicPlanID: Scalars['ID']['input'];
};


export type PlanningMutationsCreateCalendarThematicPlanArgs = {
  stageSubjectGroupId: Scalars['ID']['input'];
  thematicPlanId: Scalars['ID']['input'];
};


export type PlanningMutationsCreateThematicPlanArgs = {
  thematicPlanCreationInput: ThematicPlanCreationInput;
};


export type PlanningMutationsDeleteCalendarThematicPlanArgs = {
  calendarThematicPlanId: Scalars['ID']['input'];
};


export type PlanningMutationsDeleteThematicPlanArgs = {
  thematicPlanID: Scalars['ID']['input'];
};


export type PlanningMutationsSyncCalendarThematicPlanArgs = {
  calendarThematicPlanId: Scalars['ID']['input'];
  stageSubjectGroupId: Scalars['ID']['input'];
};


export type PlanningMutationsUpdateCalendarThematicPlanArgs = {
  calendarThematicPlanInput: CalendarThematicPlanInput;
};


export type PlanningMutationsUpdateCalendarThematicPlanTopicLessonArgs = {
  calendarThematicPlanTopicLessonInput: CalendarThematicPlanTopicLessonInput;
};


export type PlanningMutationsUpdateThematicPlanArgs = {
  thematicPlanInput: ThematicPlanInput;
};


export type PlanningMutationsUpdateThematicPlanTopicLessonArgs = {
  thematicPlanTopicLessonInput: ThematicPlanTopicLessonInput;
};

export type PlanningQueries = {
  __typename?: 'PlanningQueries';
  /** выдает список академических лет школы. */
  getAcademicYears: Array<AcademicYear>;
  /** Запрос уровней доступа */
  getAccessLevels: Array<Maybe<ThematicPlanAccessLevel>>;
  /** Запрос календарно-тематического плана по ID */
  getCalendarThematicPlan: CalendarThematicPlan;
  /** Возвращает инфомацию о наличии КТП и урока по идентификатору ГКпП и времени начала урока */
  getCalendarThematicPlanLessonStatus: CalendarThematicPlanLessonStatus;
  /** Запрос календарно-тематических планов с фильтрацией */
  getCalendarThematicPlansByFilter: Array<CalendarThematicPlan>;
  /** Запрос календарно-тематического плана по ID ГКпП */
  getCalendarThematicPlansByStageSubjectGroupIds: Array<CalendarThematicPlan>;
  /** возвращает информацию по ГКпП по идентификатору */
  getStageSubjectGroup: StageSubjectGroup;
  /** поиск ГКпП по фильтру и группировка по параллели */
  getStageSubjectGroupsGroupedByStageByFilter: Array<PlanningStageInfo>;
  /** Выдает список параллелей в школе. Для ТП. */
  getStages: Array<Stage>;
  /** Выдает список параллелей в выбранном учебном году. Для КТП */
  getStagesForCalendarThematicPlanning: Array<Stage>;
  /** список предметов для ТП */
  getSubjects: Array<Subject>;
  /** список предметов для КТП */
  getSubjectsForCalendarThematicPlanning: Array<Subject>;
  /** Запрос тематического плана по ID */
  getThematicPlan: ThematicPlan;
  /** Запрос тематических планов с фильтрацией */
  getThematicPlansByFilter: Array<ThematicPlan>;
};


export type PlanningQueriesGetAcademicYearsArgs = {
  schoolId?: InputMaybe<Scalars['ID']['input']>;
};


export type PlanningQueriesGetCalendarThematicPlanArgs = {
  calendarThematicPlanId: Scalars['ID']['input'];
};


export type PlanningQueriesGetCalendarThematicPlanLessonStatusArgs = {
  lessonStartDateTime: Scalars['DateTime']['input'];
  stageSubjectGroupId: Scalars['ID']['input'];
};


export type PlanningQueriesGetCalendarThematicPlansByFilterArgs = {
  filter: CalendarThematicPlanFilter;
};


export type PlanningQueriesGetCalendarThematicPlansByStageSubjectGroupIdsArgs = {
  stageSubjectGroupIds: Array<InputMaybe<Scalars['ID']['input']>>;
};


export type PlanningQueriesGetStageSubjectGroupArgs = {
  stageSubjectGroupId: Scalars['ID']['input'];
};


export type PlanningQueriesGetStageSubjectGroupsGroupedByStageByFilterArgs = {
  filter: StageSubjectGroupFilter;
};


export type PlanningQueriesGetStagesForCalendarThematicPlanningArgs = {
  academicYearId: Scalars['ID']['input'];
};


export type PlanningQueriesGetSubjectsForCalendarThematicPlanningArgs = {
  academicYearId: Scalars['ID']['input'];
};


export type PlanningQueriesGetThematicPlanArgs = {
  thematicPlanId: Scalars['ID']['input'];
};


export type PlanningQueriesGetThematicPlansByFilterArgs = {
  filter?: InputMaybe<ThematicPlanFilter>;
};

/** Класс */
export type PlanningStageGroupInfo = {
  __typename?: 'PlanningStageGroupInfo';
  /** идентификатор класса */
  stageGroup: StageGroup;
  /** группы класса по предмету */
  stageSubjectGroups: Array<PlanningStageSubjectGroupInfo>;
};

/** Параллель */
export type PlanningStageInfo = {
  __typename?: 'PlanningStageInfo';
  /** параллель */
  stage: Stage;
  /** Классы */
  stageGroups: Array<PlanningStageGroupInfo>;
};

/** ГКпП */
export type PlanningStageSubjectGroupInfo = {
  __typename?: 'PlanningStageSubjectGroupInfo';
  /** Может ли пользователь создавать КТП для данной ГКпП */
  canUserCreateCTP?: Maybe<Scalars['Boolean']['output']>;
  /** ГКпП */
  stageSubjectGroup: StageSubjectGroup;
  /** Предмет ГКПП */
  subject: Subject;
};

export type PlanningUserInfo = {
  __typename?: 'PlanningUserInfo';
  /** Имя автора/редактора плана */
  firstName: Scalars['String']['output'];
  /** Фамилия автора/редактора плана */
  lastName: Scalars['String']['output'];
  /** Отчество автора/редактора плана */
  middleName?: Maybe<Scalars['String']['output']>;
  /** Идентификатор автора/редактора плана */
  userId: Scalars['ID']['output'];
};

/** S21. Информация по решению проекта с платформенным типом (исп. на странице удаления файлов решения) */
export type PlatfProjectSolution = {
  __typename?: 'PlatfProjectSolution';
  /** Дата создания ответа студента */
  createdAt: Scalars['Date']['output'];
  /** Логин студента (в групповом - тим лид) */
  login: Scalars['String']['output'];
  /** Название проекта */
  projectName: Scalars['String']['output'];
  /** Идентификатор ответа студента */
  studentAnswerId: Scalars['Int']['output'];
};

/** S21. Информация по решениям проектов с платформенным типом (исп. на странице удаления файлов решения) */
export type PlatfProjectSolutions = {
  __typename?: 'PlatfProjectSolutions';
  /** Список решений */
  platfProjectSolutions: Array<PlatfProjectSolution>;
  /** Общее кол-во */
  totalCount: Scalars['Int']['output'];
};

export type PlatfSolutionInfo = {
  __typename?: 'PlatfSolutionInfo';
  /** Текст комментария */
  comment?: Maybe<Scalars['String']['output']>;
  /** Идентификатор ответа студента */
  files: Array<Maybe<StudyProcessFile>>;
};

/** Персонализированный Плейлист Студента */
export type Playlist = {
  __typename?: 'Playlist';
  /**
   * Идентификатор (base_playlists.base_playlist_id)
   * @deprecated Field no longer supported
   */
  id: Scalars['ID']['output'];
  isDefault: Scalars['Boolean']['output'];
  /** Уровень Учебного Модуля внутри Персонального Плейлиста */
  levels: Array<PlaylistLevel>;
  /** Сумма минимально-необходимых к выполнению заданий во всех слотах плейлиста */
  minimumNumberOfTasksSum: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  playlistId: Scalars['ID']['output'];
  playlistType: PlaylistType;
};

/** Элемент Цели внутри Персонального Плейлиста */
export type PlaylistGoalElement = {
  __typename?: 'PlaylistGoalElement';
  /** @deprecated Field no longer supported */
  goalElementName: Scalars['String']['output'];
  /** Идентификатор (skills.skill_id) */
  id: Scalars['ID']['output'];
  /** Буквенное обозначение Элемента цели (А, Б, ...) */
  letter: Scalars['String']['output'];
  /** Циферное обозначение Элемента цели (1, 2, 3...) */
  number: Scalars['String']['output'];
  /** Слоты внутри Персонального Плейлиста */
  slots: Array<PlaylistSlot>;
  /** Название Элемента Цели для Студента */
  studentDescription: Scalars['String']['output'];
};

/** Уровень Учебного Модуля внутри Персонального Плейлиста */
export type PlaylistLevel = {
  __typename?: 'PlaylistLevel';
  /** Элемент Цели внутри Персонального Плейлиста */
  goalElements: Array<PlaylistGoalElement>;
  /** Идентификатор (goal_levels.goal_level_id) */
  id: Scalars['ID']['output'];
  /** Числовое значение Уровня Учебного Модуля (1.0,2.0) */
  level: Scalars['Float']['output'];
};

/** Слоты внутри Персонального Плейлиста */
export type PlaylistSlot = {
  __typename?: 'PlaylistSlot';
  /** Идентификатор (base_playlist_slots.base_playlist_slot_id) */
  id: Scalars['ID']['output'];
  /**
   * Флаг -является ли этот слот слотом для проверочных Заданий, вместо него следует использовать slotType
   * @deprecated Field no longer supported
   */
  isCheck: Scalars['Boolean']['output'];
  /** Минимальное количество Заданий, которое необходимо выполнить */
  minimumNumberOfTasks: Scalars['Int']['output'];
  slotId: Scalars['ID']['output'];
  /** Задания внутри Слота */
  slotTasks: Array<PlaylistSlotTask>;
  /** Тип слота */
  slotType?: Maybe<PlaylistSlotTypeEnum>;
  /** @deprecated Field no longer supported */
  tasks: Array<StudentTask>;
};

/** Задание внутри Слота */
export type PlaylistSlotTask = {
  __typename?: 'PlaylistSlotTask';
  /** Идентификатор (base_playlist_slot_task.base_playlist_slot_task_id) */
  id: Scalars['ID']['output'];
  /** Флаг - обязательно ли данное Задание в рамках этого Слота */
  mandatory: Scalars['Boolean']['output'];
  /** Сквозной порядковый номер задания в плэйлисте */
  order: Scalars['ID']['output'];
  /** Задание */
  task: StudentTask;
};

export enum PlaylistSlotTypeEnum {
  /** Для проверочных заданий */
  Check = 'CHECK',
  /** Слот с невалидным состоянием */
  Incorrect = 'INCORRECT',
  /** Для Мотивационных заданий */
  Motivation = 'MOTIVATION',
  /** Для теорий/информационных заданий */
  Theory = 'THEORY',
  /** для учебных заданий */
  Training = 'TRAINING'
}

/** Области видимости (скоупы) */
export enum PlaylistType {
  /** Базовый плейлист */
  Base = 'BASE',
  /** Плейлист Учителя */
  Teacher = 'TEACHER'
}

/** Ключевые слова для формирования промпт-строк */
export type PortfolioAvatarPromptDetailModel = {
  __typename?: 'PortfolioAvatarPromptDetailModel';
  /** Описание */
  portfolioAvatarPromptDetailDescription: Scalars['String']['output'];
  /** Идентификатор */
  portfolioAvatarPromptDetailId?: Maybe<Scalars['ID']['output']>;
  /** Наименование */
  portfolioAvatarPromptDetailName: Scalars['String']['output'];
  /** Тип */
  portfolioAvatarPromptDetailType: Scalars['String']['output'];
};

/** Бейдж за достижение */
export type PortfolioBadge = {
  __typename?: 'PortfolioBadge';
  /** Описание бейджа */
  description: Scalars['String']['output'];
  /** Вспомогательное поле (для frontend стороны), отвечающее за наименование окна при отображении бейджа за достижение */
  feModalWindowName?: Maybe<Scalars['String']['output']>;
  /** Наименование бейджа */
  name: Scalars['String']['output'];
  /** Идентификатор бейджа */
  portfolioBadgeId: Scalars['ID']['output'];
  /** URL изображения бейджа */
  portfolioBadgeUrl: Scalars['String']['output'];
};

/** Документ портфолио */
export type PortfolioDocument = {
  __typename?: 'PortfolioDocument';
  /** Категория документа */
  documentCategory?: Maybe<PortfolioDocumentCategory>;
  /** Дата события или выдачи документа */
  documentDate?: Maybe<Scalars['Date']['output']>;
  /** Наименование документа */
  documentName?: Maybe<Scalars['String']['output']>;
  /** Тип документа */
  documentType?: Maybe<PortfolioDocumentsType>;
  /** Дополнительные поля */
  fields?: Maybe<Array<Maybe<PortfolioDocumentFields>>>;
  /** Ссылки на файл в портфолио */
  files?: Maybe<Array<Maybe<PortfolioDocumentFile>>>;
  /** Идентификатор документа */
  portfolioDocumentId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор Школы */
  schoolId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор пользователя (учителя) */
  userId?: Maybe<Scalars['ID']['output']>;
};

export type PortfolioDocumentCategory = {
  __typename?: 'PortfolioDocumentCategory';
  /** Код категории документа */
  categoryCode?: Maybe<Scalars['String']['output']>;
  /** Наименование категории документа */
  categoryName?: Maybe<Scalars['String']['output']>;
  /** Родитель категории */
  categoryParent?: Maybe<Scalars['String']['output']>;
  /** Идентификатор категории документа */
  documentCategoryId?: Maybe<Scalars['UUID']['output']>;
};

export type PortfolioDocumentComment = {
  __typename?: 'PortfolioDocumentComment';
  /** Дата создания комментария к достижению */
  created?: Maybe<Scalars['DateTime']['output']>;
  /** Идентификатор родительского комментария */
  parentId?: Maybe<Scalars['UUID']['output']>;
  /** Идентификатор комментария к документу */
  portfolioDocumentCommentId?: Maybe<Scalars['UUID']['output']>;
  /** URL аватара отправителя */
  senderAvatarUrl?: Maybe<Scalars['String']['output']>;
  /** Идентификатор отправителя комментария */
  senderId?: Maybe<Scalars['UUID']['output']>;
  /** ФИО отправителя */
  senderName?: Maybe<Scalars['String']['output']>;
  /** Текст комментария к достижению */
  text?: Maybe<Scalars['String']['output']>;
};

/** Дополнительные поля */
export type PortfolioDocumentFields = {
  __typename?: 'PortfolioDocumentFields';
  /** Наименование поля */
  fieldName?: Maybe<Scalars['String']['output']>;
  /** Значение поля */
  fieldValue?: Maybe<Scalars['String']['output']>;
};

/** Дополнительные поля */
export type PortfolioDocumentFieldsInput = {
  /** Наименование поля */
  fieldName: Scalars['String']['input'];
  /** Значение поля */
  fieldValue: Scalars['String']['input'];
};

/** Ссылки на файл в портфолио */
export type PortfolioDocumentFile = {
  __typename?: 'PortfolioDocumentFile';
  /** Признак, что файл нужно использовать, как обложку для документа (TRUE - файл обложки, FALSE - все остальные файлы) */
  documentFileCover?: Maybe<Scalars['Boolean']['output']>;
  /** Размер файла */
  fileSize: Scalars['Int']['output'];
  /** Идентификатор документа, к которому присоединен файл */
  portfolioDocumentId?: Maybe<Scalars['UUID']['output']>;
  /** Идентификатор файла */
  portfolioFileId?: Maybe<Scalars['UUID']['output']>;
  /** Имя файла, которое задает пользователь при присоединении файла к документу в портфолио */
  portfolioFileName?: Maybe<Scalars['String']['output']>;
  /** Ссылка на файл в хранилище */
  relativePath?: Maybe<Scalars['String']['output']>;
};

/** Ссылки на файл в портфолио */
export type PortfolioDocumentFileInput = {
  /** Признак, что файл нужно использовать, как обложку для документа (TRUE - файл обложки, FALSE - все остальные файлы) */
  documentFileCover: Scalars['Boolean']['input'];
  /** Размер файла */
  fileSize: Scalars['Int']['input'];
  /** Признак того, что нужно удалить файл из хранилища */
  isDelete?: InputMaybe<Scalars['Boolean']['input']>;
  /** Идентификатор документа, к которому присоединен файл */
  portfolioDocumentId?: InputMaybe<Scalars['UUID']['input']>;
  /** Идентификатор файла */
  portfolioFileId?: InputMaybe<Scalars['UUID']['input']>;
  /** Имя файла, которое задает пользователь при присоединении файла к документу в портфолио */
  portfolioFileName: Scalars['String']['input'];
  /** Ссылка на файл в хранилище */
  relativePath: Scalars['String']['input'];
};

export type PortfolioDocumentReaction = {
  __typename?: 'PortfolioDocumentReaction';
  /** Дата создания реакции к достижению */
  created?: Maybe<Scalars['DateTime']['output']>;
  /** Имя реакции к достижению */
  name?: Maybe<Scalars['String']['output']>;
  /** Идентификатор реакции к документу */
  portfolioDocumentReactionId?: Maybe<Scalars['UUID']['output']>;
  /** URL аватара отправителя */
  senderAvatarUrl?: Maybe<Scalars['String']['output']>;
  /** Идентификатор отправителя реакции */
  senderId?: Maybe<Scalars['UUID']['output']>;
  /** ФИО отправителя */
  senderName?: Maybe<Scalars['String']['output']>;
  /** URL реакции к достижению */
  url?: Maybe<Scalars['String']['output']>;
};

export type PortfolioDocumentReactionsComments = {
  __typename?: 'PortfolioDocumentReactionsComments';
  /** Список объектов-комментариев к документу портфолио */
  portfolioDocumentComments?: Maybe<Array<Maybe<PortfolioDocumentComment>>>;
  /** Идентификатор документа */
  portfolioDocumentId?: Maybe<Scalars['UUID']['output']>;
  /** Список объектов-реакций к документу портфолио */
  portfolioDocumentReactions?: Maybe<Array<Maybe<PortfolioDocumentReaction>>>;
};

export type PortfolioDocumentsType = {
  __typename?: 'PortfolioDocumentsType';
  /** Идентификатор типа документа */
  documentTypeId?: Maybe<Scalars['UUID']['output']>;
  /** Код типа документа */
  typeCode?: Maybe<Scalars['String']['output']>;
  /** Наименование типа документа */
  typeName?: Maybe<Scalars['String']['output']>;
};

/** Справочник портфолио */
export type PortfolioFieldValueList = {
  __typename?: 'PortfolioFieldValueList';
  /** Значения дополнительных полей */
  additionalFields?: Maybe<Array<Maybe<PortfolioListAdditionalField>>>;
  /** Категория документа */
  documentCategory?: Maybe<PortfolioDocumentCategory>;
  /** Идентификатор */
  portfolioFieldValueListId?: Maybe<Scalars['ID']['output']>;
  /** Тип значения справочника */
  type: Scalars['String']['output'];
  /** Значение справочника */
  value: Scalars['String']['output'];
};

/** Дополнительные поля */
export type PortfolioListAdditionalField = {
  __typename?: 'PortfolioListAdditionalField';
  /** Значение справочника */
  name: Scalars['String']['output'];
  /** Значение атрибута */
  value?: Maybe<Scalars['String']['output']>;
};

export type PortfolioReaction = {
  __typename?: 'PortfolioReaction';
  name: Scalars['String']['output'];
  portfolioReactionId: Scalars['String']['output'];
  url: Scalars['String']['output'];
};

export type Position = {
  __typename?: 'Position';
  /** Идентификатор должности */
  id: Scalars['UUID']['output'];
  /** Наименование должности */
  name: Scalars['String']['output'];
};

export type Price = {
  __typename?: 'Price';
  /**
   * Стоимость в минимальной единице валюты.
   * Зависит от Currency.fractionDigits. Так, если число знаков после запятой 2, а стоимость 1337,
   * валюта - рубль, то стоимость составляет 13 рублей 37 копеек.
   */
  amount: Scalars['Int']['output'];
  /** Валюта, в которой представлена цена. */
  currency: Currency;
};

/** Информация о сессиях печати задания */
export type PrintTaskMeta = {
  __typename?: 'PrintTaskMeta';
  /**
   * Количество копий, сделанных текущим пользователем, за последний год,
   * начиная с первого сентября (в контексте UTC).
   */
  printCountsForYear: Scalars['Int']['output'];
};

export type PrivateFeedbackInput = {
  comment: Scalars['String']['input'];
  userId: Scalars['UUID']['input'];
};

/** Информация о обработанной заявке на расформирование команды */
export type ProcessedTeamDisbandRequestInfo = {
  __typename?: 'ProcessedTeamDisbandRequestInfo';
  /** Дата обработки заявки */
  dateOfRequestProcessing?: Maybe<Scalars['DateTime']['output']>;
  /** Идентификатор статуса заявки */
  disbandRequestStatus?: Maybe<DisbandRequestStatus>;
  /** Информация о проводимом голосовании для расформирования команды */
  disbandmentTeamVotingInfo?: Maybe<DisbandmentTeamVotingInfo>;
  /** Количество часов, которое заявка находилась на рассмотрении */
  hoursToConsider?: Maybe<Scalars['Int']['output']>;
  /** Логин пользователя, обработавшего запрос */
  login?: Maybe<Scalars['String']['output']>;
  /** Название параллели, с которой пришла заявка */
  parallelName?: Maybe<Scalars['String']['output']>;
  /** Название проекта */
  projectName?: Maybe<Scalars['String']['output']>;
  /** Идентификатор заявки на расформирование команды */
  teamDisbandRequestId?: Maybe<Scalars['ID']['output']>;
  /** Информация о размере команды */
  teamSizeInfo?: Maybe<TeamSizeInfo>;
};

/** Параметры прокторинга */
export type ProctoringParameters = {
  __typename?: 'ProctoringParameters';
  /** URL для прокторинга */
  examusURL: Scalars['String']['output'];
  /** часть URL для интеграции с экзамусом */
  integrationName: Scalars['String']['output'];
  /** ID сессии пользователя */
  sessionId: Scalars['UUID']['output'];
  /** Статус сеанса прокторинга в Экзамусе */
  sessionStatus: SessionStatusFromExamus;
  /** токен */
  token: Scalars['String']['output'];
};

export type ProfileCover = {
  __typename?: 'ProfileCover';
  profileCoverFileId: Scalars['ID']['output'];
  profileCoverFileUrl: Scalars['String']['output'];
};

export type ProfileCoverUser = {
  __typename?: 'ProfileCoverUser';
  coverFileUrl: Scalars['String']['output'];
  userCoverId: Scalars['ID']['output'];
  userId: Scalars['UUID']['output'];
};

/**
 * Тип профиля польщователя, приглашенного на платформу
 * Расширяет ролевую модель для специфичного набора фролей
 */
export enum ProfileType {
  /** Стандартный БА */
  BusinessAdm = 'BUSINESS_ADM'
}

/** Уровень видимости профиля участника акселератора. */
export enum ProfileVisibilityLevel {
  Closed = 'CLOSED',
  Opened = 'OPENED',
  PartiallyClosed = 'PARTIALLY_CLOSED'
}

/** Результаты поиска учеников в глобальном поиске Ш21 */
export type ProfilesSearchResult = {
  __typename?: 'ProfilesSearchResult';
  /** Общее количество найденных профилей */
  count?: Maybe<Scalars['Int']['output']>;
  /** Профили учеников с учетом пагинации */
  profiles: Array<Maybe<S21StudentPublicProfileBasicInfo>>;
};

export type ProforientationConfigurationQueryV2 = {
  __typename?: 'ProforientationConfigurationQueryV2';
  /** Информация о текущем периоде в Профориентации */
  currentPeriodInfo: PeriodInfo;
  /** Root URL перехода в Метаверс */
  metaverseUrl: Scalars['String']['output'];
  /** Информация о следующем периоде в Профориентации */
  nextPeriodInfo: PeriodInfo;
  /** запрос для получения ключевых дат и периодов в профориентации. */
  proforientationPeriodsInfo?: Maybe<Array<Maybe<PeriodInfo>>>;
};


export type ProforientationConfigurationQueryV2ProforientationPeriodsInfoArgs = {
  bigChallengePeriods?: InputMaybe<Array<InputMaybe<BigChallengePeriod>>>;
};

export type ProforntUiElement = {
  __typename?: 'ProforntUIElement';
  /** тип элемента UI */
  name: ProforntUiElementName;
  /** Состояние элемента UI у пользователя. */
  state: ProforntUiElementState;
  /** Дата и время изменения состояния. */
  stateTimestamp: Scalars['Int']['output'];
  /** id пользователя */
  userId: Scalars['UUID']['output'];
};

export type ProforntUiElementMutations = {
  __typename?: 'ProforntUiElementMutations';
  changeProforntUIElementState?: Maybe<Scalars['Boolean']['output']>;
};


export type ProforntUiElementMutationsChangeProforntUiElementStateArgs = {
  name: ProforntUiElementName;
  state: ProforntUiElementState;
  userId: Scalars['UUID']['input'];
};

export enum ProforntUiElementName {
  BigChallengePassedNotification = 'BIG_CHALLENGE_PASSED_NOTIFICATION',
  TrialPeriodStartModal = 'TRIAL_PERIOD_START_MODAL',
  WinterChangeNotification = 'WINTER_CHANGE_NOTIFICATION'
}

export type ProforntUiElementQuery = {
  __typename?: 'ProforntUiElementQuery';
  proforntUiElement?: Maybe<ProforntUiElement>;
};


export type ProforntUiElementQueryProforntUiElementArgs = {
  name: ProforntUiElementName;
  userId: Scalars['UUID']['input'];
};

export enum ProforntUiElementState {
  Shown = 'SHOWN'
}

/** Результат верификации настроек программы */
export type ProgramValidation = {
  __typename?: 'ProgramValidation';
  /** количество добавляемых в программу школ */
  addedSchoolCount: Scalars['Int']['output'];
  /** количество школ программы, для которых изменятся проверяющие */
  changedSchoolCount: Scalars['Int']['output'];
  /** количество направлений в программе */
  directionCount: Scalars['Int']['output'];
  /** список направлений (предметов) программы */
  directions: Array<Scalars['String']['output']>;
  /** список ошибок при валидации */
  errors: Array<Scalars['String']['output']>;
  /** количество отключаемых от программы школ */
  removedSchoolCount: Scalars['Int']['output'];
  /** общее количество провалидированных школ */
  schoolCount: Scalars['Int']['output'];
  /** список предупреждений при валидации */
  warnings: Array<Scalars['String']['output']>;
};

/**
 * Группа проверяющих (региональных или школьных) программы Внешнего обучения,
 * Конкурса или Внешнего конкурса по направлению (предмету)
 */
export type ProgramVerifierGroups = {
  __typename?: 'ProgramVerifierGroups';
  /** тп группы проверяющих: региональная или школьная */
  isRegional: Scalars['Boolean']['output'];
  /** идентификатор учебного предмета, на проверке которого специализируется группа */
  subjectId: Scalars['ID']['output'];
  /** короткое наименование учебного предмета */
  subjectName: Scalars['String']['output'];
  /** список проверющих, входящих в группу */
  users: Array<VerifierGroupUser>;
  /** идентификатор группы проверяющих */
  verifierGroupId: Scalars['ID']['output'];
};

export type ProgressBarDataV2 = {
  __typename?: 'ProgressBarDataV2';
  /** Прогресс по добавленным достижениям в профиль */
  achievementProgress: ProgressInfo;
  /** Прогресс по учусь учиться */
  llTaskProgress: ProgressInfo;
  /** Прогресс по всем активностям */
  overallProgress: OverallProgress;
  /** суммарное количество баллов по предметным модулям */
  overallSubjectCategoryProgress?: Maybe<Scalars['Int']['output']>;
  /** Прогресс по квестам в метавселенной */
  questProgress: ProgressInfo;
  /** Прогресс по категориям школьных предметов */
  subjectCategoryProgress: Array<SubjectCategoryProgressV2>;
};

/** Информацию о прогрессе прохождения проверок */
export type ProgressCheckInfo = {
  __typename?: 'ProgressCheckInfo';
  /** Общее кол-во требуемых проверок */
  reviewUserCount: Scalars['Int']['output'];
  /** Пройденное кол-во проверок */
  reviewUserCountExecuted: Scalars['Int']['output'];
};

export type ProgressInfo = {
  __typename?: 'ProgressInfo';
  /** Текущий прогресс по активности */
  progress: Scalars['Int']['output'];
  /** Прогресс по активности за текущую неделю */
  progressCurrentWeek: Scalars['Int']['output'];
  /** Текущий прогресс по активности без учета результатов текущей недели */
  progressWithoutCurrentWeek: Scalars['Int']['output'];
};

export type Project = IProject & {
  __typename?: 'Project';
  branch: Branch;
  branchOtherDesc?: Maybe<Scalars['String']['output']>;
  country: Country;
  customer: Customer;
  customerOtherDesc?: Maybe<Scalars['String']['output']>;
  description: Scalars['String']['output'];
  files?: Maybe<Array<Maybe<ProjectFile>>>;
  id: Scalars['UUID']['output'];
  logotypeUrl?: Maybe<Scalars['String']['output']>;
  modifiedAt: Scalars['DateTime']['output'];
  name: Scalars['String']['output'];
  parentId?: Maybe<Scalars['UUID']['output']>;
  region?: Maybe<Region>;
  shortName: Scalars['String']['output'];
  state: ProjectState;
  teamId: Scalars['UUID']['output'];
  technology: Technology;
  technologyOtherDesc?: Maybe<Scalars['String']['output']>;
};

export type ProjectAdd = {
  __typename?: 'ProjectAdd';
  invitedDate?: Maybe<Scalars['DateTime']['output']>;
  requestedDate?: Maybe<Scalars['DateTime']['output']>;
  vacancyName?: Maybe<Scalars['String']['output']>;
  viewedDate?: Maybe<Scalars['DateTime']['output']>;
};

export type ProjectAssessmentInput = {
  grade?: InputMaybe<AcceleratorProjectGrade>;
  milestone?: InputMaybe<AcceleratorMilestone>;
  projectId: Scalars['UUID']['input'];
  score?: InputMaybe<Scalars['Int']['input']>;
};

/** Информация о проверках за попытку выполнения проекта */
export type ProjectAttemptEvaluationsInfo = {
  __typename?: 'ProjectAttemptEvaluationsInfo';
  /** Информация о результатах попытки */
  attemptResult?: Maybe<StudentGoalAttempt>;
  /** Информация об auto проверках */
  auto: AutoEvaluationInfo;
  /**
   * Информация о завершенных проверках код-ревью студенческого проекта с финальной оценкой
   * {null} - если нет проверок код-ревью
   */
  codeReview: StudentCodeReviewResult;
  /** Информация о p2p проверках */
  p2p: Array<P2PEvaluationInfo>;
  /** Ид ответа студента */
  studentAnswerId: Scalars['ID']['output'];
  /** Состав команды с возможностью перехода в профиль студента */
  team?: Maybe<TeamWithMembers>;
};

/** Информация о проверках за попытку выполнения проекта */
export type ProjectAttemptEvaluationsInfo_V1 = {
  __typename?: 'ProjectAttemptEvaluationsInfo_V1';
  /** Информация о результатах попытки */
  attemptResult?: Maybe<StudentGoalAttempt>;
  /** Информация о статусе попытки. Nullable из за обратной совместимости */
  attemptStatus?: Maybe<StudentGoalAttemptStatus>;
  /** Информация об auto проверках */
  auto: AutoEvaluationInfo;
  /**
   * Информация о завершенных проверках код-ревью студенческого проекта с финальной оценкой
   * {null} - если нет проверок код-ревью
   */
  codeReview: StudentCodeReviewResult;
  /** Информация о p2p проверках */
  p2p: Array<P2PEvaluationInfo>;
  /** Ид ответа студента */
  studentAnswerId?: Maybe<Scalars['ID']['output']>;
  /** Ид попытки */
  studentGoalAttemptId?: Maybe<Scalars['ID']['output']>;
  /** Состав команды с возможностью перехода в профиль студента */
  team?: Maybe<TeamWithMembers>;
};

/** Найденная карточка проекта */
export type ProjectCard = IProject & {
  __typename?: 'ProjectCard';
  branch: Branch;
  branchOtherDesc?: Maybe<Scalars['String']['output']>;
  country: Country;
  customer: Customer;
  customerOtherDesc?: Maybe<Scalars['String']['output']>;
  description: Scalars['String']['output'];
  files?: Maybe<Array<Maybe<ProjectFile>>>;
  id: Scalars['UUID']['output'];
  logotypeUrl?: Maybe<Scalars['String']['output']>;
  modifiedAt: Scalars['DateTime']['output'];
  name: Scalars['String']['output'];
  parentId?: Maybe<Scalars['UUID']['output']>;
  participantsCount: Scalars['Int']['output'];
  region?: Maybe<Region>;
  shortName: Scalars['String']['output'];
  state: ProjectState;
  teamId: Scalars['UUID']['output'];
  technology: Technology;
  technologyOtherDesc?: Maybe<Scalars['String']['output']>;
};

/** Статус проверки проекта */
export enum ProjectEvaluationStatus {
  /** Проверка проведена, неудачное выполнение */
  Failed = 'FAILED',
  /** Проверка не запланирована */
  NotScheduled = 'NOT_SCHEDULED',
  /** Проверка запланирована */
  Scheduled = 'SCHEDULED',
  /** Проверка проведена, успешное выполнение */
  Success = 'SUCCESS'
}

/** Информация о проверках по проекту */
export type ProjectEvaluationsInfo = {
  __typename?: 'ProjectEvaluationsInfo';
  /** Информация об auto проверках */
  auto: AutoEvaluationInfo;
  /** Информация о p2p проверках */
  p2p: Array<P2PEvaluationInfo>;
};

export type ProjectFile = {
  __typename?: 'ProjectFile';
  createDataTime: Scalars['DateTime']['output'];
  createUser: AcceleratorProfile;
  description?: Maybe<Scalars['String']['output']>;
  fileId: Scalars['String']['output'];
  fileName: Scalars['String']['output'];
  fileURL: Scalars['String']['output'];
  projectId: Scalars['String']['output'];
};

export type ProjectFileInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  fileName?: InputMaybe<Scalars['String']['input']>;
  fileURL?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['UUID']['input'];
};

export type ProjectFilterInput = {
  branchIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
  countryIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
  nameFragment?: InputMaybe<Scalars['String']['input']>;
  orgUnitId: Scalars['UUID']['input'];
  projectRoleIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
  regionIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
  state?: InputMaybe<ProjectState>;
  technologyIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
};

export type ProjectFlow = {
  __typename?: 'ProjectFlow';
  /** Дата завершения проектного потока */
  projectFlowEndDate?: Maybe<Scalars['DateTime']['output']>;
  /** Id проектного потока */
  projectFlowId: Scalars['UUID']['output'];
  /** Имя проектного потока */
  projectFlowName: Scalars['String']['output'];
  /** Дата начала проектного потока */
  projectFlowStartDate: Scalars['DateTime']['output'];
  /** Статус проектного потока */
  projectFlowStatus: ProjectFlowStatus;
  /** Количество классов проектного потока */
  stageGroupsCount?: Maybe<Scalars['Int']['output']>;
  /** Количество студентов проектного потока */
  studentsCount?: Maybe<Scalars['Int']['output']>;
};

export type ProjectFlowSaveOrUpdate = {
  projectFlowEndDate?: InputMaybe<Scalars['DateTime']['input']>;
  projectFlowId?: InputMaybe<Scalars['UUID']['input']>;
  projectFlowName: Scalars['String']['input'];
  projectFlowStartDate: Scalars['DateTime']['input'];
  stageGroups?: InputMaybe<Array<Scalars['Float']['input']>>;
};

export type ProjectFlowStageGroup = {
  __typename?: 'ProjectFlowStageGroup';
  /** Активность класса в проектном потоке */
  projectFlowActive: Scalars['Boolean']['output'];
  /** Id класса */
  stageGroupId: Scalars['UUID']['output'];
  /** Имя класса */
  stageGroupName: Scalars['String']['output'];
};

export enum ProjectFlowStatus {
  Active = 'ACTIVE',
  Finish = 'FINISH',
  Wait = 'WAIT'
}

export type ProjectFlowWithStageGroups = {
  __typename?: 'ProjectFlowWithStageGroups';
  /** Дата конца проектного потока */
  projectFlowEndDate?: Maybe<Scalars['DateTime']['output']>;
  /** Id проектного потока */
  projectFlowId: Scalars['UUID']['output'];
  /** Имя проектного потока */
  projectFlowName: Scalars['String']['output'];
  /** Дата начала проектного потока */
  projectFlowStartDate: Scalars['DateTime']['output'];
  /**
   *  Список классов проектного потока
   * !!!! В релизной версии выглядит так:
   *  stageGroups: [ProjectFlowStageGroup!]
   */
  stageGroups: Array<Maybe<ProjectFlowStageGroup>>;
};

export type ProjectInput = {
  branchId: Scalars['UUID']['input'];
  branchOtherDesc?: InputMaybe<Scalars['String']['input']>;
  countryId?: InputMaybe<Scalars['UUID']['input']>;
  customerId: Scalars['UUID']['input'];
  customerOtherDesc?: InputMaybe<Scalars['String']['input']>;
  description: Scalars['String']['input'];
  logotypeUrl?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  regionId?: InputMaybe<Scalars['UUID']['input']>;
  shortName: Scalars['String']['input'];
  technologyId: Scalars['UUID']['input'];
  technologyOtherDesc?: InputMaybe<Scalars['String']['input']>;
};

export type ProjectPage = {
  __typename?: 'ProjectPage';
  projects: Array<Maybe<ProjectViewedModel>>;
  totalCount: Scalars['Int']['output'];
};

/** Информация о проверках проекта */
export type ProjectReviewsInfo = {
  __typename?: 'ProjectReviewsInfo';
  /** Количество запланированных проверок к БА */
  relevantReviewByInspectionStaffCount: Scalars['Int']['output'];
  /** Количество запланированных проверок к студенту */
  relevantReviewByStudentsCount: Scalars['Int']['output'];
  /** Количество проверок БА для сдачи проекта */
  reviewByInspectionStaffCount: Scalars['Int']['output'];
  /** Количество проверок студентом для сдачи проекта */
  reviewByStudentCount: Scalars['Int']['output'];
};

/** Модель вакансии проекта Акселератора */
export type ProjectRole = {
  __typename?: 'ProjectRole';
  /** Требования к вакансии */
  canDo?: Maybe<Scalars['String']['output']>;
  /** Признак "вакансия уже занята" */
  isOpen: Scalars['Boolean']['output'];
  /** ID проекта */
  projectId: Scalars['UUID']['output'];
  /** ID роли из справочника */
  projectRoleId?: Maybe<Scalars['UUID']['output']>;
  /** Название роли */
  projectRoleName?: Maybe<Scalars['String']['output']>;
  /** Роль введенная вручную */
  projectRoleOther?: Maybe<Scalars['String']['output']>;
  /** ID участника вакансии */
  userId?: Maybe<Scalars['UUID']['output']>;
  /** ID вакансии */
  vacancyId: Scalars['UUID']['output'];
};

/** Модель вакансии проекта Акселератора для капитана */
export type ProjectRoleForCapitan = {
  __typename?: 'ProjectRoleForCapitan';
  /** Требования к вакансии */
  canDo?: Maybe<Scalars['String']['output']>;
  /** ID проекта */
  projectId: Scalars['UUID']['output'];
  /** ID роли из справочника */
  projectRoleId?: Maybe<Scalars['UUID']['output']>;
  /** Название роли */
  projectRoleName?: Maybe<Scalars['String']['output']>;
  /** Роль введенная вручную */
  projectRoleOther?: Maybe<Scalars['String']['output']>;
  /** Имя Участника, занявшего вакансию */
  userFirstName?: Maybe<Scalars['String']['output']>;
  /** Фамилия Участника, занявшего вакансию */
  userSecondName?: Maybe<Scalars['String']['output']>;
  /** ID вакансии */
  vacancyId: Scalars['UUID']['output'];
  /** Признак "вакансия уже занята" */
  vacancyIsOpen: Scalars['Boolean']['output'];
};

export type ProjectRoleFromDirectory = {
  __typename?: 'ProjectRoleFromDirectory';
  /** ID роли из справочника */
  projectRoleId: Scalars['UUID']['output'];
  /** Название роли */
  projectRoleName: Scalars['String']['output'];
};

/** Входная модель вакансии проекта Акселератора */
export type ProjectRoleInput = {
  /** Требования к вакансии */
  canDo?: InputMaybe<Scalars['String']['input']>;
  /** ID проекта */
  projectId?: InputMaybe<Scalars['UUID']['input']>;
  /** ID роли из справочника */
  projectRoleId?: InputMaybe<Scalars['UUID']['input']>;
  /** Роль введенная вручную */
  projectRoleOther?: InputMaybe<Scalars['String']['input']>;
  /** ID вакансии */
  vacancyId?: InputMaybe<Scalars['UUID']['input']>;
};

export type ProjectStageInput = {
  milestone: AcceleratorMilestone;
  projectId: Array<InputMaybe<Scalars['UUID']['input']>>;
};

/** Статус проекта */
export enum ProjectState {
  Closed = 'CLOSED',
  Opened = 'OPENED'
}

/** Статистика с информацией о студентах, связанных с проектом */
export type ProjectStatistics = {
  __typename?: 'ProjectStatistics';
  /** Количество студентов, успешно завершивших выполнение проекта */
  acceptedStudents: Scalars['Int']['output'];
  /** Количество студентов, находящихся в стадии проверки проекта */
  evaluationStudents: Scalars['Int']['output'];
  /** Количество студентов, неуспешно завершивших выполнение проекта */
  failedStudents: Scalars['Int']['output'];
  /** Количество студентов, завершивших выполнение проекта */
  finishedStudents: Scalars['Int']['output'];
  /** Статистика по групповому проекту */
  groupProjectStatistics?: Maybe<GroupProjectStatistics>;
  /** Количество студентов, выполняющих проект и ещё не перешедших в стадию проверки */
  inProgressStudents: Scalars['Int']['output'];
  /** Количество студентов, зарегистрированных на групповой проект */
  registeredStudents: Scalars['Int']['output'];
  /** Процент студентов, которые начали больше одной попытки выполнения проекта */
  retriedStudentsPercentage: Scalars['Int']['output'];
};

/**
 * S21 Информация о команде в групповом задании
 * DEPRECATED - use ProjectTeamWithMembers
 */
export type ProjectTeamMembers = {
  __typename?: 'ProjectTeamMembers';
  /** Кол-во участников команды */
  amountMember: Scalars['Int']['output'];
  id: Scalars['UUID']['output'];
  /** Приглашенные в команду пользователи */
  invitedUsers: Array<User>;
  /** Максимальный размер команды */
  maxTeamMemberCount: Scalars['Int']['output'];
  /** Участники команды */
  members: Array<User>;
  /** Минимальный размер команды */
  minTeamMemberCount: Scalars['Int']['output'];
  /** Тим-лид команды */
  teamLead: User;
  /** Название команды */
  teamName: Scalars['String']['output'];
  /** Статус команды */
  teamStatus: TeamStatusEnum;
};

/** Информация о команде в групповом задании */
export type ProjectTeamWithMembers = {
  __typename?: 'ProjectTeamWithMembers';
  /** Идентификатор модуля, который выполняет команда */
  goalId?: Maybe<Scalars['ID']['output']>;
  /** Приглашенные в команду студенты */
  invitedStudents: Array<StudentInvitationInfo>;
  /** Команда вместе с участниками */
  teamWithMembers: TeamWithMembers;
};

/** Элемент таймлайна проекта, каждый элемент соответствует этапу прохождения проекта (Регистрация, Выполнение, Проверка) */
export type ProjectTimelineItem = {
  __typename?: 'ProjectTimelineItem';
  /** Вложенные элементы */
  children?: Maybe<Array<Maybe<ProjectTimelineItem>>>;
  /** в зависимости от проверки как отображать элемент */
  elementType?: Maybe<TimelineElementEnum>;
  /** Время окончания этапа, которому соответствует элемент таймлайна */
  end?: Maybe<Scalars['DateTime']['output']>;
  /** порядковый номер */
  order?: Maybe<Scalars['Int']['output']>;
  /** Время начала этапа, которому соответствует элемент таймлайна */
  start?: Maybe<Scalars['DateTime']['output']>;
  /** Статус элемента таймлайна */
  status: TimelineItemStatus;
  /** Тип элемента таймлайна */
  type: TimelineItemType;
};

export type ProjectViewedModel = {
  __typename?: 'ProjectViewedModel';
  projectAdd?: Maybe<ProjectAdd>;
  projectCard: ProjectCard;
  projectFlowId: Scalars['UUID']['output'];
};

/** Результаты поиска проектов в глобальном поиске Ш21 */
export type ProjectsSearchResult = {
  __typename?: 'ProjectsSearchResult';
  /** Общее количество найденных профилей */
  count?: Maybe<Scalars['Int']['output']>;
  /** Проекты с учетом пагинации */
  projects: Array<Maybe<StudentProjectInfo>>;
};

export enum PublicationStatus {
  /** Ошибки проверки */
  ErrorValidate = 'ERROR_VALIDATE',
  /** Опубликована */
  Published = 'PUBLISHED',
  /** Проверка */
  Validate = 'VALIDATE',
  /** Проверено */
  Validated = 'VALIDATED',
  /** Ожидает публикации */
  Waiting = 'WAITING'
}

/** Ответ на публикацию контента из gitlab в ШЦП */
export type PublishContentResponse = {
  __typename?: 'PublishContentResponse';
  /** файл чек-листа */
  checklistFile?: Maybe<GitlabFile>;
  /** контент-файл */
  contentFile?: Maybe<GitlabFile>;
  /** отчет по выявленным ошибкам во время обработки данных */
  report: Array<Scalars['String']['output']>;
  /** результат публикации контента */
  result: PublishContentResult;
};

/** Результат публикации контента */
export enum PublishContentResult {
  /** сервис gitlab временно не доступен */
  NotAvailable = 'NOT_AVAILABLE',
  /** есть ошибки во время обработки данных */
  ParseError = 'PARSE_ERROR',
  /** успешная публикация */
  Success = 'SUCCESS',
  /** публикация в целом успешная, но требуется реакция пользователя */
  SuccessWithMessage = 'SUCCESS_WITH_MESSAGE'
}

/** Идентификаторы профессий/ролей/подразделений, полученных из АС Пульс с привязкой к шаблонам траекторий Bootcamp */
export type PulseJobCode = {
  __typename?: 'PulseJobCode';
  /** Дата и время создания */
  createTs?: Maybe<Scalars['DateTime']['output']>;
  /** Внешний идентификатор профессии в АС Пульс */
  extJobCodeId: Scalars['String']['output'];
  /** Название профессии в АС Пульс */
  extJobCodeName: Scalars['String']['output'];
  /** Идентификатор пользователя последним изменившим шаблон */
  lastModifierUserId?: Maybe<Scalars['UUID']['output']>;
  /** Дата и время последнего изменения */
  lastModifyTs?: Maybe<Scalars['DateTime']['output']>;
  /** Уникальный идентификатор */
  pulseJobCodeId?: Maybe<Scalars['ID']['output']>;
  /** Тип связи для определения внешнего идентификатора профессии сотрудника */
  pulseJobCodeType: PulseJobCodeType;
};

/** Данные для сохранения идентификатора профессий/ролей/подразделений */
export type PulseJobCodeInputModel = {
  /** Внешний идентификатор профессии в АС Пульс */
  extJobCodeId: Scalars['String']['input'];
  /** Название профессии в АС Пульс */
  extJobCodeName: Scalars['String']['input'];
  /** Тип связи для определения внешнего идентификатора профессии сотрудника */
  pulseJobCodeType: PulseJobCodeType;
};

/** Маппинг между шаблоном траектории и внешними идентификаторами профессий/ролей/подразделений АС Пульс */
export type PulseJobCodeMapper = {
  __typename?: 'PulseJobCodeMapper';
  /** Список профессий */
  professions: Array<Maybe<PulseJobCode>>;
  /** Список ролей */
  sbergiles: Array<Maybe<PulseJobCode>>;
  /** Идентификатор шаблона траектории */
  trajectoryTemplate: TrajectoryTemplate;
  /** Список подразделений */
  units: Array<Maybe<PulseJobCode>>;
};

/**
 * Данные для сохранения связи между шаблонами траекторий и внешними идентификаторами
 * профессий/ролей/подразделений АС Пульс для формирования траекторий новым сотрудникам Bootcamp
 */
export type PulseJobCodeMapperInputModel = {
  /** Список профессий */
  professions: Array<InputMaybe<PulseJobCodeInputModel>>;
  /** Список ролей */
  sbergiles: Array<InputMaybe<PulseJobCodeInputModel>>;
  /** Идентификатор шаблона траектории */
  trajectoryTemplateId: Scalars['ID']['input'];
  /** Список подразделений */
  units: Array<InputMaybe<PulseJobCodeInputModel>>;
};

/** Тип справочника профессий АС Пульс для сотрудников Bootcamp */
export enum PulseJobCodeType {
  /** Справочник типовых должностей */
  Profession = 'PROFESSION',
  /** Справочник ролей Sbergile */
  SbergileRole = 'SBERGILE_ROLE',
  /** Справочник подразделение */
  Unit = 'UNIT'
}

/** Информация пользователя из АС Пульс */
export type PulsePersonSmallModel = {
  __typename?: 'PulsePersonSmallModel';
  /** Список sbegile ролей пользователя в АС Пульс */
  pulseAgilePositionName?: Maybe<Scalars['String']['output']>;
  /** Город пользователя из АС Пульс */
  pulseCity?: Maybe<Scalars['String']['output']>;
  /** Внешний идентификатор пользователя в системе АС Пульс */
  pulsePersonId: Scalars['UUID']['output'];
  /** Название должности пользователя в АС Пульс */
  pulseProfessionLevelName?: Maybe<Scalars['String']['output']>;
  /** Список функциональных подразделений пользователя АС Пульс */
  pulseUnitFullName?: Maybe<Scalars['String']['output']>;
};

export type PurchaseProperties = {
  __typename?: 'PurchaseProperties';
  purchaseButtonEnabled: Scalars['Boolean']['output'];
};

/** Результат выполнения питон-кода */
export type PythonTranslationResult = {
  __typename?: 'PythonTranslationResult';
  /** Если запрос не был обработан корректно, сообщение об ошибке */
  error?: Maybe<Scalars['String']['output']>;
  /**
   * Дальнейшие поля заполняются только если status - completed
   * Результат выполнения кода - failure | success
   */
  result?: Maybe<Scalars['String']['output']>;
  /**
   * Дальнейшие поля заполняются только если success - true
   * Завершилось ли исполнение кода на данный момент. Возможные значения - pending | completed
   */
  status?: Maybe<Scalars['String']['output']>;
  /** Поток ошибок. Если скрипт "отрубился" по таймауту, то 'timeout' */
  stderr?: Maybe<Scalars['String']['output']>;
  /** Поток вывода */
  stdout?: Maybe<Scalars['String']['output']>;
  /** Корректно ли был отработан запрос внешним сервисом */
  success: Scalars['Boolean']['output'];
};

export type Query = {
  __typename?: 'Query';
  ASAP?: Maybe<AsapQueries>;
  accelerator?: Maybe<AcceleratorQueries>;
  apiMigration?: Maybe<ApiMigrationQueries>;
  asyncReport?: Maybe<AsyncReportQueries>;
  attendanceAndAchievement?: Maybe<AttendanceAndAchievementQueries>;
  attestationPeriodMark?: Maybe<AttestationPeriodMarkQueries>;
  attestationPeriods?: Maybe<AttestationPeriodQueries>;
  award?: Maybe<AwardQueries>;
  bigChallenge?: Maybe<BigChallengeQuery>;
  bigChallengeInfoWithStudentProgressV3?: Maybe<BigChallengeWithStudentProgressQueryV3>;
  bigChallengeSubjects?: Maybe<SubjectQuery>;
  businessAdmin?: Maybe<BusinessAdminQueries>;
  calendarEvent?: Maybe<CalendarEventQueries>;
  calendarEventS21?: Maybe<CalendarEventS21Queries>;
  content?: Maybe<ContentQueries>;
  contentTags?: Maybe<ContentTagsQueries>;
  course?: Maybe<CourseQueries>;
  draft?: Maybe<DraftQueries>;
  eDiary?: Maybe<EDiaryQueries>;
  eJournal?: Maybe<EJournalQueries>;
  electronicJournal?: Maybe<ElectronicJournalQueries>;
  event?: Maybe<EventQueries>;
  eventGenerator?: Maybe<EventGeneratorQueries>;
  export?: Maybe<ExportQueries>;
  externalContent?: Maybe<ExternalContentQueries>;
  externalLearning?: Maybe<ExternalLearningQueries>;
  finalMarks?: Maybe<FinalMarksQueries>;
  gamification?: Maybe<GamificationQueries>;
  globalSearch?: Maybe<GlobalSearchQueries>;
  holyGraph?: Maybe<HolyGraphQueries>;
  honorRating?: Maybe<HonorRatingQueries>;
  kandinsky?: Maybe<KandinskyQueries>;
  leaderBoard?: Maybe<LeaderBoardQueries>;
  mediateka: MediatekaQueries;
  modularPlanning?: Maybe<ModularPlanningQueries>;
  notificationConfiguration?: Maybe<NotificationConfigurationQueries>;
  parent?: Maybe<ParentQueries>;
  parentThemes?: Maybe<ParentThemesQueries>;
  penalty?: Maybe<PenaltyQueries>;
  personalTrajectory?: Maybe<PersonalTrajectoryQueries>;
  planning?: Maybe<PlanningQueries>;
  proforientationConfigurationV2?: Maybe<ProforientationConfigurationQueryV2>;
  proforntUiElement?: Maybe<ProforntUiElementQuery>;
  regionalDashboard?: Maybe<RegionalDashboardQueries>;
  routeInfo?: Maybe<RouteInfoQueries>;
  s21BaTaskFiles?: Maybe<S21BaTaskFilesQueries>;
  s21Exam?: Maybe<S21ExamQueries>;
  s21Internship?: Maybe<S21InternshipQueries>;
  s21Notification?: Maybe<S21NotificationQueries>;
  s21Plan?: Maybe<S21PlanQueries>;
  s21StudentTaskFiles?: Maybe<S21StudentTaskFiles>;
  s21StudyProgram?: Maybe<S21StudyProgramQueries>;
  sc21BaCalendar?: Maybe<Sc21BaCalendarQueries>;
  sc21BaTaskCheck?: Maybe<Sc21BaTaskCheckQueries>;
  sc21StudentTaskCheck?: Maybe<Sc21StudentTaskCheckQueries>;
  school21?: Maybe<School21Queries>;
  schoolSelfConfiguration?: Maybe<SchoolSelfConfigurationQueries>;
  selection: SelectionQueries;
  stageGroupMassCreation?: Maybe<StageGroupMassCreationQueries>;
  statisticReport?: Maybe<StatisticReportQueries>;
  statisticsMarks?: Maybe<StatisticsMarksQueries>;
  student?: Maybe<StudentQueries>;
  studentThemes?: Maybe<StudentThemesQueries>;
  systemAdmin?: Maybe<SystemAdminQueries>;
  tariffs?: Maybe<TariffsQueries>;
  taskCheck?: Maybe<TaskCheckQueries>;
  teacher?: Maybe<TeacherQueries>;
  team?: Maybe<TeamQueries>;
  trajectory?: Maybe<TrajectoryQueries>;
  user?: Maybe<UserQueries>;
  userChangeRequest?: Maybe<UserChangeRequestQueries>;
  userProfile?: Maybe<UserProfileQueries>;
  visitJournal?: Maybe<VisitJournalQueries>;
  visitLessonStat?: Maybe<VisitLessonStatQueries>;
};

/** Быстрые действия */
export enum QuickAction {
  Absence = 'ABSENCE',
  Cheat = 'CHEAT',
  Cheating = 'CHEATING',
  CodeStyle = 'CODE_STYLE',
  Crash = 'CRASH',
  EmptyWork = 'EMPTY_WORK',
  ForbiddenFunction = 'FORBIDDEN_FUNCTION',
  InvalidCompilation = 'INVALID_COMPILATION',
  Leaks = 'LEAKS',
  Norme = 'NORME'
}

/** Цитата недели */
export type Quote = {
  __typename?: 'Quote';
  author: Scalars['String']['output'];
  image?: Maybe<QuoteImage>;
  quoteId: Scalars['ID']['output'];
  text: Scalars['String']['output'];
};

/** Картинка для цитаты недели */
export type QuoteImage = {
  __typename?: 'QuoteImage';
  url: Scalars['String']['output'];
};

export enum Roles {
  /** Конфигуратор системы */
  BusinessAdm = 'BUSINESS_ADM',
  /** Директор */
  Director = 'DIRECTOR',
  /** Завуч */
  HeadTeacher = 'HEAD_TEACHER',
  /** Методолог */
  Methodologist = 'METHODOLOGIST',
  /** Без роли */
  NoRole = 'NO_ROLE',
  /** Родитель */
  Parent = 'PARENT',
  /** Ученик */
  Student = 'STUDENT',
  /** Системный администратор */
  SuperAdm = 'SUPER_ADM',
  /** Учитель */
  Teacher = 'TEACHER',
  /** Учитель Сберкод */
  TeacherSbercode = 'TEACHER_SBERCODE',
  /** Тьютор */
  Tutor = 'TUTOR'
}

/** Конфигурация оценивания */
export type RatingConfiguration = {
  __typename?: 'RatingConfiguration';
  /** Дата/время создания конфигурации оценивания */
  creationDateTime: Scalars['DateTime']['output'];
  /** Учитывается ли оценка за модуль */
  dependOfGoalMark: Scalars['Boolean']['output'];
  /** Доступна ли ручная корректировка отметок за учебный период */
  manualChangeAvailable?: Maybe<Scalars['Boolean']['output']>;
  /** Процентная зависимость отметки за период от внешней работы */
  markDependencyOfExternalWork?: Maybe<Scalars['Int']['output']>;
  /** Тип системы оценивания */
  markTypeId: Scalars['ID']['output'];
  /** Соответствие % выполнения плана к отметке */
  planCompletingToMarkRelations: Array<PlanCompletingToMarkRelation>;
  /** Идентификатор конфигурации оценивания(АвтоГенерируемый) */
  ratingConfigurationId: Scalars['ID']['output'];
};

export type RatingConfigurationInput = {
  /** Учитывается ли оценка за модуль */
  dependOfGoalMark: Scalars['Boolean']['input'];
  /** Доступна ли ручная корректировка отметок за учебный период */
  manualChangeAvailable: Scalars['Boolean']['input'];
  /** Процентная зависимость отметки за период от внешней работы */
  markDependencyOfExternalWork?: InputMaybe<Scalars['Int']['input']>;
  /** Соответствие % выполнения плана к отметке */
  planCompletingToMarkRelations: Array<PlanCompletingToMarkRelationInput>;
  /** Идентификатор школы */
  schoolId: Scalars['ID']['input'];
  /** Идентификатор параллели */
  stageId: Scalars['ID']['input'];
};

/** Список непрочитанных Уведомлений по Заданиям */
export type RecentTaskNotifications = {
  __typename?: 'RecentTaskNotifications';
  /** Информация о "схлопнутых" комментариях */
  collapsedTaskCommentsInfo: Array<CollapsedTaskCommentsInfo>;
  /** Общее количество непрочитанных уведомлений по заданию после "схлопывания" комментариев */
  collapsedTaskNotificationsCount: Scalars['Int']['output'];
  /** Количество непрочитанных уведомлений по заданию после "схлопывания" комментариев и фильтрации по запрошенным типам уведомлений */
  filteredCollapsedTaskNotificationsCount: Scalars['Int']['output'];
  /** Непрочитанные уведомления по заданию. Для типа "комментарий" содержит только последний комментарий в рамках каждого задания */
  taskNotifications: Array<TaskNotification>;
  /** Сопоставление типа и количества непрочитанных Уведомлений. Учитываются все коментарии к заданиям */
  taskNotificationsCountByType: Array<NotificationsCountByTypeMap>;
};

/** Рекомендация к выполнению задания */
export enum RecommendationToExecutionEnum {
  /** Учебное задание */
  Exercise = 'EXERCISE',
  /** Домашнее задание */
  Homework = 'HOMEWORK',
  /** Лабораторная работа */
  Labwork = 'LABWORK',
  /** На уроке */
  Lesson = 'LESSON',
  /** Контрольная работа */
  Test = 'TEST'
}

export type ReferralConfigurator = {
  __typename?: 'ReferralConfigurator';
  /** Имя реферала */
  referralFirstName: Scalars['String']['output'];
  /** Участники Акселератора, зарегистрировавшиеся по всем реферальным ссылкам */
  referralId: Scalars['UUID']['output'];
  /** Фамилия реферала */
  referralLastName: Scalars['String']['output'];
  /** Тип пользователя: Школьник, Студент */
  userType: Scalars['String']['output'];
};

export type ReferralUser = {
  __typename?: 'ReferralUser';
  /** Имя реферала */
  referralFirstName: Scalars['String']['output'];
  /** Участники Акселератора, зарегистрировавшиеся по всем реферальным ссылкам */
  referralId: Scalars['UUID']['output'];
  /** Фамилия реферала */
  referralLastName: Scalars['String']['output'];
  /** Дата регистрации реферала */
  registrationDate: Scalars['DateTime']['output'];
};

export type ReferrerConfigurator = {
  __typename?: 'ReferrerConfigurator';
  /** Количество рефералов, зарагистрировавшихся по реферальной ссылке каждого из реферреров */
  numberInvited: Scalars['Int']['output'];
  /** Количество баллов у реферрера */
  points: Scalars['Int']['output'];
  /** Имя реферала */
  referrerFirstName: Scalars['String']['output'];
  /** Участники Акселератора, зарегистрировавшиеся по всем реферальным ссылкам */
  referrerId: Scalars['UUID']['output'];
  /** Фамилия реферала */
  referrerLastName: Scalars['String']['output'];
  /** Тип пользователя (реферрера) */
  userType: Scalars['String']['output'];
};

export enum ReflectionEstimationEnum {
  No = 'NO',
  RatherNo = 'RATHER_NO',
  RatherYes = 'RATHER_YES',
  Yes = 'YES'
}

export type Region = {
  __typename?: 'Region';
  displayableName: Scalars['String']['output'];
  regionId: Scalars['UUID']['output'];
};

export type RegionAreaPolygon = {
  __typename?: 'RegionAreaPolygon';
  centerPoint?: Maybe<Scalars['String']['output']>;
  fiasAddressObjectId: Scalars['UUID']['output'];
  isCity: Scalars['Boolean']['output'];
  loggingMetrics: LoggingMetrics;
  polygon?: Maybe<Scalars['String']['output']>;
  polygonId?: Maybe<Scalars['UUID']['output']>;
  polygonName: Scalars['String']['output'];
  polygonShortName: Scalars['String']['output'];
};

/** Метрики школы региона */
export type RegionSchoolMetrics = {
  __typename?: 'RegionSchoolMetrics';
  activeStudentsPercent: Scalars['Int']['output'];
  activeTeachersPercent: Scalars['Int']['output'];
  integrationPercent?: Maybe<Scalars['Int']['output']>;
  regionId: Scalars['UUID']['output'];
  schoolFullName: Scalars['String']['output'];
  schoolId: Scalars['UUID']['output'];
  schoolName: Scalars['String']['output'];
  tagId: Scalars['Int']['output'];
  totalStudentsCount: Scalars['Int']['output'];
  totalTeachersCount: Scalars['Int']['output'];
};

/** Группа региональных проверяющих программы по направлению (предмету) */
export type RegionVerifierGroup = {
  __typename?: 'RegionVerifierGroup';
  /** идентификатор программы */
  learningProgramId: Scalars['ID']['output'];
  /** идентификатор региона, задания которого проверяются этой группой */
  regionId: Scalars['UUID']['output'];
  /** наименование региона */
  regionName: Scalars['String']['output'];
  /** идентификатор группы региональных проверяющих */
  regionVerifierGroupId: Scalars['ID']['output'];
  /** статус группы */
  status: RegionVerifierGroupStatus;
  /** идентификатор учебного предмета, на проверке которого специализируется группа */
  subjectId: Scalars['ID']['output'];
  /** короткое наименование учебного предмета */
  subjectName: Scalars['String']['output'];
  /** список региональных проверяющих группы */
  verifiers: Array<RegionVerifierGroupUser>;
};

export enum RegionVerifierGroupStatus {
  /** Действует */
  Active = 'ACTIVE',
  /** Изменена */
  Edited = 'EDITED',
  /** Подготовка */
  Preparation = 'PREPARATION'
}

/** Член группы региональных проверяющих программы */
export type RegionVerifierGroupUser = {
  __typename?: 'RegionVerifierGroupUser';
  /** идентификатор группы региональных проверяющих */
  regionVerifierGroupId: Scalars['ID']['output'];
  /** идентификатор проверяющего как пользователя платформы */
  userId: Scalars['UUID']['output'];
  /** именование проверяющего, например ФИО */
  userName: Scalars['String']['output'];
};

export type RegionalDashboardMutations = {
  __typename?: 'RegionalDashboardMutations';
  /** Возврат к дефолтным настройкам расположения виджетов */
  resetWidgetsViewToDefault: Scalars['Boolean']['output'];
  /** Конструктор дешборда Директора школы. Сохранение выполненных пользователем настроек страниц */
  saveUserWidgetsView: Scalars['Boolean']['output'];
};


export type RegionalDashboardMutationsResetWidgetsViewToDefaultArgs = {
  categories: Array<Scalars['String']['input']>;
};


export type RegionalDashboardMutationsSaveUserWidgetsViewArgs = {
  widgetsView: Array<UserWidgetInput>;
};

export type RegionalDashboardQueries = {
  __typename?: 'RegionalDashboardQueries';
  /** Получение текущего региона */
  getCurrentRegion: Region;
  /**
   * Получение карт районов региона
   * @deprecated использовать getRegionAreasWithMetricsMap
   */
  getRegionAreasMap: Array<AreaPolygon>;
  /** Получение карт с метриками */
  getRegionAreasWithMetricsMap: Array<RegionAreaPolygon>;
  /** Получение информации по школе */
  getRegionalDashboardSchoolInfo: SchoolInfo;
  /** Школы на платформе */
  getSchoolsOnPlatform: Array<EntityOnPlatform>;
  /** Активность учеников по школе и параллели в разрезе день/неделя/месяц */
  getStudentsActivityBySchoolAndStages: Array<DashboardUsersActivity>;
  /** Ученики на платформе */
  getStudentsOnPlatform: Array<EntityOnPlatform>;
  /** Количество учеников, отправляшших задания на проверку */
  getStudentsWhoSentTasksForReviewMetric?: Maybe<Scalars['Int']['output']>;
  /** Активность учителей по школе в разрезе день/неделя/месяц */
  getTeachersActivityBySchool: Array<DashboardUsersActivity>;
  /** Учителя на платформе */
  getTeachersOnPlatform: Array<EntityOnPlatform>;
  /** Количество учителей, проверивших задания */
  getTeachersVerifiedTasksMetric?: Maybe<Scalars['Int']['output']>;
  /** Загруженность учителей */
  getTeachersWorkload: Array<TeachersWorkload>;
  /** Загруженность учителей по предмету */
  getTeachersWorkloadBySubject: Array<Maybe<TeachersWorkloadBySubject>>;
  /** Загруженность учителей по предмету (для директора) */
  getTeachersWorkloadBySubjectForPrincipal: Array<Maybe<TeachersWorkloadBySubjectForPrincipal>>;
  /** Работа с заданиями */
  getWorkWithTasks: WorkWithTasks;
  /** Проверенные задания по уровням целей */
  loadCheckedTasksByGoalLevels: Array<TasksCountByGoalLevel>;
  /** Список доступных виджетов */
  loadEnabledWidgets: EnabledWidgets;
  /** Средние показатели по региону */
  loadLoggingMetricsForCurrentRegion?: Maybe<LoggingMetrics>;
  /**
   * Средние показатели по региону (синтетика)
   * @deprecated использовать loadLoggingMetricsForCurrentRegion
   */
  loadMapMetricsForCurrentRegion?: Maybe<MapMetrics>;
  /** Показатели по административным единицам региона */
  loadMapMetricsForCurrentRegionByAdministrativeUnits: Array<MapMetricsByAdministrativeUnit>;
  /** Доля активных учеников */
  loadPercOfActiveStudentsMetrics: Array<PercOfActiveStudentsMetrics>;
  /** Школы по региону */
  loadRegionSchoolMetrics: Array<RegionSchoolMetrics>;
  /** Использование Сберкласс */
  loadSberClassUsage?: Maybe<SberClassUsage>;
  /** Задания отправленные на проверку */
  loadTasksSubmittedForReview: TasksCountInfo;
  /** Настройки расположения виджетов */
  loadUserWidgetsView: Array<UserWidget>;
  /** Всего в регионе */
  loadVillageAndCitySchools?: Maybe<VillageAndCitySchools>;
};


export type RegionalDashboardQueriesGetRegionAreasMapArgs = {
  period: Scalars['String']['input'];
};


export type RegionalDashboardQueriesGetRegionAreasWithMetricsMapArgs = {
  period: Scalars['String']['input'];
};


export type RegionalDashboardQueriesGetRegionalDashboardSchoolInfoArgs = {
  schoolId: Scalars['ID']['input'];
};


export type RegionalDashboardQueriesGetSchoolsOnPlatformArgs = {
  period: Scalars['String']['input'];
};


export type RegionalDashboardQueriesGetStudentsActivityBySchoolAndStagesArgs = {
  groupBy: Scalars['String']['input'];
  period: Scalars['String']['input'];
  schoolId: Scalars['UUID']['input'];
  stageIds?: InputMaybe<Array<Scalars['Int']['input']>>;
};


export type RegionalDashboardQueriesGetStudentsOnPlatformArgs = {
  period: Scalars['String']['input'];
  schoolId: Scalars['UUID']['input'];
};


export type RegionalDashboardQueriesGetStudentsWhoSentTasksForReviewMetricArgs = {
  period: Scalars['String']['input'];
  schoolId: Scalars['UUID']['input'];
};


export type RegionalDashboardQueriesGetTeachersActivityBySchoolArgs = {
  groupBy: Scalars['String']['input'];
  period: Scalars['String']['input'];
  schoolId: Scalars['UUID']['input'];
};


export type RegionalDashboardQueriesGetTeachersOnPlatformArgs = {
  period: Scalars['String']['input'];
  schoolId: Scalars['UUID']['input'];
};


export type RegionalDashboardQueriesGetTeachersVerifiedTasksMetricArgs = {
  period: Scalars['String']['input'];
  schoolId: Scalars['UUID']['input'];
};


export type RegionalDashboardQueriesGetTeachersWorkloadArgs = {
  period: Scalars['String']['input'];
  schoolId: Scalars['UUID']['input'];
};


export type RegionalDashboardQueriesGetTeachersWorkloadBySubjectArgs = {
  period: Scalars['String']['input'];
  schoolId: Scalars['UUID']['input'];
  subjectId: Scalars['Int']['input'];
};


export type RegionalDashboardQueriesGetTeachersWorkloadBySubjectForPrincipalArgs = {
  period: Scalars['String']['input'];
  schoolId: Scalars['UUID']['input'];
  subjectId: Scalars['Int']['input'];
};


export type RegionalDashboardQueriesGetWorkWithTasksArgs = {
  count: Scalars['Int']['input'];
  from: Scalars['Int']['input'];
  period: Scalars['String']['input'];
  schoolId: Scalars['UUID']['input'];
  simpleCount: Scalars['Int']['input'];
  simpleFrom: Scalars['Int']['input'];
  stageIds: Array<Scalars['Int']['input']>;
  subjectIds: Array<Scalars['Int']['input']>;
};


export type RegionalDashboardQueriesLoadCheckedTasksByGoalLevelsArgs = {
  period: Scalars['String']['input'];
  schoolId: Scalars['UUID']['input'];
};


export type RegionalDashboardQueriesLoadLoggingMetricsForCurrentRegionArgs = {
  period: Scalars['String']['input'];
};


export type RegionalDashboardQueriesLoadMapMetricsForCurrentRegionArgs = {
  period: Scalars['String']['input'];
};


export type RegionalDashboardQueriesLoadMapMetricsForCurrentRegionByAdministrativeUnitsArgs = {
  period: Scalars['String']['input'];
};


export type RegionalDashboardQueriesLoadPercOfActiveStudentsMetricsArgs = {
  period: Scalars['String']['input'];
  schoolId: Scalars['UUID']['input'];
};


export type RegionalDashboardQueriesLoadRegionSchoolMetricsArgs = {
  period: Scalars['String']['input'];
  tagIds: Array<Scalars['ID']['input']>;
};


export type RegionalDashboardQueriesLoadSberClassUsageArgs = {
  period: Scalars['String']['input'];
};


export type RegionalDashboardQueriesLoadTasksSubmittedForReviewArgs = {
  period: Scalars['String']['input'];
  schoolId: Scalars['UUID']['input'];
};


export type RegionalDashboardQueriesLoadVillageAndCitySchoolsArgs = {
  period: Scalars['String']['input'];
};

/** Фильтр предстоящих мероприятий по доступности регистрации */
export enum RegistartionStatusEnum {
  /** Все будущие события для студента ( фильтр по умолчанию) */
  Any = 'ANY',
  /** Событие время на регистрацию на которое завершилось */
  Closed = 'CLOSED',
  /** Событие на которое студент встал в лист ожидания */
  IsInWaitlist = 'IS_IN_WAITLIST',
  /** Событие на которое студент встал в лист ожидания или зарегистрировался */
  IsParticipating = 'IS_PARTICIPATING',
  /** Событие на которое студент зарегистрировался */
  IsRegistered = 'IS_REGISTERED',
  /** Событие для которого есть возможность записаться (регистрация ИЛИ лист ожидания) */
  ParticipationAvailable = 'PARTICIPATION_AVAILABLE',
  /** Событие у которого доступен лист ожидания (места на регистрацию тоже могут быть доступны но фильтр только по доступности листа ожидания) */
  WaitlistAvailable = 'WAITLIST_AVAILABLE'
}

/** Модель восстановления студента */
export type ReinstateStudentInput = {
  /** Идентификатор коалиции, в которую восстанавливается студент */
  coalitionId: Scalars['ID']['input'];
  /** Идентификатор класса, в который восстанавливается студент */
  stageGroupId: Scalars['ID']['input'];
  /** Идентификатор восстанавливаемого студента */
  studentId: Scalars['UUID']['input'];
};

/** Информация о выполненной мутации */
export type RejectAnswerResponse = {
  __typename?: 'RejectAnswerResponse';
  /** Полная информация по Заданию в контексте Студента */
  studentTaskInfo: StudentTaskInfo;
};

export enum RememberMeState {
  Off = 'OFF',
  On = 'ON',
  Undefined = 'UNDEFINED'
}

export type RemoveLessonLearningActivityRespose = {
  __typename?: 'RemoveLessonLearningActivityRespose';
  changedFinalMarks?: Maybe<Array<Maybe<JournalFinalStudentMark>>>;
  success: Scalars['Boolean']['output'];
};

export type RemoveTaskSetRequest = {
  /** флаг - проверять аффектит ли учебный процесс студентов удаление плейлиста */
  isNeedToCheckAffecting: Scalars['Boolean']['input'];
  /** идентификатор набора заданий (base_playlists.base_playlist_id или teacher_playlists.teacher_playlist_id) */
  taskSetId: Scalars['ID']['input'];
  /** тип плейлиста */
  taskSetType: PlaylistType;
};

export type RemoveTaskSetResponse = {
  __typename?: 'RemoveTaskSetResponse';
  /** успешно ли выполнение запроса (пройдены ли все проверки) */
  isSuccess: Scalars['Boolean']['output'];
  /** удаляемый плейлист */
  removingTaskSet: TaskSet;
};

export type Report = {
  __typename?: 'Report';
  reportCode: Scalars['Int']['output'];
  reportName: Scalars['String']['output'];
  versionPropertyCode: Scalars['String']['output'];
};

export type ReportExcelFile = {
  __typename?: 'ReportExcelFile';
  base64Data?: Maybe<Scalars['String']['output']>;
  fileName: Scalars['String']['output'];
  url?: Maybe<Scalars['String']['output']>;
};

export type ReportGroup = {
  __typename?: 'ReportGroup';
  reportGroupCode: Scalars['Int']['output'];
  reportGroupName: Scalars['String']['output'];
  reports: Array<Maybe<Report>>;
};

export type ReportPeriod = {
  __typename?: 'ReportPeriod';
  activityEndDate: Scalars['Date']['output'];
  activityStartDate: Scalars['Date']['output'];
  periodEndDate?: Maybe<Scalars['Date']['output']>;
  periodStartDate: Scalars['Date']['output'];
};

export type ReportPeriodInput = {
  activityEndDate: Scalars['Date']['input'];
  activityStartDate: Scalars['Date']['input'];
  periodEndDate?: InputMaybe<Scalars['Date']['input']>;
  periodStartDate: Scalars['Date']['input'];
};

export type ReportUserSettingInput = {
  propertyCode: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

/** Уровень видимости данных в синхронных отчетах */
export enum ReportsDataAccessLevel {
  /** Регион */
  Region = 'REGION',
  /** Школа */
  School = 'SCHOOL',
  /** Система */
  System = 'SYSTEM'
}

export type RequestDataModel = {
  __typename?: 'RequestDataModel';
  pagingCount: Scalars['Int']['output'];
  requests: Array<Maybe<RequestModel>>;
};

export type RequestModel = {
  __typename?: 'RequestModel';
  birthdayDate: Scalars['Date']['output'];
  createTs: Scalars['DateTime']['output'];
  email: Scalars['String']['output'];
  hasAgreements: Scalars['Boolean']['output'];
  modifyTs?: Maybe<Scalars['DateTime']['output']>;
  requestId: Scalars['UUID']['output'];
  shortFio: Scalars['String']['output'];
};

/** Статус заявки на участие в проекте акселератора */
export enum RequestState {
  Approved = 'APPROVED',
  Closed = 'CLOSED',
  Created = 'CREATED',
  Reclaimed = 'RECLAIMED',
  Rejected = 'REJECTED'
}

export type RequestToProjectCount = {
  __typename?: 'RequestToProjectCount';
  availableCount: Scalars['Int']['output'];
  maxCount: Scalars['Int']['output'];
};

export type RequiredTaskCountByTaskType = {
  __typename?: 'RequiredTaskCountByTaskType';
  /** Минимальное количество Заданий соответствующего типа */
  requiredTaskCount: Scalars['Int']['output'];
  /** Тип Слота Заданий -- информационных, проверочный и тд */
  taskType: TaskTypeEnum;
};

/** Результат выполнения модуля */
export enum ResultModuleCompletion {
  /** Дефолтная бранча отсутсвует в проекте студента */
  FailByAbsentDefaultBranch = 'FAIL_BY_ABSENT_DEFAULT_BRANCH',
  /** Провал по расчету балла */
  FailByCalculation = 'FAIL_BY_CALCULATION',
  /** Провал по дедлайну проверок */
  FailByCheckingDeadline = 'FAIL_BY_CHECKING_DEADLINE',
  /** Провал по дедлайну выполнения */
  FailByExecutionDeadline = 'FAIL_BY_EXECUTION_DEADLINE',
  /** Провал по причине отчисления студента */
  FailByExpelledStudent = 'FAIL_BY_EXPELLED_STUDENT',
  /** Студент забыл зарегистрироваться в обоих местах - экзаменационный модуль (проект) и ивент (мероприятие) */
  FailByForgotToRegisterOnBothExamModuleAndEvent = 'FAIL_BY_FORGOT_TO_REGISTER_ON_BOTH_EXAM_MODULE_AND_EVENT',
  /** Студент забыл зарегистрироваться на экзаменационный ивент (мероприятие) */
  FailByForgotToRegisterOnExamEvent = 'FAIL_BY_FORGOT_TO_REGISTER_ON_EXAM_EVENT',
  /** Студент забыл зарегистрироваться на экзаменационный модуль (проект) */
  FailByForgotToRegisterOnExamModule = 'FAIL_BY_FORGOT_TO_REGISTER_ON_EXAM_MODULE',
  /** Провал по причине заморозки студента */
  FailByFreezingStudent = 'FAIL_BY_FREEZING_STUDENT',
  /** Провал по дедлайну регистрации */
  FailByRegistrationDeadline = 'FAIL_BY_REGISTRATION_DEADLINE',
  /** Провал по сбросу оценки */
  FailByResetRating = 'FAIL_BY_RESET_RATING',
  /** Провал по причине отсутствия файлов с решением */
  FailBySolutionFileNotFound = 'FAIL_BY_SOLUTION_FILE_NOT_FOUND',
  /** Студент зарегистрироваться экзаменационный модуль и ивент, но не явился на него (не присутствовал в аудитории) */
  FailByStudentAbsenceOnExamEvent = 'FAIL_BY_STUDENT_ABSENCE_ON_EXAM_EVENT',
  /** Провал по капитуляции */
  FailBySurrender = 'FAIL_BY_SURRENDER',
  /** Провал по капитуляции с курса */
  FailBySurrenderFromCourse = 'FAIL_BY_SURRENDER_FROM_COURSE',
  /** Команда не успела сформироваться */
  FailByTeamNotFormed = 'FAIL_BY_TEAM_NOT_FORMED',
  /** Успех */
  Success = 'SUCCESS'
}

export type ResumeFilterInput = {
  inviteEndDate?: InputMaybe<Scalars['Date']['input']>;
  inviteStartDate?: InputMaybe<Scalars['Date']['input']>;
  projectRoleId?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  regionId?: InputMaybe<Scalars['UUID']['input']>;
  shortFioSearch: Scalars['String']['input'];
};

export type ResumeForCapitan = {
  __typename?: 'ResumeForCapitan';
  aboutMe: Scalars['String']['output'];
  avatarURL: Scalars['String']['output'];
  eduDocs: Array<Maybe<EducationDocument>>;
  educationOrgName: Scalars['String']['output'];
  email?: Maybe<Scalars['String']['output']>;
  inviteDate?: Maybe<Scalars['Date']['output']>;
  inviteId?: Maybe<Scalars['UUID']['output']>;
  inviteStatus?: Maybe<Scalars['String']['output']>;
  isFavoriteByCurrentTeam: Scalars['Boolean']['output'];
  projectId?: Maybe<Scalars['UUID']['output']>;
  projectName?: Maybe<Scalars['String']['output']>;
  projectRoleNames: Array<Maybe<Scalars['String']['output']>>;
  regionName: Scalars['String']['output'];
  resumeFileName: Scalars['String']['output'];
  resumeId: Scalars['UUID']['output'];
  resumeURL: Scalars['String']['output'];
  shortFio: Scalars['String']['output'];
  speciality: Scalars['String']['output'];
  telegram?: Maybe<Scalars['String']['output']>;
  userId: Scalars['UUID']['output'];
  vkontakte?: Maybe<Scalars['String']['output']>;
};

export type ResumeForStudent = {
  __typename?: 'ResumeForStudent';
  aboutMe: Scalars['String']['output'];
  avatarURL: Scalars['String']['output'];
  eduDocs: Array<Maybe<EducationDocument>>;
  educationOrgName: Scalars['String']['output'];
  email?: Maybe<Scalars['String']['output']>;
  projectId?: Maybe<Scalars['UUID']['output']>;
  projectName?: Maybe<Scalars['String']['output']>;
  projectRoleNames: Array<Maybe<Scalars['String']['output']>>;
  regionName: Scalars['String']['output'];
  resumeFileName: Scalars['String']['output'];
  resumeId: Scalars['UUID']['output'];
  resumeURL: Scalars['String']['output'];
  shortFio: Scalars['String']['output'];
  speciality: Scalars['String']['output'];
  telegram?: Maybe<Scalars['String']['output']>;
  userId: Scalars['UUID']['output'];
  vkontakte?: Maybe<Scalars['String']['output']>;
};

export type ResumeInput = {
  aboutMe: Scalars['String']['input'];
  avatarURL: Scalars['String']['input'];
  educationDocs: Array<InputMaybe<EducationDocumentInput>>;
  educationOrgId: Scalars['UUID']['input'];
  educationOrgName: Scalars['String']['input'];
  email?: InputMaybe<Scalars['String']['input']>;
  projectRoleId: Array<InputMaybe<Scalars['UUID']['input']>>;
  projectRoleOtherName?: InputMaybe<Scalars['String']['input']>;
  regionId: Scalars['UUID']['input'];
  regionName: Scalars['String']['input'];
  resumeFileName: Scalars['String']['input'];
  resumeURL: Scalars['String']['input'];
  speciality: Scalars['String']['input'];
  telegram?: InputMaybe<Scalars['String']['input']>;
  vkontakte?: InputMaybe<Scalars['String']['input']>;
};

export type ResumeModel = {
  __typename?: 'ResumeModel';
  aboutMe: Scalars['String']['output'];
  avatarURL: Scalars['String']['output'];
  counterInvited: Array<Maybe<CounterInvite>>;
  counterViewed: Array<Maybe<CounterView>>;
  eduDocs: Array<Maybe<EducationDocument>>;
  educationOrgId: Scalars['UUID']['output'];
  educationOrgName: Scalars['String']['output'];
  email?: Maybe<Scalars['String']['output']>;
  inviteCount: Scalars['Int']['output'];
  isFavoriteByCurrentTeam: Scalars['Boolean']['output'];
  isInvitedByCurrentTeam: Scalars['Boolean']['output'];
  projectRoles: Array<Maybe<ProjectRoleFromDirectory>>;
  regionId: Scalars['UUID']['output'];
  regionName: Scalars['String']['output'];
  resumeFileName: Scalars['String']['output'];
  resumeId: Scalars['UUID']['output'];
  resumeURL: Scalars['String']['output'];
  shortFio: Scalars['String']['output'];
  speciality: Scalars['String']['output'];
  status: Scalars['String']['output'];
  telegram?: Maybe<Scalars['String']['output']>;
  viewCount: Scalars['Int']['output'];
  vkontakte?: Maybe<Scalars['String']['output']>;
};

export type ResumeShortModel = {
  __typename?: 'ResumeShortModel';
  aboutMe: Scalars['String']['output'];
  avatarURL: Scalars['String']['output'];
  eduOrgName: Scalars['String']['output'];
  inviteDate?: Maybe<Scalars['Date']['output']>;
  inviteId?: Maybe<Scalars['UUID']['output']>;
  inviteReasonDesc?: Maybe<Scalars['String']['output']>;
  isFavoriteByCurrentTeam: Scalars['Boolean']['output'];
  projectRoleNames: Array<Maybe<Scalars['String']['output']>>;
  regionName: Scalars['String']['output'];
  resumeId: Scalars['UUID']['output'];
  resumeURL: Scalars['String']['output'];
  shortFio: Scalars['String']['output'];
  vacancyName?: Maybe<Scalars['String']['output']>;
};

export type ResumesData = {
  __typename?: 'ResumesData';
  resumes: Array<Maybe<ResumeShortModel>>;
  totalCount: Scalars['Int']['output'];
};

/** Обратная связь по ревью, данная проверяемым */
export type ReviewFeedback = {
  __typename?: 'ReviewFeedback';
  /** Текст фидбэка */
  comment: Scalars['String']['output'];
  /** Заполненный чеклист по p2p проверке по которой дан фидбэк */
  filledChecklist: FilledChecklist;
  /** Идентификатор */
  id: Scalars['ID']['output'];
  /** оценки ревьюверу */
  reviewFeedbackCategoryValues: Array<Maybe<ReviewFeedbackCategoryValue>>;
};

export type ReviewFeedbackCategoryValue = {
  __typename?: 'ReviewFeedbackCategoryValue';
  /** Критерий по кторому была оценена p2p проверка проверяемым */
  feedbackCategory: FeedbackCategoryEnum;
  /** Оценка по критерию */
  feedbackValue: FeedbackCategoryValueEnum;
  /** Идентификатор */
  id: Scalars['ID']['output'];
};

export type ReviewFeedbackCategoryValueInput = {
  /** Критерий */
  feedbackCategory: FeedbackCategoryEnum;
  /** Оценка по критерию */
  feedbackCategoryValue: FeedbackCategoryValueEnum;
};

export type ReviewFeedbackInput = {
  /** Фидбэк по p2p ревью, который привязан к конкретному чек-листу */
  comment: Scalars['String']['input'];
  /** Идентификатор */
  filledChecklistId: Scalars['ID']['input'];
  /** заполненные оценки по критериям */
  reviewFeedbackCategoryValues: Array<ReviewFeedbackCategoryValueInput>;
};

export enum RoleStatus {
  /** Работает */
  Active = 'ACTIVE',
  /** Уволен */
  Inactive = 'INACTIVE'
}

/** Резолвер маршрутов */
export type RouteInfoQueries = {
  __typename?: 'RouteInfoQueries';
  /** Получение маршрута для пользователя */
  getRouteInfo: Scalars['String']['output'];
};

/** Типы отчетов на получение PRP/CRP */
export enum RpReportTypeEnum {
  AllPointsReport = 'ALL_POINTS_REPORT',
  CrpReport = 'CRP_REPORT',
  PrpReport = 'PRP_REPORT'
}

/** Прогресс распродажи */
export type RpSaleProgress = {
  __typename?: 'RpSaleProgress';
  /** Текущий процент прогресса */
  progressPercentage: Scalars['Int']['output'];
  /** Тип распродажи */
  rpType: RpType;
};

/** Настройки распродажи */
export type RpSaleSetting = {
  __typename?: 'RpSaleSetting';
  /** Настройки распродажи CRP */
  saleSettingCRP: SaleSettingCrp;
  /** Настройки распродажи PRP */
  saleSettingPRP: SaleSettingPrp;
  /** Идентификатор школы */
  schoolId: Scalars['UUID']['output'];
  /** Имя школы */
  schoolName: Scalars['String']['output'];
  /** Сущность параллели */
  stage: Stage;
  /** Кол-во студентов в параллели */
  studentsCountInStage: Scalars['Int']['output'];
};

/** Модель описывает данные необходимые для обновления информации о распродаже */
export type RpSaleSettingInput = {
  /** Флаг автоматической настройки распродажи */
  autotune: Scalars['Boolean']['input'];
  /** Количество RP в невозвратном пуле для завершения распродажи (если задано) */
  irrevocableRpCountToFinishSale?: InputMaybe<Scalars['Int']['input']>;
  /** Количество RP в невозвратном пуле для инициации распродажи (если задано) */
  irrevocableRpCountToStartSale?: InputMaybe<Scalars['Int']['input']>;
  rpType: RpType;
  /** Идентификатор школы */
  schoolId: Scalars['UUID']['input'];
  /** Идентификатор параллели */
  stageId: Scalars['ID']['input'];
};

/** Типы RP распродажи */
export enum RpType {
  Crp = 'CRP',
  Prp = 'PRP'
}

export type S21BaTaskFilesQueries = {
  __typename?: 'S21BaTaskFilesQueries';
  /** S21. Получение файлов, прикрепленных к текущей опубликованной версии задания по его идентификатору */
  getTaskContentFiles: Array<TaskFile>;
};


export type S21BaTaskFilesQueriesGetTaskContentFilesArgs = {
  taskId: Scalars['ID']['input'];
};

/** План на класс */
export type S21ClassPlan = {
  __typename?: 'S21ClassPlan';
  /** Имя класса */
  className: Scalars['String']['output'];
  /** Идентификатор плана на класс */
  classPlanId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор группы по предмету */
  classSubjectId?: Maybe<Scalars['ID']['output']>;
  /** Произошла ли миграция данного плана на курсы */
  isMigrated?: Maybe<Scalars['Boolean']['output']>;
  /** Статус плана */
  isPublished: Scalars['Boolean']['output'];
  /** Цели плана */
  planGoals: Array<S21ClassPlanGoal>;
  /** Количество проектов */
  projectCount?: Maybe<Scalars['Int']['output']>;
  /** Идентификатор паралели */
  stageId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор плана на параллель */
  stagePlanId?: Maybe<Scalars['ID']['output']>;
  /** Дата/время начала плана */
  startDate?: Maybe<Scalars['DateTime']['output']>;
  /** Название предмета */
  subjectName: Scalars['String']['output'];
};

/** Параллели и Планы на классы по предметам */
export type S21ClassPlanByStagesSubjects = {
  __typename?: 'S21ClassPlanByStagesSubjects';
  /** Список паралеллей и планов для групп по предмету */
  stageClassPlans?: Maybe<Array<Maybe<StageS21ClassPlans>>>;
  /** Наименование предмета выбранного плана группы класса */
  subjectName: Scalars['String']['output'];
};

/** Цели плана на класс */
export type S21ClassPlanGoal = {
  __typename?: 'S21ClassPlanGoal';
  /**
   * Тип проекта (групповой, индивидуальный)
   * @deprecated Под удаление. Использовать executionType
   */
  assignmentType?: Maybe<TaskAssignmentEnum>;
  /** "Начало выполнения" */
  beginDate?: Maybe<Scalars['DateTime']['output']>;
  /** "Проверка" */
  checkDate?: Maybe<Scalars['DateTime']['output']>;
  /** Идентификатор цели класса плана */
  classPlanGoalId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор глобального курса */
  courseId?: Maybe<Scalars['ID']['output']>;
  /** Количество проектов в курсе */
  courseProjectCount?: Maybe<Scalars['Int']['output']>;
  /** Тип курса */
  courseType?: Maybe<CourseType>;
  /** "Дедлайн" */
  deadlineDate?: Maybe<Scalars['DateTime']['output']>;
  /** Флаг, указывающий на игнорирование любых дедлайнов для модуля */
  deadlineFree: Scalars['Boolean']['output'];
  /** Флаг, указывающий на эквивалентность правил для конструктора условий в плане на параллель и плане на класс */
  equivalentConstructors?: Maybe<Scalars['Boolean']['output']>;
  /** Тип выполнения */
  executionType?: Maybe<ModuleExecutionType>;
  /** Идентификатор цели */
  goalId?: Maybe<Scalars['ID']['output']>;
  /** Название цели */
  goalName: Scalars['String']['output'];
  /** В курсе есть проект без дедлайнов и со случайным формированием команды */
  hasDeadlineFreeRandomTeam?: Maybe<Scalars['Boolean']['output']>;
  /** Просмотр контента */
  isContentAvailable: Scalars['Boolean']['output'];
  /** Идентификатор локального курса */
  localCourseId?: Maybe<Scalars['ID']['output']>;
  /** порядковый номер */
  order?: Maybe<Scalars['ID']['output']>;
  /** Правила подсчета даты и времени изменённого модуля/проекта */
  rules: StagePlanRules;
  /** "Регистрация" */
  signUpDate?: Maybe<Scalars['DateTime']['output']>;
  /** Настройки команд */
  teamSettings?: Maybe<TeamSettings>;
};

export type S21ClassPlanGoalInput = {
  /** "Начало выполнения" */
  beginDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** "Проверка" */
  checkDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Идентификатор цели плана на класс */
  classPlanGoalId?: InputMaybe<Scalars['ID']['input']>;
  /** Идентификатор глобального курса */
  courseId?: InputMaybe<Scalars['ID']['input']>;
  /** "Дедлайн" */
  deadlineDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Флаг, указывающий на игнорирование любых дедлайнов для модуля */
  deadlineFree: Scalars['Boolean']['input'];
  /** Идентификатор модуля */
  goalId?: InputMaybe<Scalars['ID']['input']>;
  /** Идентификатор локального курса */
  localCourseId?: InputMaybe<Scalars['ID']['input']>;
  /** Номер по порядку */
  order?: InputMaybe<Scalars['Int']['input']>;
  /** Номер курса по порядку */
  orderCourse?: InputMaybe<Scalars['Int']['input']>;
  /** "Регистрация" */
  signUpDate?: InputMaybe<Scalars['DateTime']['input']>;
};

export type S21ClassPlanInput = {
  /** Идентификатор плана на класс */
  classPlanId?: InputMaybe<Scalars['ID']['input']>;
  /** Идентификатор группы по предмету */
  classSubjectId: Scalars['ID']['input'];
  /** Статус плана */
  isPublished: Scalars['Boolean']['input'];
  /** Флаг синхронизации плана с планом на уровень выше */
  isSynchronized?: InputMaybe<Scalars['Boolean']['input']>;
  /** Цели плана */
  planGoals: Array<S21ClassPlanGoalInput>;
  /** Идентификатор плана на параллель */
  stagePlanId: Scalars['ID']['input'];
  /** Дата/время начала плана */
  startDate: Scalars['DateTime']['input'];
};

export type S21ClassPlanSavingProgress = {
  __typename?: 'S21ClassPlanSavingProgress';
  /** Является ли процесс сохранения возвращением к предыдущей версии */
  isRollback: Scalars['Boolean']['output'];
  /** План находится в процессе сохранения */
  isSavingInProgress: Scalars['Boolean']['output'];
  /** Всего студентов для обновления плана */
  studentsTotal: Scalars['Int']['output'];
  /** Кол-во студентов с ошибкой обновления */
  studentsUpdatedFail: Scalars['Int']['output'];
  /** Кол-во успешно обновленных студентов */
  studentsUpdatedSuccess: Scalars['Int']['output'];
};

export type S21ExamMutations = {
  __typename?: 'S21ExamMutations';
  /** S21. Завершение экзамена */
  finishExam: ExamResult;
  /** S21. Завершение выполнения экзаменационного теста */
  finishExamTest: ExamTestResult;
  /** S21. Получение следующего задания во время прохождения экзамена */
  pullNextExamTask: ExamTaskWithStatuses;
  /**
   * -----------------------------Мутации студента-----------------------------
   *  S21. Сохранения SSH ключа для экзаменационного пользователя
   */
  saveExamSSHKey: Scalars['String']['output'];
  /** S21. Сохранение ответов на виджеты экзаменационного теста */
  saveExamTestAnswers?: Maybe<Scalars['Boolean']['output']>;
  /** S21. Скип текущего задания во время прохождения экзамена */
  skipCurrentExamTask: ExamTaskWithStatuses;
  /** S21. Старт экзамена студентом с последующей выдачей ему первого задания */
  startExam?: Maybe<ExamTaskWithStatuses>;
  /** S21. Переключение учетной записи пользователя на временную во время прохождения экзамена */
  switchStudentToFakeAccount: Scalars['Boolean']['output'];
};


export type S21ExamMutationsFinishExamArgs = {
  examId: Scalars['ID']['input'];
};


export type S21ExamMutationsFinishExamTestArgs = {
  answersToWidgets?: InputMaybe<Array<AnswerToWidgetInput>>;
  examId: Scalars['ID']['input'];
  files: Array<FileInput>;
  reviewUserId?: InputMaybe<Scalars['ID']['input']>;
  taskId: Scalars['ID']['input'];
};


export type S21ExamMutationsPullNextExamTaskArgs = {
  examId: Scalars['ID']['input'];
  goalId: Scalars['ID']['input'];
  language?: InputMaybe<Scalars['String']['input']>;
};


export type S21ExamMutationsSaveExamSshKeyArgs = {
  fakeExternalSystemUserId: Scalars['String']['input'];
  key: Scalars['String']['input'];
};


export type S21ExamMutationsSaveExamTestAnswersArgs = {
  answers: Array<AnswerToWidgetInput>;
  examId: Scalars['ID']['input'];
  files: Array<FileInput>;
  nextPageNumber: Scalars['Int']['input'];
  reviewUserId?: InputMaybe<Scalars['ID']['input']>;
  taskId: Scalars['ID']['input'];
};


export type S21ExamMutationsSkipCurrentExamTaskArgs = {
  examId: Scalars['ID']['input'];
  goalId: Scalars['ID']['input'];
  language?: InputMaybe<Scalars['String']['input']>;
};


export type S21ExamMutationsStartExamArgs = {
  examId: Scalars['ID']['input'];
  goalId: Scalars['ID']['input'];
  language?: InputMaybe<Scalars['String']['input']>;
};


export type S21ExamMutationsSwitchStudentToFakeAccountArgs = {
  examId: Scalars['ID']['input'];
};

export type S21ExamQueries = {
  __typename?: 'S21ExamQueries';
  /** S21. Проверить доступ студента к экзамену */
  checkExamAccess: Scalars['Boolean']['output'];
  /** S21. Получить список предстоящих событий в экзаменационной среде Ш21 на текущую дату */
  getAvailableEventsForToday: Array<EventInfo>;
  /**
   * -----------------------------Запросы студента-----------------------------
   *  S21. Получение текущего задания во время прохождения экзамена
   */
  getCurrentExamTask: ExamTaskWithStatuses;
  /** S21. Получение статуса проверки автотестов на отправленное экзаменационное задание */
  getExamAnswerStatus?: Maybe<TaskStatusEnum>;
  /** S21. Получение мета информации для подготовки студента к прохождению экзамена */
  getExamPassingUser: ExamPassingUser;
  /** S21. Получение статуса текущего экзамена студента (если вернул null - текущий или следующий экзамен не найден) */
  getExamStatusInfo?: Maybe<ExamStatusInfo>;
  /** S21. Получение статуса текущего экзамена студента (если вернул null - текущий или следующий экзамен не найден) */
  getExamTestStatusInfo?: Maybe<ExamTestStatusInfo>;
  /** S21. Проверка наличия у пользователя наличия пропущенных экзаменов (true - он есть, надо показать модальное окно) */
  isExistSkippedExam: Scalars['Boolean']['output'];
};


export type S21ExamQueriesCheckExamAccessArgs = {
  token: Scalars['String']['input'];
};


export type S21ExamQueriesGetCurrentExamTaskArgs = {
  examId: Scalars['ID']['input'];
  goalId: Scalars['ID']['input'];
  language?: InputMaybe<Scalars['String']['input']>;
};


export type S21ExamQueriesGetExamAnswerStatusArgs = {
  currentLevelId: Scalars['ID']['input'];
  examId: Scalars['ID']['input'];
  goalId: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
};


export type S21ExamQueriesGetExamPassingUserArgs = {
  examId: Scalars['ID']['input'];
  goalId: Scalars['ID']['input'];
};


export type S21ExamQueriesGetExamStatusInfoArgs = {
  examId?: InputMaybe<Scalars['Int']['input']>;
};


export type S21ExamQueriesGetExamTestStatusInfoArgs = {
  examId?: InputMaybe<Scalars['Int']['input']>;
};

/** Цели */
export type S21Goal = {
  __typename?: 'S21Goal';
  /** Тип проекта (групповой, индивидуальный) */
  assignmentType?: Maybe<TaskAssignmentEnum>;
  /** "Начало выполнения" */
  beginDate?: Maybe<Scalars['DateTime']['output']>;
  /** "Проверка" */
  checkDate?: Maybe<Scalars['DateTime']['output']>;
  /** "Дедлайн" */
  deadlineDate?: Maybe<Scalars['DateTime']['output']>;
  /** Флаг, указывающий на игнорирование любых дедлайнов для модуля */
  deadlineFree?: Maybe<Scalars['Boolean']['output']>;
  /** Тип выполнения */
  executionType?: Maybe<ModuleExecutionType>;
  /** Идентификатор цели */
  goalId?: Maybe<Scalars['ID']['output']>;
  /** Название цели */
  goalName: Scalars['String']['output'];
  /** Просмотр контента */
  isContentAvailable: Scalars['Boolean']['output'];
  /** Какие периоды учитываются в проекте */
  periodSettings?: Maybe<PeriodSettings>;
  /** "Регистрация" */
  signUpDate?: Maybe<Scalars['DateTime']['output']>;
};

/** Модель для отображения процесса сохранения пачки локальных курсов */
export type S21LocalCoursesSavingPackage = {
  __typename?: 'S21LocalCoursesSavingPackage';
  /** Id процесса сохранения (пакета локальных курсов) */
  s21LocalCoursesSavingPackageId: Scalars['ID']['output'];
  /** Список элементов в данном пакете сохранения */
  s21LocalCoursesSavingPackageItems: Array<S21LocalCoursesSavingPackageItem>;
};

/** Модель для отображения одного элемента из пачки локальных курсов */
export type S21LocalCoursesSavingPackageItem = {
  __typename?: 'S21LocalCoursesSavingPackageItem';
  /** Название сущности, на которую назначен курс */
  assignedEntityName: Scalars['String']['output'];
  /** Код ошибки для отображения на фронте */
  errorMessageCode?: Maybe<Scalars['String']['output']>;
  /** Лог ошибки, список названий проектов, курсов */
  errorMessageLog?: Maybe<Scalars['String']['output']>;
  /** Id локального курса */
  localCourseId: Scalars['ID']['output'];
  /** Название локального курса */
  localCourseName: Scalars['String']['output'];
  /** Прогресс сохранения по данному курсу (если его нет то дефолтаная модель) */
  localCourseS21SavingProgress: LocalCourseS21SavingProgress;
  /** Порядок локального курса в списке начиная с 0 */
  order: Scalars['ID']['output'];
  /** Id элемента в пакете локальных курсов */
  s21LocalCoursesSavingPackageItemId: Scalars['ID']['output'];
  /** Статус сохранения данного итема (локального курса) */
  status: S21LocalCoursesSavingPackageItemStatus;
};

/** Статус сохранения одного итема в пачке локальных курсов */
export enum S21LocalCoursesSavingPackageItemStatus {
  /** Данный элемент назначен для дальнейшего сохранения */
  Assigned = 'ASSIGNED',
  /** Данный элемент зафейлен (не прошел первичнюу валидацию) */
  Failed = 'FAILED',
  /** Данный элемент находится в процессе сохранения */
  InProgress = 'IN_PROGRESS',
  /** Данный элемент получил ошибку в процессе публикации */
  PublicationError = 'PUBLICATION_ERROR',
  /** Данный элемент находится в процессе повторного сохранения */
  RetryProgress = 'RETRY_PROGRESS',
  /** Данный элемент откатан (к прошлой версии) */
  Rollbacked = 'ROLLBACKED',
  /** Данный элемент получил ошибку в процессе отката */
  RollbackError = 'ROLLBACK_ERROR',
  /** Данный элемент находится в процессе отката сохранения */
  RollbackProgress = 'ROLLBACK_PROGRESS',
  /** Данный элемент сохранен успешно */
  Success = 'SUCCESS',
  /** Данный элемент находится на этапе валидации */
  Validation = 'VALIDATION',
  /** Данный элемент не прошел первичную валидацию */
  ValidationError = 'VALIDATION_ERROR'
}

/** Массовая выдача награды ученикам */
export type S21MassAddAwardToUsersResponse = {
  __typename?: 'S21MassAddAwardToUsersResponse';
  /** Сформировать на фронте файл отчета или нет */
  createFile: Scalars['Boolean']['output'];
  /** Сообщение о результатах массовой выдачи наград */
  message: Scalars['String']['output'];
};

/** S21. Тип сущности для миграции с плана на курс */
export enum S21MigrationFromPlanToCourseEntityType {
  All = 'ALL',
  Campus = 'CAMPUS',
  Class = 'CLASS'
}

/** Результат миграции с плана в курс */
export type S21MigrationFromPlanToCourseResult = {
  __typename?: 'S21MigrationFromPlanToCourseResult';
  /** Время затраченное на миграцию */
  timeSpent: Scalars['String']['output'];
};

export type S21Notification = {
  __typename?: 'S21Notification';
  groupName?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  message: Scalars['String']['output'];
  relatedObjectId: Scalars['ID']['output'];
  relatedObjectType: S21RelatedObjectEnum;
  time: Scalars['DateTime']['output'];
  title: Scalars['String']['output'];
  type: S21NotificationEnum;
  wasRead: Scalars['Boolean']['output'];
};

export enum S21NotificationEnum {
  S21AddAward = 'S21_ADD_AWARD',
  S21ApproveParticipantEvent = 'S21_APPROVE_PARTICIPANT_EVENT',
  S21ApproveParticipantEventWithChanges = 'S21_APPROVE_PARTICIPANT_EVENT_WITH_CHANGES',
  S21CalcCourseFinalPointUi = 'S21_CALC_COURSE_FINAL_POINT_UI',
  S21CalcProjectFinalPoint = 'S21_CALC_PROJECT_FINAL_POINT',
  S21CancelCheckoutForVerifiable = 'S21_CANCEL_CHECKOUT_FOR_VERIFIABLE',
  S21CancelCheckoutForVerifier = 'S21_CANCEL_CHECKOUT_FOR_VERIFIER',
  S21CheatQuickAction = 'S21_CHEAT_QUICK_ACTION',
  S21CoinsMinus = 'S21_COINS_MINUS',
  S21CoinsPlus = 'S21_COINS_PLUS',
  S21CrpSaleFinished = 'S21_CRP_SALE_FINISHED',
  S21CrpSalePlanned = 'S21_CRP_SALE_PLANNED',
  S21CrpSaleStarted = 'S21_CRP_SALE_STARTED',
  S21DeadlineIsOver = 'S21_DEADLINE_IS_OVER',
  S21DeadlineStarted = 'S21_DEADLINE_STARTED',
  S21EventFreeSpace = 'S21_EVENT_FREE_SPACE',
  S21EventUpcoming = 'S21_EVENT_UPCOMING',
  S21ExtraForVerifiable = 'S21_EXTRA_FOR_VERIFIABLE',
  S21ExtraForVerifier = 'S21_EXTRA_FOR_VERIFIER',
  S21GitlabTaskUpdated = 'S21_GITLAB_TASK_UPDATED',
  S21GroupProjectDisbandmentTeamAvto = 'S21_GROUP_PROJECT_DISBANDMENT_TEAM_AVTO',
  S21GroupProjectDisbandmentTeamModerator = 'S21_GROUP_PROJECT_DISBANDMENT_TEAM_MODERATOR',
  S21GroupProjectDisbandmentTeamTeamlead = 'S21_GROUP_PROJECT_DISBANDMENT_TEAM_TEAMLEAD',
  S21GroupProjectFailed = 'S21_GROUP_PROJECT_FAILED',
  S21GroupProjectFailedTeamlead = 'S21_GROUP_PROJECT_FAILED_TEAMLEAD',
  S21GroupProjectTeamExitMember = 'S21_GROUP_PROJECT_TEAM_EXIT_MEMBER',
  S21InviteToTeam = 'S21_INVITE_TO_TEAM',
  S21LevelUp = 'S21_LEVEL_UP',
  S21PeerReviewAbsence = 'S21_PEER_REVIEW_ABSENCE',
  S21PenaltyCancelled = 'S21_PENALTY_CANCELLED',
  S21PenaltySchedule = 'S21_PENALTY_SCHEDULE',
  S21PenaltySet = 'S21_PENALTY_SET',
  S21PenaltyWorkedOff = 'S21_PENALTY_WORKED_OFF',
  S21PlatformTaskUpdated = 'S21_PLATFORM_TASK_UPDATED',
  S21PriorityForVerifiable = 'S21_PRIORITY_FOR_VERIFIABLE',
  S21PriorityForVerifier = 'S21_PRIORITY_FOR_VERIFIER',
  S21RecordForP2PCheck = 'S21_RECORD_FOR_P2P_CHECK',
  S21RejectParticipantEvent = 'S21_REJECT_PARTICIPANT_EVENT',
  S21SaleFinished = 'S21_SALE_FINISHED',
  S21SalePlanned = 'S21_SALE_PLANNED',
  S21SaleStarted = 'S21_SALE_STARTED',
  S21TeamDisbanded = 'S21_TEAM_DISBANDED',
  S21TournamentEnd = 'S21_TOURNAMENT_END',
  S21UpcomingP2PForVerifiable = 'S21_UPCOMING_P2P_FOR_VERIFIABLE',
  S21UpcomingP2PForVerifier = 'S21_UPCOMING_P2P_FOR_VERIFIER'
}

export type S21NotificationQueries = {
  __typename?: 'S21NotificationQueries';
  /** Получить пользовательские уведомления */
  getS21Notifications: S21NotificationReport;
  /**
   * -----------------------------Запросы студента-----------------------------
   *  Получить количество уведомлений
   */
  getS21NotificationsCount: Scalars['Int']['output'];
};


export type S21NotificationQueriesGetS21NotificationsArgs = {
  paging: PagingInput;
};


export type S21NotificationQueriesGetS21NotificationsCountArgs = {
  wasReadIncluded?: InputMaybe<Scalars['Boolean']['input']>;
};

export type S21NotificationReport = {
  __typename?: 'S21NotificationReport';
  groupNames: Array<Scalars['String']['output']>;
  notifications: Array<S21Notification>;
  totalCount: Scalars['Int']['output'];
  unreadCount: Scalars['Int']['output'];
};

export type S21PlanMutations = {
  __typename?: 'S21PlanMutations';
  /** Запуск миграции c плана на класс в курс */
  migrateFromClassPlanToCourse: S21MigrationFromPlanToCourseResult;
  /** Публикация плана на параллель */
  publishS21StagePlanByGlobalPlanIds: Array<S21StagePlan>;
  /** Сброс плана на параллель до состояния глобального плана */
  resetS21StagePlan: S21StagePlan;
  /** Сохранение настроек условий фильтрации для курса (группы проектов) в плане на класс */
  saveCourseEvaluationRulesForStageSubjectGroupPlan: Array<EvaluationRuleGroup>;
  /**
   * -----------------------------Мутации бизнес админа-----------------------------
   *  Сохранение настроек условий фильтрации для модуля (проекта, цели) в плане на класс
   */
  saveEvaluationRulesForStageSubjectGroupPlan: Array<EvaluationRuleGroup>;
  /** Сохранение плана на класс */
  saveS21ClassPlan: S21ClassPlan;
  /** Сохранение плана на параллель */
  saveS21StagePlan: S21StagePlan;
  /** Сохранение параметров команды в модуле плана на класс */
  saveTeamSettingsInStageSubjectGroupPlanGoal: Scalars['Boolean']['output'];
  /** Сохранение параметров команды в модуле плана на параллель */
  saveTeamSettingsInStageSubjectPlanGoal: Scalars['Boolean']['output'];
};


export type S21PlanMutationsMigrateFromClassPlanToCourseArgs = {
  isAsync?: InputMaybe<Scalars['Boolean']['input']>;
  migrationEntityId?: InputMaybe<Scalars['String']['input']>;
  migrationEntityType: S21MigrationFromPlanToCourseEntityType;
};


export type S21PlanMutationsPublishS21StagePlanByGlobalPlanIdsArgs = {
  globaPlanIds: Array<Scalars['ID']['input']>;
};


export type S21PlanMutationsResetS21StagePlanArgs = {
  stagePlanId: Scalars['ID']['input'];
};


export type S21PlanMutationsSaveCourseEvaluationRulesForStageSubjectGroupPlanArgs = {
  conditionType: ConditionType;
  evaluationRules: Array<EvaluationRuleGroupInput>;
  stageSubjectGroupPlanCourseId: Scalars['ID']['input'];
};


export type S21PlanMutationsSaveEvaluationRulesForStageSubjectGroupPlanArgs = {
  conditionType: ConditionType;
  evaluationRules: Array<EvaluationRuleGroupInput>;
  stageSubjectGroupPlanGoalId: Scalars['ID']['input'];
};


export type S21PlanMutationsSaveS21ClassPlanArgs = {
  classPlan: S21ClassPlanInput;
};


export type S21PlanMutationsSaveS21StagePlanArgs = {
  globalPlanId?: InputMaybe<Scalars['ID']['input']>;
  planGoalInputModels: Array<S21StagePlanGoalInput>;
  stagePlanId?: InputMaybe<Scalars['ID']['input']>;
};


export type S21PlanMutationsSaveTeamSettingsInStageSubjectGroupPlanGoalArgs = {
  isMulticampusEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  stageSubjectGroupPlanGoalId: Scalars['ID']['input'];
  teamSettings: TeamSettingsInput;
};


export type S21PlanMutationsSaveTeamSettingsInStageSubjectPlanGoalArgs = {
  isMulticampusEnabled?: InputMaybe<Scalars['Boolean']['input']>;
  stageSubjectPlanGoalId: Scalars['ID']['input'];
  teamSettings: TeamSettingsInput;
};

export type S21PlanQueries = {
  __typename?: 'S21PlanQueries';
  /** Возвращает план на класс по идентификатору */
  getS21ClassPlan: S21ClassPlan;
  /** Возвращает план на класс по идентификатору плана на параллель */
  getS21ClassPlanByStagePlanId: S21ClassPlan;
  /** Получить текущий статус по процессу сохранения плана на класс */
  getS21ClassPlanSavingProgress: S21ClassPlanSavingProgress;
  /** Возвращает все существующие планы на класс */
  getS21ClassPlans: Array<S21ClassPlanByStagesSubjects>;
  /** Возвращает план на параллель по идентификатору */
  getS21StagePlan: S21StagePlan;
  /** Возвращает план на параллель по идентификатору глобального плана */
  getS21StagePlanByGlobalPlanId: S21StagePlan;
  /** Возвращает все существующие планы на параллель */
  getS21StagePlans: Array<S21StagePlan>;
  /** Запрос параметров команды для модуля из плана на класс */
  getTeamSettingsFromStageSubjectGroupPlanGoal?: Maybe<TeamSettings>;
  /** Запрос параметров команды для модуля из плана на параллель */
  getTeamSettingsFromStageSubjectPlanGoal?: Maybe<TeamSettings>;
  /** Запрос группы параметров комманды для проекта из плана на класс */
  getTeamSettingsGroupFromStageSubjectGroupPlanGoal: TeamSettingsGroupWithEquivalentFlag;
  /** Запрос группы параметров комманды для проекта из плана на параллель */
  getTeamSettingsGroupFromStageSubjectPlanGoal: TeamSettingsGroupWithEquivalentFlag;
  /** Запрос настроек условий заданного типа для курса (группы проектов) в плане на класс */
  loadCourseEvaluationRuleGroupsFromStageSubjectGroupPlan: EvaluationRuleGroupsWithEquivalentFlag;
  /**
   * -----------------------------Запросы бизнес админа-----------------------------
   *  Запрос настроек условий заданного типа для модуля (проекта, цели) в плане на класс
   */
  loadTaskEvaluationRuleGroupsFromStageSubjectGroupPlan: EvaluationRuleGroupsWithEquivalentFlag;
};


export type S21PlanQueriesGetS21ClassPlanArgs = {
  classPlanId: Scalars['ID']['input'];
};


export type S21PlanQueriesGetS21ClassPlanByStagePlanIdArgs = {
  classSubjectId: Scalars['ID']['input'];
  stagePlanId: Scalars['ID']['input'];
};


export type S21PlanQueriesGetS21ClassPlanSavingProgressArgs = {
  stageSubjectGroupPlanId: Scalars['Int']['input'];
};


export type S21PlanQueriesGetS21StagePlanArgs = {
  stagePlanId: Scalars['ID']['input'];
};


export type S21PlanQueriesGetS21StagePlanByGlobalPlanIdArgs = {
  globalPlanId: Scalars['ID']['input'];
};


export type S21PlanQueriesGetS21StagePlansArgs = {
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
};


export type S21PlanQueriesGetTeamSettingsFromStageSubjectGroupPlanGoalArgs = {
  stageSubjectGroupPlanGoalId: Scalars['ID']['input'];
};


export type S21PlanQueriesGetTeamSettingsFromStageSubjectPlanGoalArgs = {
  stageSubjectPlanGoalId: Scalars['ID']['input'];
};


export type S21PlanQueriesGetTeamSettingsGroupFromStageSubjectGroupPlanGoalArgs = {
  stageSubjectGroupPlanGoalId: Scalars['ID']['input'];
};


export type S21PlanQueriesGetTeamSettingsGroupFromStageSubjectPlanGoalArgs = {
  stageSubjectPlanGoalId: Scalars['ID']['input'];
};


export type S21PlanQueriesLoadCourseEvaluationRuleGroupsFromStageSubjectGroupPlanArgs = {
  conditionType: ConditionType;
  stageSubjectGroupPlanCourseId: Scalars['ID']['input'];
};


export type S21PlanQueriesLoadTaskEvaluationRuleGroupsFromStageSubjectGroupPlanArgs = {
  conditionType: ConditionType;
  stageSubjectGroupPlanGoalId: Scalars['ID']['input'];
};

/** S21. Тип выполнения модуля */
export enum S21ProjectExecutionType {
  /** Курс (используется S21) */
  Course = 'COURSE',
  /** Экзаменационный модуль (используется S21) */
  Exam = 'EXAM',
  /** Модуль/Проект экзаменационного теста (используется S21) */
  ExamTest = 'EXAM_TEST',
  /** Групповой проект (используется S21) */
  Group = 'GROUP',
  /** Индивидуальный проект (используется S21) */
  Individual = 'INDIVIDUAL',
  /** Модуль/Проект стажировка (используется S21) */
  Internship = 'INTERNSHIP'
}

export enum S21RelatedObjectEnum {
  Award = 'AWARD',
  Calendar = 'CALENDAR',
  Coins = 'COINS',
  Course = 'COURSE',
  Dashboard = 'DASHBOARD',
  Deadline = 'DEADLINE',
  Event = 'EVENT',
  Invitations = 'INVITATIONS',
  MyEvents = 'MY_EVENTS',
  Penalty = 'PENALTY',
  Profile = 'PROFILE',
  Project = 'PROJECT',
  Sale = 'SALE'
}

export type S21SchoolInput = {
  /** Адрес электронной почты кампуса */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Урл экзаменационного приложения кампуса */
  examUrl?: InputMaybe<Scalars['String']['input']>;
  /** Полное название кампуса */
  fullName: Scalars['String']['input'];
  /** Краткое название кампуса */
  shortName: Scalars['String']['input'];
  /** ИД таймзоны кампуса */
  timeZoneId: Scalars['String']['input'];
};

/** S21. Тип праздничной темы */
export enum S21SchoolViewSettingType {
  Default = 'DEFAULT',
  Halloween = 'HALLOWEEN',
  NewYear = 'NEW_YEAR',
  S21Birthday = 'S21_BIRTHDAY'
}

/** Праздничная тема */
export type S21SchoolViewSettings = {
  __typename?: 'S21SchoolViewSettings';
  /** Завершение */
  endDate?: Maybe<Scalars['Date']['output']>;
  /** Включена/выключена */
  isEnabled: Scalars['Boolean']['output'];
  /** Ежегодное повторение */
  isRepeatAnnually?: Maybe<Scalars['Boolean']['output']>;
  /** ИД настройки праздничной темы */
  s21SchoolViewSettingsId?: Maybe<Scalars['ID']['output']>;
  /** Тип праздничной темы */
  schoolViewSettingType: S21SchoolViewSettingType;
  /** Начало */
  startDate?: Maybe<Scalars['Date']['output']>;
};

export type S21SchoolViewSettingsInput = {
  /** Завершение */
  endDate?: InputMaybe<Scalars['Date']['input']>;
  /** Включена/выключена */
  isEnabled: Scalars['Boolean']['input'];
  /** Ежегодное повторение */
  isRepeatAnnually?: InputMaybe<Scalars['Boolean']['input']>;
  /** ИД настройки праздничной темы */
  s21SchoolViewSettingsId?: InputMaybe<Scalars['ID']['input']>;
  /** Тип праздничной темы */
  schoolViewSettingType: S21SchoolViewSettingType;
  /** Начало */
  startDate?: InputMaybe<Scalars['Date']['input']>;
};

/** План на параллель */
export type S21StagePlan = {
  __typename?: 'S21StagePlan';
  /** Глобальный план */
  globalPlan: GlobalPlan;
  /** Статус плана */
  isPublished?: Maybe<Scalars['Boolean']['output']>;
  /** Цели плана */
  planGoals: Array<S21StagePlanGoal>;
  /** Количество проектов */
  projectCount: Scalars['Int']['output'];
  /** Идентификатор параллели */
  stageId: Scalars['ID']['output'];
  /** Название параллели */
  stageName?: Maybe<Scalars['String']['output']>;
  /** Идентификатор плана на параллель */
  stagePlanId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор предмета */
  subjectId: Scalars['ID']['output'];
  /** Название предмета */
  subjectName?: Maybe<Scalars['String']['output']>;
};

/** Цели плана на параллель */
export type S21StagePlanGoal = {
  __typename?: 'S21StagePlanGoal';
  /**
   * Тип проекта (групповой, индивидуальный)
   * @deprecated Под удаление. Использовать executionType
   */
  assignmentType?: Maybe<TaskAssignmentEnum>;
  /** "Начать с ..." */
  beginFrom: Scalars['Int']['output'];
  /** "Проверка" */
  checkFrom?: Maybe<Scalars['Int']['output']>;
  /** Количество проектов в курсе */
  courseProjectCount?: Maybe<Scalars['Int']['output']>;
  /** Тип курса */
  courseType?: Maybe<CourseType>;
  /** Флаг, указывающий на игнорирование любых дедлайнов для модуля */
  deadlineFree: Scalars['Boolean']['output'];
  /** Флаг, указывающий на эквивалентность правил для конструктора в глобальном плане и плане на параллель */
  equivalentConstructors?: Maybe<Scalars['Boolean']['output']>;
  /** Тип выполнения */
  executionType?: Maybe<ModuleExecutionType>;
  /** Идентификатор глобального курса */
  globalCourseId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор цели */
  goalId?: Maybe<Scalars['ID']['output']>;
  /** Название цели */
  goalName?: Maybe<Scalars['String']['output']>;
  /** В курсе есть проект без дедлайнов и со случайным формированием команды */
  hasDeadlineFreeRandomTeam?: Maybe<Scalars['Boolean']['output']>;
  /** Просмотр контента */
  isContentAvailable: Scalars['Boolean']['output'];
  /** Ожидаемая трудоемкость в часах */
  laboriousness?: Maybe<Scalars['Int']['output']>;
  /** Порядковый номер цели */
  order: Scalars['Int']['output'];
  /** "Часы на проект" */
  projectHours?: Maybe<Scalars['Int']['output']>;
  /** "Регистрация" */
  signUpFrom: Scalars['Int']['output'];
  /** Идентификатор цели плана на параллель */
  stagePlanGoalId?: Maybe<Scalars['ID']['output']>;
  /** Имя абстрактного глобального предмета */
  subjectName?: Maybe<Scalars['String']['output']>;
  /** Настройки формирования команд */
  teamSettings?: Maybe<TeamSettings>;
};

/** Модель ввода для целей плана на параллель */
export type S21StagePlanGoalInput = {
  /** "Начать с ..." */
  beginFrom: Scalars['Int']['input'];
  /** "Проверка" */
  checkFrom?: InputMaybe<Scalars['Int']['input']>;
  /** Флаг, указывающий на игнорирование любых дедлайнов для модуля */
  deadlineFree: Scalars['Boolean']['input'];
  /** Идентификатор глобального курса */
  globalCourseId?: InputMaybe<Scalars['ID']['input']>;
  /** Идентификатор цели */
  goalId?: InputMaybe<Scalars['ID']['input']>;
  /** Просмотр контента */
  isContentAvailable: Scalars['Boolean']['input'];
  /** Порядковый номер цели */
  order: Scalars['Int']['input'];
  /** "Часы на проект" */
  projectHours?: InputMaybe<Scalars['Int']['input']>;
  /** "Регистрация" */
  signUpFrom: Scalars['Int']['input'];
  /** Идентификатор цели плана на параллель */
  stagePlanGoalId?: InputMaybe<Scalars['ID']['input']>;
};

/** Основное инфо об ученике Школы 21 */
export type S21StudentPublicProfileBasicInfo = {
  __typename?: 'S21StudentPublicProfileBasicInfo';
  /** Аватар */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Имя */
  firstName?: Maybe<Scalars['String']['output']>;
  /** Фамилия */
  lastName?: Maybe<Scalars['String']['output']>;
  /** Уровень */
  level?: Maybe<Scalars['Int']['output']>;
  /** Логин */
  login: Scalars['String']['output'];
  /** Отчество */
  middleName?: Maybe<Scalars['String']['output']>;
  /** Школа */
  school?: Maybe<School>;
  /** Идентификатор школы пользователя */
  schoolId?: Maybe<Scalars['UUID']['output']>;
  /** Идентификатор пользователя */
  userId: Scalars['UUID']['output'];
};

export type S21StudentTaskFiles = {
  __typename?: 'S21StudentTaskFiles';
  /** S21. Получение файлов, прикрепленных к версии, которую на данный момент выполняет студент */
  getTaskContentFiles: Array<TaskFile>;
};


export type S21StudentTaskFilesGetTaskContentFilesArgs = {
  studentAnswerId: Scalars['ID']['input'];
};

/** Учебная программа */
export type S21StudyProgram = {
  __typename?: 'S21StudyProgram';
  /** Статус публикации */
  isPublic: Scalars['Boolean']['output'];
  /** Количество элементов учебной программы */
  itemsCount: Scalars['Int']['output'];
  /** Список курсов учебной программы */
  studyProgramCourses: Array<S21StudyProgramCourse>;
  /** Идентификатор учебной программы */
  studyProgramId: Scalars['ID']['output'];
  /** Название учебной программы */
  studyProgramName: Scalars['String']['output'];
};

/** Курс в учебной программе */
export type S21StudyProgramCourse = {
  __typename?: 'S21StudyProgramCourse';
  /** Название курса */
  courseName: Scalars['String']['output'];
  /** Тип курса */
  courseType: CourseType;
  /** Идентификатор курса */
  globalCourseId: Scalars['ID']['output'];
  /** Порядковый номер */
  order: Scalars['Int']['output'];
};

/** Результат проверки назначения курсов учебной программы */
export type S21StudyProgramCourseAssignment = {
  __typename?: 'S21StudyProgramCourseAssignment';
  /** Название курса */
  courseName: Scalars['String']['output'];
  /** Тип курса */
  courseType: CourseType;
  /** Идентификатор курса */
  globalCourseId: Scalars['ID']['output'];
};

/** Input курса в учебной программе */
export type S21StudyProgramCourseInput = {
  /** Идентификатор курса */
  globalCourseId: Scalars['ID']['input'];
  /** Порядковый номер */
  order: Scalars['Int']['input'];
};

/** Результат проверки назначения курсов учебной программы на класс */
export type S21StudyProgramCoursesAssignment = {
  __typename?: 'S21StudyProgramCoursesAssignment';
  /** Список назначенных курсов */
  assignedCourses: Array<S21StudyProgramCourseAssignment>;
  /** Список не назначенных курсов */
  nonAssignedCourses: Array<S21StudyProgramCourseAssignment>;
  /** Идентификатор учебной программы */
  studyProgramId: Scalars['ID']['output'];
  /** Название учебной программы */
  studyProgramName: Scalars['String']['output'];
};

/** Input учебной программы */
export type S21StudyProgramInput = {
  /** Статус публикации */
  isPublic: Scalars['Boolean']['input'];
  /** Список курсов учебной программы */
  studyProgramCourses: Array<S21StudyProgramCourseInput>;
  /** Идентификатор учебной программы */
  studyProgramId: Scalars['ID']['input'];
  /** Название учебной программы */
  studyProgramName: Scalars['String']['input'];
};

export type S21StudyProgramMutations = {
  __typename?: 'S21StudyProgramMutations';
  /**
   * -----------------------------Мутации админа-----------------------------
   *  Создание учебной программы
   */
  createStudyProgram: S21StudyProgram;
  /** Публикация учебной программы с указанным идентификатором */
  publishStudyProgram: Scalars['Boolean']['output'];
  /** Переименование учебной программы с указанным идентификатором */
  renameStudyProgram: Scalars['Boolean']['output'];
  /** Создание локальных курсов для учебной программы */
  saveLocalCourses: Array<LocalCourse>;
  /** Сохранение учебной программы */
  saveStudyProgram: S21StudyProgram;
};


export type S21StudyProgramMutationsCreateStudyProgramArgs = {
  studyProgramName: Scalars['String']['input'];
};


export type S21StudyProgramMutationsPublishStudyProgramArgs = {
  studyProgramId: Scalars['ID']['input'];
};


export type S21StudyProgramMutationsRenameStudyProgramArgs = {
  studyProgramId: Scalars['ID']['input'];
  studyProgramName: Scalars['String']['input'];
};


export type S21StudyProgramMutationsSaveLocalCoursesArgs = {
  assignedEntityId: Scalars['String']['input'];
  assignedEntityType: LocalCourseAssignedEntityType;
  localCourses: Array<MassiveLocalCourseAssignInput>;
  studyProgramId: Scalars['ID']['input'];
};


export type S21StudyProgramMutationsSaveStudyProgramArgs = {
  studyProgram: S21StudyProgramInput;
};

/** Статус публикации учебной программы */
export enum S21StudyProgramPublishedStatus {
  /** Все */
  All = 'ALL',
  /** Опубликован */
  Published = 'PUBLISHED',
  /** НЕ опубликован */
  Unpublished = 'UNPUBLISHED'
}

export type S21StudyProgramQueries = {
  __typename?: 'S21StudyProgramQueries';
  /** Назначены ли курсы в УП на класс */
  getAssignedCourses: S21StudyProgramCoursesAssignment;
  /** Возвращает учебную программу по указанному идентификатору */
  getStudyProgram: S21StudyProgram;
  /** Возвращает список всех проектов, входящих в курсы учебной программы */
  getStudyProgramCourseGoals: Array<ModuleInfo>;
  /**
   * -----------------------------Запросы админа-----------------------------
   *  Получить список учебных программ с учетом указанных фильтров
   */
  getStudyPrograms: S21StudyProgramsSearchResult;
};


export type S21StudyProgramQueriesGetAssignedCoursesArgs = {
  stageSubjectGroupId: Scalars['ID']['input'];
  studyProgramId: Scalars['ID']['input'];
};


export type S21StudyProgramQueriesGetStudyProgramArgs = {
  studyProgramId: Scalars['ID']['input'];
};


export type S21StudyProgramQueriesGetStudyProgramCourseGoalsArgs = {
  studyProgramId: Scalars['ID']['input'];
};


export type S21StudyProgramQueriesGetStudyProgramsArgs = {
  filterExceptStudyPrograms?: InputMaybe<Array<Scalars['ID']['input']>>;
  name?: InputMaybe<Scalars['String']['input']>;
  paging?: InputMaybe<PagingInput>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  studyProgramPublishedStatus?: InputMaybe<S21StudyProgramPublishedStatus>;
};

/** Представление учебной программы в списке учебных программ */
export type S21StudyProgramView = {
  __typename?: 'S21StudyProgramView';
  /** Признак опубликованности учебной программы */
  isPublic: Scalars['Boolean']['output'];
  /** Количество элементов, которые содержит учебная программа */
  itemsCount: Scalars['Int']['output'];
  /** Идентификатор учебной программы */
  studyProgramId: Scalars['ID']['output'];
  /** Название учебной программы */
  studyProgramName: Scalars['String']['output'];
};

/** Результат поиска учебных программ по заданным фильтрам */
export type S21StudyProgramsSearchResult = {
  __typename?: 'S21StudyProgramsSearchResult';
  /** Количество найденных учебных программ */
  count: Scalars['Int']['output'];
  /** Список найденных учебных программ по переданным фильтрам */
  studyPrograms?: Maybe<Array<S21StudyProgramView>>;
};

export type Sc21BaCalendarMutations = {
  __typename?: 'SC21BaCalendarMutations';
  /** S21. Добавление свободного времени для проверки (опционально указывается модуль, который будет проверяться) */
  addEventToTimetable: Array<CalendarEvent>;
  /** S21. Изменение свободного таймслота для проверки */
  changeEventSlot: Array<CalendarEvent>;
  /** S21. Создание записей на проверку групповых проектов на слоты, созданные пользователями с фролью INSPECTION_STAFF */
  createBookingsForInspectionStaff: Array<CalendarBooking>;
  /** S21. Удаление свободного времени для проверки */
  deleteEvent: Scalars['Boolean']['output'];
  /** S21. Удаление свободного таймслота для проверки */
  deleteEventSlot: Scalars['Boolean']['output'];
  /** S21. Отмена записи на проверку */
  removeBookingFromEventSlot: Scalars['Boolean']['output'];
};


export type Sc21BaCalendarMutationsAddEventToTimetableArgs = {
  end: Scalars['DateTime']['input'];
  goalId: Scalars['ID']['input'];
  isMultiVisible: Scalars['Boolean']['input'];
  start: Scalars['DateTime']['input'];
};


export type Sc21BaCalendarMutationsChangeEventSlotArgs = {
  end: Scalars['DateTime']['input'];
  eventSlotId: Scalars['ID']['input'];
  goalId?: InputMaybe<Scalars['ID']['input']>;
  start: Scalars['DateTime']['input'];
};


export type Sc21BaCalendarMutationsDeleteEventArgs = {
  eventId: Scalars['ID']['input'];
};


export type Sc21BaCalendarMutationsDeleteEventSlotArgs = {
  eventSlotId: Scalars['ID']['input'];
};


export type Sc21BaCalendarMutationsRemoveBookingFromEventSlotArgs = {
  bookingId: Scalars['ID']['input'];
};

export type Sc21BaCalendarQueries = {
  __typename?: 'SC21BaCalendarQueries';
  /** S21. Метод возвращает список событий по идентификатору школы вызывающего и по списку типов событий */
  getCalendarEvents: Array<CalendarEvent>;
  /** S21. Метод возвращает список групповых модулей, имеющих p2p проверки, по идентификатору школы вызывающего */
  getModulesForFreeSlot: Array<Goal>;
  /** S21. Запрос событий БА для выбранного диапазона */
  getMyCalendarEvents: Array<CalendarEvent>;
  /** S21. Запрос всех проверок БА начиная за конкретный период */
  getMyUpcomingBookingsByDate: Array<CalendarBooking>;
};


export type Sc21BaCalendarQueriesGetCalendarEventsArgs = {
  after?: InputMaybe<Scalars['DateTime']['input']>;
  before?: InputMaybe<Scalars['DateTime']['input']>;
  endDateAfter?: InputMaybe<Scalars['DateTime']['input']>;
  endDateBefore?: InputMaybe<Scalars['DateTime']['input']>;
  eventCodes: Array<Scalars['String']['input']>;
  nameFilter?: InputMaybe<Scalars['String']['input']>;
  page: PagingInput;
  sortingField?: InputMaybe<SortingField>;
  statuses?: InputMaybe<Array<InputMaybe<ParticipantEventStatus>>>;
};


export type Sc21BaCalendarQueriesGetMyCalendarEventsArgs = {
  from: Scalars['DateTime']['input'];
  to: Scalars['DateTime']['input'];
};


export type Sc21BaCalendarQueriesGetMyUpcomingBookingsByDateArgs = {
  endDateTime: Scalars['DateTime']['input'];
  startDateTime: Scalars['DateTime']['input'];
};

export type Sc21BaTaskCheckMutations = {
  __typename?: 'SC21BaTaskCheckMutations';
  /** S21. Обновление настроек распродаж */
  batchUpdateRpSaleSetting: Array<RpSaleSetting>;
  /** S21. Сохранить введенные данные, записать время окончания проверки, вычислить продолжительность проверки */
  completeP2pCheck: Scalars['Float']['output'];
  /** S21. Ручная обработка дедлайнов */
  handleProjectDeadlines?: Maybe<Scalars['Boolean']['output']>;
  /** S21. Инициация дополнительной проверки по ответу студента */
  initiateAdditionalCheck: Scalars['Boolean']['output'];
  /** S21. Отметка что запланированная встреча не состоялась из-за отсутствия одного из участников */
  markAbsenceInProtocol: BookingStatusEnum;
  /** S21. Сохранение приватного фидбэка на команду */
  savePrivateFeedback: Scalars['Boolean']['output'];
  /** S21. Старт Р2Р проверки */
  startP2pCheck: FilledChecklist;
};


export type Sc21BaTaskCheckMutationsBatchUpdateRpSaleSettingArgs = {
  rpSaleSettings: Array<RpSaleSettingInput>;
};


export type Sc21BaTaskCheckMutationsCompleteP2pCheckArgs = {
  checklistFilledInput: ChecklistFilledInput;
};


export type Sc21BaTaskCheckMutationsHandleProjectDeadlinesArgs = {
  stageSubjectGroupPlanGoalId: Scalars['ID']['input'];
};


export type Sc21BaTaskCheckMutationsInitiateAdditionalCheckArgs = {
  additionalCheckInitiationInputModel: AdditionalCheckInitiationInputModel;
};


export type Sc21BaTaskCheckMutationsMarkAbsenceInProtocolArgs = {
  bookingId: Scalars['ID']['input'];
};


export type Sc21BaTaskCheckMutationsSavePrivateFeedbackArgs = {
  feedbacks: Array<PrivateFeedbackInput>;
  filledChecklistId: Scalars['ID']['input'];
};


export type Sc21BaTaskCheckMutationsStartP2pCheckArgs = {
  actualStartTime: Scalars['DateTime']['input'];
  filledChecklistId: Scalars['ID']['input'];
};

export type Sc21BaTaskCheckQueries = {
  __typename?: 'SC21BaTaskCheckQueries';
  /** S21. Получение информации для назначения дополнительной проверки */
  getAdditionalCheckInitialData: AdditionalCheckInitialData;
  /** S21. Получить подробную информацию о попытке */
  getAttemptCheckDetailInfo: AttemptCheckDetailInfo;
  /** S21. Получение информации о попытке и проверках за нее */
  getAttemptWithChecksInfoById: AttemptWithChecks;
  /** S21. Получить подробную информацию об авто проверке */
  getAutoCheckReportDetailInfo: AutoCheckReportDetailInfo;
  /** S21. Получение занятых промежутков времени для проверяемого и проверяющего при назначение доп. проверки */
  getBusyTimeIntervals: Array<BusyTimeInterval>;
  /** S21. Запрос данных для подсчета разбалловки */
  getCountPointsInfo: CountInfo;
  /** S21. Получения отзыва сотрудника */
  getFeedbackFromStaff: FeedbackFromStaff;
  /** S21. Запрос последнего созданного чеклиста к заданию */
  getLatestChecklistForTask?: Maybe<Checklist>;
  /** S21. Получение ссылки на приватный студенческий Gitlab проект по задаче студента */
  getLinkToPrivateStudentGitlabProjectByStudentTaskId: GitlabLink;
  /** S21. Получить подробную информацию о п2п проверке */
  getP2pCheckDetailInfo: P2pCheckDetailInfo;
  /** S21. Получение информации о Р2Р проверки с указанием языка. Возвращает чек-лист */
  getP2pInfo: FilledChecklist;
  /**
   * S21. Получение финального результата за проект
   * @deprecated use getStudentGoalFinalScoreByLoginAndGoalId
   */
  getStudentGoalFinalScoreById: StudentGoalFinalScore;
  /** S21. Получение модуля студента по id студента и id модуля */
  getStudentModuleByStudentIdAndGoalId: StudentModule;
};


export type Sc21BaTaskCheckQueriesGetAdditionalCheckInitialDataArgs = {
  studentAnswerId: Scalars['ID']['input'];
};


export type Sc21BaTaskCheckQueriesGetAttemptCheckDetailInfoArgs = {
  studentGoalAttemptId: Scalars['ID']['input'];
};


export type Sc21BaTaskCheckQueriesGetAttemptWithChecksInfoByIdArgs = {
  studentGoalAttemptId: Scalars['ID']['input'];
};


export type Sc21BaTaskCheckQueriesGetAutoCheckReportDetailInfoArgs = {
  autoCheckReportId: Scalars['ID']['input'];
};


export type Sc21BaTaskCheckQueriesGetBusyTimeIntervalsArgs = {
  currentDateTime: Scalars['DateTime']['input'];
  studentAnswerId: Scalars['ID']['input'];
  verifierLogin: Scalars['String']['input'];
  verifierSchoolId: Scalars['UUID']['input'];
};


export type Sc21BaTaskCheckQueriesGetCountPointsInfoArgs = {
  sectionId: Scalars['Int']['input'];
  taskId: Scalars['ID']['input'];
};


export type Sc21BaTaskCheckQueriesGetFeedbackFromStaffArgs = {
  filledChecklistId: Scalars['ID']['input'];
};


export type Sc21BaTaskCheckQueriesGetLatestChecklistForTaskArgs = {
  languageCodeType?: InputMaybe<LanguageCodeType>;
  taskId: Scalars['ID']['input'];
};


export type Sc21BaTaskCheckQueriesGetLinkToPrivateStudentGitlabProjectByStudentTaskIdArgs = {
  studentTaskId: Scalars['ID']['input'];
};


export type Sc21BaTaskCheckQueriesGetP2pCheckDetailInfoArgs = {
  filledChecklistId: Scalars['ID']['input'];
};


export type Sc21BaTaskCheckQueriesGetP2pInfoArgs = {
  filledChecklistId: Scalars['ID']['input'];
  languageCodeType?: InputMaybe<LanguageCodeType>;
};


export type Sc21BaTaskCheckQueriesGetStudentGoalFinalScoreByIdArgs = {
  studentGoalId: Scalars['ID']['input'];
};


export type Sc21BaTaskCheckQueriesGetStudentModuleByStudentIdAndGoalIdArgs = {
  goalId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};

export type Sc21ProjectFlowMutations = {
  __typename?: 'SC21ProjectFlowMutations';
  /** S21. Завершение экзаменационного задания и отправка на автопроверку в систему GitLab */
  finishExamTask: Scalars['Boolean']['output'];
  /** S21. Завершение выполнения проекта (индивидуальный, групповой) */
  finishProject: Scalars['DateTime']['output'];
  /** S21. Регистрация на экзамен и экзаменационный тест */
  registerForExam: Scalars['Boolean']['output'];
  /** S21. Регистрация на проект (индивидуальный, групповой, стажировка) */
  registerForProject: Scalars['Boolean']['output'];
  /** S21. Запуск повторной попытки выполнения экзамена и экзаменационного теста */
  retryExam: Scalars['Boolean']['output'];
  /**
   * S21. Запуск повторной попытки выполнения проекта (стажировка, индивидуальный, групповой).
   * Возвращает ссылку на проект в GitLab только для стажировки, в остальных случаях null.
   */
  retryProject: Scalars['Boolean']['output'];
  /** S21. Старт проекта */
  startProject: Scalars['Boolean']['output'];
  /** S21. Капитуляция с экзаменационного модуля или теста */
  surrenderFromExam: Scalars['Boolean']['output'];
  /** S21. Капитуляция с индивидуального или группового проекта */
  surrenderFromProject: Scalars['Boolean']['output'];
};


export type Sc21ProjectFlowMutationsFinishExamTaskArgs = {
  currentLevelId: Scalars['ID']['input'];
  examEventId: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
};


export type Sc21ProjectFlowMutationsFinishProjectArgs = {
  taskId: Scalars['ID']['input'];
};


export type Sc21ProjectFlowMutationsRegisterForExamArgs = {
  goalId: Scalars['ID']['input'];
};


export type Sc21ProjectFlowMutationsRegisterForProjectArgs = {
  goalId: Scalars['ID']['input'];
};


export type Sc21ProjectFlowMutationsRetryExamArgs = {
  goalId: Scalars['ID']['input'];
};


export type Sc21ProjectFlowMutationsRetryProjectArgs = {
  taskId: Scalars['ID']['input'];
};


export type Sc21ProjectFlowMutationsStartProjectArgs = {
  goalId: Scalars['ID']['input'];
};


export type Sc21ProjectFlowMutationsSurrenderFromExamArgs = {
  examEventId?: InputMaybe<Scalars['ID']['input']>;
  goalId: Scalars['ID']['input'];
  skillId?: InputMaybe<Scalars['ID']['input']>;
  taskId?: InputMaybe<Scalars['ID']['input']>;
};


export type Sc21ProjectFlowMutationsSurrenderFromProjectArgs = {
  taskId: Scalars['ID']['input'];
};

export type Sc21StudentTaskCheckMutations = {
  __typename?: 'SC21StudentTaskCheckMutations';
  /** S21. Включить онлайн p2p проверку для существующей записи на проверку */
  enableOnlineP2pCheck: CalendarBooking;
  /** S21. Записать ошибку сохранения файла решения задания */
  markFileSolutionFailedToUpload: StudyProcessFile;
  /** S21. Предварительно загружаем файлы решения, ставим им статус ожидания загрузки */
  markFileSolutionPending: Array<StudyProcessFile>;
  /** S21. Пользователь отменил загрузку файла решения задания */
  markFileSolutionUploadCancelled: StudyProcessFile;
  /**
   * S21. Сохранить файл решения задания
   * @deprecated Field no longer supported
   */
  markFileSolutionUploaded: Array<StudyProcessFile>;
  /** S21. Обновление статуса */
  markFileSolutionUploadedStatus: StudyProcessFile;
  /** S21. Сохранить комментарий к ответу студента, для задания с платформенным решением */
  saveSolutionComment: StudentAnswerComment;
  /** S21. Сохранить результат опроса у студента */
  saveStudentFeedbackResults: Scalars['Boolean']['output'];
};


export type Sc21StudentTaskCheckMutationsEnableOnlineP2pCheckArgs = {
  bookingId: Scalars['ID']['input'];
};


export type Sc21StudentTaskCheckMutationsMarkFileSolutionFailedToUploadArgs = {
  errorMessage: Scalars['String']['input'];
  studyProcessFileId: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
};


export type Sc21StudentTaskCheckMutationsMarkFileSolutionPendingArgs = {
  initialFileEvents: Array<StudyProcessFileInitialInput>;
  taskId: Scalars['ID']['input'];
};


export type Sc21StudentTaskCheckMutationsMarkFileSolutionUploadCancelledArgs = {
  studyProcessFileId: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
};


export type Sc21StudentTaskCheckMutationsMarkFileSolutionUploadedArgs = {
  fileUploadEvents: Array<StudyProcessFileUploadInput>;
  taskId: Scalars['ID']['input'];
};


export type Sc21StudentTaskCheckMutationsMarkFileSolutionUploadedStatusArgs = {
  studyProcessFileIds: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
};


export type Sc21StudentTaskCheckMutationsSaveSolutionCommentArgs = {
  comment: Scalars['String']['input'];
  taskId: Scalars['ID']['input'];
};


export type Sc21StudentTaskCheckMutationsSaveStudentFeedbackResultsArgs = {
  studentFeedbackId: Scalars['ID']['input'];
  studentFeedbackResults: Array<StudentFeedbackResultInput>;
};

export type Sc21StudentTaskCheckQueries = {
  __typename?: 'SC21StudentTaskCheckQueries';
  /** S21. Получить все незавершенные опросы у студента для попапа */
  getAllInCompletedStudentFeedbackPopup: Array<StudentFeedbackPopup>;
  /** S21. Получить информацию о текущем загруженном решении студента по заданию, для заданий с платформенной загрузкой решения */
  getPlatfSolutionInfo?: Maybe<PlatfSolutionInfo>;
  /** S21. Получить идентификатор группы доступа к файлам по идентификатору ответа студента */
  getProjectAccessGroupIdByStudentAnswerId: Scalars['ID']['output'];
  /** S21. Получить опрос студента */
  getStudentFeedbackById: StudentFeedback;
  /** S21. Получить тип загружаемого решения задания */
  getTaskSolutionType: TaskSolutionTypeEnum;
  /** S21. Получить видео в незавершенном статусе для переданного чеклиста, если есть */
  getUploadedAndNotConfirmedVideos: Array<OnlineReviewVideo>;
  /** S21. Доступен ли Open Api */
  isOpenApiAllowed: Scalars['Boolean']['output'];
};


export type Sc21StudentTaskCheckQueriesGetPlatfSolutionInfoArgs = {
  studentGoalAttemptId: Scalars['ID']['input'];
};


export type Sc21StudentTaskCheckQueriesGetProjectAccessGroupIdByStudentAnswerIdArgs = {
  answerId: Scalars['ID']['input'];
};


export type Sc21StudentTaskCheckQueriesGetStudentFeedbackByIdArgs = {
  studentFeedbackId: Scalars['ID']['input'];
};


export type Sc21StudentTaskCheckQueriesGetTaskSolutionTypeArgs = {
  taskId: Scalars['ID']['input'];
};


export type Sc21StudentTaskCheckQueriesGetUploadedAndNotConfirmedVideosArgs = {
  filledChecklistId: Scalars['ID']['input'];
};

/** Все школы (безопасные, без доп.инфы) */
export type SafeSchool = {
  __typename?: 'SafeSchool';
  /** Адрес */
  address: Scalars['String']['output'];
  fullName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** Идентификатор */
  identifier: Scalars['String']['output'];
  logo?: Maybe<Scalars['String']['output']>;
  /** Идентификатор иерархии орг.единицы */
  organizationHierarchyTypeId: Scalars['ID']['output'];
  /** Тип учреждения */
  organizationType: Scalars['String']['output'];
  /** Идентификатор типа учреждения */
  organizationTypeId: Scalars['ID']['output'];
  region: Region;
  shortName: Scalars['String']['output'];
};

/** Настройки распродажи CRP */
export type SaleSettingCrp = {
  __typename?: 'SaleSettingCRP';
  /** Флаг автоматической настройки */
  autotune: Scalars['Boolean']['output'];
  /** Количество CRP в невозвратном пуле для завершения распродажи */
  irrevocableCRPCountToFinishSale: Scalars['Int']['output'];
  /** Количество CRP в невозвратном пуле для инициации распродажи */
  irrevocableCRPCountToStartSale: Scalars['Int']['output'];
  /** Дата начала распродажи (проставляется в момент инициации распродажи) */
  saleStartTime?: Maybe<Scalars['DateTime']['output']>;
  /** Количество CRP в невозвратном пуле параллели */
  stageIrrevocableCRPCount: Scalars['Int']['output'];
  /** Идентификатор статуса распродажи */
  statusId: Scalars['Int']['output'];
};

/** Настройки распродажи PRP */
export type SaleSettingPrp = {
  __typename?: 'SaleSettingPRP';
  /** Флаг автоматической настройки */
  autotune: Scalars['Boolean']['output'];
  /** Количество PRP в невозвратном пуле для завершения распродажи */
  irrevocablePRPCountToFinishSale: Scalars['Int']['output'];
  /** Количество PRP в невозвратном пуле для инициации распродажи */
  irrevocablePRPCountToStartSale: Scalars['Int']['output'];
  /** Дата начала распродажи (проставляется в момент инициации распродажи) */
  saleStartTime?: Maybe<Scalars['DateTime']['output']>;
  /** Количество PRP в невозвратном пуле параллели */
  stageIrrevocablePRPCount: Scalars['Int']['output'];
  /** Идентификатор cтатуса распродажи */
  statusId: Scalars['Int']['output'];
};

/** Информация о выполненной мутации */
export type SaveAnswerResponse = {
  __typename?: 'SaveAnswerResponse';
  /**
   * Информация о текущем состоянии Закрывающего теста,
   * с которым связан данный ответ на Задание (если ответ был отправлен в рамках некоторого закрывающего теста)
   */
  goalLevelTestProgressInfo?: Maybe<AnswerRelatedGoalLevelTestProgressInfo>;
  /** Информация о текущем состоянии Домашней Работы, с которой связан данный ответ на Задание (если ответ был отправлен в рамках некоторой Домашней Работы) */
  homeworkProgressInfo?: Maybe<AnswerRelatedHomeworkProgressInfo>;
  /** информация о прогрессе уроков, в которые входит задание, на которое был отправлен ответ */
  lessonProgressInfos?: Maybe<Array<Maybe<StudentLessonProgressInfo>>>;
  /** Информация о текущем состоянии связанной с Заданием Персональной Цели (если есть) */
  personalObjectiveProgressInfo?: Maybe<PersonalObjectiveProgressInfo>;
  /** Полная информация по Заданию в контексте Студента */
  studentTaskInfo: StudentTaskInfo;
};

export type SaveJournalFinalStudentMark = {
  __typename?: 'SaveJournalFinalStudentMark';
  periodMark?: Maybe<JournalFinalStudentMark>;
  yearMark?: Maybe<JournalFinalStudentMark>;
};

export type SaveJournalStudentMarkResponse = {
  __typename?: 'SaveJournalStudentMarkResponse';
  changedFinalMark?: Maybe<JournalFinalStudentMark>;
  mark: JournalStudentMark;
};

/** Результат сохранения настройки */
export type SaveSchoolConfigurationResponse = {
  __typename?: 'SaveSchoolConfigurationResponse';
  /** Данные о сохраненной настройке */
  data?: Maybe<SchoolSelfConfigurationProperty>;
  /** Описание ошибки, возникшей в ходе выполнения запроса */
  error?: Maybe<SchoolSelfConfigurationError>;
  /** Признак успешности выполнения запроса */
  isSuccess: Scalars['Boolean']['output'];
};

/** Входная модель сохранения значения настройки для школы */
export type SaveSchoolSelfConfigurationPropertyValueInput = {
  /** Код настройки */
  propertyCode: Scalars['String']['input'];
  /** Значение настройки */
  value: Scalars['String']['input'];
};

/** Информация о выполненной мутации */
export type SaveStudentAnswerResponse = {
  __typename?: 'SaveStudentAnswerResponse';
  /**
   * Информация о текущем состоянии Закрывающего теста,
   * с которым связан данный ответ на Задание (если ответ был отправлен в рамках некоторого закрывающего теста)
   */
  goalLevelTestProgressInfo?: Maybe<AnswerRelatedGoalLevelTestProgressInfo>;
  /** Информация о текущем состоянии Домашней Работы, с которой связан данный ответ на Задание (если ответ был отправлен в рамках некоторой Домашней Работы) */
  homeworkProgressInfo?: Maybe<AnswerRelatedHomeworkProgressInfo>;
  /** информация о прогрессе уроков, в которые входит задание, на которое был отправлен ответ */
  lessonProgressInfos?: Maybe<Array<Maybe<StudentLessonProgressInfo>>>;
  /** Информация о текущем состоянии связанной с Заданием Персональной Цели (если есть) */
  personalObjectiveProgressInfo?: Maybe<PersonalObjectiveProgressInfo>;
  /** Полная информация по Заданию в контексте Студента */
  studentTaskInfo: StudentTaskInfo;
};

export type SaveStudentGoalLevelTestAnswerResponse = {
  __typename?: 'SaveStudentGoalLevelTestAnswerResponse';
  attemptOldTask?: Maybe<GoalLevelTestAttemptOldTask>;
  attemptStatus: StudentGoalLevelTestAttemptStatus;
  taskStatus: TaskStatusEnum;
  testStatus: StudentGoalLevelTestStatus;
  widgets?: Maybe<Array<GoalLevelTestAttemptTaskWidget>>;
};

/** Данные для создания предупреждений при переводе учеников между группами по предметам */
export type SaveSubjectGroupStudentsMessage = {
  __typename?: 'SaveSubjectGroupStudentsMessage';
  stageGroupName: Scalars['String']['output'];
  stageSubjectGroupName: Scalars['String']['output'];
  studentFullName: Scalars['String']['output'];
};

/** Использование Сберкласс */
export type SberClassUsage = {
  __typename?: 'SberClassUsage';
  activeCount: Scalars['Int']['output'];
  activeCountPercent: Scalars['Int']['output'];
  activeEduCount: Scalars['Int']['output'];
  activeEduCountPercent: Scalars['Int']['output'];
  activePmoCount: Scalars['Int']['output'];
  activePmoCountPercent: Scalars['Int']['output'];
  schoolCount: Scalars['Int']['output'];
  totalCount: Scalars['Int']['output'];
  totalCountPercent: Scalars['Int']['output'];
  totalEduCount: Scalars['Int']['output'];
  totalEduCountPercent: Scalars['Int']['output'];
  totalPmoCount: Scalars['Int']['output'];
  totalPmoCountPercent: Scalars['Int']['output'];
};

/** Расписание */
export type Schedule = {
  __typename?: 'Schedule';
  /** Классные Контрольные Работы, назначенные на диапазон дат; используются учителем */
  classSubjectControlWorks: Array<ClassSubjectControlWork>;
  /** События в рассписании */
  events: Array<Event>;
  /** Индикатор наличия загруженного расписания для данной школы и учебного года */
  eventsUploaded: Scalars['Boolean']['output'];
  /** Дата и время начала периода расписания */
  from: Scalars['DateTime']['output'];
  /** Идентификатор расписания */
  id: Scalars['ID']['output'];
  /** Персональные Контрольные Работы, назначенные на диапазон дат */
  personalControlWorks: Array<PersonalControlWork>;
  /** Дата и время окончания периода расписания */
  to: Scalars['DateTime']['output'];
  total: Scalars['Float']['output'];
};

/** Ограничение планировщика */
export type ScheduleConstraint = {
  __typename?: 'ScheduleConstraint';
  /** дефолтное значение веса штрафа */
  defaultPenaltyValue: Scalars['Int']['output'];
  /** код правила */
  id: Scalars['String']['output'];
  /** название правила */
  name: Scalars['String']['output'];
};

/** Ограничение планировщика */
export type ScheduleConstraintInput = {
  /** код правила */
  id: Scalars['String']['input'];
  /** дефолтное значение веса штрафа */
  weight: Scalars['Int']['input'];
};

export enum ScheduleCron {
  /** Каждый учебный год */
  EveryAcademicYear = 'EVERY_ACADEMIC_YEAR',
  /** Каждый день */
  EveryDay = 'EVERY_DAY',
  /** Каждый месяц */
  EveryMonth = 'EVERY_MONTH',
  /** Каждый квартал */
  EveryQuarter = 'EVERY_QUARTER',
  /** Каждую неделю */
  EveryWeek = 'EVERY_WEEK',
  /** Каждый календарный год */
  EveryYear = 'EVERY_YEAR'
}

export type ScheduleEventsVisitJournalInfo = {
  __typename?: 'ScheduleEventsVisitJournalInfo';
  /** Дата и время завершения события */
  end: Scalars['DateTime']['output'];
  /** ИД модуля к которому относится событие(урок) */
  goalId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор события(timetableId) */
  id: Scalars['ID']['output'];
  /** Дата и время начала события */
  start: Scalars['DateTime']['output'];
  /** Предмет (пример: Биология) */
  subjectId: Scalars['ID']['output'];
  /** Отметка о посещении Учеником события */
  visitJournalValue?: Maybe<VisitJournalCellValueEnum>;
};

export type ScheduleEventsVisitJournalInfoResponse = {
  __typename?: 'ScheduleEventsVisitJournalInfoResponse';
  eventInfo: Array<ScheduleEventsVisitJournalInfo>;
};

export type ScheduledStudentTask = {
  __typename?: 'ScheduledStudentTask';
  deadline: Scalars['DateTime']['output'];
  goalId: Scalars['Int']['output'];
  goalName: Scalars['String']['output'];
  subjectName: Scalars['String']['output'];
  taskId: Scalars['Int']['output'];
  taskName: Scalars['String']['output'];
};

export type School = {
  __typename?: 'School';
  active: Scalars['Boolean']['output'];
  address: Scalars['String']['output'];
  /** Draft-пользователи с бизнес-ролью БА, которых пригласили на платформу */
  businessAdminUserDrafts: Array<UserDraft>;
  /**
   * Активные БА школы V1
   * @deprecated use businessAdminsV2 field
   */
  businessAdmins?: Maybe<Array<UserNameView>>;
  /** Активные БА школы V2 */
  businessAdminsV2?: Maybe<Array<BusinessAdminView>>;
  /** Адрес электронной почты школы */
  email?: Maybe<Scalars['String']['output']>;
  /** Урл экзаменационного приложения школы */
  examUrl?: Maybe<Scalars['String']['output']>;
  fullName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  identifier: Scalars['String']['output'];
  individualPlan?: Maybe<Scalars['Boolean']['output']>;
  /** ИНН */
  inn?: Maybe<Scalars['String']['output']>;
  /** Статус заполнения обязательных данных для начала учебного процесса (здания, кабинеты, звонки, ученики, учителя, классы) */
  isMandatoryDataFilled: Scalars['Boolean']['output'];
  logo?: Maybe<Scalars['String']['output']>;
  organizationType: Scalars['String']['output'];
  region: Region;
  shortName: Scalars['String']['output'];
  /** Draft-пользователи с бизнес-ролью STUDENT, которых пригласили на платформу */
  studentUserDrafts?: Maybe<Array<UserDraft>>;
  studyStepSubjects: Array<StudyStepSubject>;
  /** Теги */
  tags: Array<Scalars['String']['output']>;
  /** Конфигурация чтения / записи */
  tenantConfiguration: TenantConfiguration;
  timeZoneId: Scalars['String']['output'];
};

export type School21Mutations = {
  __typename?: 'School21Mutations';
  /** Модератор одобряет заявку на расформирование команды */
  acceptTeamDisbandRequest: DisbandRequestStatus;
  /** Заблокировать пользователя */
  blockUser: Scalars['Boolean']['output'];
  /**
   * Кидает ивенты о необходимости блокировки студентов определенной группы по предмету и отмену их штрафов
   * @deprecated Will be deleted later
   */
  blockUsersOfStageSubjectGroup: Scalars['Boolean']['output'];
  /**
   * очистка всех сохраненных связей для кампуса и его активация
   * @deprecated использовать clearMulticampusSchoolStageDependenciesAndActivate
   */
  clearMulticampusSchoolStageDependencies?: Maybe<Scalars['Boolean']['output']>;
  /** очистка всех сохраненных связей для кампуса и его активация */
  clearMulticampusSchoolStageDependenciesAndActivate?: Maybe<Scalars['Boolean']['output']>;
  /** S21. Удаление свободного времени для проверки */
  deleteEvent: Scalars['Boolean']['output'];
  expelStudent: ExpelResult;
  /** Отчислить студентов с основы */
  expelStudents?: Maybe<ExpelResult>;
  /** S21. Принудительное создание приватного репозитория экзаменационного задания */
  forcedCreateExamPrivateGitlabProject: Scalars['Boolean']['output'];
  /** S21. Принудительная синхронизация командных настроек для групповых проектов в аланах на параллель, класс и в локальных курсах */
  forcedTeamSettingsSynchronization: Scalars['Boolean']['output'];
  freezeStudent: ExpelResult;
  /** Заморозить студентов */
  freezeStudents?: Maybe<ExpelResult>;
  /** S21. Логирование ошибок Centrifugo, которые получает Front */
  logCentrifugoError: Scalars['Boolean']['output'];
  /** S21. Ручное изменение результата прохождения экзамена по указанной попытке */
  manualChangeExamResult: Scalars['Boolean']['output'];
  /** Добавляет видеозапись онлайн-проверки в статусе NOT_CONFIRMED */
  markFilesPending: Array<OnlineReviewVideo>;
  /** Ошибка загрузки видеозаписи онлайн-проверки */
  markP2pCheckVideoFailedToUpload: OnlineReviewVideo;
  /** Пользователь отменил загрузку видео */
  markP2pCheckVideoUploadCancelled: OnlineReviewVideo;
  /** Видеозапись онлайн-проверки загружена */
  markP2pCheckVideoUploaded: OnlineReviewVideo;
  /** Пометить указанные заявки на расформирование команд, как прочитанные */
  markingReadTeamDisbandRequests: Scalars['Boolean']['output'];
  reinstateStudent: ExpelResult;
  /** Восстановить студентов */
  reinstateStudents?: Maybe<ExpelResult>;
  /** Модератор отклоняет заявку на расформирование команды */
  rejectTeamDisbandRequest: DisbandRequestStatus;
  /** S21. Откат попытки выполнения экзамена/теста студентом */
  rollbackExamAttempt: Scalars['Boolean']['output'];
  /** сохранение связей между кампусами для выбранной параллели */
  saveMulticampusSchoolStageDependencies?: Maybe<Scalars['Boolean']['output']>;
  /** сохранение настроек ультикампусности для школы (вкл/выкл) */
  saveMulticampusSchoolStatus?: Maybe<Scalars['Boolean']['output']>;
  /** S21 сохранение/изменение пользователя */
  saveS21User: User;
  /** сохранение кампуса */
  saveSchool: ValidatedSchool;
  /** S21. Сохранить настройки страниц экзаменационного теста */
  saveSettingsExamTestPages: Array<SettingsExamTestPageModel>;
  /** S21. Сохранить дату и время завершения обучения в классе */
  saveStageGroupFinishDate: StageGroupFinishDate;
  /** Сохранение дефолтных значений дополнительных атрибутов задания при его создании (когда заполнено только поле "Название задания") */
  saveTaskAdditionalAttributesDefaultValues: CheckSequenceSettings;
  /** Добавление признака успешной загрузки видеозаписи проверки для уже заполненного чек-листа */
  submitFilledChecklistRecording: FilledChecklist;
  /** S21. Перевод студентов из класса в класс */
  transferStudentsToNewStageGroup: TransferResult;
  /** Разблокировать пользователя */
  unblockUser: Scalars['Boolean']['output'];
  /** Разморозить студентов */
  unfreezeStudents?: Maybe<ExpelResult>;
};


export type School21MutationsAcceptTeamDisbandRequestArgs = {
  teamDisbandRequestId: Scalars['ID']['input'];
};


export type School21MutationsBlockUserArgs = {
  userId: Scalars['UUID']['input'];
};


export type School21MutationsBlockUsersOfStageSubjectGroupArgs = {
  stageSubjectGroupId: Scalars['ID']['input'];
};


export type School21MutationsClearMulticampusSchoolStageDependenciesArgs = {
  schoolId: Scalars['UUID']['input'];
};


export type School21MutationsClearMulticampusSchoolStageDependenciesAndActivateArgs = {
  schoolId: Scalars['UUID']['input'];
};


export type School21MutationsDeleteEventArgs = {
  eventId: Scalars['ID']['input'];
};


export type School21MutationsExpelStudentArgs = {
  student: Scalars['UUID']['input'];
};


export type School21MutationsExpelStudentsArgs = {
  students: Array<Scalars['UUID']['input']>;
};


export type School21MutationsForcedCreateExamPrivateGitlabProjectArgs = {
  examEventId: Scalars['ID']['input'];
  gitlabUserAccessLevel: GitlabUserAccessLevel;
  studentId: Scalars['UUID']['input'];
  taskId: Scalars['ID']['input'];
};


export type School21MutationsForcedTeamSettingsSynchronizationArgs = {
  learningEntityGroupType?: InputMaybe<LearningEntityGroupType>;
};


export type School21MutationsFreezeStudentArgs = {
  student: Scalars['UUID']['input'];
};


export type School21MutationsFreezeStudentsArgs = {
  students: Array<Scalars['UUID']['input']>;
};


export type School21MutationsLogCentrifugoErrorArgs = {
  jsonMessage: Scalars['String']['input'];
};


export type School21MutationsManualChangeExamResultArgs = {
  finalPercentage: Scalars['Int']['input'];
  studentGoalAttemptId?: InputMaybe<Scalars['ID']['input']>;
  studentGoalId: Scalars['ID']['input'];
};


export type School21MutationsMarkFilesPendingArgs = {
  filledChecklistId: Scalars['ID']['input'];
  pendingFiles: Array<StudyProcessFileInitialInput>;
};


export type School21MutationsMarkP2pCheckVideoFailedToUploadArgs = {
  errorMessage: Scalars['String']['input'];
  filledChecklistId: Scalars['ID']['input'];
  onlineReviewId: Scalars['ID']['input'];
};


export type School21MutationsMarkP2pCheckVideoUploadCancelledArgs = {
  filledChecklistId: Scalars['ID']['input'];
  onlineReviewId: Scalars['ID']['input'];
};


export type School21MutationsMarkP2pCheckVideoUploadedArgs = {
  filledChecklistId: Scalars['ID']['input'];
  onlineReviewId: Scalars['ID']['input'];
};


export type School21MutationsMarkingReadTeamDisbandRequestsArgs = {
  teamDisbandRequestIds: Array<Scalars['Int']['input']>;
};


export type School21MutationsReinstateStudentArgs = {
  reinstateStudent: ReinstateStudentInput;
};


export type School21MutationsReinstateStudentsArgs = {
  reinstateStudents: Array<ReinstateStudentInput>;
};


export type School21MutationsRejectTeamDisbandRequestArgs = {
  teamDisbandRequestId: Scalars['ID']['input'];
};


export type School21MutationsRollbackExamAttemptArgs = {
  studentGoalId: Scalars['ID']['input'];
};


export type School21MutationsSaveMulticampusSchoolStageDependenciesArgs = {
  schoolId: Scalars['UUID']['input'];
  schoolIds: Array<Scalars['UUID']['input']>;
  stageId: Scalars['ID']['input'];
};


export type School21MutationsSaveMulticampusSchoolStatusArgs = {
  isActive: Scalars['Boolean']['input'];
  schoolId: Scalars['UUID']['input'];
};


export type School21MutationsSaveS21UserArgs = {
  user: UserInput;
};


export type School21MutationsSaveSchoolArgs = {
  school: S21SchoolInput;
  schoolId?: InputMaybe<Scalars['ID']['input']>;
};


export type School21MutationsSaveSettingsExamTestPagesArgs = {
  settingsExamTestPages: SettingsExamTestPagesInput;
};


export type School21MutationsSaveStageGroupFinishDateArgs = {
  finishDate?: InputMaybe<Scalars['DateTime']['input']>;
  stageGroupId: Scalars['ID']['input'];
};


export type School21MutationsSaveTaskAdditionalAttributesDefaultValuesArgs = {
  taskId: Scalars['ID']['input'];
};


export type School21MutationsSubmitFilledChecklistRecordingArgs = {
  filledChecklistId: Scalars['ID']['input'];
};


export type School21MutationsTransferStudentsToNewStageGroupArgs = {
  newStageGroupId: Scalars['ID']['input'];
  oldStageGroupId: Scalars['ID']['input'];
  stageSubjectGroupIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  studentIds: Array<Scalars['UUID']['input']>;
};


export type School21MutationsUnblockUserArgs = {
  userId: Scalars['UUID']['input'];
};


export type School21MutationsUnfreezeStudentsArgs = {
  students: Array<Scalars['UUID']['input']>;
};

export type School21Queries = {
  __typename?: 'School21Queries';
  /** S21.Подсчитывает показатели настроек (опыт, вес) страниц экзаменационного теста */
  calcIndicatorsSettingExamTestPage: Array<IndicatorsSettingExamTestPageModel>;
  /** S21. Сделать валидацию названия задания в Gitlab */
  checkIfLegalTaskNameToCreateGitlabProject: Scalars['Boolean']['output'];
  /** S21. Сравнение плана на класс с планом на параллель */
  compareClassPlanAndStagePlan: Scalars['Boolean']['output'];
  /** S21. Сравнение локального курса с глобальным курсом */
  compareLocalCourseAndGlobalCourse: Scalars['Boolean']['output'];
  /** S21. Сравнение локального курса с глобальным курсом, по модулям и конструкторам */
  compareLocalCourseAndGlobalCourseAndConstructors: LocalCourseCompareGlobalCourseResult;
  /** S21. Сравнение плана на параллель с глобальным планом */
  compareStagePlanAndGlobalPlan: Scalars['Boolean']['output'];
  /** S21. Генерация JWT токена для подключения к Centrifugo */
  generateJwtTokenForCentrifugo: Scalars['String']['output'];
  /** Возвращает список всех активных кампусов (уровень EDUCATIONAL_INSTITUTION(3000)) в пределах Школы 21. */
  getActiveS21Campuses: Array<SafeSchool>;
  /** Получение списка типов мероприятий */
  getActivityTypes: Array<ActivityType>;
  /** Получение информации о настройках распродаж по всем школам */
  getAllSaleSettings: Array<RpSaleSetting>;
  /** S21 получить список профилей, доступных для назначения на указанную орг.единицу и роль */
  getAvailableFroleSetsWithRole: Array<FunctionalRoleSet>;
  /** S21. Публичный профиль студента. Получение ссылки на автар по UserId */
  getAvatarByUserId?: Maybe<Scalars['String']['output']>;
  /** S21. Публичный профиль студента. Получение достижений для публичного профиля */
  getBadgesPublicProfile: Array<UserBadgeAward>;
  /** S21. Публичный профиль студента. Получение всех доступных достижений пользователя, включая не полученные */
  getBadgesWithFakePublicProfile: Array<UserBadgeAward>;
  /** Получение публичного профиля пользователя по userID */
  getBasePublicProfile: BasePublicProfile;
  /** S21. Получить список попыток записей проверяемых по конкретному этапу */
  getBookingAttemptVerifiableByStage: Array<BookingAttemptVerifiable>;
  /** S21. Получить кандидатов на место проверяющих по записи */
  getBookingAttemptsVerifier: Array<BookingAttemptVerifier>;
  /** S21. Хлебные крошки в админке */
  getBreadCrumbs?: Maybe<BreadCrumbsPlanItem>;
  /** S21. Публичный профиль студента. Возращает здания с кабинетами. Для текущего студента, если schoolId не передан */
  getBuildingsBySchoolId: Array<Building>;
  /** S21. Публичный профиль студента. Получение класса в котором авторизован студент по его логину */
  getClassRoomByLogin?: Maybe<ClassRoom>;
  /** S21. Возвращает текущие Группы по Предмету Учителя по идентификатору Предмета и идентифкатору параллели */
  getClassSubjectsBySubjectIdAndStageId: Array<ClassSubject>;
  /** S21. Публичный профиль студента. Получение коалиции по UserId */
  getCoalitionPublicProfile?: Maybe<CoalitionMember>;
  /** S21. Получить общую статистику по слотам студента */
  getCommonP2pStatistic: P2pCommonStatistic;
  getCourseGoalsExperience: Array<CourseGoalExperience>;
  /** Получение дедлайнов по фильтрам */
  getDeadlinesForStudents: Array<Maybe<DeadlineStudentInfo>>;
  /** Получение количество дедлайнов по фильтрам */
  getDeadlinesForStudentsCount: Scalars['Int']['output'];
  /**
   * S21. Публичный профиль студента. Информация об отчисленном/завершившем обучение студенте
   *  Может быть null, если студент не отчислен
   */
  getDismissInfoByStudentId?: Maybe<StudentDismissInfo>;
  /** Получение пользователей, исключенных из определенной параллели */
  getDismissedStudentsFromStage: Array<Maybe<User>>;
  /** Получение количества пользователей, исключенных из определенной параллели */
  getDismissedStudentsFromStageCount: Scalars['Int']['output'];
  /** S21. Публичный профиль студента. Получение email по UserId */
  getEmailbyUserId?: Maybe<Scalars['String']['output']>;
  /** S21. Получение отчета по проведенным мероприятиям */
  getEventsReport: ReportExcelFile;
  /** S21. Публичный профиль студента. Получение опыта по UserId */
  getExperiencePublicProfile?: Maybe<UserExperience>;
  /** S21. Публичный профиль студента. Получение списка завершенных проектов с датами завершения */
  getFinishedGoalsPublicProfile: Array<GoalFinished>;
  /** Получение статистики по попыткам студента на модуле для студента */
  getGoalAttemptStatisticByStudent?: Maybe<Array<Maybe<StudentGoalAttemptStatistic>>>;
  /** S21. Публичный профиль студента. Получение информации по ретраям проекта */
  getGoalRetryInfo: StudentGoalRetryInfo;
  /** S21. Возвращает список источников проектов по типу источника */
  getGoalSources: Array<GoalSourceShortInfo>;
  /** S21. Публичный профиль студента. получение названия проекта */
  getGoalTitleById: Scalars['String']['output'];
  /** S21. Возвращает список проектов по типу и Id источника */
  getGoalsByGoalSourceId: Array<GoalShortInfo>;
  /** S21. Получить данные для тепловой карты по статистике таймслотов студентов школы */
  getHeatMapCampusCalendarTimeSlot: P2pHeatMapWithMean;
  /** S21. Получить данные для тепловой карты по статистике событий студента */
  getHeatMapEventsStudentStatistic: P2pHeatMapWithMedian;
  /** Получение всех языков, которые уже опубликованы для текущей активной контент версии */
  getImportedLanguagesForCurrentVersion: Array<Maybe<Scalars['String']['output']>>;
  /** Получение всех языков, которые уже опубликованы для текущей активной контент версии для код ревью по студенческому голу */
  getImportedLanguagesForCurrentVersionByStudentGoalId: Array<Maybe<Scalars['String']['output']>>;
  /** S21. получение ссылки на приватный студенческий Gitlab проект по логину студента и идентификатору задачи */
  getLinkToPrivateStudentGitlabProjectByStudentLoginAndTaskId: GitlabLink;
  /** S21. Публичный профиль студента. Получение персонализированного учебного модуля */
  getModuleById: StudentModule;
  /** S21. Публичный профиль студента. Получение полной информации на странице проекта */
  getModuleCoverInformation?: Maybe<ModuleCoverInformation>;
  /** получение настроек мультикампусности */
  getMulticampusSettings: Array<MulticampusSetting>;
  /** S21. Получить настройки для шторки с настройками восстановления мультикампусности для определенной школы */
  getMulticampusSettingsForRecovery: Array<StageMulticampusSettingForRecovery>;
  /** S21. Публичный профиль студента. Получение информации по проверкам проекта */
  getP2PChecksInfo?: Maybe<P2PChecksInfo>;
  /** Получение количества студентов в классе в статусах Active / Inactive */
  getParticipantsStatus: UsersStatusCount;
  /** S21. Публичный профиль студента. Получение информации о проверках по проекту */
  getProjectAttemptEvaluationsInfo: Array<ProjectAttemptEvaluationsInfo>;
  /** S21. Публичный профиль студента. Получение информации о проверках по проекту */
  getProjectAttemptEvaluationsInfo_V1: Array<ProjectAttemptEvaluationsInfo_V1>;
  /** S21. Получить список доступных статусов проекта */
  getProjectStatuses: Array<StudentProjectStatus>;
  /** Получение команды, в которой состоит пользователь, выполняющий групповой проект */
  getProjectTeamWithMembers?: Maybe<ProjectTeamWithMembers>;
  /** В классе (в плане или назначенных на класс курсах) есть проекты с дедлайнами */
  getS21ClassHasDeadline: Scalars['Boolean']['output'];
  /**
   * В плане на класс есть проекты с дедлайнами
   * @deprecated use getS21ClassHasDeadline
   */
  getS21ClassPlanHasDeadline: Scalars['Boolean']['output'];
  /** S21. Получить список заявок на расформирование команд на рассмотрении у пользователя */
  getS21CurrentTeamDisbandRequests: Array<CurrentTeamDisbandRequestInfo>;
  /** S21. Получить список обработанных заявок на расформирование команд */
  getS21ProcessedTeamDisbandRequests: Array<ProcessedTeamDisbandRequestInfo>;
  /** S21. Получить число необработанных модератором команд запросов */
  getS21RequestsCountForTeamModerator: Scalars['Int']['output'];
  /** S21. Возвращает план на параллель по идентификатору c групповыми проектами */
  getS21StageGroupPlan: S21StagePlan;
  /** S21. Возвращает план на параллель по идентификатору */
  getS21StagePlan: S21StagePlan;
  /** S21. Возвращает все существующие планы на параллель */
  getS21StagePlans: Array<S21StagePlan>;
  /** S21. Получить список участников команды */
  getS21TeamMembersByTeam: Array<TeamMember>;
  /** Получить текущий процент прогресса распродаж */
  getSaleProgressPercentages: Array<Maybe<RpSaleProgress>>;
  /** Получение информации о настройках распродаж в конкретной школе */
  getSaleSettingsBySchoolId: Array<RpSaleSetting>;
  /**
   * S21. Публичный профиль студента. Получение SchoolId по Login пользователя, если нет schoolId - EMPTY_UUID
   * @deprecated использовать getStudentByLogin
   */
  getSchoolIdByLogin?: Maybe<Scalars['UUID']['output']>;
  /** S21. Получить список всех студентов школы, которой принадлежит бизнес-админ */
  getSchoolStudents: Array<StudentWithLoginModel>;
  /** S21. Получить настройки страниц экзаменационного теста */
  getSettingsExamTestPages: Array<SettingsExamTestPageModel>;
  /** S21. Публичный профиль студента. Получение максимального значения софт-скилов */
  getSoftSkillLimitByStudentId: SoftSkillLimit;
  /** Возвращает список навыков */
  getSoftSkillTypes: Array<SoftSkillType>;
  /** S21. Публичный профиль студента. Получение навыков для публичного профиля */
  getSoftSkillsByStudentId: Array<SoftSkillPower>;
  /** S21. Поиск одноклассников студента по параллели */
  getStageClassmates: Array<User>;
  /** S21. Публичный профиль студента. Получение волны (аналог stage_group_name) и формы обучения (аналог stage_name) по StudentId */
  getStageGroupS21PublicProfile?: Maybe<StageGroupS21>;
  /** S21. Получить список классов школы 21 по фильтрам Кампус/Параллель */
  getStageGroups?: Maybe<Array<Maybe<StageGroup>>>;
  /** S21. Получить список классов школы 21 по фильтрам Кампус/Параллель с дополнительными ограничениями по полномочиям текущего пользователя */
  getStageGroupsRestricted?: Maybe<Array<Maybe<StageGroup>>>;
  /** S21. Публичный профиль студента. Получение всех волн (аналог stage_group_name) и форм обучения (аналог stage_name) по StudentId */
  getStageGroupsS21PublicProfile?: Maybe<Array<Maybe<StageGroupS21>>>;
  /** S21. Получить статистику по алгоритму выбора проверяющего */
  getStatisticBookingAttempt: Array<BookingAttemptStatistic>;
  getStudentByLogin?: Maybe<StudentAttributes>;
  /** Получение попыток прохождения курса */
  getStudentCourseFinalScoreByLoginAndGoalId: StudentCourseFinalScore;
  /** S21. Получение финального результата за проект */
  getStudentGoalFinalScoreByLoginAndGoalId: StudentGoalFinalScore;
  /**
   * S21. Публичный профиль студента. Получение StudentId по Login пользователя, если нет studetnId - EMPTY_UUID
   * @deprecated использовать getStudentByLogin
   */
  getStudentIdByLogin?: Maybe<Scalars['UUID']['output']>;
  /** S21. Получить список всех групповых и индивидуальных проектов студента со статусами и датами получения статусов */
  getStudentProjects: Array<StudentProjectForBa>;
  /** S21. Публичный профиль студента. Получение всех проектов для публичного профиля по userId и stageGroupId */
  getStudentProjectsForPublicProfileByStageGroup: Array<Maybe<StudentItem>>;
  /** S21. Получить задание для студента по проекту */
  getTasksById: Array<StudentTask>;
  /** S21. Получить список комментариев к личным заявкам участников на расформирование команды */
  getUserDisbandRequestComments: Array<UserDisbandRequestComment>;
  /** S21. Публичный профиль студента. Получение UserId по Login пользователя */
  getUserIdByLogin?: Maybe<Scalars['UUID']['output']>;
  /** S21. получение активных ограничений студента */
  getUserRestrictions: Array<Maybe<UserRestriction>>;
  /** S21. получение активных ограничений пользователя по userId */
  getUserRestrictionsByUserIdAndSchoolId: Array<Maybe<UserRestriction>>;
  /** S21. Получение профилей студента по идентификаторам пользователя */
  getUsers?: Maybe<Array<S21StudentPublicProfileBasicInfo>>;
  /** S21. Публичный профиль студента. Получение рабочей станции за которой авторизован студент по идентификатору студента */
  getWorkstationByUserId?: Maybe<WorkstationModel>;
  /** S21. Запрос консистентности нескольких глобальных курсов */
  loadAllGlobalCoursesConsistencyInfos: Array<CourseConsistency>;
  /** получение информации по средней посещаемости за неделю/месяц */
  loadAverageLogtime: AverageLogtime;
  /** S21. Запрос консистентности курса */
  loadCourseConsistencyInfo: CourseConsistency;
  /** S21. Запрос консистентности глобального курса */
  loadGlobalCourseConsistencyInfo: CourseConsistency;
  /** S21. Запрос консистентности проекта */
  loadGoalConsistencyInfo: GoalConsistency;
  /** S21. Запрос отчета по времени выполнения проектов */
  loadProjectExecutionTimeS21Report: ReportExcelFile;
  /** @deprecated использовать loadProjectProgressReportV2 */
  loadProjectProgressReport: ReportExcelFile;
  /** S21. Запрос отчета по прогрессу за проект в Ш21 */
  loadProjectProgressReportV2: ReportExcelFile;
  /** S21. Запрос отчета по статистике PRP/CRP студентов */
  loadRpBalanceReport: ReportExcelFile;
  /** S21. Запрос на получение условий выполнения проекта для студента */
  loadStudentProjectExecutionConditions: Array<StudentEvaluationRuleGroup>;
  /** S21. Публичный профиль студента. Получение всех волн (аналог stage_group_name) и форм обучения (аналог stage_name) по StudentId */
  loadStudentStageGroups?: Maybe<Array<Maybe<StageGroupS21Student>>>;
  /** S21. Публичный профиль студента. Получение всех волн (аналог stage_group_name) и форм обучения (аналог stage_name) по userId и schoolId */
  loadStudentStageGroupsS21PublicProfile?: Maybe<Array<Maybe<StageGroupS21Student>>>;
  /** S21. Запрос отчета по успеваемости студентов */
  loadStudentsAcademicPerformanceS21Report: ReportExcelFile;
  /** S21. Запрос отчета по успеваемости абитуриентов */
  loadStudentsPerformanceS21Report: ReportExcelFile;
  /** S21. Запрос отчета по командам */
  loadStudentsTeamS21Report: ReportExcelFile;
  /** S21. Запрос отчета по командам */
  loadStudentsTeamS21ReportV2: ReportExcelFile;
};


export type School21QueriesCalcIndicatorsSettingExamTestPageArgs = {
  settingsExamTestPages: SettingsExamTestPagesInput;
};


export type School21QueriesCheckIfLegalTaskNameToCreateGitlabProjectArgs = {
  taskName: Scalars['String']['input'];
};


export type School21QueriesCompareClassPlanAndStagePlanArgs = {
  classPlanId: Scalars['ID']['input'];
};


export type School21QueriesCompareLocalCourseAndGlobalCourseArgs = {
  localCourseId: Scalars['ID']['input'];
};


export type School21QueriesCompareLocalCourseAndGlobalCourseAndConstructorsArgs = {
  localCourseId: Scalars['ID']['input'];
};


export type School21QueriesCompareStagePlanAndGlobalPlanArgs = {
  stagePlanId: Scalars['ID']['input'];
};


export type School21QueriesGetAvailableFroleSetsWithRoleArgs = {
  appicableRole: Roles;
};


export type School21QueriesGetAvatarByUserIdArgs = {
  userId: Scalars['UUID']['input'];
};


export type School21QueriesGetBadgesPublicProfileArgs = {
  userId: Scalars['UUID']['input'];
};


export type School21QueriesGetBadgesWithFakePublicProfileArgs = {
  userId?: InputMaybe<Scalars['UUID']['input']>;
};


export type School21QueriesGetBasePublicProfileArgs = {
  userId: Scalars['UUID']['input'];
};


export type School21QueriesGetBookingAttemptVerifiableByStageArgs = {
  end: Scalars['DateTime']['input'];
  paging?: InputMaybe<PagingInput>;
  stageEnum: SelectionStageEnum;
  start: Scalars['DateTime']['input'];
  userId: Scalars['UUID']['input'];
};


export type School21QueriesGetBookingAttemptsVerifierArgs = {
  bookingId: Scalars['Int']['input'];
};


export type School21QueriesGetBreadCrumbsArgs = {
  itemId: Scalars['ID']['input'];
  planItemType: PlanItemType;
  planType: PlanTypeForCondition;
};


export type School21QueriesGetBuildingsBySchoolIdArgs = {
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
};


export type School21QueriesGetClassRoomByLoginArgs = {
  login: Scalars['String']['input'];
};


export type School21QueriesGetClassSubjectsBySubjectIdAndStageIdArgs = {
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  stageId: Scalars['ID']['input'];
  subjectId: Scalars['ID']['input'];
};


export type School21QueriesGetCoalitionPublicProfileArgs = {
  userId: Scalars['UUID']['input'];
};


export type School21QueriesGetCommonP2pStatisticArgs = {
  endDate: Scalars['Date']['input'];
  startDate: Scalars['Date']['input'];
  userId: Scalars['UUID']['input'];
};


export type School21QueriesGetCourseGoalsExperienceArgs = {
  courseGoalWeights: Array<CourseGoalWeightInput>;
  courseId: Scalars['ID']['input'];
};


export type School21QueriesGetDeadlinesForStudentsArgs = {
  createdFrom?: InputMaybe<Scalars['DateTime']['input']>;
  createdTo?: InputMaybe<Scalars['DateTime']['input']>;
  deadlineFrom?: InputMaybe<Scalars['DateTime']['input']>;
  deadlineStatuses: Array<DeadlineStatus>;
  deadlineTo?: InputMaybe<Scalars['DateTime']['input']>;
  isClosest: Scalars['Boolean']['input'];
  page: PagingInput;
  sorting?: InputMaybe<Array<InputMaybe<SortingField>>>;
  stageGroupIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type School21QueriesGetDeadlinesForStudentsCountArgs = {
  createdFrom?: InputMaybe<Scalars['DateTime']['input']>;
  createdTo?: InputMaybe<Scalars['DateTime']['input']>;
  deadlineFrom?: InputMaybe<Scalars['DateTime']['input']>;
  deadlineStatuses: Array<DeadlineStatus>;
  deadlineTo?: InputMaybe<Scalars['DateTime']['input']>;
  isClosest: Scalars['Boolean']['input'];
  stageGroupIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type School21QueriesGetDismissInfoByStudentIdArgs = {
  studentId: Scalars['UUID']['input'];
};


export type School21QueriesGetDismissedStudentsFromStageArgs = {
  paging?: InputMaybe<PagingInput>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  stageId: Scalars['ID']['input'];
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type School21QueriesGetDismissedStudentsFromStageCountArgs = {
  stageId: Scalars['ID']['input'];
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type School21QueriesGetEmailbyUserIdArgs = {
  userId: Scalars['UUID']['input'];
};


export type School21QueriesGetEventsReportArgs = {
  eventCodes: Array<Scalars['String']['input']>;
  from: Scalars['DateTime']['input'];
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  timeZone?: InputMaybe<Scalars['String']['input']>;
  to: Scalars['DateTime']['input'];
};


export type School21QueriesGetExperiencePublicProfileArgs = {
  userId: Scalars['UUID']['input'];
};


export type School21QueriesGetFinishedGoalsPublicProfileArgs = {
  studentId: Scalars['UUID']['input'];
};


export type School21QueriesGetGoalAttemptStatisticByStudentArgs = {
  goalId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type School21QueriesGetGoalRetryInfoArgs = {
  goalId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type School21QueriesGetGoalSourcesArgs = {
  goalSourceType: GoalSourceTypeEnum;
  schoolId: Scalars['UUID']['input'];
  stageSubjectGroupId?: InputMaybe<Scalars['ID']['input']>;
};


export type School21QueriesGetGoalTitleByIdArgs = {
  goalId: Scalars['ID']['input'];
};


export type School21QueriesGetGoalsByGoalSourceIdArgs = {
  goalSourceId: Scalars['ID']['input'];
  goalSourceType: GoalSourceTypeEnum;
  schoolId: Scalars['UUID']['input'];
  stageSubjectGroupId?: InputMaybe<Scalars['ID']['input']>;
};


export type School21QueriesGetHeatMapCampusCalendarTimeSlotArgs = {
  endDate: Scalars['Date']['input'];
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  startDate: Scalars['Date']['input'];
};


export type School21QueriesGetHeatMapEventsStudentStatisticArgs = {
  endDate: Scalars['Date']['input'];
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  startDate: Scalars['Date']['input'];
  userId: Scalars['UUID']['input'];
};


export type School21QueriesGetImportedLanguagesForCurrentVersionArgs = {
  taskId: Scalars['ID']['input'];
};


export type School21QueriesGetImportedLanguagesForCurrentVersionByStudentGoalIdArgs = {
  studentGoalId: Scalars['ID']['input'];
};


export type School21QueriesGetLinkToPrivateStudentGitlabProjectByStudentLoginAndTaskIdArgs = {
  login: Scalars['String']['input'];
  taskId: Scalars['ID']['input'];
};


export type School21QueriesGetModuleByIdArgs = {
  goalId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type School21QueriesGetModuleCoverInformationArgs = {
  goalId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type School21QueriesGetMulticampusSettingsArgs = {
  stageId?: InputMaybe<Scalars['ID']['input']>;
};


export type School21QueriesGetMulticampusSettingsForRecoveryArgs = {
  schoolId: Scalars['UUID']['input'];
};


export type School21QueriesGetP2PChecksInfoArgs = {
  goalId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type School21QueriesGetParticipantsStatusArgs = {
  dismissTypeId: Array<InputMaybe<Scalars['ID']['input']>>;
  filterStageGroups: Array<InputMaybe<Scalars['ID']['input']>>;
};


export type School21QueriesGetProjectAttemptEvaluationsInfoArgs = {
  goalId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type School21QueriesGetProjectAttemptEvaluationsInfo_V1Args = {
  goalId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type School21QueriesGetProjectTeamWithMembersArgs = {
  goalId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type School21QueriesGetS21ClassHasDeadlineArgs = {
  classId: Scalars['ID']['input'];
};


export type School21QueriesGetS21ClassPlanHasDeadlineArgs = {
  classPlanId: Scalars['ID']['input'];
};


export type School21QueriesGetS21StageGroupPlanArgs = {
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  stagePlanId: Scalars['ID']['input'];
};


export type School21QueriesGetS21StagePlanArgs = {
  stagePlanId: Scalars['ID']['input'];
};


export type School21QueriesGetS21StagePlansArgs = {
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
};


export type School21QueriesGetS21TeamMembersByTeamArgs = {
  teamId: Scalars['UUID']['input'];
};


export type School21QueriesGetSaleSettingsBySchoolIdArgs = {
  schoolId: Scalars['ID']['input'];
};


export type School21QueriesGetSchoolIdByLoginArgs = {
  login: Scalars['String']['input'];
};


export type School21QueriesGetSettingsExamTestPagesArgs = {
  taskId: Scalars['ID']['input'];
};


export type School21QueriesGetSoftSkillLimitByStudentIdArgs = {
  studentId: Scalars['UUID']['input'];
};


export type School21QueriesGetSoftSkillTypesArgs = {
  isArchive?: InputMaybe<Scalars['Boolean']['input']>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
};


export type School21QueriesGetSoftSkillsByStudentIdArgs = {
  studentId: Scalars['UUID']['input'];
};


export type School21QueriesGetStageClassmatesArgs = {
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type School21QueriesGetStageGroupS21PublicProfileArgs = {
  studentId: Scalars['UUID']['input'];
};


export type School21QueriesGetStageGroupsArgs = {
  schoolIds?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  stageIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type School21QueriesGetStageGroupsRestrictedArgs = {
  isIntergroup?: InputMaybe<Scalars['Boolean']['input']>;
  schoolIds?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  stageIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type School21QueriesGetStageGroupsS21PublicProfileArgs = {
  studentId: Scalars['UUID']['input'];
};


export type School21QueriesGetStatisticBookingAttemptArgs = {
  end: Scalars['DateTime']['input'];
  start: Scalars['DateTime']['input'];
  userId: Scalars['UUID']['input'];
};


export type School21QueriesGetStudentByLoginArgs = {
  login: Scalars['String']['input'];
};


export type School21QueriesGetStudentCourseFinalScoreByLoginAndGoalIdArgs = {
  localCourseId: Scalars['ID']['input'];
  login: Scalars['String']['input'];
};


export type School21QueriesGetStudentGoalFinalScoreByLoginAndGoalIdArgs = {
  goalId: Scalars['ID']['input'];
  login: Scalars['String']['input'];
};


export type School21QueriesGetStudentIdByLoginArgs = {
  login: Scalars['String']['input'];
};


export type School21QueriesGetStudentProjectsArgs = {
  studentId: Scalars['UUID']['input'];
};


export type School21QueriesGetStudentProjectsForPublicProfileByStageGroupArgs = {
  stageGroupId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type School21QueriesGetTasksByIdArgs = {
  goalId: Scalars['ID']['input'];
  language?: InputMaybe<Scalars['String']['input']>;
  localCourseId?: InputMaybe<Scalars['ID']['input']>;
  taskId: Scalars['ID']['input'];
};


export type School21QueriesGetUserDisbandRequestCommentsArgs = {
  teamDisbandRequestId: Scalars['ID']['input'];
};


export type School21QueriesGetUserIdByLoginArgs = {
  login: Scalars['String']['input'];
};


export type School21QueriesGetUserRestrictionsByUserIdAndSchoolIdArgs = {
  schoolId: Scalars['UUID']['input'];
  userId: Scalars['UUID']['input'];
};


export type School21QueriesGetUsersArgs = {
  userIds: Array<Scalars['UUID']['input']>;
};


export type School21QueriesGetWorkstationByUserIdArgs = {
  userId?: InputMaybe<Scalars['UUID']['input']>;
};


export type School21QueriesLoadAllGlobalCoursesConsistencyInfosArgs = {
  courseIds: Array<Scalars['ID']['input']>;
};


export type School21QueriesLoadAverageLogtimeArgs = {
  date: Scalars['Date']['input'];
  login: Scalars['String']['input'];
  schoolID: Scalars['UUID']['input'];
};


export type School21QueriesLoadCourseConsistencyInfoArgs = {
  localCourseId: Scalars['ID']['input'];
};


export type School21QueriesLoadGlobalCourseConsistencyInfoArgs = {
  courseId: Scalars['ID']['input'];
};


export type School21QueriesLoadGoalConsistencyInfoArgs = {
  goalId: Scalars['ID']['input'];
};


export type School21QueriesLoadProjectExecutionTimeS21ReportArgs = {
  goalId?: InputMaybe<Scalars['ID']['input']>;
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  stageId: Scalars['ID']['input'];
  stageSubjectGroupId?: InputMaybe<Scalars['ID']['input']>;
  timeZone?: InputMaybe<Scalars['String']['input']>;
};


export type School21QueriesLoadProjectProgressReportArgs = {
  goalId: Scalars['ID']['input'];
  timeZone?: InputMaybe<Scalars['String']['input']>;
};


export type School21QueriesLoadProjectProgressReportV2Args = {
  endDate: Scalars['Date']['input'];
  goalId: Scalars['ID']['input'];
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  stageGroupId?: InputMaybe<Scalars['ID']['input']>;
  stageId: Scalars['ID']['input'];
  startDate: Scalars['Date']['input'];
  timeZone?: InputMaybe<Scalars['String']['input']>;
};


export type School21QueriesLoadRpBalanceReportArgs = {
  endDate: Scalars['Date']['input'];
  rpReportType: RpReportTypeEnum;
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  stageId: Scalars['ID']['input'];
  stageSubjectGroupId?: InputMaybe<Scalars['ID']['input']>;
  startDate: Scalars['Date']['input'];
  timeZone?: InputMaybe<Scalars['String']['input']>;
};


export type School21QueriesLoadStudentProjectExecutionConditionsArgs = {
  goalId: Scalars['ID']['input'];
  login: Scalars['String']['input'];
};


export type School21QueriesLoadStudentStageGroupsArgs = {
  studentId: Scalars['UUID']['input'];
};


export type School21QueriesLoadStudentStageGroupsS21PublicProfileArgs = {
  schoolId: Scalars['UUID']['input'];
  userId: Scalars['UUID']['input'];
};


export type School21QueriesLoadStudentsAcademicPerformanceS21ReportArgs = {
  endDate: Scalars['Date']['input'];
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  stageSubjectGroupId: Scalars['Int']['input'];
  startDate: Scalars['Date']['input'];
  timeZone?: InputMaybe<Scalars['String']['input']>;
};


export type School21QueriesLoadStudentsPerformanceS21ReportArgs = {
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  stageSubjectGroupId: Scalars['Int']['input'];
  timeZone?: InputMaybe<Scalars['String']['input']>;
};


export type School21QueriesLoadStudentsTeamS21ReportArgs = {
  goalId?: InputMaybe<Scalars['ID']['input']>;
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  stageId: Scalars['ID']['input'];
  stageSubjectGroupId?: InputMaybe<Scalars['ID']['input']>;
  timeZone?: InputMaybe<Scalars['String']['input']>;
};


export type School21QueriesLoadStudentsTeamS21ReportV2Args = {
  goalId?: InputMaybe<Scalars['ID']['input']>;
  goalSourceId: Scalars['ID']['input'];
  goalSourceType: GoalSourceTypeEnum;
  schoolId: Scalars['UUID']['input'];
  stageSubjectGroupId?: InputMaybe<Scalars['ID']['input']>;
  timeZone?: InputMaybe<Scalars['String']['input']>;
};

export type SchoolAdditionalInformation = {
  __typename?: 'SchoolAdditionalInformation';
  /** Количество групп по предмету в школе */
  classSubjectCount: Scalars['Int']['output'];
  /** ID группы класса по предмету, если classSubjectCount = 1 */
  classSubjectId?: Maybe<Scalars['ID']['output']>;
  /** ID школы */
  schoolId: Scalars['UUID']['output'];
};

export type SchoolChannels = {
  __typename?: 'SchoolChannels';
  channels: Array<Channel>;
  schoolId: Scalars['ID']['output'];
};

export type SchoolChannelsInput = {
  /** Каналы, которые должны быть включены/отключены */
  channels: Array<InputMaybe<ChannelInput>>;
  schoolId: Scalars['ID']['input'];
};

/** Информация о кампусах */
export type SchoolDependency = {
  __typename?: 'SchoolDependency';
  /** id кампуса */
  schoolId: Scalars['UUID']['output'];
  /** имя кампуса */
  schoolName: Scalars['String']['output'];
};

/** Школа для добавления в программу */
export type SchoolForLearningProgram = {
  __typename?: 'SchoolForLearningProgram';
  /** информация об учебной программе */
  learningProgramInfo?: Maybe<LearningProgramInfo>;
  /** идентификатор региона школы */
  regionId: Scalars['UUID']['output'];
  /** наименование региона школы */
  regionName: Scalars['String']['output'];
  /** id школы */
  schoolId: Scalars['UUID']['output'];
  /** идентификатор школы, например "00-00055" */
  schoolIdentifier: Scalars['String']['output'];
  /** краткое наименование школы */
  schoolName: Scalars['String']['output'];
};

export type SchoolFunctionalRoleInput = {
  roleName: Scalars['String']['input'];
  schoolId?: InputMaybe<Scalars['ID']['input']>;
};

/** Информация по школе для дашборда регминистра */
export type SchoolInfo = {
  __typename?: 'SchoolInfo';
  address: Scalars['String']['output'];
  organizationType: Scalars['String']['output'];
  regionId: Scalars['UUID']['output'];
  regionName: Scalars['String']['output'];
  schoolFullName: Scalars['String']['output'];
  schoolId: Scalars['UUID']['output'];
  schoolName: Scalars['String']['output'];
  /** Теги */
  tags: Array<Scalars['Int']['output']>;
};

/** Cтатус заполнения обязательных данных для школы для начала учебного процесса (здания, кабинеты, звонки, ученики, учителя, классы) */
export type SchoolMandatoryData = {
  __typename?: 'SchoolMandatoryData';
  /** Здания и кабинеты */
  buildingsAndClasses: Scalars['Boolean']['output'];
  /** Расписание звонков */
  lessonTimeSlots: Scalars['Boolean']['output'];
  /** Предметные группы */
  stageSubjectGroups: Scalars['Boolean']['output'];
  /** Классы */
  stages: Scalars['Boolean']['output'];
  /** Ученики */
  students: Scalars['Boolean']['output'];
  /** Учебные периоды */
  studyPeriods: Scalars['Boolean']['output'];
  /** Учителя */
  teachers: Scalars['Boolean']['output'];
};

/** Государственная оценка за контрольное тестирование */
export type SchoolMark = {
  __typename?: 'SchoolMark';
  /** Сокращенное название оценки */
  abbreviation?: Maybe<Scalars['String']['output']>;
  /** Название оценки */
  customName: Scalars['String']['output'];
  /** Дополнительное описание оценки (Полное название оценки) */
  description?: Maybe<Scalars['String']['output']>;
  /** Численное значение оценки */
  governmentMark: Scalars['Int']['output'];
  /**
   * Горячая клавиша клавиатуры, ассоциированная с оценкой
   * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode
   * Например, "Digit1", "KeyS"
   */
  hotkey?: Maybe<Scalars['String']['output']>;
  /** Название пиктограммы, которая будет использована для отображения данной оценки */
  iconName?: Maybe<Scalars['String']['output']>;
  /** Идентификатор оценки */
  id: Scalars['ID']['output'];
  /** Признак того, меняет ли отметка статус задания на зачтено или на не зачтено */
  isAccepted: Scalars['Boolean']['output'];
};

/** Группа системы оценивания */
export type SchoolMarkTypeGroup = {
  __typename?: 'SchoolMarkTypeGroup';
  /** Идентификатор учебного года окончания действия группы системы оценивания */
  endAcademicYear?: Maybe<AcademicYear>;
  /** Система оценивания */
  governmentMarkType: GovernmentMarkType;
  id: Scalars['ID']['output'];
  /** Наименование группы систем оценивания */
  name: Scalars['String']['output'];
  /** Идентификатор школы */
  schoolId: Scalars['UUID']['output'];
  /** Параллели */
  stages: Array<Stage>;
  /** Идентификатор учебного года начала действия группы системы оценивания */
  startAcademicYear: AcademicYear;
};

export type SchoolMarkTypeGroupConfiguration = {
  __typename?: 'SchoolMarkTypeGroupConfiguration';
  /** Дата и время создания конфигурации */
  createTime: Scalars['DateTime']['output'];
  /** Зависит ли оценивание от отметки за модуль */
  dependOfGoalMark: Scalars['Boolean']['output'];
  /** Идентификатор конфигурации оценивания */
  id: Scalars['ID']['output'];
  /** Доступна ли ручная корректировка отметок за учебный период */
  isManualChangeAvailable: Scalars['Boolean']['output'];
  /** Процентная зависимость отметки за период от внешней контрольной работы */
  markDependencyOfExternalWork?: Maybe<Scalars['Float']['output']>;
  /** Группа системы оценивания */
  schoolMarkTypeGroup: SchoolMarkTypeGroup;
  /** Соответствия процента завершения плана получаемой отметке */
  schoolMarkTypeGroupConfigurationRelation: Array<SchoolMarkTypeGroupConfigurationRelation>;
  /** Параллели конфигурации оценивания */
  stages: Array<Stage>;
  /** Дата и время последнего изменения данных конфигурации */
  updateTime?: Maybe<Scalars['DateTime']['output']>;
};

export type SchoolMarkTypeGroupConfigurationInput = {
  /** Дата и время создания конфигурации */
  createTime: Scalars['DateTime']['input'];
  /** Зависит ли оценивание от отметки за модуль */
  dependOfGoalMark: Scalars['Boolean']['input'];
  /** Идентификатор конфигурации оценивания */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** Доступна ли ручная корректировка отметок за учебный период */
  isManualChangeAvailable: Scalars['Boolean']['input'];
  /** Процентная зависимость отметки за период от внешней контрольной работы */
  markDependencyOfExternalWork?: InputMaybe<Scalars['Float']['input']>;
  /** Группа системы оценивания */
  schoolMarkTypeGroup: SchoolMarkTypeGroupInput;
  /** Соответствия процента завершения плана получаемой отметке */
  schoolMarkTypeGroupConfigurationRelation: Array<SchoolMarkTypeGroupConfigurationRelationInput>;
  /** Параллели конфигурации оценивания */
  stages: Array<Scalars['ID']['input']>;
  /** Дата и время последнего изменения данных конфигурации */
  updateTime?: InputMaybe<Scalars['DateTime']['input']>;
};

export type SchoolMarkTypeGroupConfigurationRelation = {
  __typename?: 'SchoolMarkTypeGroupConfigurationRelation';
  /** Идентификатор получаемой оценки */
  governmentMark: SchoolMark;
  /** Идентификатор конфигурации оценивания в которой учитывается отношение % завершения плана к получаемой отметке */
  id: Scalars['ID']['output'];
  /** Минимальное требуемое количество процентов прохождения плана для получения отметки */
  planCompletingPercentCount: Scalars['Float']['output'];
  /** Идентификатор конфигурации оценивания */
  schoolMarkTypeGroupConfigurationId: Scalars['ID']['output'];
  /** Время последнего изменения */
  updateTs: Scalars['DateTime']['output'];
};

export type SchoolMarkTypeGroupConfigurationRelationInput = {
  /** Идентификатор получаемой оценки */
  governmentMarkId: Scalars['ID']['input'];
  /** Идентификатор конфигурации оценивания в которой учитывается отношение % завершения плана к получаемой отметке */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** Минимальное требуемое количество процентов прохождения плана для получения отметки */
  planCompletingPercentCount: Scalars['Float']['input'];
  /** Идентификатор конфигурации оценивания */
  schoolMarkTypeGroupConfigurationId: Scalars['ID']['input'];
};

export type SchoolMarkTypeGroupInput = {
  endAcademicYearId?: InputMaybe<Scalars['ID']['input']>;
  governmentMarkTypeId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
  name: Scalars['String']['input'];
  schoolId: Scalars['UUID']['input'];
  stageIds: Array<Scalars['ID']['input']>;
  startAcademicYearId: Scalars['ID']['input'];
};

export type SchoolMonitoring = {
  __typename?: 'SchoolMonitoring';
  entries?: Maybe<Array<SchoolMonitoringEntry>>;
  isHeader: Scalars['Boolean']['output'];
  metricName: Scalars['String']['output'];
  orderNumber: Scalars['Int']['output'];
};

export type SchoolMonitoringEntry = {
  __typename?: 'SchoolMonitoringEntry';
  date: Scalars['Date']['output'];
  value: Scalars['String']['output'];
};

export type SchoolMonitoringInput = {
  endDate: Scalars['Date']['input'];
  schoolId: Scalars['UUID']['input'];
  startDate: Scalars['Date']['input'];
};

export type SchoolReportPeriods = {
  __typename?: 'SchoolReportPeriods';
  reportPeriodSetId: Scalars['UUID']['output'];
  reportPeriods: Array<ReportPeriod>;
  stageIds: Array<Scalars['ID']['output']>;
};

export type SchoolReportPeriodsInput = {
  reportPeriodSetId?: InputMaybe<Scalars['UUID']['input']>;
  reportPeriods: Array<ReportPeriodInput>;
  stageIds: Array<Scalars['ID']['input']>;
};

/** Модель ошибки настроек школы */
export type SchoolSelfConfigurationError = {
  __typename?: 'SchoolSelfConfigurationError';
  /** Код ошибки */
  errorCode: SchoolSelfConfigurationErrorCode;
};

/** Коды ошибок настроек школ */
export enum SchoolSelfConfigurationErrorCode {
  AccessToSchoolConfigurationSectionIsNotAllowed = 'ACCESS_TO_SCHOOL_CONFIGURATION_SECTION_IS_NOT_ALLOWED'
}

export type SchoolSelfConfigurationMutations = {
  __typename?: 'SchoolSelfConfigurationMutations';
  /** Мутация на изменение значения настройки для контекстной школы */
  saveConfiguration: SaveSchoolConfigurationResponse;
};


export type SchoolSelfConfigurationMutationsSaveConfigurationArgs = {
  saveSchoolConfigurationPropertyValueInput: SaveSchoolSelfConfigurationPropertyValueInput;
};

/** Настройка, входящая в подраздел */
export type SchoolSelfConfigurationProperty = {
  __typename?: 'SchoolSelfConfigurationProperty';
  /** Идентификатор настройки */
  configurationSubsectionPropertyId: Scalars['ID']['output'];
  /** Код настройки */
  propertyCode: Scalars['String']['output'];
  /** Комментарий к настройке */
  propertyComment?: Maybe<Scalars['String']['output']>;
  /** Тип визуального элемента для управления настройкой */
  propertyInputType: ConfigurationPropertyInputType;
  /** Имя настройки */
  propertyName: Scalars['String']['output'];
  /**
   * Модель параметра системы, связанного с настройкой по propertyCode.
   * Содержит значение настройки для контекстной школы и метаинформацию
   */
  relatedConfiguration: Configuration;
  /** Порядковый номер настройки в рамках подраздела и организации */
  sequenceNumber: Scalars['Int']['output'];
};

export type SchoolSelfConfigurationQueries = {
  __typename?: 'SchoolSelfConfigurationQueries';
  /** Запрос на получение подразделов и настроек для школы по идентификатору раздела */
  getSchoolConfigurationSection: GetSchoolSelfConfigurationSectionResponse;
  /** Запрос на получение разделов настроек для контекстной школы */
  getSchoolConfigurationSections: Array<SchoolSelfConfigurationSection>;
};


export type SchoolSelfConfigurationQueriesGetSchoolConfigurationSectionArgs = {
  configurationSectionId: Scalars['ID']['input'];
};

/** Раздел настроек организации */
export type SchoolSelfConfigurationSection = {
  __typename?: 'SchoolSelfConfigurationSection';
  /** Идентификатор раздела */
  configurationSectionId: Scalars['ID']['output'];
  /** Название раздела. Например "Информация о школе", "Выставление отметок" */
  sectionName: Scalars['String']['output'];
  /** Порядковый номер этого раздела среди разделов той же организации */
  sequenceNumber: Scalars['Int']['output'];
  /** Подразделы настроек этого раздела */
  subsections: Array<SchoolSelfConfigurationSubsection>;
};

/** Подраздел настроек организации */
export type SchoolSelfConfigurationSubsection = {
  __typename?: 'SchoolSelfConfigurationSubsection';
  /** Идентификатор подраздела */
  configurationSubsectionId: Scalars['ID']['output'];
  /** Настройки, входящие в подраздел */
  properties: Array<SchoolSelfConfigurationProperty>;
  /** Порядковый номер этого подраздела в рамках определенного раздела и организации */
  sequenceNumber: Scalars['Int']['output'];
  /** Название подраздела */
  subsectionName: Scalars['String']['output'];
};

export type SchoolTag = {
  __typename?: 'SchoolTag';
  id: Scalars['Int']['output'];
  tag: Scalars['String']['output'];
};

export type SchoolUpdateInput = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  /** Новый список тегов */
  addedTags: Array<Scalars['String']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  individualPlan?: InputMaybe<Scalars['Boolean']['input']>;
  /** ИНН */
  inn?: InputMaybe<Scalars['String']['input']>;
  logo?: InputMaybe<Scalars['String']['input']>;
  organizationType: OrganizationType;
  regionId: Scalars['UUID']['input'];
  /** Удаленный список тэгов */
  removedTags: Array<Scalars['String']['input']>;
  shortName?: InputMaybe<Scalars['String']['input']>;
  /** Конфигурация чтения / записи */
  tenantConfiguration?: InputMaybe<TenantConfigurationInput>;
  timeZoneId: Scalars['String']['input'];
};

/** Проверяющий по предмету в текущей школе */
export type SchoolVerifier = {
  __typename?: 'SchoolVerifier';
  /** имя проверяющего */
  firstName: Scalars['String']['output'];
  /** фамилия проверяющего */
  lastName: Scalars['String']['output'];
  /** отчетство проверяющего */
  middleName?: Maybe<Scalars['String']['output']>;
  /** идентификатор проверяющего как пользователя платформы */
  userId: Scalars['UUID']['output'];
};

/** Ответ на массовый перевод модулей/заданий на необходимый статус/скоуп */
export type ScopeAndStatusChangeResponse = {
  __typename?: 'ScopeAndStatusChangeResponse';
  /** Отношение неуспешно переведенных ИД модулей к возникшей ошибке */
  goalIdToErrorMapModel?: Maybe<Array<GoalIdToErrorMapModel>>;
  /** Признак успешно выполненного перевода всех модулей */
  isSuccess: Scalars['Boolean']['output'];
  /** Отношение неуспешно переведенных ИД заданий к возникшей ошибке */
  taskIdToErrorMapModel?: Maybe<Array<TaskIdToErrorMapModel>>;
};

export enum ScopeEnum {
  /** Кастомная */
  Custom = 'CUSTOM',
  /** Глобальная */
  Global = 'GLOBAL',
  /** Персональная */
  Private = 'PRIVATE'
}

/** Скоуп для установки на модуль или задание */
export type ScopeForSet = {
  /** Скоуп */
  code?: InputMaybe<ScopeEnum>;
  /** Школы (для кастомного скоупа) */
  schools: Array<Scalars['ID']['input']>;
  /** Пользователи (для кастомного скоупа) */
  users?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** информация по скоуп */
export type ScopeInfo = {
  __typename?: 'ScopeInfo';
  schoolIds: Array<Scalars['ID']['output']>;
  schoolShortNames?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  scope: ScopeEnum;
  userIds: Array<Scalars['ID']['output']>;
};

/** Пресеты для кастомной области видимости */
export enum ScopePresetEnum {
  /** Школьный */
  School = 'SCHOOL',
  /** Учительский */
  Teacher = 'TEACHER'
}

/** Счет */
export type Score = {
  __typename?: 'Score';
  hardScore: Scalars['Int']['output'];
  softScore: Scalars['Int']['output'];
};

/** Объяснение счета */
export type ScoreExplanation = {
  __typename?: 'ScoreExplanation';
  /** Объяснения ограничений */
  constraintExplanations: Array<ConstraintExplanation>;
  /** список результатов обработки ограничения, упорядоченный и отфильтрованный */
  constraintResults: Array<ConstraintResult>;
  /** Счет */
  solutionScore: Score;
  /** количество попыток составить расписание */
  stepsCount: ConstraintResult;
  /** количество нерасставленных уроков */
  unprocessedLessonsCount: ConstraintResult;
};

/** Модель оценки вопроса по чек-листу */
export type ScoreQuestion = {
  __typename?: 'ScoreQuestion';
  /** Id балла оценки */
  ratingWeightId: Scalars['ID']['output'];
  /** Id вопроса секции */
  sectionQuestionId: Scalars['ID']['output'];
  /** Описание оценки */
  value?: Maybe<Scalars['String']['output']>;
};

/** Модель оценки вопроса по чек-листу */
export type ScoreQuestionInput = {
  /** Id балла оценки */
  ratingWeightId: Scalars['ID']['input'];
  /** Id вопроса секции */
  sectionQuestionId: Scalars['ID']['input'];
};

/** Получение результата выполнения scorm-задания с бэка */
export type ScormAnswerBody = {
  __typename?: 'ScormAnswerBody';
  /** результат */
  result?: Maybe<Scalars['String']['output']>;
};

/**
 * Отправляемый ответ
 * внутри result следующая структура (+ экранирование)
 * {
 *    "type":"result",
 *    "data":{
 *       "progress":"null",
 *       "passingScore":"",
 *       "status":"incomplete"
 *    }
 * }
 */
export type ScormAnswerBodyInput = {
  /** результат */
  result?: InputMaybe<Scalars['String']['input']>;
};

/** Для фильтра по описаниям заданий (searchExternalTasks) */
export type SearchExternalTaskInput = {
  stage?: InputMaybe<Scalars['Int']['input']>;
  subject?: InputMaybe<Scalars['String']['input']>;
};

/** Параметры глобального поиска */
export enum SearchItem {
  /** Ученики */
  Profiles = 'PROFILES',
  /** Группы проектов участника Ш21 */
  StudentCourses = 'STUDENT_COURSES',
  /** Группы пронктов и проекты участника Ш21 */
  StudentCoursesAndProjects = 'STUDENT_COURSES_AND_PROJECTS',
  /** Проекты участника Ш21 */
  StudentProjects = 'STUDENT_PROJECTS'
}

/** Подсказка из истории поиска */
export type SearchTooltip = {
  __typename?: 'SearchTooltip';
  /** Категория поиска */
  tooltipCategory?: Maybe<SearchItem>;
  /** Текст подсказки */
  tooltipText?: Maybe<Scalars['String']['output']>;
};

/** Вопрос секции чек-листа */
export type SectionQuestion = {
  __typename?: 'SectionQuestion';
  /** Идентификатор секции */
  checklistSectionId: Scalars['ID']['output'];
  /** Описание вопроса */
  description: Scalars['String']['output'];
  /** Название вопроса */
  name: Scalars['String']['output'];
  /** Идентификатор вопроса */
  sectionQuestionId: Scalars['ID']['output'];
  /** Идентификатор шкалы */
  taskAssessmentScale: CriterionScale;
};

export enum SectionType {
  /** Пятый шаблон: 2 равные колонки, слева 1 блок, справа 1 блок */
  ColsEqL1R1 = 'COLS_EQ_L1_R1',
  /** Первый шаблон: 2 равные колонки, слева 2 блока, справа 1 блок */
  ColsEqL2R1 = 'COLS_EQ_L2_R1',
  /** Второй шаблон: 2 равные колонки, слева 1 блок, справа 2 блока */
  ColsEqL2R1Mirrored = 'COLS_EQ_L2_R1_MIRRORED',
  /** Второй шаблон: 2 неравные колонки, слева 1 блок, справа 1 блок */
  ColsNeqL1R2 = 'COLS_NEQ_L1_R2',
  /** Четвертый шаблон: 2 неравные колонки, слева 2 блока, справа 1 блок */
  ColsNeqL1R2Mirrored = 'COLS_NEQ_L1_R2_MIRRORED',
  /** Третий шаблон: 1 колонка, суженная по краям, 1 блок */
  ColNarrow = 'COL_NARROW',
  /** Четвёртый шаблон: 1 колонка во всю ширину, 1 блок */
  ColWide = 'COL_WIDE'
}

export type Selection = {
  __typename?: 'Selection';
  /** Ссылка на обложку подборки */
  coverUrl?: Maybe<Scalars['String']['output']>;
  /** идентификатор автора */
  creatorId: Scalars['ID']['output'];
  /** время создания подборки */
  creatorTs: Scalars['DateTime']['output'];
  /** автор */
  creatorUser?: Maybe<UserInfo>;
  /** true - нормальнай элемент, false - удален */
  isActive: Scalars['Boolean']['output'];
  /** можно ли управлять (менять/назначать/работать с содержимым) данной подборкой */
  isManageable: Scalars['Boolean']['output'];
  /** количество материалов в подборке */
  itemsCount?: Maybe<Scalars['Int']['output']>;
  /** время изменения подборки */
  lastModifiedTs: Scalars['DateTime']['output'];
  /** идентификатор пользователя, изменившего подборку */
  lastModifierUserId: Scalars['ID']['output'];
  /**
   * правила составления подборки
   * rules: [SelectionRuleDTO!]!
   * мета с названиями параллелей в EDUCATION_STAGE
   * @deprecated Произвели переход к идентификаторам параллелей, использовать metaV2
   */
  meta: Array<SelectionMetaValue>;
  /** мета с идентификаторами параллелей в EDUCATION_STAGE */
  metaV2: Array<SelectionMetaValue>;
  /** юзер, внесший исправления */
  modifierUser?: Maybe<UserInfo>;
  /** Имя подборки */
  name: Scalars['String']['output'];
  selectionId: Scalars['ID']['output'];
  /** Тип подборки */
  selectionType: SelectionType;
};

export type SelectionCreateInput = {
  /** Ссылка на обложку подборки */
  coverUrl?: InputMaybe<Scalars['String']['input']>;
  /** Имя подборки */
  name: Scalars['String']['input'];
  /** Тип подборки */
  selectionType: SelectionType;
};

export enum SelectionKind {
  Colleagues = 'COLLEAGUES',
  MyOnly = 'MY_ONLY',
  Sber = 'SBER'
}

export enum SelectionMeta {
  EducationCourse = 'EDUCATION_COURSE',
  EducationStage = 'EDUCATION_STAGE',
  EducationSubject = 'EDUCATION_SUBJECT',
  S21StudyProgram = 'S21_STUDY_PROGRAM'
}

export type SelectionMetaInput = {
  metaType: SelectionMeta;
  metaValue: Scalars['String']['input'];
};

export type SelectionMetaValue = {
  __typename?: 'SelectionMetaValue';
  metaType: SelectionMeta;
  metaValue: Scalars['String']['output'];
};

export type SelectionMutations = {
  __typename?: 'SelectionMutations';
  /** Добавить элементы в подборку */
  addItems: Scalars['Boolean']['output'];
  /** Связать подборку с объектом */
  bindEntity: Scalars['Boolean']['output'];
  /** создание подборки */
  createSelection: Selection;
  /** создание подборки и привязка к объекту */
  createSelectionAndBindToAndAddItems: Selection;
  /** Исключить элементы из подборки */
  deleteItems: Scalars['Boolean']['output'];
  /** удалить items из подборки, отвязать подборку от объекта, удалить подборку */
  deleteItemsAndUnbindFromAndDeleteSelection: Scalars['Boolean']['output'];
  /** удаление подборки */
  deleteSelection: Scalars['Boolean']['output'];
  /**
   * Задать список подборок для айтема (элемента каталога)
   * @deprecated Перечисление всех подборок может привести к нежелательному удалению материала из поборок коллег.
   * А также использование этого запроса может привести к потере изменений при одновременном использовании коллегами.
   */
  setSelectionsForItem: Scalars['Boolean']['output'];
  /** Задать список подборок для айтема (элемента каталога) V2 */
  setSelectionsForItemV2: Scalars['Boolean']['output'];
  /** Разорвать связь подборки и объекта */
  unbindEntity: Scalars['Boolean']['output'];
  /** изменение подборки */
  updateSelection: Selection;
};


export type SelectionMutationsAddItemsArgs = {
  itemIds: Array<Scalars['ID']['input']>;
  selectionId: Scalars['ID']['input'];
};


export type SelectionMutationsBindEntityArgs = {
  entityId: Scalars['ID']['input'];
  entityType: EntityType;
  meta: Array<SelectionMetaInput>;
  selectionId: Scalars['ID']['input'];
};


export type SelectionMutationsCreateSelectionArgs = {
  selection: SelectionCreateInput;
};


export type SelectionMutationsCreateSelectionAndBindToAndAddItemsArgs = {
  entityId: Scalars['ID']['input'];
  entityType: EntityType;
  itemIds: Array<Scalars['ID']['input']>;
  meta: Array<SelectionMetaInput>;
  selection: SelectionCreateInput;
};


export type SelectionMutationsDeleteItemsArgs = {
  itemIds: Array<Scalars['ID']['input']>;
  selectionId: Scalars['ID']['input'];
};


export type SelectionMutationsDeleteItemsAndUnbindFromAndDeleteSelectionArgs = {
  entityId: Scalars['ID']['input'];
  entityType: EntityType;
  itemIds: Array<Scalars['ID']['input']>;
  selectionId: Scalars['ID']['input'];
};


export type SelectionMutationsDeleteSelectionArgs = {
  selectionId: Scalars['ID']['input'];
};


export type SelectionMutationsSetSelectionsForItemArgs = {
  itemId: Scalars['ID']['input'];
  selectionIds: Array<Scalars['ID']['input']>;
};


export type SelectionMutationsSetSelectionsForItemV2Args = {
  addedSelectionIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  deletedSelectionIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  itemId: Scalars['ID']['input'];
};


export type SelectionMutationsUnbindEntityArgs = {
  entityId: Scalars['ID']['input'];
  entityType: EntityType;
  selectionId: Scalars['ID']['input'];
};


export type SelectionMutationsUpdateSelectionArgs = {
  selection: SelectionUpdateInput;
};

export type SelectionQueries = {
  __typename?: 'SelectionQueries';
  /** Получить список всех авторов */
  getAllCreators: Array<Maybe<UserInfo>>;
  /**
   * Получение списка паралелей для предмета из указаной подборки
   * @deprecated Использовать getAvailableStagesByEntityV2
   */
  getAvailableStagesByEntity: Array<AdditionalContentStage>;
  /** Получение списка доступных параллелей для сущности, связанной с подборкой */
  getAvailableStagesByEntityV2: Array<Stage>;
  /** Получить счетчики по подборкам */
  getCounters: CounterInfo;
  /** Получить объекты по выборке */
  getEntityBySelection: Array<Entity>;
  /** Получить состав подборки (список элементов) */
  getItems: Array<ContentItem>;
  /** Получить список значений мета подборок */
  getMetaValues: Array<Scalars['String']['output']>;
  /** Получить модуль по коду */
  getModuleById: ModuleInfo;
  /**
   * Получить список модулей по фильтру
   * @deprecated Использовать getModulesV2
   */
  getModules: Array<ModuleInfo>;
  /** Получить список модулей по фильтру */
  getModulesV2: Array<ModuleInfo>;
  /** получить информацию по коду подборки */
  getSelection: Selection;
  /** получить список подборок (коды) по объекту */
  getSelectionByEntity: Array<Scalars['ID']['output']>;
  /** получить список подборок (коды) по айтему */
  getSelectionByItem: Array<Scalars['ID']['output']>;
  /** Получить подборки по фильтру */
  getSelections: Array<Selection>;
  /** Получить подборки по списку авторов */
  getSelectionsByCreatorIds: Array<Selection>;
};


export type SelectionQueriesGetAllCreatorsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


export type SelectionQueriesGetAvailableStagesByEntityArgs = {
  entityId: Scalars['ID']['input'];
  entityType: EntityType;
};


export type SelectionQueriesGetAvailableStagesByEntityV2Args = {
  entityId: Scalars['ID']['input'];
  entityType: EntityType;
};


export type SelectionQueriesGetEntityBySelectionArgs = {
  selectionId: Scalars['ID']['input'];
};


export type SelectionQueriesGetItemsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  selectionId: Scalars['ID']['input'];
};


export type SelectionQueriesGetMetaValuesArgs = {
  metaId: SelectionMeta;
};


export type SelectionQueriesGetModuleByIdArgs = {
  moduleId: Scalars['ID']['input'];
};


export type SelectionQueriesGetModulesArgs = {
  stage: AdditionalContentStage;
  subjectId: Scalars['ID']['input'];
};


export type SelectionQueriesGetModulesV2Args = {
  stage?: InputMaybe<Scalars['ID']['input']>;
  subjectId: Scalars['ID']['input'];
};


export type SelectionQueriesGetSelectionArgs = {
  selectionId: Scalars['ID']['input'];
};


export type SelectionQueriesGetSelectionByEntityArgs = {
  entityId: Scalars['ID']['input'];
  entityType: EntityType;
};


export type SelectionQueriesGetSelectionByItemArgs = {
  itemId: Scalars['ID']['input'];
};


export type SelectionQueriesGetSelectionsArgs = {
  bound?: InputMaybe<Scalars['Boolean']['input']>;
  creatorId?: InputMaybe<Scalars['ID']['input']>;
  entityType?: InputMaybe<EntityType>;
  entityTypes?: InputMaybe<Array<EntityType>>;
  kind?: InputMaybe<SelectionKind>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  selectionType?: InputMaybe<SelectionType>;
  stageIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  stages?: InputMaybe<Array<AdditionalContentStage>>;
  subjectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  tagIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type SelectionQueriesGetSelectionsByCreatorIdsArgs = {
  creatorIds: Array<Scalars['ID']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};

export enum SelectionStageEnum {
  ConstructorConditions = 'CONSTRUCTOR_CONDITIONS',
  LastMeetingTime = 'LAST_MEETING_TIME',
  MeetingsFrequency = 'MEETINGS_FREQUENCY',
  Multicampus = 'MULTICAMPUS',
  PrpAmount = 'PRP_AMOUNT',
  RandomSelection = 'RANDOM_SELECTION',
  Winner = 'WINNER'
}

export enum SelectionType {
  ListBased = 'LIST_BASED',
  RuleBased = 'RULE_BASED'
}

export type SelectionUpdateInput = {
  /** Ссылка на обложку подборки */
  coverUrl?: InputMaybe<Scalars['String']['input']>;
  /** Имя подборки */
  name: Scalars['String']['input'];
  /** код подборки */
  selectionId: Scalars['ID']['input'];
  /** Тип подборки */
  selectionType: SelectionType;
};

/** Флаги управления подборками каталога в рамках медиатеки (комбинация прав доступа и фича-флагов) */
export type SelectionsManagementProperties = {
  __typename?: 'SelectionsManagementProperties';
  /** Доступность создания подборки (мутация createSelections) */
  createSelection: Scalars['Boolean']['output'];
};

export type Selector = {
  __typename?: 'Selector';
  group: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  subTitle: Scalars['String']['output'];
  title: Scalars['String']['output'];
};

export type SelectorByAttestationPeriod = {
  __typename?: 'SelectorByAttestationPeriod';
  /** дата закрытия модулей */
  closeModuleDate: Scalars['Date']['output'];
  /** дата окончания */
  endDate: Scalars['Date']['output'];
  id: Scalars['Int']['output'];
  /** дата начала */
  startDate: Scalars['Date']['output'];
  subTitle: Scalars['String']['output'];
  title: Scalars['String']['output'];
};

export type SelfAssessmentAllTestsResults = {
  __typename?: 'SelfAssessmentAllTestsResults';
  softSkillResults: Array<Maybe<SelfAssessmentSoftSkillResults>>;
  studentId: Scalars['ID']['output'];
};

export type SelfAssessmentAnswer = {
  __typename?: 'SelfAssessmentAnswer';
  answerId: Scalars['ID']['output'];
  answerPoints: Scalars['Int']['output'];
  answerVariantText: Scalars['String']['output'];
  questionId: Scalars['ID']['output'];
};

export type SelfAssessmentAverage = {
  __typename?: 'SelfAssessmentAverage';
  averageScore: Scalars['Int']['output'];
  createdTime: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  softSkillId: Scalars['ID']['output'];
  studentId: Scalars['UUID']['output'];
};

export type SelfAssessmentAverageInput = {
  averageScore: Scalars['Int']['input'];
  softSkillId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};

export type SelfAssessmentQuestion = {
  __typename?: 'SelfAssessmentQuestion';
  assessmentAnswerModels: Array<SelfAssessmentAnswer>;
  mixAnswer: Scalars['Boolean']['output'];
  questionId: Scalars['ID']['output'];
  questionText: Scalars['String']['output'];
  softSkillId: Scalars['ID']['output'];
  testId: Scalars['ID']['output'];
};

export type SelfAssessmentSoftSkillResults = {
  __typename?: 'SelfAssessmentSoftSkillResults';
  averageScoreForTest1: Scalars['Int']['output'];
  averageScoreForTest2: Scalars['Int']['output'];
  softSkillId: Scalars['ID']['output'];
};

export type SelfAssessmentTest = {
  __typename?: 'SelfAssessmentTest';
  questions: Array<SelfAssessmentQuestion>;
  stageId: Scalars['ID']['output'];
  testId: Scalars['ID']['output'];
};

export type SelfCheckInfo = {
  __typename?: 'SelfCheckInfo';
  /** Список прикрепленных файлов */
  files: Array<TaskInfoFile>;
  /** ключ к тесту SurveyJs (json) */
  jsonKey: Scalars['String']['output'];
  /** ключ к вопросу */
  questionKey: Scalars['String']['output'];
};

export enum SessionStatusFromExamus {
  /** Время сдачи еще не наступило */
  EarlyToStart = 'EARLY_TO_START',
  /** Пользователь завершил тестирование */
  Finished = 'FINISHED',
  /** Пользователь не может приступить к тестированию, т.к. время старта уже прошло */
  LateToStart = 'LATE_TO_START',
  /** Ошибка 404, означает что запрошенного sessionId не существует */
  NotFound = 'NOT_FOUND',
  /** Пользователь не записан на тестирование с прокторингом (для экзаменов с записью) */
  NotScheduled = 'NOT_SCHEDULED',
  /** Пользователь может приступить к тестированию */
  ReadyToStart = 'READY_TO_START',
  /** Пользователь проходит тестирование */
  Started = 'STARTED',
  /** Неопознанная ошибка */
  Unknown = 'UNKNOWN'
}

export type SetTaskCriteriaConformityForStudentTasksResponse = {
  __typename?: 'SetTaskCriteriaConformityForStudentTasksResponse';
  studentCriteriaValueModels: Array<StudentCriteriaValue>;
  studentId: Scalars['ID']['output'];
};

/** Сохраняемые настройки страницы экзаменационного теста */
export type SettingsExamTestPageInput = {
  /** Количество одновременно отображаемых виджетов на странице */
  numberOfDisplayedPageWidgets: Scalars['Int']['input'];
  /** Идентификатор страницы */
  pageId: Scalars['UUID']['input'];
  /** Список настроенных для страницы гибких навыков */
  softSkillsInPageSettings: Array<SoftSkillInExamTestPageSettingsInput>;
};

/** Настройки страницы экзаменационного теста */
export type SettingsExamTestPageModel = {
  __typename?: 'SettingsExamTestPageModel';
  /** Количество всех виджетов на странице */
  numberOfAllPageWidgets: Scalars['Int']['output'];
  /** Количество одновременно отображаемых виджетов на странице */
  numberOfDisplayedPageWidgets: Scalars['Int']['output'];
  /** Опыт, начисляемый за прохождение страницы (всех виджетов на странице) */
  pageExperience?: Maybe<Scalars['Int']['output']>;
  /** Идентификатор страницы */
  pageId: Scalars['UUID']['output'];
  /** Порядковый номер страницы в экзаменационном тесте */
  pageOrder?: Maybe<Scalars['Int']['output']>;
  /** Вес страницы */
  pageWeight?: Maybe<Scalars['Float']['output']>;
  /** Список настроенных для страницы гибких навыков */
  softSkillsInPageSettings: Array<SoftSkillInExamTestPageSettings>;
};

/** Блок сохраняемых настроек страниц экзаменационного теста */
export type SettingsExamTestPagesInput = {
  /** Список настроек страниц экзаменационного теста */
  settingsExamTestPages: Array<SettingsExamTestPageInput>;
  /** Идентификатор задания (таски) экзаменационного теста */
  taskId: Scalars['ID']['input'];
};

/** Перенос дедлайна */
export type ShiftDeadline = {
  /**
   * Количество дней для сдвига
   * @deprecated(reason: "Use parameter 'shiftTs' instead")
   */
  daysToShift: Scalars['Int']['input'];
  /** Идентификатор дедлайна */
  deadlineId: Scalars['UUID']['input'];
  /** Дата и время сдвига для дедлайна */
  shiftTs?: InputMaybe<Scalars['DateTime']['input']>;
  /** Идентификатор студента */
  studentId: Scalars['UUID']['input'];
};

/** Сокращенная модель организаций */
export type ShortOrganizationModel = {
  __typename?: 'ShortOrganizationModel';
  fullName: Scalars['String']['output'];
  orderBase: Scalars['Int']['output'];
  organizationId: Scalars['UUID']['output'];
  postAddress?: Maybe<Scalars['String']['output']>;
  shortName: Scalars['String']['output'];
};

/** Краткая информация о прогрессе студента */
export type ShortStudentProgress = {
  __typename?: 'ShortStudentProgress';
  /**
   * Сумма всех достигнутых уровней
   * (если на уровне 1.0 нет заданий, то достижении уровня 2.0 считается достигнутым 2 уровня)
   */
  achievedModuleLevelCount: Scalars['Int']['output'];
  /** Окончание прохождения */
  end?: Maybe<Scalars['DateTime']['output']>;
  /** Возможность получения сертификата по траекториям студента */
  isHavePossibilityToGetCertificate?: Maybe<Scalars['Boolean']['output']>;
  /** Запланированная трудоемкость в днях */
  planLaboriousnessDays?: Maybe<Scalars['Int']['output']>;
  /** Запланированная трудоемкость в часах */
  planLaboriousnessHours?: Maybe<Scalars['Int']['output']>;
  /** Сумма целевых уровней всех модулей */
  plannedModuleLevelCount: Scalars['Int']['output'];
  /** Прогресс прохождения всех модулей в процентах. (achievedModuleLevelCount / plannedModuleLevelCount) */
  progress: Scalars['Int']['output'];
  /** Начало прохождения */
  start?: Maybe<Scalars['DateTime']['output']>;
  /** Траектория */
  trajectory?: Maybe<Scalars['String']['output']>;
};

export type SimpleAnswerBody = {
  __typename?: 'SimpleAnswerBody';
  /** Ответ */
  answer: Scalars['String']['output'];
  /** Правильный ответ */
  correct?: Maybe<Scalars['Boolean']['output']>;
};

export type SimpleAnswerBodyInput = {
  /** Простой ответ */
  answer: Scalars['String']['input'];
};

/** Упрощенное представление пользователя */
export type SimpleUserInfoModel = {
  __typename?: 'SimpleUserInfoModel';
  /** Полное ФИО пользователя */
  fullName: Scalars['String']['output'];
  /** ID пользователя */
  userId: Scalars['UUID']['output'];
};

export type SkillDescription = {
  __typename?: 'SkillDescription';
  achieved: Scalars['Boolean']['output'];
  description: Scalars['String']['output'];
};

/** Навык из чек-листа */
export type SkillWithNameInChecklist = {
  __typename?: 'SkillWithNameInChecklist';
  /** Идентификатор объекта к которому привязан навык */
  id: Scalars['ID']['output'];
  /** Процент навыка */
  percent: Scalars['Int']['output'];
  /** Название навыка */
  skill: Scalars['String']['output'];
};

/** Навык из чек-листа */
export type SkillWithNameInChecklistInput = {
  /** Идентификатор объекта к которому привязан навык */
  id: Scalars['ID']['input'];
  /** Процент навыка */
  percent: Scalars['Int']['input'];
  /** Название навыка */
  skill: Scalars['String']['input'];
};

export type SkillsTaskCriteriaValue = {
  __typename?: 'SkillsTaskCriteriaValue';
  /** Процент соответствия навыку */
  averageCriteria: Scalars['Int']['output'];
  /** Соответствия критериев */
  criteriaValues: Array<TaskCriteriaValue>;
  /** Идентификатор навыка */
  skillId: Scalars['ID']['output'];
};

/** Информация о мягких навыках */
export type SoftSkill = {
  __typename?: 'SoftSkill';
  /** ID */
  id: Scalars['ID']['output'];
  /** Название иконки навыка, хранящееся на фронте */
  imageUrl: Scalars['String']['output'];
  /** Название навыка */
  name: Scalars['String']['output'];
};

/** Cправочник категорий навыков */
export enum SoftSkillCategoryEnum {
  /** Цифровые навыки */
  DigitalSkill = 'DIGITAL_SKILL',
  /** Предметные навыки */
  HardSkill = 'HARD_SKILL',
  /** Навыки для Школы 21 */
  School21 = 'SCHOOL21',
  /** Мягкие навыки */
  SoftSkill = 'SOFT_SKILL'
}

export type SoftSkillCount = {
  __typename?: 'SoftSkillCount';
  /** Количество Зачтенных Заданий с этим Мягким Навыком */
  completedTaskCount: Scalars['Int']['output'];
  /** Группа Мягкого Навыка */
  group: SoftSkillGroupEnum;
  /** Название Мягкого Навыка */
  name: Scalars['String']['output'];
  /** Id Мягкого Навыка */
  softSkillId: Scalars['ID']['output'];
  /** Количество Заданий с этим Мягким Навыком */
  taskCount: Scalars['Int']['output'];
};

/** Группа софт-скилла (объект) */
export type SoftSkillGroup = {
  __typename?: 'SoftSkillGroup';
  /** Идентификатор */
  id: Scalars['ID']['output'];
  /** Название */
  name?: Maybe<Scalars['String']['output']>;
  /** Порядок */
  order?: Maybe<Scalars['Int']['output']>;
};

/** Cправочник групп навыков */
export enum SoftSkillGroupEnum {
  /** Когнитивные */
  Cognitive = 'COGNITIVE',
  /** Комуникация и сотрудничество */
  CommunicationAndCollaboration = 'COMMUNICATION_AND_COLLABORATION',
  /** Разработка цифровых продуктов */
  DigitalProductDevelopment = 'DIGITAL_PRODUCT_DEVELOPMENT',
  /** Безопасность в цифровой среде */
  DigitalSecurity = 'DIGITAL_SECURITY',
  /** Эмоциональные */
  Emotional = 'EMOTIONAL',
  /** Предметные навыки */
  HardSkill = 'HARD_SKILL',
  /** Информационная грамотность */
  InformationLiteracy = 'INFORMATION_LITERACY',
  /** Навыки в сфере IT (для Школы 21) */
  ItSkill = 'IT_SKILL',
  /** Социальные */
  Social = 'SOCIAL'
}

/** Гибкий навык в настройках страницы экзаменационного теста */
export type SoftSkillInExamTestPageSettings = {
  __typename?: 'SoftSkillInExamTestPageSettings';
  /** Процент навыка */
  percent?: Maybe<Scalars['Int']['output']>;
  /** Идентификатор навыка */
  softSkillId: Scalars['ID']['output'];
  /** Название навыка */
  softSkillName: Scalars['String']['output'];
};

/** Гибкий навык в настройках страницы экзаменационного теста */
export type SoftSkillInExamTestPageSettingsInput = {
  /** Процент навыка */
  percent: Scalars['Int']['input'];
  /** Идентификатор навыка */
  softSkillId: Scalars['ID']['input'];
};

/** Максимаьные значения гибких навыков */
export type SoftSkillLimit = {
  __typename?: 'SoftSkillLimit';
  /** Максимальное значение навыков для параллели */
  powerLimit?: Maybe<Scalars['Int']['output']>;
  /**
   * ИД параллели
   * @deprecated Field no longer supported
   */
  stageId: Scalars['ID']['output'];
};

export type SoftSkillPercentage = {
  __typename?: 'SoftSkillPercentage';
  percentage: Scalars['Int']['output'];
  softSkillTypeId: Scalars['ID']['output'];
};

export type SoftSkillPercentageInput = {
  percentage: Scalars['Int']['input'];
  softSkillTypeId: Scalars['ID']['input'];
};

export type SoftSkillPoint = {
  __typename?: 'SoftSkillPoint';
  /** Количество очков навыка, полученное студентом за выполнение заданий */
  achievedUserPower?: Maybe<Scalars['Int']['output']>;
  /** Текущий уровень развития этого навыка у студента */
  currentUserPower: Scalars['Int']['output'];
  /** Максимальный уровень развития этого навыка в системе */
  maxPower: Scalars['Int']['output'];
  /** Идентификатор гибкого навыка */
  softSkillId: Scalars['Int']['output'];
  /** Название гибкого навыка */
  softSkillName: Scalars['String']['output'];
  /** Роль в команде, которой начисляется данный навык */
  teamRole?: Maybe<TeamRole>;
  /** Суммарное кол-во очков, которое можно получить за выполнение заданий в этом курсе, укрепляющих навык */
  totalPower: Scalars['Int']['output'];
};

/** Прогресс в разрезе типов навыков */
export type SoftSkillPower = {
  __typename?: 'SoftSkillPower';
  /** В архиве */
  archive: Scalars['Boolean']['output'];
  /** Категория */
  category: SoftSkillCategoryEnum;
  /** Код */
  code: Scalars['String']['output'];
  /** Дескриптор */
  descriptor: Scalars['String']['output'];
  /** Группа */
  group: SoftSkillGroupEnum;
  /** Цветовая кодировка */
  hueSaturationLightness: Scalars['String']['output'];
  /** Идентификатор (рандомно генерируется) */
  id: Scalars['ID']['output'];
  /** Относительное ссылка в файловый сервис на изображением мягкого навыка */
  imageUrl: Scalars['String']['output'];
  /** Кол-во очков, полученное за текущую дату при выполнении заданий, укрепляющих навык */
  powerGrow: Scalars['Int']['output'];
  /** Группа (объект) */
  softSkillGroup?: Maybe<SoftSkillGroup>;
  /** Общее кол-во очков, полученное за выполнение заданий, укрепляющих навык */
  totalPower: Scalars['Int']['output'];
  /** Наименование навыка(Пример: Познаю себя) */
  type: Scalars['String']['output'];
};

/** Группа навыков */
export type SoftSkillType = {
  __typename?: 'SoftSkillType';
  /** В архиве */
  archive: Scalars['Boolean']['output'];
  /** Категория */
  category: SoftSkillCategoryEnum;
  /** Код */
  code: Scalars['String']['output'];
  /** Описание */
  description: Scalars['String']['output'];
  /** Дескриптор */
  descriptor: Scalars['String']['output'];
  /** Группа */
  group: SoftSkillGroupEnum;
  /** Цветовая кодировка */
  hueSaturationLightness: Scalars['String']['output'];
  /** Идентификатор */
  id: Scalars['ID']['output'];
  /** Относительное ссылка в файловый сервис на изображением мягкого навыка */
  imageUrl: Scalars['String']['output'];
  /** Наименование */
  name: Scalars['String']['output'];
  /** Сокращенное наименование тенанта */
  tenantShortName?: Maybe<Scalars['String']['output']>;
};

/** Гибкие навыки с весом, прикрепляемые к заданию */
export type SoftSkillTypePowerInput = {
  id: Scalars['ID']['input'];
  power: Scalars['Float']['input'];
};

export type SolutionInfo = {
  __typename?: 'SolutionInfo';
  /** Информация о решении при тип решения GitLab */
  gitlabSolutionInfo?: Maybe<GitlabSolutionInfo>;
  /** Информация о решении при тип решения Platf */
  platfSolutionInfo?: Maybe<PlatfSolutionInfo>;
  /** Тип решения задания */
  solutionType: TaskSolutionTypeEnum;
};

export type SortableAnswerBody = {
  __typename?: 'SortableAnswerBody';
  answers: Array<SortableAnswerBodyPair>;
};

export type SortableAnswerBodyInput = {
  /** Ответ на виджет сортировка */
  answers: Array<SortableAnswerBodyPairInput>;
};

export type SortableAnswerBodyPair = {
  __typename?: 'SortableAnswerBodyPair';
  /** UUID карточки */
  cardId: Scalars['ID']['output'];
  /** Правильно/неправильно */
  correct: Scalars['Boolean']['output'];
  /** UUID группы, в случае если null значит, что карточка без группы */
  groupId?: Maybe<Scalars['ID']['output']>;
  groupOrder?: Maybe<Scalars['Int']['output']>;
};

export type SortableAnswerBodyPairInput = {
  /** UUID карточки */
  cardId: Scalars['ID']['input'];
  /** UUID группы, в случае если null значит, что карточка без группы */
  groupId?: InputMaybe<Scalars['ID']['input']>;
  groupOrder?: InputMaybe<Scalars['Int']['input']>;
};

export type SortingField = {
  asc: Scalars['Boolean']['input'];
  name: Scalars['String']['input'];
};

export type Stage = {
  __typename?: 'Stage';
  /** идентификатор (номер) параллели */
  id: Scalars['ID']['output'];
  /** название параллели */
  name: Scalars['String']['output'];
};

export type StageBySubjectResponse = {
  __typename?: 'StageBySubjectResponse';
  stageId: Scalars['ID']['output'];
  stageSubjectGroupsTaskCount: Array<StageSubjectGroupsTaskCountBySubjectTeacherResponse>;
};

export type StageConfiguration = {
  __typename?: 'StageConfiguration';
  isDeadlinesEnabled: Scalars['Boolean']['output'];
  stage: Stage;
};

export type StageConfigurationInput = {
  isDeadlinesEnabled: Scalars['Boolean']['input'];
  stageId: Scalars['ID']['input'];
};

/** Связи параллели с кампусами */
export type StageDependency = {
  __typename?: 'StageDependency';
  /** список классов для данной параллели (необязательное поле используется только у БА) */
  classes?: Maybe<Array<ClassInStage>>;
  /** список связанных с параллелью кампусов */
  schools: Array<SchoolDependency>;
  /** id параллели */
  stageId: Scalars['ID']['output'];
  /** наименование параллели */
  stageName: Scalars['String']['output'];
};

/** deprecated, consider using StageGroupV2 instead */
export type StageGroup = {
  __typename?: 'StageGroup';
  /** академический год */
  academicYear: AcademicYear;
  /** группы по предметам */
  classSubjects?: Maybe<Array<ClassSubject>>;
  /** количество групп по предметам */
  classSubjectsCount: Scalars['Int']['output'];
  /** группы по предметам вместе с учителями */
  classSubjectsWithTeacher?: Maybe<Array<ClassSubject>>;
  /** классный руководитель */
  formMaster?: Maybe<User>;
  /** идентификатор классного руководителя класса, как пользователя */
  formMasterUserId?: Maybe<Scalars['ID']['output']>;
  id: Scalars['ID']['output'];
  /** не активные студенты класса */
  inactiveStudents?: Maybe<Array<Student>>;
  /** Активный или удаленный */
  isActive: Scalars['Boolean']['output'];
  /** является ли межклассной группой */
  isIntergroup: Scalars['Boolean']['output'];
  /** Дата завершения обучения */
  learningCompleteTs?: Maybe<Scalars['DateTime']['output']>;
  /** Статус обучения */
  learningStatus: LearningStatusEnum;
  /** тип обучения */
  learningType: LearningTypeEnum;
  /** @deprecated Используйте StageGroupWithTimeslotSetId */
  lessonTimeslotsGroupId?: Maybe<Scalars['ID']['output']>;
  /** название класса (А, ФизТех) */
  name: Scalars['String']['output'];
  /** параллель */
  stage: Scalars['Int']['output'];
  /** количество студентов в классе */
  studentNumber: Scalars['Int']['output'];
  /** студенты класса */
  students?: Maybe<Array<Student>>;
};

export type StageGroupAggregated = {
  __typename?: 'StageGroupAggregated';
  /** академический год */
  academicYear: AcademicYear;
  /** группы по предметам */
  classSubjects?: Maybe<Array<ClassSubject>>;
  /** количество групп по предметам */
  classSubjectsCount: Scalars['Int']['output'];
  /** классный руководитель */
  formMaster?: Maybe<User>;
  /** идентификатор классного руководителя класса, как пользователя */
  formMasterUserId?: Maybe<Scalars['ID']['output']>;
  id: Scalars['ID']['output'];
  /** не активные студенты класса */
  inactiveStudents?: Maybe<Array<Student>>;
  /** Активный или удаленный */
  isActive: Scalars['Boolean']['output'];
  /** является ли межклассной группой */
  isIntergroup: Scalars['Boolean']['output'];
  /** Дата завершения обучения */
  learningCompleteTs?: Maybe<Scalars['DateTime']['output']>;
  /** Статус обучения */
  learningStatus: LearningStatusEnum;
  /** тип обучения */
  learningType: LearningTypeEnum;
  /** название класса (А, ФизТех) */
  name: Scalars['String']['output'];
  /** параллель */
  stage: Scalars['Int']['output'];
  /** количество студентов в классе */
  studentNumber: Scalars['Int']['output'];
  /** студенты класса */
  students?: Maybe<Array<Student>>;
};

/** Общая информация по классу */
export type StageGroupCommonInfo = {
  __typename?: 'StageGroupCommonInfo';
  /** Идентификатор класса */
  stageGroupId: Scalars['ID']['output'];
  /** Название класса */
  stageGroupName: Scalars['String']['output'];
};

/** Драфт группы */
export type StageGroupDraft = {
  __typename?: 'StageGroupDraft';
  /** Идентификатор учебного года */
  academicYearId: Scalars['ID']['output'];
  /** Идентификатор учителя классного руководителя */
  formMaster?: Maybe<Scalars['UUID']['output']>;
  /** Идентификатор драфта */
  stageGroupDraftId: Scalars['ID']['output'];
  /** Наименование группы */
  stageGroupName: Scalars['String']['output'];
  /** Идентификатор параллели */
  stageId: Scalars['ID']['output'];
  /** Имя учителя */
  teacherFirstName?: Maybe<Scalars['String']['output']>;
  /** Фамилия учителя */
  teacherLastName?: Maybe<Scalars['String']['output']>;
  /** Отчество учителя */
  teacherMiddleName?: Maybe<Scalars['String']['output']>;
};

/** Драфт группы входная модель */
export type StageGroupDraftInput = {
  /** Идентификатор учебного года */
  academicYearId: Scalars['ID']['input'];
  /** Идентификатор драфта */
  stageGroupDraftId?: InputMaybe<Scalars['ID']['input']>;
  /** Наименование группы */
  stageGroupName: Scalars['String']['input'];
  /** Идентификатор параллели */
  stageId: Scalars['ID']['input'];
};

export type StageGroupExtended = {
  __typename?: 'StageGroupExtended';
  /** академический год */
  academicYear: AcademicYear;
  /** группы по предметам */
  classSubjects?: Maybe<Array<ClassSubject>>;
  /** количество групп по предметам */
  classSubjectsCount: Scalars['Int']['output'];
  /** дата дедлайна */
  finishDate?: Maybe<Scalars['DateTime']['output']>;
  /** классный руководитель */
  formMaster?: Maybe<User>;
  /** идентификатор классного руководителя класса, как пользователя */
  formMasterUserId?: Maybe<Scalars['ID']['output']>;
  id: Scalars['ID']['output'];
  /** не активные студенты класса */
  inactiveStudents?: Maybe<Array<Student>>;
  /** является ли межклассной группой */
  isIntergroup: Scalars['Boolean']['output'];
  /** является ли интенсивом */
  isItIntensiveStage?: Maybe<Scalars['Boolean']['output']>;
  /** Дата завершения обучения */
  learningCompleteTs?: Maybe<Scalars['DateTime']['output']>;
  /** Статус обучения */
  learningStatus: LearningStatusEnum;
  /** тип обучения */
  learningType: LearningTypeEnum;
  /** название класса (А, ФизТех) */
  name: Scalars['String']['output'];
  /** параллель */
  stage: Scalars['Int']['output'];
  /** количество студентов в классе */
  studentNumber: Scalars['Int']['output'];
  /** студенты класса */
  students?: Maybe<Array<Student>>;
};

/** Дата и время завершения обучения в классе */
export type StageGroupFinishDate = {
  __typename?: 'StageGroupFinishDate';
  /** Дата завершения обучения */
  finishDate?: Maybe<Scalars['DateTime']['output']>;
  /** Идентификатор */
  stageGroupFinishDateId: Scalars['UUID']['output'];
  /** Идентификатор группы (класса) */
  stageGroupId: Scalars['ID']['output'];
};

/** Email на класс для помощи студентам Bootcamp */
export type StageGroupHelpEmailModel = {
  __typename?: 'StageGroupHelpEmailModel';
  /** Дата и время создания */
  createTs?: Maybe<Scalars['DateTime']['output']>;
  /** Идентификатор пользователя создавшего запись */
  creatorUserId?: Maybe<Scalars['ID']['output']>;
  /** Email для обращений учеников в классе за помощью */
  email?: Maybe<Scalars['String']['output']>;
  /** Признак доступности для обращений */
  enabled: Scalars['Boolean']['output'];
  /** Идентификатор пользователя последним изменившим запись */
  lastModifierUserId?: Maybe<Scalars['ID']['output']>;
  /** Дата и время последнего изменения */
  lastModifyTs?: Maybe<Scalars['DateTime']['output']>;
  /** Уникальный идентификатор */
  stageGroupHelpEmailId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор класса */
  stageGroupId: Scalars['ID']['output'];
};

export type StageGroupInfo = {
  __typename?: 'StageGroupInfo';
  /** академический год */
  academicYearId: Scalars['ID']['output'];
  /** классный руководитель */
  formMaster?: Maybe<Scalars['UUID']['output']>;
  /** является ли межклассной группой */
  isIntergroup: Scalars['Boolean']['output'];
  stageGroupId: Scalars['ID']['output'];
  /** название класса (А, ФизТех) */
  stageGroupName: Scalars['String']['output'];
  /**
   * параллель
   * @deprecated Нет названия параллели. Использовать поле stageInfo
   */
  stageId: Scalars['Int']['output'];
  /** информация о параллели */
  stageInfo: Stage;
  /** идентификатор набора учебных периодов */
  studyPeriodSetId?: Maybe<Scalars['Int']['output']>;
};

export type StageGroupInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  /** Активный или удаленный */
  isActive: Scalars['Boolean']['input'];
  learningType?: InputMaybe<LearningTypeEnum>;
  lessonTimeslotsGroupId?: InputMaybe<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
  stage: Scalars['Int']['input'];
};

/** Первый шаг массового создания групп, входная модель */
export type StageGroupMassCreationFirstStepInput = {
  /** Кол-во создаваемых групп */
  numberOfGroups: Scalars['Int']['input'];
  /** Идентификатор параллели */
  stageId: Scalars['Int']['input'];
};

export type StageGroupMassCreationMutations = {
  __typename?: 'StageGroupMassCreationMutations';
  /** Создание групп и гкпп из драфтов */
  createFromDrafts: Scalars['Boolean']['output'];
  /** Создание драфтов групп на первом шаге массового создания */
  createStageGroupDraftsOnFirstStage: Array<StageGroupDraft>;
  /** Создание драфта гкпп */
  createStageSubjectGroupDraft: StageSubjectGroupDraft;
  /** Удаление драфта группы */
  deleteStageGroupDraft?: Maybe<Scalars['Boolean']['output']>;
  /** Удаление драфта гкпп */
  deleteStageSubjectGroupDraft?: Maybe<Scalars['Boolean']['output']>;
  /** Сохранение/обновление драфта группы */
  saveStageGroupDraft: StageGroupDraft;
  /** Назначение классного руководителя класса */
  setStageGroupDraftFormMaster: StageGroupDraft;
  /** Установка владельца процесса массового создания групп */
  setStageGroupMassCreationOwner: StageGroupMassCreationStatus;
  /** Установка шага массового создания групп */
  setStageGroupMassCreationStatusStep: StageGroupMassCreationStatus;
};


export type StageGroupMassCreationMutationsCreateFromDraftsArgs = {
  academicYearId: Scalars['ID']['input'];
};


export type StageGroupMassCreationMutationsCreateStageGroupDraftsOnFirstStageArgs = {
  academicYearId: Scalars['ID']['input'];
  stageGroupMassCreationFirstStepInputs: Array<StageGroupMassCreationFirstStepInput>;
};


export type StageGroupMassCreationMutationsCreateStageSubjectGroupDraftArgs = {
  stageSubjectGroupDraftInput: StageSubjectGroupDraftInput;
};


export type StageGroupMassCreationMutationsDeleteStageGroupDraftArgs = {
  stageGroupDraftId: Scalars['ID']['input'];
};


export type StageGroupMassCreationMutationsDeleteStageSubjectGroupDraftArgs = {
  stageSubjectGroupDraftId: Scalars['ID']['input'];
};


export type StageGroupMassCreationMutationsSaveStageGroupDraftArgs = {
  stageGroupDraftInput: StageGroupDraftInput;
};


export type StageGroupMassCreationMutationsSetStageGroupDraftFormMasterArgs = {
  formMaster: Scalars['UUID']['input'];
  stageGroupDraftId: Scalars['ID']['input'];
};


export type StageGroupMassCreationMutationsSetStageGroupMassCreationStatusStepArgs = {
  stageId?: InputMaybe<Scalars['ID']['input']>;
  step: StageGroupMassCreationStep;
};

export type StageGroupMassCreationQueries = {
  __typename?: 'StageGroupMassCreationQueries';
  /** Получение статуса массового создания групп */
  findStageGroupMassCreationStatus?: Maybe<StageGroupMassCreationStatus>;
  /** Получение драфтов групп по академическому году */
  getStageGroupDraftsByAcademicYearId: Array<StageGroupDraft>;
  /** Получение драфтов гкпп по академическому году и параллели */
  getStageSubjectGroupDraftsBy: Array<StageSubjectGroupDraft>;
  /** Проверка наличия групп во всех учебных годах школы */
  ifSchoolHasStageGroups: Scalars['Boolean']['output'];
  /** Проверка наличия связанных сущностей (драфты гкпп) драфта группы */
  ifStageGroupDraftHasRelatedEntities: Scalars['Boolean']['output'];
};


export type StageGroupMassCreationQueriesGetStageGroupDraftsByAcademicYearIdArgs = {
  academicYearId: Scalars['ID']['input'];
};


export type StageGroupMassCreationQueriesGetStageSubjectGroupDraftsByArgs = {
  academicYearId: Scalars['ID']['input'];
  stageId: Scalars['ID']['input'];
};


export type StageGroupMassCreationQueriesIfStageGroupDraftHasRelatedEntitiesArgs = {
  stageGroupDraftId: Scalars['ID']['input'];
};

/** Статус массового создания групп */
export type StageGroupMassCreationStatus = {
  __typename?: 'StageGroupMassCreationStatus';
  /** Идентификатор академического года */
  academicYearId: Scalars['ID']['output'];
  /** Имя пользователя */
  firstName: Scalars['String']['output'];
  /** Признак того, что процесс создания групп из драфтов запущен */
  isCreationInProcess: Scalars['Boolean']['output'];
  /** Признак того, что процесс массового создания завершен */
  isFinished: Scalars['Boolean']['output'];
  /** Фамилия пользователя */
  lastName: Scalars['String']['output'];
  /** Отчество пользователя */
  middleName?: Maybe<Scalars['String']['output']>;
  /** Идентификатор школы */
  schoolId: Scalars['UUID']['output'];
  /** Идентификатор статуса */
  stageGroupMassCreationStatusId: Scalars['ID']['output'];
  /** Идентификатор параллели (только для второго шага) */
  stageId?: Maybe<Scalars['Int']['output']>;
  /** Шаг */
  step: StageGroupMassCreationStep;
  /** Идентификатор пользователя владельца процесса массового создания */
  userId: Scalars['UUID']['output'];
};

export enum StageGroupMassCreationStep {
  FirstStep = 'FIRST_STEP',
  SecondStep = 'SECOND_STEP',
  ThirdStep = 'THIRD_STEP'
}

/** Емейл психолога с перечнем класов привязанных к этому емейлу */
export type StageGroupPsychologistEmail = {
  __typename?: 'StageGroupPsychologistEmail';
  /** Емейл психолога */
  email: Scalars['String']['output'];
  /** Идентификаторы классов школы закрепленых за данным психологом */
  stageGroupIds: Array<Scalars['ID']['output']>;
};

export type StageGroupS21 = {
  __typename?: 'StageGroupS21';
  /** статус класса */
  active?: Maybe<Scalars['Boolean']['output']>;
  /** название формы обучения (аналог stage_name) */
  eduForm: Scalars['String']['output'];
  waveId: Scalars['Int']['output'];
  /** название волны (аналог stage_group_name) */
  waveName: Scalars['String']['output'];
};

export type StageGroupS21Student = {
  __typename?: 'StageGroupS21Student';
  /** Школа */
  safeSchool: SafeSchool;
  /** Параллель в Ш21 */
  stageGroupS21: StageGroupS21;
  /** Идентификатор связки студента и параллели */
  stageGroupStudentId: Scalars['ID']['output'];
  /** Идентификатор студента */
  studentId: Scalars['UUID']['output'];
};

/** Заявка на вступление в класс */
export type StageGroupStudentRequest = {
  __typename?: 'StageGroupStudentRequest';
  /** Время создания */
  createdTs: Scalars['DateTime']['output'];
  /** Группа (класс) */
  stageGroup: StageGroup;
  stageGroupStudentRequestId: Scalars['ID']['output'];
  /** Статус заявки */
  status: StageGroupStudentRequestStatus;
  /** Студент */
  student: Student;
  /** Время изменения */
  updatedTs?: Maybe<Scalars['DateTime']['output']>;
};

/** Статус заявки на вступление в класс */
export enum StageGroupStudentRequestStatus {
  /** Подтверждено */
  Confirmed = 'CONFIRMED',
  /** На подтверждении */
  PendingConfirmation = 'PENDING_CONFIRMATION',
  /** Отклонено */
  Rejected = 'REJECTED'
}

/** Уроки по группе по параллели */
export type StageGroupTimetable = {
  __typename?: 'StageGroupTimetable';
  lessons: Array<ExtendedLesson>;
  stageGroupName: Scalars['String']['output'];
};

/** Драфты уроков групп по классам */
export type StageGroupTimetableDraft = {
  __typename?: 'StageGroupTimetableDraft';
  /** Драфты уроков по ГКпП */
  lessonDrafts: Array<ExtendedLessonDraft>;
  /** Наименование класса */
  stageGroupName: Scalars['String']['output'];
};

/** Драфты уроков групп по классам */
export type StageGroupTimetableDraftInput = {
  /** Драфты уроков по ГКпП */
  lessonDrafts: Array<LessonDraft>;
  /** Идентификатор класса */
  stageGroupId: Scalars['ID']['input'];
};

export type StageGroupType = {
  __typename?: 'StageGroupType';
  id?: Maybe<Scalars['UUID']['output']>;
  /** ID школы */
  schoolId: Scalars['UUID']['output'];
  /** Название школы */
  schoolShortName: Scalars['String']['output'];
  /** ID класса для регистрации несовершеннолетних (18-) */
  stageGroupForJuvenilesId?: Maybe<Scalars['Float']['output']>;
  /** Название класса для регистрации несовершеннолетних */
  stageGroupForJuvenilesName?: Maybe<Scalars['String']['output']>;
  /** ID класса команд */
  stageGroupForTeamsId?: Maybe<Scalars['Float']['output']>;
  /** Название класса команд */
  stageGroupForTeamsName?: Maybe<Scalars['String']['output']>;
  /** ID основного (18+) класса */
  stageGroupId: Scalars['Float']['output'];
  /** Название основного класса */
  stageGroupName: Scalars['String']['output'];
  /** Указывает на тип школы: SCHOOL или UNIVERSITY */
  userType: Scalars['String']['output'];
};

/**
 * Единая модель учебного класса
 * Состоит из базовых и дополнительных полей:
 * Базовые поля заполняются всегда.
 * Дополнительные поля заполняются только по запросу клиента через кастомные резолверы, например StageGroupV2Resolver
 */
export type StageGroupV2 = {
  __typename?: 'StageGroupV2';
  /** академический год класса #academicYearId */
  academicYear: AcademicYear;
  /** идентификатор академического года, к которому относится класс */
  academicYearId: Scalars['ID']['output'];
  /** все ученики класса, включая неактивных */
  allStudents?: Maybe<Array<Student>>;
  /** классный руководитель #formMasterUserId */
  formMaster?: Maybe<User>;
  /** идентификатор пользователя, являющегося классным руководителем */
  formMasterUserId?: Maybe<Scalars['UUID']['output']>;
  /** не активные ученики класса */
  inactiveStudents?: Maybe<Array<Student>>;
  /** признак класса: активен или удален */
  isActive: Scalars['Boolean']['output'];
  /** является ли класс межклассовой группой (группой параллели) */
  isIntergroup: Scalars['Boolean']['output'];
  /**
   * базовые поля
   * идентификатор класса
   */
  stageGroupId: Scalars['ID']['output'];
  /** тип обучения класса */
  stageGroupLearningType: LearningTypeEnum;
  /** наименование класса */
  stageGroupName: Scalars['String']['output'];
  /** идентификатор (номер) учебной параллели, на которой располагается класс */
  stageId: Scalars['Int']['output'];
  /**
   * дополнительные поля
   * учебная параллель, которой принадлежит класс
   */
  stageInfo: Stage;
  /**
   * количество ГКпП в классе
   * учитываются только активные ГКпП с типом обучения #stageSubjectGroupLearningTypes
   */
  stageSubjectGroupCount: Scalars['Int']['output'];
  /** техническое поле. Типы обучения для агрегации дополнительных полей с информацией о ГКпП класса */
  stageSubjectGroupLearningTypes?: Maybe<Array<LearningTypeEnum>>;
  /**
   * ГКпП класса
   * учитываются только активные ГКпП с типом обучения #stageSubjectGroupLearningTypes
   */
  stageSubjectGroups?: Maybe<Array<ClassSubject>>;
  /** количество активных учеников в классе */
  studentCount: Scalars['Int']['output'];
  /** активные ученики класса */
  students?: Maybe<Array<Student>>;
  /** идентификатор набора учебных периодов, к которому привязан класс */
  studyPeriodSetId?: Maybe<Scalars['Int']['output']>;
};

export type StageGroupWithTimeslotSetId = {
  __typename?: 'StageGroupWithTimeslotSetId';
  stageGroup: StageGroup;
  timeslotSetId?: Maybe<Scalars['ID']['output']>;
};

/** Доступные и недоступные настройки мультикампусности для одной параллели определенной школы */
export type StageMulticampusSettingForRecovery = {
  __typename?: 'StageMulticampusSettingForRecovery';
  /** Доступные кампусы под восстановление для данной параллели */
  availableSchoolDependency?: Maybe<Array<SchoolDependency>>;
  /** id параллели */
  stageId: Scalars['ID']['output'];
  /** наименование параллели */
  stageName: Scalars['String']['output'];
  /** Недоступные кампусы под восстановление для данной параллели */
  unavailableSchoolDependency?: Maybe<Array<SchoolDependency>>;
};

/** План на Параллель по Предмету (stage_subject_plan_id) */
export type StagePlan = {
  __typename?: 'StagePlan';
  /** Последний день последнего модуля */
  endDate?: Maybe<Scalars['Date']['output']>;
  /** список Учебных Модулей в Плане с привязкой к датам и необходимому для достижения уровню */
  frames: Array<StagePlanFrame>;
  /** Идентификатор глобального плана, на основе которого создан этот план */
  globalStagePlanId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор (stage_subject_plans.stage_subject_plan_id) */
  id: Scalars['ID']['output'];
  /** Общая трудоемкость */
  laboriousness?: Maybe<Scalars['Int']['output']>;
  /** Количество модулей */
  modulesCount?: Maybe<Scalars['Int']['output']>;
  /** Параллель, для котоой составлен Учебный План */
  stage: Stage;
  /** статус Плана */
  status: PlanStatusEnum;
  /** Предмет, по которому составлен План на параллель */
  subject: Subject;
};

/** Учебный Модуль внутри Плана на Параллель */
export type StagePlanFrame = {
  __typename?: 'StagePlanFrame';
  /** Уровень, на котором Учебный Модуль объявляется достигнутым учеником */
  achieveLevel: Scalars['Float']['output'];
  /** Условия прохождения учебного модуля в плане */
  conditions: Array<PlanFrameCondition>;
  /** Длительность данного учебного модуля в днях */
  countOfDays: Scalars['Int']['output'];
  /** Идентификатор (stage_subject_plan_goals.stage_subject_plan_goal_id) */
  id: Scalars['ID']['output'];
  /** Примерная трудоемкость Учебного Модуля в часах в рамках текущего Плана */
  laboriousness: Scalars['Int']['output'];
  /** Учебный Модуль */
  module: StudyModule;
  /** Порядок следования учебных модулей */
  order: Scalars['Int']['output'];
  /** Дефолтный плейлист относящийся к данному модулю */
  playlist: TaskSet;
};

export type StagePlanFrameInput = {
  /** Уровень, на котором Учебный Модуль объявляется достигнутым учеником */
  achieveLevel: Scalars['Float']['input'];
  /** Условия прохождения Учебного Модуля */
  conditions: Array<PlanFrameConditionInput>;
  /** Количество дней рекомендуемых для прохождения Учебного Модуля */
  countOfDays: Scalars['Int']['input'];
  /** Идентификатор */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** Примерная трудоемкость Учебного Модуля в часах в рамках текущего Плана */
  laboriousness: Scalars['Int']['input'];
  /** Учебный Модуль */
  moduleId: Scalars['ID']['input'];
  /** Порядок Учебного Модуля в рамках Плана */
  order: Scalars['Int']['input'];
};

/** Правила подсчета дат для проекта */
export type StagePlanRules = {
  __typename?: 'StagePlanRules';
  /** Флаг, указывающий на игнорирование любых дедлайнов для модуля */
  deadlineFree: Scalars['Boolean']['output'];
  /** "Начать с ..." */
  ruleBeginFrom?: Maybe<Scalars['Int']['output']>;
  /** "Проверка" */
  ruleCheckFrom?: Maybe<Scalars['Int']['output']>;
  /** "Часы на проект" */
  ruleProjectHours?: Maybe<Scalars['Int']['output']>;
  /** "Регистрация" */
  ruleSignUpFrom?: Maybe<Scalars['Int']['output']>;
};

export type StageS21ClassPlans = {
  __typename?: 'StageS21ClassPlans';
  /** Список планов для групп по предмету */
  classPlans: Array<S21ClassPlan>;
  /** Идентификатор параллели */
  stageId: Scalars['ID']['output'];
  /** Название параллели */
  stageName?: Maybe<Scalars['String']['output']>;
};

/** Параллели со списками доступных учебных периодов */
export type StageStudyPeriods = {
  __typename?: 'StageStudyPeriods';
  stageId: Scalars['Int']['output'];
  stageName: Scalars['String']['output'];
  studyPeriods: Array<Maybe<StudyPeriod>>;
  userPeriodId?: Maybe<Scalars['Int']['output']>;
};

/** Предмет который преподается в конкретной Школе в конкретной Параллели */
export type StageSubject = {
  __typename?: 'StageSubject';
  /** Идентификатор (stage_subjects.stage_subject_id) */
  id: Scalars['ID']['output'];
  /**
   * Минимальное кол-во часов в год,
   *  выделенное на предмет среди классов одной параллели определенной школы по учебному плану
   */
  minHourInYearForSubject?: Maybe<Scalars['Int']['output']>;
  /** План по Предмету на Параллель */
  plan?: Maybe<StagePlan>;
  /** Параллель */
  stage: Stage;
  /** Предмет */
  subject?: Maybe<Subject>;
};

/** Итоговые оценки по предмету параллели */
export type StageSubjectFinalMarks = {
  __typename?: 'StageSubjectFinalMarks';
  /** Итоговые оценки за АП */
  marks: Array<AttestationPeriodFinalMark>;
  /** Идентификатор предмета параллели */
  stageSubjectId: Scalars['ID']['output'];
  /** Наименование предмета */
  subjectName: Scalars['String']['output'];
  /** Наименование тенанта */
  tenantShortName?: Maybe<Scalars['String']['output']>;
  /** Годовые оценки (за экзамен, аттестационные в зависимости от настроек) */
  yearMarks: Array<YearFinalMark>;
};

export type StageSubjectGroup = {
  __typename?: 'StageSubjectGroup';
  name: Scalars['String']['output'];
  personalizationLevel: Scalars['String']['output'];
  singleSubjectGroup: Scalars['Boolean']['output'];
  stageGroupId: Scalars['ID']['output'];
  stageSubjectGroupId: Scalars['ID']['output'];
  stageSubjectId: Scalars['ID']['output'];
  startDate?: Maybe<Scalars['DateTime']['output']>;
  teacherId: Scalars['UUID']['output'];
};

export type StageSubjectGroupAttestationEntryModel = {
  __typename?: 'StageSubjectGroupAttestationEntryModel';
  key: Scalars['String']['output'];
  stageSubjectGroupAttestation: StageSubjectGroupAttestationModel;
};

export type StageSubjectGroupAttestationInputModel = {
  /** id Графика Аттестационных периодов, по которому проходит аттестация по предмету в классе */
  attestationPeriodSetId?: InputMaybe<Scalars['ID']['input']>;
  /** Тип аттестации */
  attestationType: AttestationTypeModel;
  /** id класса */
  stageGroupId: Scalars['ID']['input'];
  /** id предмета */
  subjectId: Scalars['ID']['input'];
};

/**
 * Вид Аттестации, установленный для Класса по Предмету.
 * Распространяется на все ГКпП класса {@link #stageGroupId} по предмету {@link #subjectId}
 */
export type StageSubjectGroupAttestationModel = {
  __typename?: 'StageSubjectGroupAttestationModel';
  /** id Графика Аттестационных периодов, по которому проходит аттестация по предмету в классе */
  attestationPeriodSetId?: Maybe<Scalars['ID']['output']>;
  /** Тип аттестации */
  attestationType: AttestationTypeModel;
  /** id класса */
  stageGroupId: Scalars['ID']['output'];
  /** id предмета */
  subjectId: Scalars['ID']['output'];
};

/** Драфт гкпп */
export type StageSubjectGroupDraft = {
  __typename?: 'StageSubjectGroupDraft';
  /** Идентификатор драфта группы из таблицы 'stage_group_drafts' */
  stageGroupDraftId: Scalars['ID']['output'];
  /** Идентификатор драфта */
  stageSubjectGroupDraftId: Scalars['ID']['output'];
  /** Идентификатор предмета */
  subjectId: Scalars['ID']['output'];
  /** Идентификатор учителя */
  teacherId: Scalars['UUID']['output'];
};

/** Драфт гкпп входная модель */
export type StageSubjectGroupDraftInput = {
  /** Идентификатор драфта группы из таблицы 'stage_group_drafts' */
  stageGroupDraftId: Scalars['ID']['input'];
  /** Идентификатор драфта */
  stageSubjectGroupDraftId?: InputMaybe<Scalars['ID']['input']>;
  /** Идентификатор предмета */
  subjectId: Scalars['ID']['input'];
  /** Идентификатор учителя */
  teacherId: Scalars['UUID']['input'];
};

export type StageSubjectGroupExtended = {
  __typename?: 'StageSubjectGroupExtended';
  itemsCount: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  numberOfStudents: Scalars['Int']['output'];
  singleSubjectGroup: Scalars['Boolean']['output'];
  stageSubjectGroupId: Scalars['ID']['output'];
  stageSubjectId: Scalars['ID']['output'];
  subjectName: Scalars['String']['output'];
  teacherFullName: Scalars['String']['output'];
  teacherId: Scalars['UUID']['output'];
  teacherUserId: Scalars['UUID']['output'];
};

/** Фильтр для поиска ГКпП */
export type StageSubjectGroupFilter = {
  /** список учебных лет */
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  /** показывать ГКпП без КТП */
  showStageSubjectGroupsWithoutCalendarThematicPlan?: InputMaybe<Scalars['Boolean']['input']>;
  /** список параллелей */
  stageIds: Array<Scalars['ID']['input']>;
  /** список ГКпП */
  stageSubjectGroupIds: Array<Scalars['ID']['input']>;
  /** список предметов */
  subjectIds: Array<Scalars['ID']['input']>;
};

/** Информация о ГКпП в контексте ЭЖ */
export type StageSubjectGroupInfo = {
  __typename?: 'StageSubjectGroupInfo';
  /** Признак является ли контекстный пользователь учителем переданной ГКПП */
  isStageSubjectGroupTeacher: Scalars['Boolean']['output'];
  /** Класс в котором была создана ГКПП */
  stageGroup: StageGroup;
  /** Все ГКПП, созданные в классе запрошенной ГКпП (по тому же предмету) */
  stageSubjectGroups: Array<StageSubjectGroup>;
  /** Предмет ГКПП */
  subject: Subject;
};

/** Модель данных по гкпп */
export type StageSubjectGroupInfoForMarks = {
  __typename?: 'StageSubjectGroupInfoForMarks';
  /** Аттестационные периоды */
  attestationPeriods: Array<AttestationPeriod>;
  /** Обобщенная конфигурация оценивания */
  ratingConfiguration: RatingConfiguration;
  /** Параллель */
  stage: Stage;
  /** ГКПП */
  stageSubjectGroup: StageSubjectGroup;
  /** Подгруппы гкпп */
  stageSubjectSubgroups: Array<StageSubjectSubgroupForMarks>;
  /** Предмет */
  subject: Subject;
};

/** Модель ответа на запрос общей информации о ГКпП в контексте ЭЖ */
export type StageSubjectGroupInfoResponse = {
  __typename?: 'StageSubjectGroupInfoResponse';
  /** Тело ответа */
  data?: Maybe<StageSubjectGroupInfo>;
  /** Описание ошибки, возникшей в ходе выполнения запроса */
  error?: Maybe<EJournalError>;
  /** Признак успешности выполнения запроса */
  isSuccess: Scalars['Boolean']['output'];
};

export type StageSubjectGroupTaskCount = {
  __typename?: 'StageSubjectGroupTaskCount';
  stageGroup: StageGroup;
  stageSubjectGroup: StageSubjectGroup;
  studentTaskIds?: Maybe<Array<Scalars['ID']['output']>>;
  subject: Subject;
  taskCount: Scalars['Int']['output'];
};

/** Данные из журнала посещаемости, сгруппированный для одной группы по предмету */
export type StageSubjectGroupVisitJournal = {
  __typename?: 'StageSubjectGroupVisitJournal';
  /** Идентификатор учителя группы */
  groupTeacherId: Scalars['ID']['output'];
  /** Даты посещений (группы для колонок) */
  lessons: Array<VisitJournalLesson>;
  /** Строки журнала */
  rows: Array<VisitJournalRow>;
  /** Идентификатор группы по предмету */
  stageSubjectGroupId: Scalars['ID']['output'];
  /** Предмет */
  subject: Subject;
};

export type StageSubjectGroupsBySubjectTeacherResponse = {
  __typename?: 'StageSubjectGroupsBySubjectTeacherResponse';
  stageGroupTeacher: Array<StageGroup>;
  subjectGroupsTeacher: Array<SubjectGroupsTeacherResponse>;
  subjectTeacher: Array<Subject>;
};

export type StageSubjectGroupsByTeacherResponse = {
  __typename?: 'StageSubjectGroupsByTeacherResponse';
  stageSubjectGroupCount: Scalars['Int']['output'];
  stageSubjectGroups: Array<StageSubjectGroupTaskCount>;
};

export type StageSubjectGroupsTaskCountBySubjectTeacherResponse = {
  __typename?: 'StageSubjectGroupsTaskCountBySubjectTeacherResponse';
  containsMore3DaysNeedCheck: Scalars['Boolean']['output'];
  containsMore7DaysNeedCheck: Scalars['Boolean']['output'];
  countNeedCheckTasks: Scalars['Int']['output'];
  countStudentIdsForCurrentStageSubjectGroup: Scalars['Int']['output'];
  countUnreadMessages: Scalars['Int']['output'];
  stageGroupName: Scalars['String']['output'];
  stageSubjectGroup: StageSubjectGroup;
  stageSubjectGroupId: Scalars['ID']['output'];
  studentTaskIds?: Maybe<Array<Scalars['ID']['output']>>;
};

/** Итоговые оценки по предмету параллели */
export type StageSubjectStatisticsMarks = {
  __typename?: 'StageSubjectStatisticsMarks';
  /** Итоговые оценки за АП */
  marks: Array<AttestationPeriodStatisticsMark>;
  /** Идентификатор предмета параллели */
  stageSubjectId: Scalars['ID']['output'];
  /** Наименование предмета */
  subjectName: Scalars['String']['output'];
  /** Наименование тенанта */
  tenantShortName?: Maybe<Scalars['String']['output']>;
  /** Годовые оценки (за экзамен, аттестационные в зависимости от настроек) */
  yearMarks: Array<YearStatisticsMark>;
};

/** Модель подгруппы гкпп */
export type StageSubjectSubgroup = {
  __typename?: 'StageSubjectSubgroup';
  isDefault: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  stageSubjectGroupId: Scalars['ID']['output'];
  stageSubjectSubgroupId: Scalars['ID']['output'];
};

/** Модель подгруппы гкпп */
export type StageSubjectSubgroupForMarks = {
  __typename?: 'StageSubjectSubgroupForMarks';
  /** Подгруппа гкпп */
  stageSubjectSubgroup: StageSubjectSubgroup;
  /** Студенты подгруппы */
  subgroupStudents: Array<SubgroupStudent>;
};

export type StatisticReportMutations = {
  __typename?: 'StatisticReportMutations';
  /** Удаление Отчетных периодов */
  deleteReportPeriodSetById?: Maybe<Scalars['Boolean']['output']>;
  /** Сохранение отчетных периодов */
  saveReportPeriods?: Maybe<Scalars['Boolean']['output']>;
  /** Изменение флага включения "Тонкой настройки" отчетных периодов */
  saveReportPeriodsByStagesFlag?: Maybe<Scalars['Boolean']['output']>;
  /** Сохранение пользовательских настроек по отчетам */
  saveReportUserSettings?: Maybe<Scalars['Boolean']['output']>;
  /** Сохранение Отчетных периодов по параллелям для школы */
  saveSchoolReportPeriods?: Maybe<Scalars['Boolean']['output']>;
  /** Отправляет отчет прилежности ученика родителям */
  sendStudentDiligenceReportToParent: Scalars['Boolean']['output'];
};


export type StatisticReportMutationsDeleteReportPeriodSetByIdArgs = {
  reportPeriodSetId: Scalars['UUID']['input'];
};


export type StatisticReportMutationsSaveReportPeriodsArgs = {
  dateIntervals: Array<DateIntervalInput>;
};


export type StatisticReportMutationsSaveReportPeriodsByStagesFlagArgs = {
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
};


export type StatisticReportMutationsSaveReportUserSettingsArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  reportName: Scalars['String']['input'];
  reportUserSettingsInput: Array<ReportUserSettingInput>;
};


export type StatisticReportMutationsSaveSchoolReportPeriodsArgs = {
  schoolReportPeriodsInput: SchoolReportPeriodsInput;
};


export type StatisticReportMutationsSendStudentDiligenceReportToParentArgs = {
  studentId: Scalars['UUID']['input'];
};

export type StatisticReportQueries = {
  __typename?: 'StatisticReportQueries';
  /** Мониторинг выполнения заданий учениками с состояниями загрузка в Excel */
  downloadModuleStudentsTaskStatusExcel: ReportExcelFile;
  /** Обзор работы пользователей платформы. Выгрузка в Excel */
  downloadSchoolMonitoringExcel: ReportExcelFile;
  /** Отчет о завершенных модулях по ученикам Excel */
  downloadStudentsCompletedGoalsReport: ReportExcelFile;
  /** Отчет "Итоговые оценки для классного руководителя" по ученикам и всем предметам. Выгрузка в Excel. */
  downloadStudentsFinalMarksForFormMaster: ReportExcelFile;
  /** Мониторинг выполнения заданий учениками загрузка в Excel */
  downloadStudentsGoalLevelsExcel: ReportExcelFile;
  /** Итоговые оценки для ученика. Выгрузка в Excel */
  downloadStudyPeriodMarksByStudentExcel: ReportExcelFile;
  /** Оценки по предмету и параллели загрузка в Excel */
  downloadStudyPeriodsSubjectMarksExcel: ReportExcelFile;
  /** Оценки по предмету загрузка в Excel */
  downloadStudyPeriodsSubjectSchoolMarksExcel: ReportExcelFile;
  /** Оценки по учителю и параллели загрузка в Excel */
  downloadStudyPeriodsTeacherMarksExcel: ReportExcelFile;
  /**
   * Обзор обучения учителей 3ья волна. Выгрузка в Excel.
   * @deprecated Использовать downloadTeacherTrainings3rdWaveDetailedV2
   */
  downloadTeacherTrainings3rdWave: ReportExcelFile;
  /** @deprecated Использовать downloadTeacherTrainings3rdWaveDetailedV3 добавлен параметр showDate: Boolean! */
  downloadTeacherTrainings3rdWaveDetailed: ReportExcelFile;
  downloadTeacherTrainings3rdWaveDetailedV2: ReportExcelFile;
  downloadTeacherTrainings3rdWaveDetailedV3: ReportExcelFile;
  /** Обзор обучения учителей 'Персонализированное образование' детальный. Выгрузка в Excel. */
  downloadTeachersPersonalTrainingDetailedExcel: ReportExcelFile;
  /** Обзор обучения учителей 'Персонализированное образование'. Выгрузка в Excel. */
  downloadTeachersPersonalTrainingExcel: ReportExcelFile;
  /** Обзор обучения учителей детальный. Выгрузка в Excel. */
  downloadTeachersTrainingDetailedExcel: ReportExcelFile;
  /** Обзор обучения учителей. Выгрузка в Excel. */
  downloadTeachersTrainingExcel: ReportExcelFile;
  /** Обзор работы пользователей платформы. Список учителей/учеников которые 'Заходили на платформу'. Выгрузка в Excel */
  downloadUsersLoggingFioReport: ReportExcelFile;
  /** @deprecated Под удаление. EDU-44903 */
  getAcademicPerformanceAllPlansFeatureFlagsPerSchool: Array<FeatureFlagsPerSchool>;
  /** @deprecated Под удаление. EDU-44903 */
  getAcademicPerformanceForStudentFeatureFlagsPerSchool: Array<FeatureFlagsPerSchool>;
  /** @deprecated Под удаление. EDU-44903 */
  getAcademicPerformanceForTeacherFeatureFlagsPerSchool: Array<FeatureFlagsPerSchool>;
  /**
   * Аттестационные периоды
   * @deprecated Под удаление. EDU-44903
   */
  getAttestationPeriodsForSelectorByStage: Array<Maybe<SelectorByAttestationPeriod>>;
  /** Метод для получения умолчательного интервала дат для отчетов */
  getDateIntervalForReport: DateInterval;
  /** @deprecated Под удаление. EDU-77019 */
  getDefaultDateIntervalForReportByStageId: DateInterval;
  getDefaultDateIntervalForReportByStageIdNullable?: Maybe<DateInterval>;
  getDefaultDateIntervalForReportByUserId?: Maybe<DateInterval>;
  /** Получение списка направлений по школе-организатору с именами программ и предметов для отчета Обзор обучения учителей */
  getLearningProgramDirectionsForReport: Array<LearningProgramDirectionViewForReport>;
  /** @deprecated Под удаление. EDU-44903 */
  getMarkDetailsForStudentFeatureFlagsPerSchool: Array<FeatureFlagsPerSchool>;
  /** @deprecated Под удаление. EDU-44903 */
  getMarkDetailsForTeacherFeatureFlagsPerSchool: Array<FeatureFlagsPerSchool>;
  /** @deprecated Под удаление. EDU-44903 */
  getMarksGroupFeatureFlagsPerSchool: Array<FeatureFlagsPerSchool>;
  /** @deprecated Под удаление. EDU-44903 */
  getModuleProgressBySubjectsFeatureFlagsPerSchool: Array<FeatureFlagsPerSchool>;
  /** Статистика по модулю, вызывается на конкретном модуле */
  getModuleStatisticsReport: Array<ModuleStatistics>;
  /** Мониторинг выполнения заданий учениками с состояниями */
  getModuleStudentsTaskStatus: StudentsGoalsTaskStatus;
  /** @deprecated Под удаление. EDU-44903 */
  getOverviewAdminFeatureFlagsPerSchool: Array<FeatureFlagsPerSchool>;
  /** @deprecated Под удаление. EDU-44903 */
  getOverviewFeatureFlagsPerSchool: Array<FeatureFlagsPerSchool>;
  /** Школьные периоды для фильтрации */
  getPeriodsForSelectorByStage: Array<Maybe<Selector>>;
  getPeriodsForSelectorByUserId: Array<Maybe<Selector>>;
  /** Возвращает список отчетов, доступных пользователю */
  getReportList: Array<Maybe<ReportGroup>>;
  /** Отчетные периоды */
  getReportPeriods?: Maybe<DateIntervals>;
  getReportPeriodsByStageId?: Maybe<DateIntervals>;
  /**
   * Настройка отчетных периодов по умолчанию для школ и параллелей "Тонкая настройка"
   * Получение флага включения "Тонкой настройки" отчетных периодов
   */
  getReportPeriodsByStagesFlag: Scalars['Boolean']['output'];
  /** Получение флага "Уровень видимости данных в синхронных отчетах" */
  getReportsDataAccessLevelFlag: ReportsDataAccessLevel;
  /** Обзор работы пользователей платформы. Список учителей/учеников которые 'Заходили на платформу'. */
  getSchoolMonitoringDetailed: Array<Scalars['String']['output']>;
  /** Получение Отчетных периодов по параллелям для школы */
  getSchoolReportPeriods: Array<SchoolReportPeriods>;
  /** Список классов для завуча, классного руководителя или консультирующего учителя */
  getStageGroupsBySchoolAndFormMasterOrConsultingTeacher: Array<StageGroupInfo>;
  /** Возвращает параллели с доступными учебными периодами */
  getStagesWithStudyPeriods: Array<Maybe<StageStudyPeriods>>;
  /** @deprecated Под удаление. EDU-44903 */
  getStatisticModuleTabFlagsPerSchool: Array<FeatureFlagsPerSchool>;
  /** @deprecated Под удаление. EDU-44903 */
  getStatisticTaskTabFlagsPerSchool: Array<FeatureFlagsPerSchool>;
  /** Форма достигнутого уровня по модулю */
  getStudentAchievedGoals: Array<StudentGoalAchievement>;
  /** Не реализован */
  getStudentSchoolMetrics: Array<StudentSchoolMetrics>;
  /** Возвращает данные для отчета прилежности учеников */
  getStudentsDiligence: Array<StudentDiligence>;
  /** Отчет "Итоговые оценки для классного руководителя" по ученикам и всем предметам */
  getStudentsFinalMarksForFormMaster: StudentFinalMarksForFormMasterModel;
  /** @deprecated Под удаление. EDU-44903 */
  getStudentsFinalMarksForFormMasterFeatureFlagsPerSchool: Array<FeatureFlagsPerSchool>;
  /** Мониторинг выполнения заданий учениками */
  getStudentsGoalLevels: StudentsGoalsResults;
  /** Значение флага отчёта о прохождении */
  getStudentsPlanExecutionPerSchool: Array<FeatureFlagsPerSchool>;
  /** Получение списка предметов для отчета по успеваемости */
  getStudyPeriodDailyStudentSubjects: Array<StudyPeriodDailyStudentSubject>;
  /** Итоговые оценки для ученика */
  getStudyPeriodMarksByStudent: Array<StudyPeriodMark>;
  /** @deprecated Под удаление. EDU-44903 */
  getStudyPeriodMarksForStudentFeatureFlagsPerSchool: Array<FeatureFlagsPerSchool>;
  /** @deprecated Под удаление. EDU-44903 */
  getStudyPeriodMarksForTeacherFeatureFlagsPerSchool: Array<FeatureFlagsPerSchool>;
  /** Оценки по предмету и параллели */
  getStudyPeriodsSubjectMarks: StudyPeriodSubjectMarks;
  /** Оценки по предмету */
  getStudyPeriodsSubjectSchoolMarks: StudyPeriodSubjectSchoolMarks;
  /** Оценки по учителю и параллели. Список предметов по школе и периодам */
  getStudyPeriodsSubjects: Array<StudyPeriodDailyStudentSubject>;
  /** Оценки по учителю и параллели */
  getStudyPeriodsTeacherMarks: StudyPeriodTeacherMarks;
  /** Метрики на вкладке задания */
  getTaskCompletedMetrics: TaskCompletedMetrics;
  /** Публичные метрики по заданию */
  getTaskPublicMetrics: TaskPublicMetrics;
  /** @deprecated Под удаление. EDU-44903 */
  getTasksMonitoringFeatureFlagsPerSchool: Array<FeatureFlagsPerSchool>;
  /** @deprecated Под удаление. EDU-44903 */
  getTasksOnCheckFeatureFlagsPerSchool: Array<FeatureFlagsPerSchool>;
  /** @deprecated Под удаление. EDU-44903 */
  getTasksOnCheckForMoreThan7DaysDetailedFeatureFlagsPerSchool: Array<FeatureFlagsPerSchool>;
  getTeacherMetricsFeatureFlagsPerSchool: Array<FeatureFlagsPerSchool>;
  /** Обзор обучения учителей 'Персонализированное образование' */
  getTeacherPersonalTrainings: TeacherPersonalTraining;
  /** 'Обзор работы учителей'. Выгрузка в Excel. */
  getTeacherSchoolMetricsExcelFiltered: ReportExcelFile;
  /** Фильтр отчета 'Обзор работы учителей' */
  getTeacherSchoolMetricsFilter: Array<TeacherSchoolMetricsFilter>;
  /** Получение данных отчета 'Обзор работы учителей' с фильтром */
  getTeacherSchoolMetricsFiltered: Array<TeacherSchoolMetrics>;
  /** График кол-ва непроверенных заданий */
  getTeacherTasksReviewedMetrics: Array<TeacherSchoolMetrics>;
  /** Обзор обучения учителей */
  getTeacherTrainings: TeacherTraining;
  /**
   * Обзор обучения учителей 3ья волна
   * @deprecated Использовать getTeacherTrainings3rdWaveDetailedV2
   */
  getTeacherTrainings3rdWave: TeacherTraining3rdWave;
  getTeacherTrainings3rdWaveDetailed: TeacherTraining3rdWaveDetailed;
  getTeacherTrainings3rdWaveDetailedV2: TeacherTraining3rdWaveDetailed;
  /** Обзор обучения учителей детальный */
  getTeacherTrainingsDetailed: TeacherTrainingDetailed;
  /** @deprecated Под удаление. EDU-44903 */
  getTeacherTrainingsDetailedReportFeatureFlagsPerSchool: Array<FeatureFlagsPerSchool>;
  /** Обзор обучения учителей 'Персонализированное образование' детальный. */
  getTeacherTrainingsPersonalDetailed: TeacherPersonalTrainingDetailed;
  /** @deprecated Под удаление. EDU-44903 */
  getTeacherTrainingsReportFeatureFlagsPerSchool: Array<FeatureFlagsPerSchool>;
  /** Отчет о завершенных модулях по ученикам */
  loadStudentsCompletedGoalsReport: Array<StudentCompletedGoalsInfo>;
};


export type StatisticReportQueriesDownloadModuleStudentsTaskStatusExcelArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  goalId: Scalars['Int']['input'];
  goalLevelId: Scalars['Int']['input'];
  reportDateTime: Scalars['String']['input'];
  stageSubjectGroupId: Scalars['Int']['input'];
  studyPeriodId?: InputMaybe<Scalars['Int']['input']>;
};


export type StatisticReportQueriesDownloadSchoolMonitoringExcelArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  reportDateTime: Scalars['String']['input'];
  schoolMonitoringInput?: InputMaybe<SchoolMonitoringInput>;
};


export type StatisticReportQueriesDownloadStudentsCompletedGoalsReportArgs = {
  modeLevel4?: InputMaybe<Scalars['Boolean']['input']>;
  stageGroupIds: Array<Scalars['ID']['input']>;
  stageIds: Array<Scalars['ID']['input']>;
  stageSubjectGroupIds: Array<Scalars['ID']['input']>;
  subjectIds: Array<Scalars['ID']['input']>;
  teacherIds: Array<Scalars['UUID']['input']>;
};


export type StatisticReportQueriesDownloadStudentsFinalMarksForFormMasterArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  currentRole?: InputMaybe<Scalars['String']['input']>;
  periodEndDate: Scalars['Date']['input'];
  periodStartDate: Scalars['Date']['input'];
  reportDateTime: Scalars['String']['input'];
  stageGroupId: Scalars['Int']['input'];
};


export type StatisticReportQueriesDownloadStudentsGoalLevelsExcelArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  goalId: Scalars['Int']['input'];
  reportDateTime: Scalars['String']['input'];
  stageSubjectGroupId: Scalars['Int']['input'];
  studyPeriodId?: InputMaybe<Scalars['Int']['input']>;
};


export type StatisticReportQueriesDownloadStudyPeriodMarksByStudentExcelArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  currentRole?: InputMaybe<Scalars['String']['input']>;
  reportDateTime: Scalars['String']['input'];
  studentId: Scalars['UUID']['input'];
};


export type StatisticReportQueriesDownloadStudyPeriodsSubjectMarksExcelArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  currentRole?: InputMaybe<Scalars['String']['input']>;
  reportDateTime: Scalars['String']['input'];
  reportName: Scalars['String']['input'];
};


export type StatisticReportQueriesDownloadStudyPeriodsSubjectSchoolMarksExcelArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  currentRole?: InputMaybe<Scalars['String']['input']>;
  reportDateTime: Scalars['String']['input'];
  reportName: Scalars['String']['input'];
};


export type StatisticReportQueriesDownloadStudyPeriodsTeacherMarksExcelArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  currentRole?: InputMaybe<Scalars['String']['input']>;
  reportDateTime: Scalars['String']['input'];
  reportName: Scalars['String']['input'];
  subjectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  transparent: Scalars['Boolean']['input'];
};


export type StatisticReportQueriesDownloadTeacherTrainings3rdWaveArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  learningProgramDirectionId: Scalars['Int']['input'];
  reportDateTime: Scalars['String']['input'];
};


export type StatisticReportQueriesDownloadTeacherTrainings3rdWaveDetailedArgs = {
  learningProgramDirectionId: Scalars['Int']['input'];
  reportDateTime: Scalars['String']['input'];
};


export type StatisticReportQueriesDownloadTeacherTrainings3rdWaveDetailedV2Args = {
  learningProgramDirectionId: Scalars['Int']['input'];
  periodEndDate?: InputMaybe<Scalars['Date']['input']>;
  periodStartDate?: InputMaybe<Scalars['Date']['input']>;
  reportDateTime: Scalars['String']['input'];
};


export type StatisticReportQueriesDownloadTeacherTrainings3rdWaveDetailedV3Args = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  learningProgramDirectionId: Scalars['Int']['input'];
  periodEndDate?: InputMaybe<Scalars['Date']['input']>;
  periodStartDate?: InputMaybe<Scalars['Date']['input']>;
  reportDateTime: Scalars['String']['input'];
  showDate: Scalars['Boolean']['input'];
};


export type StatisticReportQueriesDownloadTeachersPersonalTrainingDetailedExcelArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  reportDateTime: Scalars['String']['input'];
};


export type StatisticReportQueriesDownloadTeachersPersonalTrainingExcelArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  reportDateTime: Scalars['String']['input'];
};


export type StatisticReportQueriesDownloadTeachersTrainingDetailedExcelArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  reportDateTime: Scalars['String']['input'];
};


export type StatisticReportQueriesDownloadTeachersTrainingExcelArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  reportDateTime: Scalars['String']['input'];
};


export type StatisticReportQueriesDownloadUsersLoggingFioReportArgs = {
  date: Scalars['Date']['input'];
  isTeachers: Scalars['Boolean']['input'];
  reportDateTime: Scalars['String']['input'];
  schoolId: Scalars['UUID']['input'];
};


export type StatisticReportQueriesGetAttestationPeriodsForSelectorByStageArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  stageId: Scalars['ID']['input'];
};


export type StatisticReportQueriesGetDefaultDateIntervalForReportByStageIdArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  stageId: Scalars['ID']['input'];
};


export type StatisticReportQueriesGetDefaultDateIntervalForReportByStageIdNullableArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  stageId: Scalars['ID']['input'];
};


export type StatisticReportQueriesGetDefaultDateIntervalForReportByUserIdArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  userId: Scalars['UUID']['input'];
};


export type StatisticReportQueriesGetModuleStatisticsReportArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  goalId: Scalars['Int']['input'];
};


export type StatisticReportQueriesGetModuleStudentsTaskStatusArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  goalId: Scalars['Int']['input'];
  goalLevelId: Scalars['Int']['input'];
  stageSubjectGroupId: Scalars['Int']['input'];
  studyPeriodId?: InputMaybe<Scalars['Int']['input']>;
};


export type StatisticReportQueriesGetPeriodsForSelectorByStageArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  stageId: Scalars['ID']['input'];
};


export type StatisticReportQueriesGetPeriodsForSelectorByUserIdArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  userId: Scalars['UUID']['input'];
};


export type StatisticReportQueriesGetReportListArgs = {
  currentRole: Scalars['String']['input'];
};


export type StatisticReportQueriesGetReportPeriodsByStageIdArgs = {
  stageId: Scalars['ID']['input'];
};


export type StatisticReportQueriesGetSchoolMonitoringDetailedArgs = {
  date: Scalars['Date']['input'];
  isTeacher: Scalars['Boolean']['input'];
  schoolId: Scalars['UUID']['input'];
};


export type StatisticReportQueriesGetStageGroupsBySchoolAndFormMasterOrConsultingTeacherArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  currentRole?: InputMaybe<Scalars['String']['input']>;
};


export type StatisticReportQueriesGetStagesWithStudyPeriodsArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  reportName: Scalars['String']['input'];
};


export type StatisticReportQueriesGetStudentAchievedGoalsArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  goalId: Scalars['Int']['input'];
  studentId: Scalars['UUID']['input'];
};


export type StatisticReportQueriesGetStudentSchoolMetricsArgs = {
  studentSchoolMetricsInput?: InputMaybe<SchoolMonitoringInput>;
};


export type StatisticReportQueriesGetStudentsDiligenceArgs = {
  stageGroupIds: Array<Scalars['ID']['input']>;
  stageIds: Array<Scalars['ID']['input']>;
  stageSubjectGroupIds: Array<Scalars['ID']['input']>;
  subjectIds: Array<Scalars['ID']['input']>;
  teacherIds: Array<Scalars['UUID']['input']>;
};


export type StatisticReportQueriesGetStudentsFinalMarksForFormMasterArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  currentRole?: InputMaybe<Scalars['String']['input']>;
  periodEndDate: Scalars['Date']['input'];
  periodStartDate: Scalars['Date']['input'];
  stageGroupId: Scalars['Int']['input'];
};


export type StatisticReportQueriesGetStudentsGoalLevelsArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  goalId: Scalars['Int']['input'];
  stageSubjectGroupId: Scalars['Int']['input'];
  studyPeriodId?: InputMaybe<Scalars['Int']['input']>;
};


export type StatisticReportQueriesGetStudyPeriodDailyStudentSubjectsArgs = {
  endDate: Scalars['DateTime']['input'];
  stageGroupId?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  startDate: Scalars['DateTime']['input'];
  studentId?: InputMaybe<Scalars['UUID']['input']>;
};


export type StatisticReportQueriesGetStudyPeriodMarksByStudentArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  currentRole?: InputMaybe<Scalars['String']['input']>;
  studentId: Scalars['UUID']['input'];
};


export type StatisticReportQueriesGetStudyPeriodsSubjectMarksArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  currentRole?: InputMaybe<Scalars['String']['input']>;
  reportName: Scalars['String']['input'];
};


export type StatisticReportQueriesGetStudyPeriodsSubjectSchoolMarksArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  currentRole?: InputMaybe<Scalars['String']['input']>;
  reportName: Scalars['String']['input'];
};


export type StatisticReportQueriesGetStudyPeriodsSubjectsArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  reportName: Scalars['String']['input'];
};


export type StatisticReportQueriesGetStudyPeriodsTeacherMarksArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  currentRole?: InputMaybe<Scalars['String']['input']>;
  reportName: Scalars['String']['input'];
  subjectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type StatisticReportQueriesGetTaskCompletedMetricsArgs = {
  schoolId: Scalars['UUID']['input'];
  taskId: Scalars['Int']['input'];
};


export type StatisticReportQueriesGetTaskPublicMetricsArgs = {
  schoolId: Scalars['UUID']['input'];
  taskId: Scalars['Int']['input'];
};


export type StatisticReportQueriesGetTeacherPersonalTrainingsArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
};


export type StatisticReportQueriesGetTeacherSchoolMetricsExcelFilteredArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  reportDateTime: Scalars['String']['input'];
  teacherSchoolMetricsInput: TeacherSchoolMetricsExcelInput;
};


export type StatisticReportQueriesGetTeacherSchoolMetricsFilterArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['Date']['input'];
  startDate: Scalars['Date']['input'];
};


export type StatisticReportQueriesGetTeacherSchoolMetricsFilteredArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  teacherSchoolMetricsInput?: InputMaybe<TeacherSchoolMetricsInput>;
};


export type StatisticReportQueriesGetTeacherTasksReviewedMetricsArgs = {
  currentRole: Scalars['String']['input'];
  teacherTasksReviewedMetricsInput?: InputMaybe<SchoolMonitoringInput>;
};


export type StatisticReportQueriesGetTeacherTrainingsArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
};


export type StatisticReportQueriesGetTeacherTrainings3rdWaveArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  learningProgramDirectionId: Scalars['Int']['input'];
};


export type StatisticReportQueriesGetTeacherTrainings3rdWaveDetailedArgs = {
  learningProgramDirectionId: Scalars['Int']['input'];
};


export type StatisticReportQueriesGetTeacherTrainings3rdWaveDetailedV2Args = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  learningProgramDirectionId: Scalars['Int']['input'];
  periodEndDate?: InputMaybe<Scalars['Date']['input']>;
  periodStartDate?: InputMaybe<Scalars['Date']['input']>;
};


export type StatisticReportQueriesGetTeacherTrainingsDetailedArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
};


export type StatisticReportQueriesGetTeacherTrainingsPersonalDetailedArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
};


export type StatisticReportQueriesLoadStudentsCompletedGoalsReportArgs = {
  stageGroupIds: Array<Scalars['ID']['input']>;
  stageIds: Array<Scalars['ID']['input']>;
  stageSubjectGroupIds: Array<Scalars['ID']['input']>;
  studentIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  subjectIds: Array<Scalars['ID']['input']>;
  teacherIds: Array<Scalars['UUID']['input']>;
};

/** Данные по текущим оценкам */
export type StatisticsCurrentMarksData = {
  __typename?: 'StatisticsCurrentMarksData';
  /** Общее кол-во уроков за период */
  lessonsNumber: Scalars['Int']['output'];
  /** Текущие оценки */
  marks: Array<EJournalStudentMark>;
  /** Кол-во пропущенных уроков за период */
  missedLessons: Scalars['Int']['output'];
  /** Модель "Учителя по предмету" как пользователя */
  userAccountOfSubjectTeacher: UserAccount;
};

/** Ответ на запрос текущих оценок */
export type StatisticsCurrentMarksDataResponse = {
  __typename?: 'StatisticsCurrentMarksDataResponse';
  /** Данные */
  data?: Maybe<StatisticsCurrentMarksData>;
  /** Ошибки */
  error?: Maybe<StatisticsMarksError>;
  /** Успешность операции */
  isSuccess: Scalars['Boolean']['output'];
};

/** Модель запроса текущих оценок */
export type StatisticsCurrentMarksRequest = {
  /** Идентификатор АП */
  periodId: Scalars['ID']['input'];
  /** Идентификатор типа АП */
  periodTypeId: Scalars['ID']['input'];
  /** Идентификатор предмета параллели */
  stageSubjectId: Scalars['ID']['input'];
  /** Идентификатор пользователя ученика */
  userId: Scalars['ID']['input'];
};

/** Коды ошибок */
export enum StatisticsMarkErrorCode {
  /** Аттестационные периоды не найдены */
  NoAttestationPeriodsFound = 'NO_ATTESTATION_PERIODS_FOUND',
  /** Группы студентов не найдены */
  NoStageGroupsFound = 'NO_STAGE_GROUPS_FOUND'
}

/** Ответ данных об уроке */
export type StatisticsMarkLesson = {
  __typename?: 'StatisticsMarkLesson';
  /** Дата урока */
  date: Scalars['Date']['output'];
  /** Время окончания урока */
  lessonEnd: Scalars['Time']['output'];
  /** Время начала урока */
  lessonStart: Scalars['Time']['output'];
};

/** Предметы параллели */
export type StatisticsMarkStageSubject = {
  __typename?: 'StatisticsMarkStageSubject';
  /** Идентификатор предмета параллели */
  stageSubjectId: Scalars['ID']['output'];
  /** Наименование предмета */
  subjectName: Scalars['String']['output'];
  /** Наименование тенанта */
  tenantShortName?: Maybe<Scalars['String']['output']>;
};

/** Данные по финальным оценкам */
export type StatisticsMarksData = {
  __typename?: 'StatisticsMarksData';
  /** Итоговые оценки по графикам аттестационных периодов */
  attestationPeriodSetMarks: Array<AttestationPeriodSetStatisticsMarks>;
  /** Типы итоговых оценок */
  markTypes: Array<EJournalFinalStudentMarkType>;
  /** Предметы параллели */
  stageSubjects: Array<StatisticsMarkStageSubject>;
};

/** Ответ на запрос финальных оценок */
export type StatisticsMarksDataResponse = {
  __typename?: 'StatisticsMarksDataResponse';
  /** Данные */
  data?: Maybe<StatisticsMarksData>;
  /** Ошибки */
  error?: Maybe<StatisticsMarksError>;
  /** Успешность операции */
  isSuccess: Scalars['Boolean']['output'];
};

/** Модель ошибки */
export type StatisticsMarksError = {
  __typename?: 'StatisticsMarksError';
  /** Код ошибки */
  errorCode: StatisticsMarkErrorCode;
};

export type StatisticsMarksQueries = {
  __typename?: 'StatisticsMarksQueries';
  /** Запрос списка академических годов школы */
  getAcademicYears: Array<AcademicYear>;
  /** Запрос данных урока */
  getLesson: StatisticsMarkLesson;
  /** Запрос данных по классу */
  getStageGroupsV2ForStatisticsMarks: Array<StageGroupV2>;
  /** Запрос текущих оценок */
  getStatisticsCurrentMarks: StatisticsCurrentMarksDataResponse;
  /** Запрос финальных оценок для статистики */
  getStatisticsMarks: StatisticsMarksDataResponse;
  /** Показывать ли пользователю страницу статистики */
  isStatisticsEnabledForUser: Scalars['Boolean']['output'];
};


export type StatisticsMarksQueriesGetLessonArgs = {
  lessonId: Scalars['ID']['input'];
};


export type StatisticsMarksQueriesGetStageGroupsV2ForStatisticsMarksArgs = {
  academicYearId: Scalars['ID']['input'];
};


export type StatisticsMarksQueriesGetStatisticsCurrentMarksArgs = {
  statisticsCurrentMarksRequest: StatisticsCurrentMarksRequest;
};


export type StatisticsMarksQueriesGetStatisticsMarksArgs = {
  statisticsMarksRequest: StatisticsMarksRequest;
};

/** Модель запроса финальных оценок */
export type StatisticsMarksRequest = {
  /** Идентификатор учебного года */
  academicYearId: Scalars['ID']['input'];
  /** Идентификатор предмета параллели */
  stageSubjectIds: Array<Scalars['ID']['input']>;
  /** Идентификатор пользователя ученика */
  userId: Scalars['ID']['input'];
};

export type StatusAndTaskCount = {
  __typename?: 'StatusAndTaskCount';
  taskCount: Scalars['Int']['output'];
  taskStatus: TaskStatusEnum;
};

export type StatusCount = {
  __typename?: 'StatusCount';
  count?: Maybe<Scalars['Int']['output']>;
  status: Scalars['String']['output'];
};

export type StatusModulesReport = {
  __typename?: 'StatusModulesReport';
  setStatusTime: Scalars['DateTime']['output'];
  status: Scalars['String']['output'];
};

export type StringBooleanMapEntry = {
  __typename?: 'StringBooleanMapEntry';
  key: Scalars['String']['output'];
  value?: Maybe<Scalars['Boolean']['output']>;
};

export type Student = {
  __typename?: 'Student';
  class: StageGroup;
  digitalSkills: Array<SoftSkillPower>;
  /** @deprecated Field no longer supported */
  goals: Array<PersonalGoal>;
  id: Scalars['ID']['output'];
  /** @deprecated Field no longer supported */
  personalPerformance: Scalars['String']['output'];
  school: SafeSchool;
  softSkills: Array<SoftSkillPower>;
  user: User;
  userProfile: UserProfile;
};

/** Пара <идентификатор студента, идентифкатор задания> в рамках миграции этому студенту будет зачтено это задание */
export type Student2TaskPairForAcceptInput = {
  /** edu_power_global.students.student_id */
  studentId: Scalars['UUID']['input'];
  /** edu_power_content.tasks.task_id */
  taskId: Scalars['ID']['input'];
};

export type StudentAcademicPerformance = {
  __typename?: 'StudentAcademicPerformance';
  finalMark: Scalars['Int']['output'];
  goalLevelPercent: Scalars['Int']['output'];
  levelPercentDetails?: Maybe<Array<StudentGoalLevelPercentDetail>>;
  markValue: Scalars['Int']['output'];
  percent: Scalars['Int']['output'];
  stageGroupName: Scalars['String']['output'];
  stageId: Scalars['Int']['output'];
  stageSubjectGroupId: Scalars['Int']['output'];
  stageSubjectSubgroupStudentId: Scalars['Int']['output'];
  studentId: Scalars['UUID']['output'];
  studentModuleInfoList: Array<StudentModuleStatus>;
  studentName: Scalars['String']['output'];
  studentUserId: Scalars['UUID']['output'];
  studyPeriodId: Scalars['Int']['output'];
  studyPeriodName?: Maybe<Scalars['String']['output']>;
  subjectId: Scalars['Int']['output'];
  subjectModuleSize: Scalars['Int']['output'];
  subjectName: Scalars['String']['output'];
  teacherId: Scalars['UUID']['output'];
  teacherName: Scalars['String']['output'];
  testPercent: Scalars['Int']['output'];
  testPercentDetails?: Maybe<Array<StudentTestPercentDetail>>;
};

/** Статистика. Успеваемость учеников расширенная */
export type StudentAcademicPerformanceExpanded = {
  __typename?: 'StudentAcademicPerformanceExpanded';
  achievedTime?: Maybe<Scalars['DateTime']['output']>;
  daysBeforeEndDate?: Maybe<Scalars['Int']['output']>;
  endDate: Scalars['Date']['output'];
  goalAvatarUrl?: Maybe<Scalars['String']['output']>;
  goalId: Scalars['Int']['output'];
  goalLevelFourTaskCnt?: Maybe<Scalars['Int']['output']>;
  goalLevelOneTaskCnt?: Maybe<Scalars['Int']['output']>;
  goalLevelThreeTaskCnt?: Maybe<Scalars['Int']['output']>;
  goalLevelTwoTaskCnt?: Maybe<Scalars['Int']['output']>;
  goalName: Scalars['String']['output'];
  goalNumber: Scalars['Int']['output'];
  goalStatus: Scalars['Int']['output'];
  hidePercent: Scalars['Boolean']['output'];
  isHardEndDate: Scalars['Boolean']['output'];
  mandatoryCount?: Maybe<Scalars['Int']['output']>;
  markValue: Scalars['Int']['output'];
  maxArchLevel: Scalars['String']['output'];
  percent: Scalars['Int']['output'];
  plan: Scalars['Int']['output'];
  playListCount?: Maybe<Scalars['Int']['output']>;
  stageGroupName: Scalars['String']['output'];
  stageId: Scalars['Int']['output'];
  stageSubjectGroupId: Scalars['Int']['output'];
  stageSubjectGroupName?: Maybe<Scalars['String']['output']>;
  stageSubjectSubgroupStudentId: Scalars['Int']['output'];
  startDate: Scalars['Date']['output'];
  studentId: Scalars['UUID']['output'];
  studentName: Scalars['String']['output'];
  studentUserId: Scalars['UUID']['output'];
  studyPeriodId: Scalars['Int']['output'];
  studyPeriodName?: Maybe<Scalars['String']['output']>;
  subjectId: Scalars['Int']['output'];
  subjectName: Scalars['String']['output'];
  taskCommittedCount?: Maybe<Scalars['Int']['output']>;
  taskSelectedCount?: Maybe<Scalars['Int']['output']>;
  teacherId: Scalars['UUID']['output'];
  teacherName: Scalars['String']['output'];
};

export type StudentAcademicPerformanceExpandedV2 = {
  __typename?: 'StudentAcademicPerformanceExpandedV2';
  achievedTime?: Maybe<Scalars['DateTime']['output']>;
  daysBeforeEndDate?: Maybe<Scalars['Int']['output']>;
  finalMark: Scalars['Int']['output'];
  goalAvatarUrl?: Maybe<Scalars['String']['output']>;
  goalLevelFourTaskCnt?: Maybe<Scalars['Int']['output']>;
  goalLevelOneTaskCnt?: Maybe<Scalars['Int']['output']>;
  goalLevelThreeTaskCnt?: Maybe<Scalars['Int']['output']>;
  goalLevelTwoTaskCnt?: Maybe<Scalars['Int']['output']>;
  goalStatus?: Maybe<Scalars['Int']['output']>;
  hidePercent: Scalars['Boolean']['output'];
  isHardEndDate?: Maybe<Scalars['Boolean']['output']>;
  mandatoryCount?: Maybe<Scalars['Int']['output']>;
  markValue: Scalars['Int']['output'];
  maxArchLevel?: Maybe<Scalars['String']['output']>;
  percent: Scalars['Int']['output'];
  plan?: Maybe<Scalars['Int']['output']>;
  playListCount?: Maybe<Scalars['Int']['output']>;
  stageGroupName: Scalars['String']['output'];
  stageId: Scalars['Int']['output'];
  stageSubjectGroupId: Scalars['Int']['output'];
  stageSubjectGroupName?: Maybe<Scalars['String']['output']>;
  stageSubjectSubgroupStudentId: Scalars['Int']['output'];
  studentId: Scalars['UUID']['output'];
  studentName: Scalars['String']['output'];
  studentUserId: Scalars['UUID']['output'];
  studyPeriodId: Scalars['Int']['output'];
  studyPeriodName?: Maybe<Scalars['String']['output']>;
  subjectId: Scalars['Int']['output'];
  subjectName: Scalars['String']['output'];
  taskCommittedCount?: Maybe<Scalars['Int']['output']>;
  taskSelectedCount?: Maybe<Scalars['Int']['output']>;
  teacherId: Scalars['UUID']['output'];
  teacherName: Scalars['String']['output'];
  workEndDate: Scalars['Date']['output'];
  workId: Scalars['Int']['output'];
  workName: Scalars['String']['output'];
  workNumber: Scalars['Int']['output'];
  workPercent: Scalars['Int']['output'];
  workStartDate: Scalars['Date']['output'];
  /** 0 - задания модулей, 1 - контрольные работы */
  workType: Scalars['Int']['output'];
};

/** Информация о пользователе как ученике школы */
export type StudentAccount = {
  __typename?: 'StudentAccount';
  /** дата выпуска ученика из учебного заведения */
  graduationDateTime?: Maybe<Scalars['DateTime']['output']>;
  /** название роли */
  role: Roles;
  /** статус роли ученика */
  roleStatus: RoleStatus;
  /**
   * идентификатор школы, в которой числится ученик
   * Фактически поле является non-nullable. Добавлено как nullable из-за ограничений расширения gql-схемы
   */
  schoolId?: Maybe<Scalars['ID']['output']>;
  /** общая информация о школе, в которой числится ученик */
  schoolInfo: SafeSchool;
  /** идентификатор текущего класса ученика */
  stageGroupId?: Maybe<Scalars['ID']['output']>;
  /** информация о текущем классе ученика */
  stageGroupInfo?: Maybe<StageGroupInfo>;
  /** идентификатор студента */
  studentId: Scalars['ID']['output'];
  /** состояние ученика */
  studentStatus?: Maybe<StudentStatus>;
  /** общая информация аккаунта пользователя */
  userInfo: UserAccount;
};

/** Результат постраничного запроса списка пользователей-учеников */
export type StudentAccountList = {
  __typename?: 'StudentAccountList';
  /** общее количество записей в БД, удовлетворяющих запросу */
  count: Scalars['Int']['output'];
  /** информация об учениках */
  studentAccounts: Array<StudentAccount>;
};

/** Текстовый ответ ученика */
export type StudentAnswer = {
  __typename?: 'StudentAnswer';
  /** ответ (текст, json, etc) */
  answer: Scalars['String']['output'];
  /** Когда ученик поменял ответ */
  answerModified?: Maybe<Scalars['DateTime']['output']>;
  /** Информация о попытке сдать проект с этим ответом */
  attempt?: Maybe<StudentGoalAttempt>;
  /** Автор ответа */
  author: User;
  /** Когда был отправлен ответ */
  created: Scalars['DateTime']['output'];
  /** список файлов */
  files: Array<File>;
  /** PK */
  id: Scalars['ID']['output'];
  /** Был ли ли модуль внеплановым во время сохранения ответа */
  plannedGoal?: Maybe<Scalars['Boolean']['output']>;
  /** Проверяющий пользователь */
  reviewUser?: Maybe<User>;
  /** статус: на проверке, не принято, принято */
  status: AnswerStatusEnum;
  /** Когда поменялся статус */
  statusModified?: Maybe<Scalars['DateTime']['output']>;
  student: Student;
  /** Код studentId */
  studentId: Scalars['ID']['output'];
  /** Задание в рамках которого ответ */
  task: Task;
  /** Задание */
  taskId: Scalars['ID']['output'];
  /** тип ответа (текст, SurveyJs, ЭОР) */
  type: StudentAnswerType;
};

export type StudentAnswerComment = {
  __typename?: 'StudentAnswerComment';
  /** Текст комментария */
  comment: Scalars['String']['output'];
  /** Идентификатор ответа студента */
  studentAnswerId: Scalars['ID']['output'];
};

export enum StudentAnswerType {
  /** Результат выполнения задания ЭОР (РосУчебник, Физикон...) */
  EorResult = 'EOR_RESULT',
  /** Ответ на тест SurveyJs (JSON) */
  TestJson = 'TEST_JSON',
  /** Текстовый ответ (с форматированием) */
  Text = 'TEXT',
  /** Для всех ответов, сохраненных ранее без типа */
  Unknown = 'UNKNOWN'
}

/** Посещаемость по предметам */
export type StudentAttendanceBySubject = {
  __typename?: 'StudentAttendanceBySubject';
  /** Посещаеость в текущем периоде */
  currentPeriodAttendance: Array<Maybe<StudentLessonAttendance>>;
  /** Посещаемость в прошедших периодах */
  pastPeriodAttendance: Array<Maybe<StudentPastPeriodAttendance>>;
  /** Предмет */
  subjectId: Scalars['ID']['output'];
};

/** Статистика посещаемости уроков учеником */
export type StudentAttendanceStatistic = {
  __typename?: 'StudentAttendanceStatistic';
  /** Количество посещённых занятий WAS_LATE + VISITED */
  numberOfAttendedLessons: Scalars['Int']['output'];
  /** Общее количество уроков за период */
  numberOfLessons: Scalars['Int']['output'];
  /** Статистика посещаемости уроков в разрезе состояний (статусов) VisitJournalCellValueEnum */
  stateStatistics: Array<AttendanceStateStatistics>;
};

export type StudentAttributes = {
  __typename?: 'StudentAttributes';
  createTs: Scalars['DateTime']['output'];
  /** @deprecated refactor */
  graduationTs: Scalars['DateTime']['output'];
  isActive: Scalars['Boolean']['output'];
  /** @deprecated refactor */
  isGraduate: Scalars['Boolean']['output'];
  schoolId: Scalars['ID']['output'];
  stageGroupId: Scalars['ID']['output'];
  /** @deprecated Use getDismissInfoByStudentId() */
  studentDismissInfo?: Maybe<StudentDismissInfo>;
  studentId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

/** Жалоба на буллинг */
export type StudentBullyingComplaintInput = {
  /** Тип жалобы */
  bullyingComplaintType: BullyingComplaintTypeEnum;
  /** Анонимно ли была подана жалоба */
  isAnonymous: Scalars['Boolean']['input'];
  /** Сообщение к обращению */
  message?: InputMaybe<Scalars['String']['input']>;
};

/** Проверка студент/студент (взаимопроверка) */
export type StudentByStudentCheckInfo = {
  __typename?: 'StudentByStudentCheckInfo';
  /**
   * код ответа
   * @deprecated unused. Will be deleted in 0.13
   */
  answerId: Scalars['ID']['output'];
  /**
   * кого оценивать (может быт пустым если анонимная провека)
   * @deprecated unused. Will be deleted in 0.13
   */
  assigneeUser?: Maybe<User>;
  /**
   * оценивать мне
   * @deprecated unused. Will be deleted in 0.13
   */
  reviewByMe: Scalars['Boolean']['output'];
  /** Другой ученик/студент, проверяющий Задание (может быт пустым если анонимная провека) */
  reviewUser?: Maybe<User>;
};

/** Информация об оцененных заданиях в контексте ГКПП(Группы класса по предмету) */
export type StudentCheckedTaskInfo = {
  __typename?: 'StudentCheckedTaskInfo';
  stageGroup: StageGroup;
  stageSubjectGroupName: Scalars['String']['output'];
  /** Необходимая информация о заданиях студента, выполнившем задания */
  studentTaskAndTasks: Array<Maybe<StudentTaskAndTask>>;
  /** Количество студентов в рамках данной ГКПП, у которых есть проверенные задания за выбраннный период. */
  studentsCount: Scalars['Int']['output'];
  subject: Subject;
  /** Количество проверенных заданий для данного студента в рамках данной ГКПП */
  tasksCount: Scalars['Int']['output'];
  /** Подробная информация о студенте, выполнившем задания */
  user: User;
};

/** для получения данных по проверенным заданиям включая фильтр модулей */
export type StudentCheckedTasksWithGoalsFilter = {
  __typename?: 'StudentCheckedTasksWithGoalsFilter';
  goalsFilter: Array<Maybe<GoalsFilter>>;
  studentCheckedTaskInfoModels: Array<Maybe<StudentCheckedTaskInfo>>;
};

/** Процесс код-ревью студенческого проекта */
export type StudentCodeReview = {
  __typename?: 'StudentCodeReview';
  /** Этапы код-ревью */
  codeReviewRounds: Array<CodeReviewRound>;
  /**
   * Финальная оценка проекта после код-ревью
   *  {null} - оценка не проведена
   *  {true} - оценка код-ревью пройдена успешна
   *  {false} - оценка код-ревью провалена
   */
  finalMark?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Время, когда установлена финальная оценка по проекту
   * {null} - если ревьювер еще не установил финальную оценку
   */
  markTime?: Maybe<Scalars['DateTime']['output']>;
  /** Количество комментариев в GitLab по код-ревью */
  reviewerCommentsCount?: Maybe<Scalars['Int']['output']>;
  /** ID студента проводящего код-ревью */
  reviewerStudentId: Scalars['UUID']['output'];
  /** ID процесса код-ревью модуля студента */
  studentCodeReviewId: Scalars['ID']['output'];
  /** ID студенческого модуля по которому проводится код-ревью */
  studentGoalId: Scalars['ID']['output'];
  /** Пользователь-ревьювер */
  user: User;
};

/** Процесс код-ревью с финальной(усредненной) оценкой */
export type StudentCodeReviewResult = {
  __typename?: 'StudentCodeReviewResult';
  /**
   * Усредненная оценка
   * {null} - оценка не проведена (не завершены код-ревью процессы)
   * {COMPLETELY_AGREE} - пройдено успешно
   * {COMPLETELY_DISAGREE} - провалено
   */
  averageMark?: Maybe<CodeReviewMark>;
  /** Информация о проверках код-ревью студенческого проекта */
  studentCodeReviews: Array<StudentCodeReview>;
};

export enum StudentCodeReviewStatus {
  /** Доступен */
  Available = 'AVAILABLE',
  /** Завершен */
  Completed = 'COMPLETED',
  /** В ревью раунд 1 */
  InReviewRound_1 = 'IN_REVIEW_ROUND_1',
  /** В ревью раунд 2 */
  InReviewRound_2 = 'IN_REVIEW_ROUND_2',
  /** Недоступен */
  Unavailable = 'UNAVAILABLE',
  /** Капитуляция проверяемого студента */
  VerifiableCapitulation = 'VERIFIABLE_CAPITULATION',
  /** Ожидает начала раунда 2 */
  WaitForRound_2 = 'WAIT_FOR_ROUND_2'
}

/**
 * Отправляемый ответ
 * внутри result следующая структура (+ экранирование)
 * {
 *    "type":"result",
 *    "data":{
 *       "progress":"null",
 *       "passingScore":"",
 *       "status":"incomplete"
 *    }
 * }
 * Процессы код-ревью студенческого проекта, с количеством завершенных Round1 и Round2
 */
export type StudentCodeReviewsWithCountRound = {
  __typename?: 'StudentCodeReviewsWithCountRound';
  /** Получение информации по настройкам code review проекта или null проверки code review нет */
  codeReviewsInfo?: Maybe<CodeReviewChecksInfo>;
  /** Количество завершенных Round1 */
  countRound1: Scalars['Int']['output'];
  /** Количество завершенных Round2 */
  countRound2: Scalars['Int']['output'];
  /** Процесс код-ревью студенческого проекта */
  studentCodeReviews: Array<StudentCodeReview>;
};

/** Процессы код-ревью студенческого проекта, проводимые другими студентами, с датой начала раунда 2 */
export type StudentCodeReviewsWithPlaneSecondRound = {
  __typename?: 'StudentCodeReviewsWithPlaneSecondRound';
  /** Дата начала раунда 2 */
  secondRoundStartDate: Scalars['Date']['output'];
  /** Процесс код-ревью студенческого проекта */
  studentCodeReviews: Array<StudentCodeReview>;
};

/** Информация о завершенных модулях */
export type StudentCompletedGoalsInfo = {
  __typename?: 'StudentCompletedGoalsInfo';
  /** кол-во закрытых модулей с уровнем 3 у оторых целевой уровень 3 */
  achievedLevel3: Scalars['Int']['output'];
  /** % модулей с достигнутым уровнем 3 от количества модулей с целевым уровнем 3.0 */
  achievedLevel3Percent: Scalars['Float']['output'];
  /** кол-во закрытых модулей с уровнем 4 */
  achievedLevel4: Scalars['Int']['output'];
  /** % модулей с достигнутым уровнем 4.0 от модулей, имеющих задания уровня 4.0 */
  achievedLevel4Percent: Scalars['Float']['output'];
  /** кол-во закрытых модулей с уровнем 2.5 у оторых целевой уровень 3 */
  achievedLevel25: Scalars['Int']['output'];
  /** % модулей с достигнутым уровнем 2.5 от количества модулей с целевым уровнем 3.0 */
  achievedLevel25Percent: Scalars['Float']['output'];
  /** фио ученика */
  fio: Scalars['String']['output'];
  /** Количество модулей, имеющих задания уровня 4.0 */
  goalsWithTasksAtLevel4: Scalars['Int']['output'];
  /** идентификатор группы ученика */
  stageGroupId: Scalars['ID']['output'];
  /** название группы ученика */
  stageGroupName: Scalars['String']['output'];
  /** идентификатор ученика */
  studentId: Scalars['UUID']['output'];
  /** кол-во модулей с целевым уровнем 3 */
  targetLevel3: Scalars['Int']['output'];
};

/** Информация о попытке прохождения курса */
export type StudentCourseAttempt = {
  __typename?: 'StudentCourseAttempt';
  /** Процент пройденного */
  finalPercentage: Scalars['Int']['output'];
  /** Порог прохождения */
  percentageOfCompletion: Scalars['Int']['output'];
  /** Количество баллов полученное за попытку */
  pointProject: Scalars['Int']['output'];
  /** Идентификатор попытки выполнения модуля студента */
  studentCourseAttemptId: Scalars['ID']['output'];
};

/** Информация о попытке прохождения курса */
export type StudentCourseAttemptHeader = {
  __typename?: 'StudentCourseAttemptHeader';
  /** Процент пройденного */
  finalPercentage?: Maybe<Scalars['Int']['output']>;
  /** Количество баллов полученное за попытку */
  pointProject?: Maybe<Scalars['Int']['output']>;
  /** Результат попытки */
  resultCourseCompletion?: Maybe<CompletionResultStatus>;
  /** Дата и время попытки */
  resultDate?: Maybe<Scalars['DateTime']['output']>;
  /** Идентификатор попытки выполнения модуля студента */
  studentCourseAttemptId?: Maybe<Scalars['ID']['output']>;
};

/** Информация о попытке курса */
export type StudentCourseAttemptInfo = {
  __typename?: 'StudentCourseAttemptInfo';
  finalPercentage?: Maybe<Scalars['Int']['output']>;
  finalPoint?: Maybe<Scalars['Int']['output']>;
  softSkills: Array<StudentCourseAttemptSoftSkill>;
  studentCourseAttemptId: Scalars['ID']['output'];
};

/** Информация о попытке курса */
export type StudentCourseAttemptSoftSkill = {
  __typename?: 'StudentCourseAttemptSoftSkill';
  maxAvailableScore?: Maybe<Scalars['Int']['output']>;
  score: Scalars['Int']['output'];
  softSkillId: Scalars['ID']['output'];
  studentCourseAttemptId: Scalars['ID']['output'];
};

/** Информация о попытке прохождения курса */
export type StudentCourseAttemptStatistic = {
  __typename?: 'StudentCourseAttemptStatistic';
  /** Результат попытки */
  completionResultStatus: CompletionResultStatus;
  /** Процент пройденного */
  finalPercentage: Scalars['Int']['output'];
  /** Количество баллов полученное за попытку */
  pointProject: Scalars['Int']['output'];
  /** Дата и время попытки */
  resultDate: Scalars['DateTime']['output'];
};

/** Финальный результат за курс */
export type StudentCourseFinalScore = {
  __typename?: 'StudentCourseFinalScore';
  /** Тип формулы финальной сборки */
  attemptCountingFormula?: Maybe<AttemptCountingFormulaEnum>;
  /** Статус модуля */
  courseStatus?: Maybe<CourseStatus>;
  /** Процент выполнения */
  finalPercentage?: Maybe<Scalars['Int']['output']>;
  /** Начисленный фактический бал выполнения задания */
  finalPoint?: Maybe<Scalars['Int']['output']>;
  /** Процент, который необходимо набрать чтобы задание считалось выполненным */
  percentageOfCompletion: Scalars['Int']['output'];
  /** Дата и время расчета оценки за проект */
  resultDate?: Maybe<Scalars['DateTime']['output']>;
  /** Информация о попытке прохождения модуля */
  studentAttemptList: Array<StudentCourseAttemptHeader>;
  /** Идентификатор студенческого курса */
  studentCourseId: Scalars['ID']['output'];
};

/** Курс назначенный на студента */
export type StudentCourseModel = {
  __typename?: 'StudentCourseModel';
  /** Статус курса */
  courseStatus?: Maybe<CourseStatus>;
  /** Процент завершения курса */
  finalPercentage?: Maybe<Scalars['Int']['output']>;
  /** Кол-во набранных очков за курс */
  finalPoint?: Maybe<Scalars['Int']['output']>;
  /** Флаг, определяющий актуальность курса для студента */
  isActual?: Maybe<Scalars['Boolean']['output']>;
  /** Идентификатор локального курса */
  localCourseId: Scalars['ID']['output'];
  /** Количество повторных прохождения курса */
  retryCount?: Maybe<Scalars['Int']['output']>;
  /** Идентификатор записи о курсе студента */
  studentCourseId: Scalars['ID']['output'];
  /** Идентификатор студента */
  studentId: Scalars['UUID']['output'];
};

/** Процент соответствия и оценка */
export type StudentCriteriaPercent = {
  __typename?: 'StudentCriteriaPercent';
  /** Процент соответствия */
  percent: Scalars['Int']['output'];
  /** Оценка соответствующая проценту соответствия */
  value: CriteriaRecommendedValue;
};

/** Оценка по критерию */
export type StudentCriteriaValue = {
  __typename?: 'StudentCriteriaValue';
  confirmedTs?: Maybe<Scalars['DateTime']['output']>;
  createdTs: Scalars['DateTime']['output'];
  /** Идентификатор критерия */
  criteriaId: Scalars['ID']['output'];
  /** Степень соответствия критерию */
  criteriaValue: CriteriaValue;
  /** Подтвержденное соответствие критерию */
  isConfirmed: Scalars['Boolean']['output'];
  studentCriteriaValueId: Scalars['ID']['output'];
  /** Идентификатор ученика */
  studentId: Scalars['ID']['output'];
  updatedTs?: Maybe<Scalars['DateTime']['output']>;
};

export type StudentCriteriaValueInput = {
  /** Идентификатор критерия */
  criteriaId: Scalars['ID']['input'];
  /** Значение соответствия */
  criteriaValue: CriteriaValue;
  /** Идентификатор ученика */
  studentId?: InputMaybe<Scalars['ID']['input']>;
};

export type StudentCurrentLessonCWorkHWork = {
  __typename?: 'StudentCurrentLessonCWorkHWork';
  homework?: Maybe<HomeworkInfo>;
  lessonsCompact: StudentLessonCompact;
};

/** Дашборд ученика */
export type StudentDashboard = {
  __typename?: 'StudentDashboard';
  /** Информация о следующем "учебном дне" (день на который назначены уроки) */
  activeLearningDayLessonsInfo: ActiveLearningDayLessonsInfo;
  /** Индикатор наличия загруженного расписания для данной школы и учебного года */
  eventsUploaded: Scalars['Boolean']['output'];
  /** Модули с Запланированными заданиями в календаре ученика на сегодня и завтра */
  modulesWithPlanedTasks: Array<StudentModule>;
  /** Контрольные работы на сегодня и завтра */
  personalControlWorks: Array<PersonalControlWork>;
  /** Статистика достигнутых навыков ученика(общее/за день) */
  softSkillDayProgress: Array<SoftSkillPower>;
};

/** Модель для дневника ученика */
export type StudentDiary = {
  __typename?: 'StudentDiary';
  events: Array<StudentDiaryEvent>;
  /** перечень уроков */
  lessons: Array<StudentDiaryItem>;
};

/** Элемент события для дневника ученика */
export type StudentDiaryEvent = {
  __typename?: 'StudentDiaryEvent';
  /** Признак события на весь день */
  allDayEvent: Scalars['Boolean']['output'];
  /** Категория события */
  calendarEventCategory?: Maybe<CalendarEventCategory>;
  /** Временная метка создания события */
  createdTs?: Maybe<Scalars['DateTime']['output']>;
  /** Идентификатор пользователя - создателя события */
  creatorId?: Maybe<Scalars['UUID']['output']>;
  /** Описание события */
  description?: Maybe<Scalars['String']['output']>;
  /** Дата и время окончания события */
  endTime: Scalars['DateTime']['output'];
  /** Тип события */
  eventType?: Maybe<CalendarEventType>;
  /** Идентификатор события */
  id: Scalars['ID']['output'];
  /** Местонахождение (локация) */
  location: Scalars['String']['output'];
  /** Название события */
  name: Scalars['String']['output'];
  /** Идентификатор основного повторяющегося события для события-исключения из правила */
  parentCalendarEventId?: Maybe<Scalars['UUID']['output']>;
  /** Идентификатор типа групп, которые могут быть участниками события */
  participantGroupTypeId?: Maybe<Scalars['UUID']['output']>;
  /** До какого числа действует правило для повторяющегося события */
  recurrenceEndTs?: Maybe<Scalars['DateTime']['output']>;
  /** Правило для повторяющегося события */
  recurrenceRule?: Maybe<Scalars['String']['output']>;
  /** Дата и время начала события */
  startTime: Scalars['DateTime']['output'];
};

/** Модель домашней работы для дневника */
export type StudentDiaryHomework = {
  __typename?: 'StudentDiaryHomework';
  /** Сумма трудозатрат */
  amountOfLaborCost: Scalars['Int']['output'];
  /** Статус выполнения домашних работ */
  completed?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Идентификатор домашней работы
   * @deprecated Нет в V4
   */
  homeworkId: Scalars['ID']['output'];
  /**
   * Текстовая заметка к домашней работе
   * @deprecated Превращен в массив в V4
   */
  note?: Maybe<Scalars['String']['output']>;
  /** Заметки к домашней работе */
  notes: Array<LessonPlanNote>;
  /** Количество заданий в рамках домашней работы */
  numberOfTasks: Scalars['Int']['output'];
};

/** Элемент дневника ученика, отражающий урок или другое событие */
export type StudentDiaryItem = {
  __typename?: 'StudentDiaryItem';
  /** Название (номер) кабинета */
  classRoomName: Scalars['String']['output'];
  /** Комментарии учителя */
  comments: Array<Maybe<StudentDiaryLessonComment>>;
  /** Дата и время окончания */
  end: Scalars['DateTime']['output'];
  /** Признак контрольной на уроке */
  hasControlWork: Scalars['Boolean']['output'];
  /** Домашняя работа */
  homeworks: Array<StudentDiaryHomework>;
  /** Идентификатор урока */
  lessonId: Scalars['ID']['output'];
  /** Классные работы на уроке */
  lessonPlan: StudentDiaryLessonPlan;
  /** Оценки, которые получил ученик на уроке */
  marks: Array<StudentDiaryMark>;
  /** Модуль по предмету, соответствующий плану */
  module?: Maybe<StudentDiaryModule>;
  /** Номер элемента в дневнике (урока) */
  number: Scalars['String']['output'];
  /** Признак online урока */
  onlineLesson: Scalars['Boolean']['output'];
  /** Дата и время начала */
  start: Scalars['DateTime']['output'];
  /** Предмет */
  subject: Subject;
  /** Тип посещения урока */
  visitJournalValue: VisitJournalCellValueEnum;
};

/** Активность на уроке для оценок дневника */
export type StudentDiaryLearningActivity = {
  __typename?: 'StudentDiaryLearningActivity';
  /** Название активности */
  name: Scalars['String']['output'];
  /** Вес активности */
  weight: Scalars['Float']['output'];
};

/** Модель наиболее длительной домашней работы в дневнике ученика */
export type StudentDiaryLengthyHomework = {
  __typename?: 'StudentDiaryLengthyHomework';
  /** Домашняя работа */
  homework: StudentDiaryHomework;
  /** Идентификатор урока */
  lessonId: Scalars['ID']['output'];
  /** Дата начала урока */
  lessonStartDateTime: Scalars['DateTime']['output'];
  /** Предмет */
  subject: Subject;
};

/** Модель комментария учителя в рамках урока */
export type StudentDiaryLessonComment = {
  __typename?: 'StudentDiaryLessonComment';
  /** Комментарий */
  comment: Scalars['String']['output'];
  /** Идентификатор комментария для урока */
  id: Scalars['ID']['output'];
  /** URL аватара учителя */
  teacherAvatarUrl: Scalars['String']['output'];
  /** ФИО учителя */
  teacherFullName: Scalars['String']['output'];
  /** Идентификатор учителя */
  teacherId: Scalars['ID']['output'];
};

/** Модель классной работы на уроке для дневника */
export type StudentDiaryLessonPlan = {
  __typename?: 'StudentDiaryLessonPlan';
  /** Сумма трудозатрат в рамках классной работы */
  amountOfLaborCost: Scalars['Int']['output'];
  /** Статус выполнения классных работ */
  completed?: Maybe<Scalars['Boolean']['output']>;
  /** Идентификатор плана */
  id?: Maybe<Scalars['ID']['output']>;
  /** Название плана */
  name?: Maybe<Scalars['String']['output']>;
  /**
   * Комментарий к классной работе
   * @deprecated Превращен в массив в V4
   */
  note?: Maybe<Scalars['String']['output']>;
  /** Заметки к домашней работе */
  notes: Array<LessonPlanNote>;
  /** Количество заданий в рамках классной работы */
  numberOfTasks: Scalars['Int']['output'];
};

/** Модель оценки для дневника */
export type StudentDiaryMark = {
  __typename?: 'StudentDiaryMark';
  /** Комментарий к оценке */
  comment?: Maybe<Scalars['String']['output']>;
  /** Значение оценки из справочника оценок government_marks */
  governmentMark: Scalars['Int']['output'];
  /** Идентификатор оценки */
  id: Scalars['ID']['output'];
  /** Активность, за которую была получена оценка */
  learningActivity: StudentDiaryLearningActivity;
};

/** Модель учебного модуля для дневника (goals) */
export type StudentDiaryModule = {
  __typename?: 'StudentDiaryModule';
  /** Идентификатор модуля (goals.goal_id) */
  id: Scalars['ID']['output'];
  /** Наименование модуля (goals.name) */
  name: Scalars['String']['output'];
};

export type StudentDiligence = {
  __typename?: 'StudentDiligence';
  diligence: Scalars['Float']['output'];
  stageGroupId: Scalars['ID']['output'];
  studentGoalDiligenceList: Array<StudentGoalDiligence>;
  studentId: Scalars['UUID']['output'];
  studentName: Scalars['String']['output'];
};

export type StudentDismissInfo = {
  __typename?: 'StudentDismissInfo';
  dismissTs: Scalars['DateTime']['output'];
  dismissTypeId: Scalars['ID']['output'];
  lastCoalitionId?: Maybe<Scalars['ID']['output']>;
  lastCoalitionName?: Maybe<Scalars['String']['output']>;
  /** @deprecated Use lastStageGroupS21 instead */
  lastStageGroup?: Maybe<StageGroup>;
  lastStageGroupS21?: Maybe<StageGroupS21>;
};

/** Оценка трудоемкости студентом */
export type StudentEffortEstimation = {
  __typename?: 'StudentEffortEstimation';
  /** Дата и время создания */
  createTs: Scalars['DateTime']['output'];
  /** Трудоемкость в минутах */
  estimation?: Maybe<Scalars['Int']['output']>;
  /** ID трудоемкости */
  estimationId: Scalars['ID']['output'];
  /** Дата и время модификации */
  modifyTs: Scalars['DateTime']['output'];
  /** ID задания в контексте студента */
  studentTaskId: Scalars['ID']['output'];
  /** Пользователь */
  user: User;
};

/** Оценка трудоемкости студентом */
export type StudentEffortEstimationInput = {
  /** Признак необходимости удаления записи */
  deleteFlag: Scalars['Boolean']['input'];
  /** Оценка трудозатрат (мин) */
  estimation?: InputMaybe<Scalars['Int']['input']>;
  /** Ид оценки */
  estimationId?: InputMaybe<Scalars['ID']['input']>;
  /** Ид задания в контексте студента */
  studentTaskId: Scalars['ID']['input'];
};

/** Правило и соединяющий оператор в конструкторе выполняющего для студента */
export type StudentEvaluationRule = {
  __typename?: 'StudentEvaluationRule';
  logicalOperatorId?: Maybe<LogicalLinkTypeEnum>;
  value: StudentEvaluationRuleValue;
};

/** Группа правил конструктора выполняющего для студента */
export type StudentEvaluationRuleGroup = {
  __typename?: 'StudentEvaluationRuleGroup';
  logicalOperatorId?: Maybe<LogicalLinkTypeEnum>;
  rulesInGroup: Array<StudentEvaluationRule>;
};

/** Информация об правиле конструктора выполняющего для студента */
export type StudentEvaluationRuleValue = {
  __typename?: 'StudentEvaluationRuleValue';
  fieldId: Scalars['ID']['output'];
  fieldName?: Maybe<Scalars['String']['output']>;
  fieldType: EvaluationRuleValueFieldType;
  operator: Scalars['String']['output'];
  projectRoutingInfo: Array<KeyValue>;
  subFieldKey?: Maybe<Scalars['String']['output']>;
  subFieldName?: Maybe<Scalars['String']['output']>;
  value: Array<Scalars['String']['output']>;
  valueWithDescription: Array<KeyValue>;
};

export type StudentEvent = {
  __typename?: 'StudentEvent';
  /** Инфо о пользователе */
  User: User;
  /** Дата записи на экзамен */
  registerDate: Scalars['DateTime']['output'];
};

export type StudentEventFeedback = {
  __typename?: 'StudentEventFeedback';
  comment?: Maybe<Scalars['String']['output']>;
  createDate: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  rating: Scalars['Int']['output'];
  user: User;
};

export type StudentEventFeedbackInput = {
  calendarEventId: Scalars['ID']['input'];
  comment?: InputMaybe<Scalars['String']['input']>;
  rating: Scalars['Int']['input'];
};

/** Тип студентов в событии */
export enum StudentEventTypeEnum {
  OnWaitList = 'ON_WAIT_LIST',
  Registered = 'REGISTERED'
}

/** S21. Студенческий опросник */
export type StudentFeedback = {
  __typename?: 'StudentFeedback';
  /** Форма для обратной связи */
  feedbackForm?: Maybe<FeedbackForm>;
  /** Тип проекта */
  goalExecutionType: ModuleExecutionType;
  /** ID проекта */
  goalId: Scalars['ID']['output'];
  /** Название проекта */
  goalName: Scalars['String']['output'];
  /** ID студенческого опросника */
  id: Scalars['ID']['output'];
  /** Процент выполнения попытки */
  pointPercent: Scalars['Int']['output'];
  /** Дата завершения попытки */
  resultAttemptDate: Scalars['DateTime']['output'];
  /** Результат за попытку */
  resultModuleCompletion: ResultModuleCompletion;
  /** Порядковый номер попытки */
  serialNumber: Scalars['Int']['output'];
  /** ID попытки */
  studentGoalAttemptId: Scalars['ID']['output'];
};

/** S21. Студенческий опросник для попапа */
export type StudentFeedbackPopup = {
  __typename?: 'StudentFeedbackPopup';
  /** Название проекта */
  goalName: Scalars['String']['output'];
  /** Дата завершения попытки */
  resultAttemptDate: Scalars['DateTime']['output'];
  /** ID студенческого опросника */
  studentFeedbackId: Scalars['ID']['output'];
};

/** S21. Ответ по вопросу обратной связи студента */
export type StudentFeedbackResult = {
  __typename?: 'StudentFeedbackResult';
  /** Описание вопроса на русском */
  descriptionRu?: Maybe<Scalars['String']['output']>;
  /** ID вопроса на форме */
  feedbackFormQuestionId: Scalars['ID']['output'];
  /** Тип секции вопроса */
  feedbackSectionEnum: FeedbackSectionEnum;
  /** ID обратной связи студента */
  id: Scalars['ID']['output'];
  /** Номер вопроса на форме обратной связи */
  serialNumber: Scalars['Int']['output'];
  /** Заголовок вопроса на русском */
  titleRu: Scalars['String']['output'];
  /** Ответ на вопрос */
  value?: Maybe<Scalars['String']['output']>;
};

/** S21. Ответ студента по опросу */
export type StudentFeedbackResultInput = {
  /** ID вопроса */
  feedbackFormQuestionId: Scalars['ID']['input'];
  /** Ответ */
  value: Scalars['String']['input'];
};

/** S21. Статус студенческого ответа */
export enum StudentFeedbackStatusEnum {
  /** Заполнен, есть ответы */
  Filled = 'FILLED',
  /** Попытка завершена раньше чем сделали опрос */
  FinishedBeforeFeedback = 'FINISHED_BEFORE_FEEDBACK',
  /** Не заполнен */
  NotFilled = 'NOT_FILLED',
  /** Не требуется */
  NotRequired = 'NOT_REQUIRED'
}

export type StudentFinalMark = {
  __typename?: 'StudentFinalMark';
  finalMark?: Maybe<Scalars['Int']['output']>;
  goalLevelPercent?: Maybe<Scalars['Int']['output']>;
  levelPercentDetails?: Maybe<Array<StudentGoalLevelPercentDetail>>;
  markValue?: Maybe<Scalars['Int']['output']>;
  recomendedMark?: Maybe<Scalars['Int']['output']>;
  studentId: Scalars['UUID']['output'];
  studentName: Scalars['String']['output'];
  teacherId: Scalars['UUID']['output'];
  teacherName: Scalars['String']['output'];
  testPercent?: Maybe<Scalars['Int']['output']>;
  testPercentDetails?: Maybe<Array<StudentTestPercentDetail>>;
};

export type StudentFinalMarkForFormMaster = {
  __typename?: 'StudentFinalMarkForFormMaster';
  finalMark?: Maybe<Scalars['Int']['output']>;
  goalLevelPercent?: Maybe<Scalars['Int']['output']>;
  markValue?: Maybe<Scalars['Int']['output']>;
  recommendedMark?: Maybe<Scalars['Int']['output']>;
  studentId: Scalars['UUID']['output'];
  studentName: Scalars['String']['output'];
  teacherId: Scalars['UUID']['output'];
  teacherName: Scalars['String']['output'];
  testPercent?: Maybe<Scalars['Int']['output']>;
};

export type StudentFinalMarkModel = {
  __typename?: 'StudentFinalMarkModel';
  footer: Scalars['String']['output'];
  markDependencyOfExternalWork: Scalars['String']['output'];
  recommendedMarkDescription: Scalars['String']['output'];
  studentFinalMark?: Maybe<Array<StudentFinalMark>>;
  viewStudentSubjects: Scalars['Boolean']['output'];
};

export type StudentFinalMarkSubjectForFormMaster = {
  __typename?: 'StudentFinalMarkSubjectForFormMaster';
  studentFinalMarks?: Maybe<Array<StudentFinalMarkForFormMaster>>;
  subject2MarkCount: Scalars['Int']['output'];
  subjectId: Scalars['Int']['output'];
  subjectName: Scalars['String']['output'];
};

/** Отчет "Итоговые оценки. Детальный" по ученику и всем предметам */
export type StudentFinalMarkSubjects = {
  __typename?: 'StudentFinalMarkSubjects';
  finalMark?: Maybe<Scalars['Int']['output']>;
  goalLevelPercent?: Maybe<Scalars['Int']['output']>;
  levelPercentDetails?: Maybe<Array<StudentGoalLevelPercentDetail>>;
  markValue?: Maybe<Scalars['Int']['output']>;
  recomendedMark?: Maybe<Scalars['Int']['output']>;
  subjecName: Scalars['String']['output'];
  teacherId: Scalars['UUID']['output'];
  teacherName: Scalars['String']['output'];
  testPercent?: Maybe<Scalars['Int']['output']>;
  testPercentDetails?: Maybe<Array<StudentTestPercentDetail>>;
};

export type StudentFinalMarkSubjectsModel = {
  __typename?: 'StudentFinalMarkSubjectsModel';
  markDependencyOfExternalWork: Scalars['String']['output'];
  recommendedMarkDescription?: Maybe<Scalars['String']['output']>;
  studentFinalMarkSubjects?: Maybe<Array<StudentFinalMarkSubjects>>;
};

/** Отчет "Итоговые оценки для классного руководителя" по ученикам и всем предметам */
export type StudentFinalMarksForFormMasterModel = {
  __typename?: 'StudentFinalMarksForFormMasterModel';
  footer: Scalars['String']['output'];
  studentFinalMarkSubjects?: Maybe<Array<StudentFinalMarkSubjectForFormMaster>>;
};

/** Информация о студенте для фильтра в отчете по прогрессу */
export type StudentForProgress = {
  __typename?: 'StudentForProgress';
  /** Имя ученика */
  firstName: Scalars['String']['output'];
  /** Фамилия ученика */
  lastName: Scalars['String']['output'];
  /** Отчество ученика */
  middleName?: Maybe<Scalars['String']['output']>;
  /** Идентификатор студента (students.student_id) */
  studentId: Scalars['ID']['output'];
  /** Идентификатор пользователя (users.user_id) */
  userId: Scalars['ID']['output'];
};

/** Данные для формы достигнутого уровня по модулю */
export type StudentGoalAchievement = {
  __typename?: 'StudentGoalAchievement';
  goalLevelValueName: Scalars['String']['output'];
  skillDescriptions: Array<SkillDescription>;
};

/** Результаты попытки прохождения студентом проекта */
export type StudentGoalAttempt = {
  __typename?: 'StudentGoalAttempt';
  /** Фактический процент выполнения авто-проверки */
  factPercentageAuto?: Maybe<Scalars['Int']['output']>;
  /** Фактический процент прохождения всех p2p-проверкок по чек-листу */
  factPercentageP2p?: Maybe<Scalars['Int']['output']>;
  /** Итоговый процент выполнения */
  finalPercentageProject: Scalars['Int']['output'];
  /** Итоговый балл за авто-проверку */
  finalPointAuto?: Maybe<Scalars['Int']['output']>;
  /** Итоговый балл за все p2p-проверки по чек-листу */
  finalPointP2p?: Maybe<Scalars['Int']['output']>;
  /** Итоговый балл за выполнение проекта */
  finalPointProject: Scalars['Int']['output'];
  /** Дата окончания выполнения */
  resultDate: Scalars['Date']['output'];
  /** Результат проверки */
  resultModuleCompletion: ResultModuleCompletion;
};

/** Информация о попытке прохождения модуля */
export type StudentGoalAttemptHeader = {
  __typename?: 'StudentGoalAttemptHeader';
  /** Процент пройденного */
  finalPercentage?: Maybe<Scalars['Int']['output']>;
  /** Количество баллов полученное за попытку */
  pointProject?: Maybe<Scalars['Int']['output']>;
  /** Дата и время попытки */
  resultDate?: Maybe<Scalars['DateTime']['output']>;
  /** Результат попытки */
  resultModuleCompletion?: Maybe<ResultModuleCompletion>;
  /** Идентификатор ответа */
  studentAnswerId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор попытки выполнения модуля студента */
  studentGoalAttemptId?: Maybe<Scalars['ID']['output']>;
};

/** Результаты попытки прохождения студентом проекта */
export type StudentGoalAttemptShortInfo = {
  __typename?: 'StudentGoalAttemptShortInfo';
  /** Результат проверки */
  attemptStatusId: Scalars['Int']['output'];
  /** Итоговый балл за выполнение проекта */
  finalPercentageProject?: Maybe<Scalars['Int']['output']>;
  /** Дата окончания выполнения */
  resultDate?: Maybe<Scalars['Date']['output']>;
  /** ID попытки студенческого проекта */
  studentGoalAttemptId: Scalars['ID']['output'];
};

/** Информация о попытке прохождения модуля */
export type StudentGoalAttemptStatistic = {
  __typename?: 'StudentGoalAttemptStatistic';
  /** Процент пройденного */
  finalPercentage: Scalars['Int']['output'];
  /** Процент за выполнение задания */
  percentageOfCompletion?: Maybe<Scalars['Int']['output']>;
  /** Количество баллов полученное за попытку */
  pointProject: Scalars['Int']['output'];
  /** Дата и время попытки */
  resultDate: Scalars['DateTime']['output'];
  /** Результат попытки */
  resultModuleCompletion: ResultModuleCompletion;
  /** Идентификатор попытки выполнения модуля студента */
  studentGoalAttemptId: Scalars['ID']['output'];
};

/** Статус попытки выполнения проекта студентом */
export enum StudentGoalAttemptStatus {
  /** Студент провалил задание */
  Fail = 'FAIL',
  /** Студент начал выполнение задания (нажал start project) */
  InProgress = 'IN_PROGRESS',
  /** Студент завершил выполнение задания, перешел на этап проверок (нажал finish project) */
  InReview = 'IN_REVIEW',
  /** Студент зарегистрировался на задание (нажал registered) */
  Registered = 'REGISTERED',
  /**
   * После завершения проекта (провал или успех) по любой возможной причине
   * Студент выполнил задание успешно
   */
  Success = 'SUCCESS'
}

export type StudentGoalDiligence = {
  __typename?: 'StudentGoalDiligence';
  diligence: Scalars['Float']['output'];
  endDate: Scalars['Date']['output'];
  goalId: Scalars['ID']['output'];
  goalLevelPerformanceList: Array<GoalLevelPerformance>;
  goalName: Scalars['String']['output'];
  goalTargetLevel?: Maybe<Scalars['String']['output']>;
  progress: Scalars['Float']['output'];
  startDate: Scalars['Date']['output'];
  subjectId: Scalars['ID']['output'];
  subjectName: Scalars['String']['output'];
};

/** Финальный результат за проект (суммируется из всех попыток) */
export type StudentGoalFinalScore = {
  __typename?: 'StudentGoalFinalScore';
  /** Тип формулы финальной сборки */
  attemptCountingFormula?: Maybe<AttemptCountingFormulaEnum>;
  /** Процент выполнения */
  finalPercentage?: Maybe<Scalars['Int']['output']>;
  /** Начисленный фактический бал выполнения задания */
  finalPoint?: Maybe<Scalars['Int']['output']>;
  /** Статус модуля */
  goalStatus?: Maybe<GoalStatus>;
  /** Процент, который необходимо набрать чтобы задание считалось выполненным */
  percentageOfCompletion: Scalars['Int']['output'];
  /** Дата и время расчета оценки за проект */
  resultDate?: Maybe<Scalars['DateTime']['output']>;
  /** Информация о попытке прохождения модуля */
  studentAttemptList: Array<StudentGoalAttemptHeader>;
  /** Информация о попытке прохождения модуля */
  studentAttempts: Array<StudentGoalAttemptStatistic>;
  /** Идентификатор модуля студента */
  studentGoalId: Scalars['ID']['output'];
};

export type StudentGoalLevelPercentDetail = {
  __typename?: 'StudentGoalLevelPercentDetail';
  achievedTime?: Maybe<Scalars['Date']['output']>;
  currentLevel?: Maybe<Scalars['Float']['output']>;
  daysBeforeEndDate?: Maybe<Scalars['Int']['output']>;
  endDate: Scalars['Date']['output'];
  goalAvatarUrl?: Maybe<Scalars['String']['output']>;
  goalId?: Maybe<Scalars['Int']['output']>;
  goalLevelPercent?: Maybe<Scalars['Int']['output']>;
  goalNumber?: Maybe<Scalars['Int']['output']>;
  goalStatus?: Maybe<Scalars['Int']['output']>;
  isHardEndDate?: Maybe<Scalars['Boolean']['output']>;
  module: Scalars['String']['output'];
  startDate: Scalars['Date']['output'];
  targetLevel: Scalars['Int']['output'];
};

/** Персональный прогресс ученика по закрывающему тесту */
export type StudentGoalLevelTest = {
  __typename?: 'StudentGoalLevelTest';
  /** Попытки прохождения теста */
  attempts: Array<StudentGoalLevelTestAttempt>;
  /** Текущая попытка */
  currentAttempt?: Maybe<StudentGoalLevelTestAttempt>;
  /** Сам тест(контент) */
  goalLevelTest: GoalLevelTest;
  /** ID самого закрывающего теста */
  goalLevelTestId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  /** Статус прохождения теста */
  status: StudentGoalLevelTestStatus;
  /** ID студента */
  studentId: Scalars['ID']['output'];
};

/** Попытка прохождения закрывающего теста */
export type StudentGoalLevelTestAttempt = {
  __typename?: 'StudentGoalLevelTestAttempt';
  /** номер попытки */
  attemptNumber: Scalars['Int']['output'];
  /** ID попытки */
  id: Scalars['ID']['output'];
  /** результат попытки */
  status: StudentGoalLevelTestAttemptStatus;
  /** Задания в контексте попытки */
  tasks: Array<StudentGoalLevelTestAttemptTask>;
};

/** Статус выполнения попытки теста уровня цели */
export enum StudentGoalLevelTestAttemptStatus {
  /** В рамках попытки тест выполнен */
  Accepted = 'ACCEPTED',
  /** В рамках попытки тест завален */
  Failed = 'FAILED',
  /** Студент проходит тест */
  InProgress = 'IN_PROGRESS'
}

/** Задание внутри попытки прохождения закрывающего теста */
export type StudentGoalLevelTestAttemptTask = {
  __typename?: 'StudentGoalLevelTestAttemptTask';
  /** tasks.task_id */
  id: Scalars['ID']['output'];
  /** tasks.task_id */
  taskId: Scalars['ID']['output'];
  /** Статус студента по заданию */
  taskStatus?: Maybe<TaskStatusEnum>;
};

/** Статус выполнения теста уровня цели */
export enum StudentGoalLevelTestStatus {
  /** Тест успешно выполнен */
  Accepted = 'ACCEPTED',
  /** Тест завален, попыток больше нет */
  Failed = 'FAILED',
  /** Студент проходит тест */
  InProgress = 'IN_PROGRESS',
  /** Тест неуспешно выполнен, но есть еще попытки */
  TryAgain = 'TRY_AGAIN'
}

export type StudentGoalLevelTestTaskAttemptAnswers = {
  __typename?: 'StudentGoalLevelTestTaskAttemptAnswers';
  /** Несет в себе ответ старого типа */
  oldAnswer?: Maybe<GoalLevelTestAttemptOldTask>;
  /** Несет в себе ответы типа виджет */
  widgetAnswer?: Maybe<Array<Maybe<GoalLevelTestAttemptTaskWidget>>>;
};

/** Информации для виджета закрывающего теста */
export type StudentGoalLevelTestWidget = {
  __typename?: 'StudentGoalLevelTestWidget';
  /** Сам тест(контент) */
  goalLevelTest?: Maybe<GoalLevelTest>;
  /** goal_levels.goal_level_id */
  id: Scalars['ID']['output'];
  /** Доступно ли прохождение закрывающего теста */
  isAvailableGoalLevelTest: Scalars['Boolean']['output'];
  /** Может ли тест быть сформирован */
  isCanBeGenerated: Scalars['Boolean']['output'];
  /** Прогресс студента по закрывающему тесту */
  studentGoalLevelTest?: Maybe<StudentGoalLevelTest>;
};

/** Рефлексия по итогам модуля */
export type StudentGoalReflection = {
  __typename?: 'StudentGoalReflection';
  /** Ответ на вопрос "сможешь объяснить друзьям ?" */
  canExplain: ReflectionEstimationEnum;
  /** Ответ на вопрос "достигнута ли учебная цель ?" */
  goalAchieved: ReflectionEstimationEnum;
  /** Ид модуля */
  goalId: Scalars['ID']['output'];
  /** Ответ на вопрос "хотел бы узнать больше ?" */
  knowMore: ReflectionEstimationEnum;
  /** Ответ на проблемный вопрос */
  problematicQuestionAnswer?: Maybe<Scalars['String']['output']>;
  /** Ид рефлексии */
  reflectionId: Scalars['ID']['output'];
  /** Ответ на вопрос "было трудно ?" */
  wasHard: ReflectionEstimationEnum;
  /** Ответ на вопрос "было интересно ?" */
  wasInteresting: ReflectionEstimationEnum;
  /** Ответ на вопрос "было полезно ?" */
  wasUseful: ReflectionEstimationEnum;
};

/** Рефлексия по итогам модуля */
export type StudentGoalReflectionInput = {
  /** Ответ на вопрос "сможешь объяснить друзьям ?" */
  canExplain: ReflectionEstimationEnum;
  /** Ответ на вопрос "достигнута ли учебная цель ?" */
  goalAchieved: ReflectionEstimationEnum;
  /** Ид модуля */
  goalId: Scalars['ID']['input'];
  /** Ответ на вопрос "хотел бы узнать больше ?" */
  knowMore: ReflectionEstimationEnum;
  /** Ответ на проблемный вопрос */
  problematicQuestionAnswer?: InputMaybe<Scalars['String']['input']>;
  /** Ид рефлексии */
  reflectionId?: InputMaybe<Scalars['ID']['input']>;
  /** Ответ на вопрос "было трудно ?" */
  wasHard: ReflectionEstimationEnum;
  /** Ответ на вопрос "было интересно ?" */
  wasInteresting: ReflectionEstimationEnum;
  /** Ответ на вопрос "было полезно ?" */
  wasUseful: ReflectionEstimationEnum;
};

export type StudentGoalRetryInfo = {
  __typename?: 'StudentGoalRetryInfo';
  totalRetryValue: Scalars['Int']['output'];
  unlimitedAttempts: Scalars['Boolean']['output'];
  usedRetryCount: Scalars['Int']['output'];
};

/** Отчет по итогам модуля по итогам прохождения студентом */
export type StudentGoalSummary = {
  __typename?: 'StudentGoalSummary';
  /** Список достигнутых уровней цели с описанием */
  achievedGoals?: Maybe<Array<Maybe<GoalWithLevel>>>;
  /** Основная идея модуля */
  basicIdea: Scalars['String']['output'];
  /** Количество выполненных заданий в траектории */
  completedTasks?: Maybe<Scalars['Int']['output']>;
  /** Список не достигнутых уровней цели с описанием */
  goalsToGo?: Maybe<Array<Maybe<GoalWithLevel>>>;
  /** Количество коментариев к самому обсуждаемому заданию */
  mostDiscussedCommentsNumber?: Maybe<Scalars['Int']['output']>;
  /** Самые обсуждаемые задания */
  mostDiscussedTasks?: Maybe<Array<Maybe<Task>>>;
  /** Наиболее трудозатратные задания */
  taskWithLongestSpentTime?: Maybe<Array<Maybe<Task>>>;
  /** Наименее трудозатратные задания */
  taskWithMinimalSpentTime?: Maybe<Array<Maybe<Task>>>;
  /** Задания выполненные в группе */
  tasksMadeInGroup?: Maybe<Array<Maybe<Task>>>;
  /** Количество заданий в траектории */
  tasksNumber?: Maybe<Scalars['Int']['output']>;
  /** Всего трудозатрат на выполненные задания */
  totalTimeSpent?: Maybe<Scalars['Int']['output']>;
  /** Ид траектории */
  trajectoryId?: Maybe<Scalars['ID']['output']>;
};

/** Список Домашних Работ с дедлайном на определённую дату */
export type StudentHomeworksByDate = {
  __typename?: 'StudentHomeworksByDate';
  /** Дата дедлайна Домашних Работ (в зоне школы) */
  date: Scalars['Date']['output'];
  /** Список Домашних Работ с дедлайном на данную дату (в зоне школы) */
  homeworks: Array<HomeworkInfo>;
};

export enum StudentHonorRatingEnum {
  Antihero = 'ANTIHERO',
  Hero = 'HERO'
}

export type StudentHonorRatingInput = {
  /** комментарий */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** рейтинг */
  rating: StudentHonorRatingEnum;
  /** оцениваемый пользователь */
  userId: Scalars['UUID']['input'];
};

export type StudentHonorRatingModel = {
  __typename?: 'StudentHonorRatingModel';
  comment?: Maybe<Scalars['String']['output']>;
  createTs: Scalars['DateTime']['output'];
  rating: StudentHonorRatingEnum;
  reporterStudentId: Scalars['UUID']['output'];
  stageGroupId: Scalars['ID']['output'];
  studentHonorRatingId: Scalars['ID']['output'];
  studentId: Scalars['UUID']['output'];
};

/** Студент внутри Подгруппы */
export type StudentInSubgroup = {
  __typename?: 'StudentInSubgroup';
  /** Название класса, к которому относится эта подгруппа - 5А */
  className?: Maybe<Scalars['String']['output']>;
  /** План на Класс по Предмету, в котором находится Подгруппа, в которой находится Студент */
  classPlan?: Maybe<ClassPlan>;
  /** id группы класса по предмету */
  classSubjectId: Scalars['ID']['output'];
  /** Название группы класса по предмету */
  classSubjectName?: Maybe<Scalars['String']['output']>;
  /** Текущий Учебный Модуль студента в рамках подгруппы */
  currentModule?: Maybe<StudentModule>;
  /** Номер Варианта ученика по умолчанию для контрольных работ(если null, то вариант = 1) */
  defaultControlWorkVariantNumber?: Maybe<Scalars['Int']['output']>;
  /** Идентификатор студента в подгруппе (stage_subject_subgroup_students.stage_subject_subgroup_student_id) */
  id: Scalars['ID']['output'];
  /** Последняя просмотренная версия персонального плана */
  lastViewedPersonalPlanVersion?: Maybe<PersonalPlanVersion>;
  /** Список учебных модулей назначенных на студента в рамках подгруппы */
  modules: Array<StudentModule>;
  /** Персональная успеваемость студента внутри подгруппы (Идет по плану, Отстающий) */
  performance?: Maybe<PersonalPerformance>;
  /** Персональные Контрольные Работы назначенные на Студента в рамках Группы по Предмету */
  personalControlWorks: Array<PersonalControlWork>;
  /** Персональный План по Предмету */
  personalPlan?: Maybe<PersonalPlan>;
  /** Короткое название предметма - Английский язык */
  shortSubjectName?: Maybe<Scalars['String']['output']>;
  /** Мета информация о студенте, находящемся в подгруппе. */
  student: Student;
  /**
   * Персональная информация по четвертям Студента
   * корректное название studentStageSubjectStudyPeriodMarks
   */
  studentStageSubjectStudyPeriods: Array<StudentStageSubjectStudyPeriod>;
  studentSubjectAcademicPerformances?: Maybe<Array<StudentSubjectAcademicPerformance>>;
  /** Идентификатор Подгруппы (stage_subject_subgroups.stage_subject_subgroup_id) */
  subgroupId: Scalars['ID']['output'];
  /** Название Подгруппы, в которой находится Студент */
  subgroupName: Scalars['String']['output'];
  /** id предмета */
  subjectId?: Maybe<Scalars['ID']['output']>;
  /** Название предмета, к которому относится эта подгруппа - Иностранный язык (Английский язык) */
  subjectName?: Maybe<Scalars['String']['output']>;
  /** Годовая оценка */
  yearMark?: Maybe<SchoolMark>;
};

/** Информация о приглашении в команду в групповом задании */
export type StudentInvitationInfo = {
  __typename?: 'StudentInvitationInfo';
  /** Статус приглашения в команду */
  invitationStatus: InvitationStatusEnum;
  /** Наименование кампуса */
  schoolShortName?: Maybe<Scalars['String']['output']>;
  /** Студент */
  student: Student;
};

/** Плашка с информация о проекте или курсе на экранах студента */
export type StudentItem = {
  __typename?: 'StudentItem';
  /** Количество ответов студента в цели */
  amountAnswers?: Maybe<Scalars['Int']['output']>;
  /** Максимальное количество участников code review */
  amountCodeReviewMembers?: Maybe<Scalars['Int']['output']>;
  /** Текущее количество участников code review, прошедших round1 или round2 */
  amountCurrentCodeReviewMembers?: Maybe<Scalars['Int']['output']>;
  /** Текущее количество участников в групповом проекте */
  amountJoinedMembers?: Maybe<Scalars['Int']['output']>;
  /** Максимальное кол-во участников команды */
  amountMembers?: Maybe<Scalars['Int']['output']>;
  /** Количество проверенных ответов студента в цели */
  amountReviewedAnswers?: Maybe<Scalars['Int']['output']>;
  /**
   * Статус курса (deprecated)
   * @deprecated изменен на расширенный список отображаемых статусов (DisplayedCourseStatus)
   */
  courseStatus?: Maybe<CourseStatus>;
  /** Тип курса (если не модуль, иначе null) */
  courseType?: Maybe<CourseType>;
  /**
   * Дата (deprecated)
   * @deprecated параметр стал необязательным
   */
  date: Scalars['DateTime']['output'];
  /** Дата (актуальная) */
  dateTime?: Maybe<Scalars['DateTime']['output']>;
  /** Описание проекта или курса */
  description: Scalars['String']['output'];
  /** Статус курса (если не модуль, иначе null) */
  displayedCourseStatus?: Maybe<DisplayedCourseStatus>;
  /** Тип выполнения (если модуль, иначе null) */
  executionType?: Maybe<ModuleExecutionType>;
  /** Опыт */
  experience: Scalars['Int']['output'];
  /** Процент прохождения завершенного проекта */
  finalPercentage?: Maybe<Scalars['Int']['output']>;
  /** Идентификатор цели (если модуль, иначе null) */
  goalId?: Maybe<Scalars['Int']['output']>;
  /** Статус (если модуль, иначе null) */
  goalStatus?: Maybe<DisplayedGoalStatus>;
  /** Имя группы из плашек для отображения на фронте */
  groupName: Scalars['String']['output'];
  /** Трудоемкость в часах */
  laboriousness: Scalars['Int']['output'];
  /** Идентификатор курса (если не модуль, иначе null) */
  localCourseId?: Maybe<Scalars['Int']['output']>;
  /** Имя проекта или курса */
  name: Scalars['String']['output'];
};

export type StudentJournalMark = {
  __typename?: 'StudentJournalMark';
  comment?: Maybe<Scalars['String']['output']>;
  date: Scalars['Date']['output'];
  mark?: Maybe<Scalars['String']['output']>;
  title: Scalars['String']['output'];
};

/** Отчет "Успеваемость по эл.журналу" */
export type StudentJournalPerformance = {
  __typename?: 'StudentJournalPerformance';
  /** --СР */
  avgMark?: Maybe<Scalars['String']['output']>;
  /** --СРВ */
  avgWeightedMark?: Maybe<Scalars['String']['output']>;
  /** --итог.оценка */
  finalMarkValue?: Maybe<Scalars['String']['output']>;
  /** --средняя итог.оценка всех учеников ГП */
  finalStageSubjectGroupStudentsAvgMark?: Maybe<Scalars['String']['output']>;
  marks: Array<StudentJournalMark>;
  /** --СР по всем предметам (средняя оценка всех учеников класса по всем предметам) */
  sgAvgMark?: Maybe<Scalars['String']['output']>;
  stageGroupId: Scalars['ID']['output'];
  stageGroupName: Scalars['String']['output'];
  stageSubjectGroupId: Scalars['ID']['output'];
  stageSubjectGroupName: Scalars['String']['output'];
  /** --СР всех учеников ГП */
  stageSubjectGroupStudentsAvgMark?: Maybe<Scalars['String']['output']>;
  /** --средняя СРВ всех учеников ГП */
  stageSubjectGroupStudentsAvgWeightedMark?: Maybe<Scalars['String']['output']>;
  /** --СР по всем предметам (средняя оценка ученика по всем предметам) */
  studentAvgMark?: Maybe<Scalars['String']['output']>;
  studentId: Scalars['UUID']['output'];
  studentName: Scalars['String']['output'];
  subjectId: Scalars['ID']['output'];
  subjectName: Scalars['String']['output'];
  teacherId: Scalars['UUID']['output'];
  teacherName: Scalars['String']['output'];
};

/** Фильтр данных отчета 'Успеваемость по эл.журналу' выгрузка в Excel */
export type StudentJournalPerformanceExcelInput = {
  reportDateTime: Scalars['String']['input'];
  showStageGroupMarks: Scalars['Boolean']['input'];
  stageId: Scalars['ID']['input'];
  stageName: Scalars['String']['input'];
  studentUserId?: InputMaybe<Scalars['UUID']['input']>;
  studyPeriodId: Scalars['ID']['input'];
};

/** Урок ученика */
export type StudentLesson = {
  __typename?: 'StudentLesson';
  /** Признак завершенности всех модулей из плана по предмету урока */
  allSubjectPlanModulesAchieved?: Maybe<Scalars['Boolean']['output']>;
  /** Наименование кабинета/помещения в котором проводиться урок */
  classRoomName?: Maybe<Scalars['String']['output']>;
  /** Контрольная работа по данному предмету */
  controlWork?: Maybe<PersonalControlWork>;
  /** Текущий модуль ученика */
  currentModule?: Maybe<StudentModule>;
  /** Дата/Время окончания урока */
  end: Scalars['DateTime']['output'];
  /** Идентификатор урока(TimetableId) */
  id: Scalars['ID']['output'];
  /** Номер урока по предмету в этот день */
  lessonNumber: Scalars['Int']['output'];
  /** Текущий, ближайший будущий или ближайший прошедший модуль */
  nearestModuleForLessonDate?: Maybe<StudentModule>;
  /** Следующий урок */
  nextLessonOnSubject?: Maybe<LessonShort>;
  /** План на урок */
  plan?: Maybe<LessonPlan>;
  /** Предыдущий урок */
  previousLessonOnSubject?: Maybe<LessonShort>;
  /** Дата/Время начала урока */
  start: Scalars['DateTime']['output'];
  /** Предмет изучаемый на уроке */
  subject: Subject;
  /** Учитель, который проводит урок */
  teacher: User;
  /** Идентификатор учителя, ведущего урок (teachers.teacher_id) */
  teacherId: Scalars['UUID']['output'];
};

/** Посещаемость урока */
export type StudentLessonAttendance = {
  __typename?: 'StudentLessonAttendance';
  /** Значение(пропуск, пропуск по болезни) */
  cellValue: VisitJournalCellValueEnum;
  /** Дата урока */
  lessonDate: Scalars['DateTime']['output'];
  /** Урок */
  lessonId: Scalars['ID']['output'];
  /** Тема урока */
  lessonTheme?: Maybe<Scalars['String']['output']>;
};

/** Сокращенный урок ученика */
export type StudentLessonCompact = {
  __typename?: 'StudentLessonCompact';
  /** Наименование кабинета/помещения в котором проводиться урок */
  classRoomName?: Maybe<Scalars['String']['output']>;
  /** Контрольная работа по данному предмету */
  controlWork?: Maybe<PersonalControlWork>;
  /** Дата/Время окончания урока */
  end: Scalars['DateTime']['output'];
  /** Идентификатор урока(TimetableId) */
  id: Scalars['ID']['output'];
  /** Номер урока по предмету в этот день */
  lessonNumber: Scalars['Int']['output'];
  /** Блоки материалов */
  lessonWithoutPlanMaterials?: Maybe<Array<Maybe<LessonPlanMaterial>>>;
  /** Блоки заметок для урока вне плана */
  lessonWithoutPlanNotes?: Maybe<Array<Maybe<LessonPlanNote>>>;
  /** Блоки заданий для урока вне плана */
  lessonWithoutPlanTasks?: Maybe<Array<Maybe<LessonPlanTask>>>;
  /** Следующий урок */
  nextLessonOnSubject?: Maybe<LessonShort>;
  /** План на урок */
  plan?: Maybe<LessonPlanV4>;
  /** Предыдущий урок */
  previousLessonOnSubject?: Maybe<LessonShort>;
  /** Дата/Время начала урока */
  start: Scalars['DateTime']['output'];
  /** Модуль V4 относящийся к уроку */
  studentModuleModel?: Maybe<StudentModule>;
  /** Счетчик запланированных модулей у ученика */
  studentPlanModuleCounter?: Maybe<Scalars['Int']['output']>;
  /** Предмет изучаемый на уроке */
  subject?: Maybe<Subject>;
  /** Учитель по текущему уроку */
  teacher?: Maybe<Teacher>;
};

export type StudentLessonData = {
  __typename?: 'StudentLessonData';
  /** запланирован ли урок */
  isPlanned?: Maybe<Scalars['Boolean']['output']>;
  /** урок */
  lesson?: Maybe<Lesson>;
};

/** Информация со статусом по уроку */
export type StudentLessonProgressInfo = {
  __typename?: 'StudentLessonProgressInfo';
  /** идентификатор урока */
  lessonId: Scalars['ID']['output'];
  /** текущий статус урока */
  status: LessonProgressStatus;
};

/** прогресс учеников по уровню */
export type StudentLevelPerformance = {
  __typename?: 'StudentLevelPerformance';
  /** Признак достижения уровня */
  achieved?: Maybe<Scalars['Boolean']['output']>;
  /** Процент зачтенных заданий уровня */
  levelPerformance: Scalars['Int']['output'];
  /** id ученика */
  studentId: Scalars['UUID']['output'];
};

export type StudentLightMarkModel = {
  __typename?: 'StudentLightMarkModel';
  /** Оценка */
  journalStudentMarkModel: JournalStudentMark;
  /** Активность (домашняя, классная работа) */
  learningActivity?: Maybe<LearningActivity>;
  /** Урок к которому привязана оценка */
  lesson?: Maybe<Lesson>;
};

export type StudentMark = {
  __typename?: 'StudentMark';
  studentLessons?: Maybe<Array<Maybe<StudentLessonData>>>;
  studyActivities?: Maybe<Array<Maybe<StudyActivity>>>;
};

/** Материалы к домашнему заданию и к уроку */
export type StudentMaterialsForLessonModel = {
  __typename?: 'StudentMaterialsForLessonModel';
  /** Список материалов к домашнему заданию */
  homeworkContentItem?: Maybe<Array<ContentItem>>;
  /** Список материалов к уроку */
  lessonContentItem?: Maybe<Array<ContentItem>>;
};

/** Персонализированный учебный модуль */
export type StudentModule = {
  __typename?: 'StudentModule';
  /** Включен/Выключен чек-бокс "Просмотр контента" */
  accessBeforeStartProgress?: Maybe<Scalars['Boolean']['output']>;
  /** Информация о закрытии модуля */
  achieveInfo: ModuleAchieveInfo;
  /** Максимально достигнутый Студентом Уровень в рамках Учебного Модуля */
  achievedLevel: Scalars['Float']['output'];
  /** формула подсчета оценки при повторном прохождении проекта */
  attemptCountingFormula?: Maybe<AttemptCountingFormulaEnum>;
  /** Аватар модуля (старая версия) */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Награды, выдаваемые за закрытие модуля */
  awards: Array<UserModuleAward>;
  /** Признак что на данный модуль можно зарегистрироваться */
  canRegister: Scalars['Boolean']['output'];
  /** Дата окончания проверки */
  checkFinish?: Maybe<Scalars['DateTime']['output']>;
  /** Комментарий Учителя по прогрессу прохождения Учебного Модуля Учеником */
  comment?: Maybe<Scalars['String']['output']>;
  /** Количество выполненных заданий */
  completedTaskCount: Scalars['Int']['output'];
  /** Дата завершение проекта студентом */
  completionDate?: Maybe<Scalars['DateTime']['output']>;
  /** Базовые параметры курса */
  courseBaseParameters?: Maybe<CourseBaseParameters>;
  /** Номер попытки */
  currentAttemptNumber?: Maybe<Scalars['Int']['output']>;
  /** Текущий урок модуля. Определяется по тайм-зоне школы ученика */
  currentLesson?: Maybe<StudentLesson>;
  /** Текущее рекомендуемое задание в рамках модуля */
  currentTask?: Maybe<StudentTask>;
  /** Дедлайн цели */
  deadLineDate?: Maybe<Scalars['Date']['output']>;
  /** Дата окончания выполнения */
  deadline?: Maybe<Scalars['DateTime']['output']>;
  /** Отображаемый статус проекта */
  displayedGoalStatus?: Maybe<DisplayedGoalStatus>;
  /** Продолжительность модуля */
  durationFromStageSubjectGroupPlan?: Maybe<Scalars['Int']['output']>;
  /** Очки за экзамен */
  examPoints?: Maybe<Scalars['Int']['output']>;
  /** Начисленный фактический процент выполнения задания */
  finalPercentage?: Maybe<Scalars['Int']['output']>;
  /** Начисленный фактический бал выполнения задания */
  finalPoint?: Maybe<Scalars['Int']['output']>;
  /** Дата завершения выполнения проекта шедуллером (если проект не завершён шедуллером, вернёт null) */
  finishedExecutionDateByScheduler?: Maybe<Scalars['DateTime']['output']>;
  /** Ссылка на геймифицированный контент (для гейм-модулей) */
  gameLink?: Maybe<Scalars['String']['output']>;
  /** Типы модулей */
  goalExecutionType?: Maybe<ModuleExecutionType>;
  /** Порядковый номер модуля в предмете */
  goalOrderNumber?: Maybe<Scalars['Int']['output']>;
  /** Статусы модуля */
  goalStatus?: Maybe<GoalStatus>;
  /**
   * Количество заданий, относящихся к теме лайт
   * @deprecated Использовать studentPlaylistTasksCount
   */
  goalTasksCount?: Maybe<Scalars['Int']['output']>;
  /** Доступен ли Учебный Модуль на чтение текущему пользователю */
  hasReadAccess: Scalars['Boolean']['output'];
  /** Часы из Базисного Плана */
  hours?: Maybe<SubjectHours>;
  /** moduleId / goalId / Ид модуля / Ид цели */
  id: Scalars['ID']['output'];
  /** Признак текущего модуля */
  isActive: Scalars['Boolean']['output'];
  /** Флаг - отсутствуют ли дедлайны в модуле, null, когда не применимо */
  isDeadlineFree?: Maybe<Scalars['Boolean']['output']>;
  /** Является ли дедлайл жестким. После истечения жесткого дедлайна нельзять отправлять задания модуля на проверку */
  isHardDeadline: Scalars['Boolean']['output'];
  /** Флаг - готов ли Учебный Модуль к генерации Траектории */
  isReadyForPlanning: Scalars['Boolean']['output'];
  /** Прошел ли ученик рефлексию по модулю */
  isReflectionPassed: Scalars['Boolean']['output'];
  /** Флаг для определения доступности ретраев задания */
  isRetryAvailable: Scalars['Boolean']['output'];
  /** Флаг - выставлен ли порядковый номер */
  isSubjectOrderNumberExists?: Maybe<Scalars['Boolean']['output']>;
  /** Лендинг модуля */
  landingTemplate: StudyModuleLandingTemplate;
  /** Обложка модуля */
  landingUrl?: Maybe<Scalars['String']['output']>;
  /** Id локального курса */
  localCourseId?: Maybe<Scalars['ID']['output']>;
  /** Флаг обязательности модуля */
  mandatory: Scalars['Boolean']['output'];
  /** * Флаг обязательности Учебного Модуля в рамках текущего Плана */
  mandatoryIntoPlan: Scalars['Boolean']['output'];
  /** Оценка */
  mark?: Maybe<SchoolMark>;
  /** Максимальный уровень на который учителем был закрыт Учебный Модуль */
  maxClosedByTeacherLevel?: Maybe<Scalars['Float']['output']>;
  /** Краткое описание модуля # */
  moduleShortDesc: Scalars['String']['output'];
  /** Название модуля */
  moduleTitle: Scalars['String']['output'];
  /** Заходил ли ученик в мотивационный блок */
  motivationBlockOpened: Scalars['Boolean']['output'];
  /** Есть ли мотивационный блок у модуля */
  motivationBlockPresent: Scalars['Boolean']['output'];
  /** Ответ ученика на проблемный вопрос мотивационного блока */
  motivationBlockProblematicAnswer?: Maybe<Scalars['String']['output']>;
  /** Вопрос на который ученик давал ответ в мотивационном блоке данного модуля */
  motivationBlockProblematicQuestion?: Maybe<Scalars['String']['output']>;
  /** Дата регистрации */
  openRegistration?: Maybe<Scalars['DateTime']['output']>;
  /** Персональные Контрольные Работы Ученика по Учебному Модулю */
  personalControlWorks: Array<PersonalControlWork>;
  /** Цель по отстающему предмету */
  personalObjective?: Maybe<PersonalObjective>;
  /** Тип Плана, в рамках которого ученик выполняет Учебный Модуль */
  planType: PlanTypeEnum;
  /** Задания модуля, которые запланированы у ученика в календаре */
  planedTasks: Array<StudentTask>;
  /** Запланированный уровень достижения цели учителем */
  plannedGoalLevel: Scalars['String']['output'];
  /** Планируемая ТрудоемкостьStudyModule */
  plannedLaboriousness: Scalars['Int']['output'];
  /** Запланированный уровень достижения цели учителем */
  plannedLevel?: Maybe<Scalars['Float']['output']>;
  /** Плейлист, назначенный Студенту для прохождения текущего Учебного Модуля */
  playlist?: Maybe<Playlist>;
  /** Задачи, по которым Студент проявлял активность вне текущей Траектории */
  pointsOutOfTrajectory: Array<StudentTask>;
  /** Прогноз прохождения модуля */
  probability?: Maybe<Scalars['Boolean']['output']>;
  /** Результат выполнения модуля */
  resultModuleCompletion?: Maybe<ResultModuleCompletion>;
  /** Список гибких навыков с макс. кол-вом очков за проект */
  softSkills: Array<SoftSkillPoint>;
  /** Запланированная дата начала выполнения Учебного Модуля */
  startDate?: Maybe<Scalars['Date']['output']>;
  /** Дата начала выполнения */
  startProgress?: Maybe<Scalars['DateTime']['output']>;
  /** Id ученика */
  studentId: Scalars['ID']['output'];
  /** Запланированный уровень достижения цели студентом */
  studentLevel?: Maybe<Scalars['Float']['output']>;
  studentModuleId: Scalars['ID']['output'];
  /** Количество заданий в текущей системе заданий модуля ученика */
  studentPlaylistTasksCount: Scalars['Int']['output'];
  /** Запланированный уровень достижения цели студентом */
  studentTargetGoalLevel?: Maybe<Scalars['String']['output']>;
  /** Учебный модуль */
  studyModule: StudyModule;
  /** Полное название предмета/дисциплины */
  subjectFullTitle: Scalars['String']['output'];
  /** Ид дисциплины */
  subjectId: Scalars['ID']['output'];
  /** Порядковый номер предмета */
  subjectOrderNumber?: Maybe<Scalars['Int']['output']>;
  /** Название предмета/дисциплины */
  subjectTitle: Scalars['String']['output'];
  /** Количество заданий в модуле */
  taskCount: Scalars['Int']['output'];
  /** Настройки команды из плана на класс, null если проект не групповой */
  teamSettings?: Maybe<TeamSettings>;
  /** Темп прохождения модуля участником относительно ожидаемого */
  tempo: StudentModuleTempo;
  /** Текущие задания в модуле */
  threeNextTasks?: Maybe<Array<StudentTask>>;
  /** Персонализированная траектория */
  trajectory?: Maybe<PersonalTrajectory>;
  /** Наличие актуальной траектории по данному модулю */
  validTrajectoryExists: Scalars['Boolean']['output'];
};

/** Полная информация по Учебному Модулю в контексте Студента */
export type StudentModuleInfo = {
  __typename?: 'StudentModuleInfo';
  /**
   * Плэйлисты, доступные для назначения Студенту
   *  + плейлист, который в данный момент назначен на студента по этому модулю
   */
  availableModulePlaylists: Array<Playlist>;
  /** Группа по Предмету, в рамках которой Студент в данный момент изучает Предмет, к которому относится Модуль */
  currentClassSubject?: Maybe<ClassSubject>;
  /** Персональная информация по Учебному Модулю в контексте Студента */
  studentModule?: Maybe<StudentModule>;
  /** Студент в Подгруппе, в рамках которой Студент в данный момент выполняет Учебный Модуль */
  subgroupStudent?: Maybe<StudentInSubgroup>;
};

/** Персонализированный учебный модуль лайт */
export type StudentModuleLight = {
  __typename?: 'StudentModuleLight';
  /** Дата окончания выполения модуля актуальная */
  actualEndDate?: Maybe<Scalars['Date']['output']>;
  /** Дата начала выполения модуля актуальная */
  actualStartDate?: Maybe<Scalars['Date']['output']>;
  /**
   * Дата окончания выполения модуля устаревшая
   * @deprecated We need nullable field due to out of plan modules
   */
  endDate: Scalars['Date']['output'];
  /** Флаг наличия траектории по модулю */
  hasTrajectory: Scalars['Boolean']['output'];
  /** moduleId / goalId / Ид модуля */
  id: Scalars['ID']['output'];
  /** Краткое описание модуля */
  moduleShortDesc: Scalars['String']['output'];
  /** Название модуля */
  moduleTitle: Scalars['String']['output'];
  /** Тип Плана, в рамках которого ученик выполняет Учебный Модуль */
  planType?: Maybe<PlanTypeEnum>;
  /** Задания модуля отсортированные по плейлисту */
  plannedTasks: Array<StudentTask>;
  /**
   * Дата начала выполения модуля устаревшая
   * @deprecated We need nullable field due to out of plan modules
   */
  startDate: Scalars['Date']['output'];
  /** Идентификатор предмета учебного модуля */
  subjectId: Scalars['ID']['output'];
};

/** Состояние прохождения модуля учеников */
export enum StudentModuleState {
  /** Модуль запланирован для изучения и уже пройден */
  Completed = 'COMPLETED'
}

export type StudentModuleStatus = {
  __typename?: 'StudentModuleStatus';
  achievedTime?: Maybe<Scalars['DateTime']['output']>;
  daysBeforeEndDate?: Maybe<Scalars['Int']['output']>;
  endDate: Scalars['Date']['output'];
  goalAvatarUrl?: Maybe<Scalars['String']['output']>;
  goalId: Scalars['Int']['output'];
  goalName: Scalars['String']['output'];
  goalNumber: Scalars['Int']['output'];
  goalStatus: Scalars['Int']['output'];
  hidePercent: Scalars['Boolean']['output'];
  isHardEndDate: Scalars['Boolean']['output'];
  maxArchLevel: Scalars['String']['output'];
  plan: Scalars['Int']['output'];
  startDate: Scalars['Date']['output'];
};

export type StudentModuleTempo = {
  __typename?: 'StudentModuleTempo';
  actualEndDate?: Maybe<Scalars['Date']['output']>;
  actualStartDate?: Maybe<Scalars['Date']['output']>;
  progressPercentage?: Maybe<Scalars['Float']['output']>;
  tempoStatus?: Maybe<StudentModuleTempoEnum>;
};

/** Темп выполнения модуля учеником */
export enum StudentModuleTempoEnum {
  /** ученик отстает от ожидаемого темпа */
  Expired = 'EXPIRED',
  /** ученик не закрыл модуль до дедлайна */
  Failed = 'FAILED',
  /** отсутствует траектория и достижения */
  NotExists = 'NOT_EXISTS',
  /** ученик выполняет задания в соответсвии с ожидаемым темпом */
  OnTime = 'ON_TIME'
}

export type StudentModuleWidget = {
  __typename?: 'StudentModuleWidget';
  moduleAvatarUrl: Scalars['String']['output'];
  moduleId: Scalars['Int']['output'];
  moduleStatus: Scalars['String']['output'];
  moduleTitle: Scalars['String']['output'];
  subjectTitle: Scalars['String']['output'];
};

export type StudentModuleWidgetData = {
  __typename?: 'StudentModuleWidgetData';
  modules: Array<Maybe<StudentModuleWidget>>;
  progressValue: Scalars['Int']['output'];
};

/** тип агрегированных данных из плана обучения, который напрямую связывает модули с заданиями для конкретного студента. Такакая агрегация нужна для шторы офлайн заданий */
export type StudentModuleWithTasksModel = {
  __typename?: 'StudentModuleWithTasksModel';
  /** Модуль */
  module: StudentModule;
  /** Задания с уровнем которые относятся к данному студенту */
  tasks: Array<TaskWithLevel>;
};

/** Текущий модуль по предмету и общее количество модулей в учебном периоде */
export type StudentModulesInSubjectContext = {
  __typename?: 'StudentModulesInSubjectContext';
  modulesCountInStudyPeriod: Scalars['Int']['output'];
  studentModule?: Maybe<StudentModule>;
};

/** Количество заданий с определенным статусом в модуле */
export type StudentModulesTaskStatusWithQuantity = {
  __typename?: 'StudentModulesTaskStatusWithQuantity';
  /** Количество заданий в модулях студента в определенных статусах */
  moduleTaskStatusQuantity: Array<ModuleTaskStatusWithQuantity>;
  /** идентификатор Студента в Подгруппе (stage_subject_subgroup_students.stage_subject_subgroup_student_id) */
  studentInSubgroupId: Scalars['ID']['output'];
};

export type StudentMutations = {
  __typename?: 'StudentMutations';
  /** Принятие приглашения в команду в групповом задании */
  acceptInvitation: Scalars['Boolean']['output'];
  /** Ответ принят, задание зачтено */
  acceptStudentAnswer: AcceptAnswerResponse;
  acceptTheory: StudentTaskInfo;
  /** S21. Запись на проверку код-ревью */
  addBookingCodeReviewToEventSlot?: Maybe<CalendarBooking>;
  /** S21. Запись на проверку */
  addBookingP2PToEventSlot: CalendarBooking;
  /** @deprecated S21-12171. Заменено на addBookingP2PToEventSlot. Добавлено обязательное поле wasStaffSlotChosen. */
  addBookingToEventSlot: CalendarBooking;
  /** S21. Добавление свободного времени для проверки */
  addEventToTimetable: Array<CalendarEvent>;
  /** Добавить Задание в Траекторию */
  addTrajectoryPoint: PersonalTrajectory;
  attachTaskMessageFile: File;
  /** Отмена приглашения в команду в групповом задании с ручным формированием команд */
  cancelInvitation: StudentInvitationInfo;
  capitulationFromTheCourse: StudentCourseModel;
  /** изменение проверяющего (до самой проверки) */
  changeAnswerReviewer: StudentAnswer;
  /** S21. Изменение свободного таймслота для проверки */
  changeEventSlot: Array<CalendarEvent>;
  /** Изменение имени команды в групповом задании */
  changeGroupName: Scalars['String']['output'];
  changeStudentTaskStatus: StudentTask;
  /** Изменяет статус задания в контексте студента */
  changeTaskProgressStatus: StudentTaskInfo;
  /** S21. Завершить Раунд_1 по код-ревью */
  completeFirstCodeReviewRound: Array<CodeReviewRound>;
  /** Сохранить введенные данные, записать время окончания проверки, вычислить продолжительность проверки */
  completeP2pCheck: Scalars['Float']['output'];
  /** Создание фидбэка на мероприятие */
  createCalendarEventFeedback: StudentEventFeedback;
  /** Запрос на сдвиг дедлайна */
  createDeadlineShiftRequest?: Maybe<DeadlineShiftRequest>;
  /** Создать новую попытку теста для уровня цели (закрывающий тест 2.0) */
  createGoalLevelTestAttempt: StudentGoalLevelTestAttempt;
  createPortfolioDocumentComment: PortfolioDocumentComment;
  createPortfolioDocumentReaction: PortfolioDocumentReaction;
  /** Создание фидбэка проверяемого по заданию, привязанного к чек-листу */
  createReviewFeedback: ReviewFeedback;
  /** Отправка заявки на вступление в класс */
  createStageGroupStudentRequest: StageGroupStudentRequest;
  /** Создать сообщение к заданию */
  createTaskMessage: TaskMessage;
  /** создать факты прочтения комментариев */
  createTaskMessageReadFacts: Array<TaskMessageReadFact>;
  /** Создание команды в групповом задании с ручным формированием команд */
  createTeam: ProjectTeamMembers;
  deattachTaskMessageFile: Scalars['ID']['output'];
  /** S21. Удаление свободного времени для проверки */
  deleteEvent: Scalars['Boolean']['output'];
  /** S21. Удаление свободного таймслота для проверки */
  deleteEventSlot: Scalars['Boolean']['output'];
  /** Удаление цели по её id */
  deletePersonalObjectiveById?: Maybe<Scalars['Boolean']['output']>;
  deletePortfolioDocumentComment: Scalars['Boolean']['output'];
  deletePortfolioDocumentReaction: Scalars['Boolean']['output'];
  deletePortfolioDocuments: Scalars['Boolean']['output'];
  /** Расформирование команды в групповом задании с ручным формированием команд */
  disbandTeam: Scalars['Boolean']['output'];
  /**
   * редактирование отправленного ответа (до проверки учителем)
   * @deprecated Will be deleted in 0.13.0
   */
  editAnswer: StudentAnswer;
  /** Изменить сообщение к заданию и/или прикрепленные к сообщению файлы. Файлы будут соответствовать переданному списку - пустой список удалит файлы */
  editTaskMessage: TaskMessage;
  /** S21. Завершить Раунд_2 по код-ревью, оценить проект и ревьюверов */
  evaluateCodeReviewProjectAndReviewers?: Maybe<StudentCodeReview>;
  /**
   * Проверка ответа ученика на задание с типом "Инофрмационное"
   * @deprecated Changed return type to StudentTask. Use evaluateInfoTaskAnswers.
   */
  evaluateInfoTaskAnswer: Array<TaskPreviewEvaluationWidgetResult>;
  /** Проверка ответа ученика на задание с типом "Инофрмационное" */
  evaluateInfoTaskAnswers: StudentTask;
  evaluateTaskPreviewStudentAnswer: Array<TaskPreviewEvaluationWidgetResult>;
  /** Выход студента из команды в групповом проекте, до начала его выполнения */
  exitStudentFromTeam: Scalars['Boolean']['output'];
  /** Провалить попытку теста для уровня цели (закрывающий тест 2.0) */
  failGoalLevelTestAttempt: StudentGoalLevelTestAttempt;
  /** Генерирует Траекторию достаточную для достижения Учебного Модуля по идентификатору Учебного Модуля (goals.goal_id) */
  generateTrajectory: StudentModule;
  /** S21. Отметка что запланированная встреча не состоялась из-за отсутствия одного из участников */
  markAbsenceInProtocol: BookingStatusEnum;
  /** Пометить уведомления ученика как прочитанные в рамках задания */
  markNotificationsAsRead: Array<Notification>;
  /** Пометить сообщение к заданию как удаленное */
  markTaskMessageAsRemoved: TaskMessage;
  /** Пометить результат как просмотренный */
  markTournamentResultAsShown: Array<UserTournamentResult>;
  /** Отправка кода питон на проверку; в ответ получает id задания */
  postPythonTranslation: Scalars['String']['output'];
  readAllNotifications: Scalars['Boolean']['output'];
  readNotification: Scalars['ID']['output'];
  /** Пометить список Уведомлений как прочитанные */
  readNotifications: Array<Scalars['ID']['output']>;
  /** Отказ от приглашения в команду в групповом задании */
  rejectInvitation: Scalars['Boolean']['output'];
  /** Ответ не принят, задание провалено */
  rejectStudentAnswer: RejectAnswerResponse;
  /** S21. Отмена записи на проверку */
  removeBookingFromEventSlot: Scalars['Boolean']['output'];
  /** S21. Отмена записи на проверку код ревью. {null} - если не найдено событие в календаре */
  removeBookingToCodeReview?: Maybe<CalendarEvent>;
  removeTrajectoryById: Scalars['ID']['output'];
  /** Метод удаляет старую траекторию и автоматически генерирует новую для того же модуля */
  removeTrajectoryByIdAndRegenerateTrajectory: StudentModule;
  /** Метод удаляет старую траекторию и создает новую траекторию только с обязательными заданиями в ней */
  removeTrajectoryByIdAndRestartCreatingTrajectory: StudentModule;
  /** Удалить Задание из Траектории */
  removeTrajectoryPoint: PersonalTrajectory;
  /** Сброс токена раннера для задания в гитлабе */
  resetRunnersToken: GitlabLink;
  /** S21. Повторная попытка создать проект студента в GitLab */
  retryCreatePrivateGitlabProject: Scalars['Boolean']['output'];
  /**
   * новый универсальный метод для отправки ответа ученика (для текстового ответа, ответа surveyjs, ЭОР)
   * переписать с использованием Input
   */
  saveAnswer: SaveAnswerResponse;
  /** Сохранить факт просмотра тултипа по буллингу */
  saveBullyingTooltipView: Scalars['Boolean']['output'];
  /** Сохранить ответ ученика на проблемный вопрос */
  saveMotivationBlockAnswer?: Maybe<Scalars['Boolean']['output']>;
  saveNewDataAndEndTimeCheck: Scalars['Float']['output'];
  /** Формирует/сохраняет Персональную Цель типа CATCH_UP_ON_SUBJECT_TASKS */
  saveNewPersonalObjectiveCatchUpOnSubject: PersonalObjectiveWithBuildInfo;
  saveOrUpdatePortfolioDocument?: Maybe<PortfolioDocument>;
  saveP2PAnswers: Array<SaveAnswerResponse>;
  saveSelfAssessmentAverageValue: Array<SelfAssessmentAverage>;
  /** Сохранение информации по ученику Bootcamp */
  saveSelfCheckInStudInfoBTC?: Maybe<Scalars['Boolean']['output']>;
  saveStudentAnswer: SaveStudentAnswerResponse;
  /** Подача жалобы на буллинг */
  saveStudentBullyingComplaint: Scalars['UUID']['output'];
  /** Сохранение реальной трудоемкости задания */
  saveStudentEffortEstimation: Scalars['ID']['output'];
  /** Сохранение ответа на задание в рамках закрывающего теста */
  saveStudentGoalLevelTestAnswer: SaveStudentGoalLevelTestAnswerResponse;
  /** Сохранение рефлексии по итогу модуля */
  saveStudentGoalReflection: Scalars['ID']['output'];
  saveStudentSoftSkillGoals: Array<Maybe<StudentSoftSkillGoal>>;
  /** Сохранение статуса показа тултипов */
  saveStudentTooltipStatus: Scalars['ID']['output'];
  /** Сохранение информации по соответствию ученика и его университетской почты */
  saveStudentUniversityEmail: Scalars['ID']['output'];
  /** Сохранить желаемый целевой уровень модуля */
  saveTargetGoalLevel: StudentTargetGoalLevel;
  /** Изменяет Траекторию по идентификатору Траектории (ersonal_trajectories.personal_trajectory_id) */
  saveTrajectory: StudentModule;
  /** Отправка приглашения в команду в групповом задании с ручным формированием команд */
  sendInvitation: StudentInvitationInfo;
  /** Отправка студентом заявки на расформирование команды */
  sendTeamDisbandRequest: UserDisbandRequestStatus;
  /** Изменение статуса подтверждения университетской почты */
  setEmailConfirmationStatus?: Maybe<Scalars['Boolean']['output']>;
  /** Смена статуса заданий */
  setExternalStudentTaskStatus: StudentTask;
  /** Установка флага показа страницы с верификацией почты */
  setIsVisibleEmailVerificationPageFlag?: Maybe<Scalars['Boolean']['output']>;
  setMotivationBlockOpened?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Переключить флаг использования нового дизайна
   * @deprecated Будет удалена после внедрения нового дизайна
   */
  setNewDesignUsageFlag: Scalars['Boolean']['output'];
  /** Проставление время первого просмотра задания учеником */
  setStudentTaskFirstViewTime: StudentTask;
  /** Время прохождения задания */
  setTaskCompletionTime?: Maybe<Scalars['Boolean']['output']>;
  setTaskCriteriaConformity: Array<StudentCriteriaValue>;
  /**
   * Установить соответствие критерию
   * @deprecated Field no longer supported
   */
  setTaskCriteriaValue: StudentCriteriaValue;
  /**
   * Подтвердить соответствие критериям
   * @deprecated Field no longer supported
   */
  setTaskCriteriaValueConfirm: Scalars['Boolean']['output'];
  /**
   * Создает Траекторию, которая заполняется исключительно обязательными Заданиями из Плейлиста
   * по идентификатору Учебного Модуля (goals.goal_id)
   */
  startCreatingTrajectory: StudentModule;
  /**
   * S21. Старт Р2Р проверки. Обновление заполненного чек-листа по ответу студента
   * @deprecated Use completeP2pCheck
   */
  startP2pCheck: Scalars['Boolean']['output'];
  /** Запись на мероприятие */
  subscribeToEvent: CalendarEvent;
  /**
   * Запись на экзамен
   * @deprecated Use subscribeToEvent(eventId: ID!)
   */
  subscribeToExam: Exam;
  /**
   * S21. Попытаться списать CRP (сode review points) для отправки модуля на проверку код-ревью
   * {null} - если не удалось списать CRP
   */
  tryDecreaseCodeReviewPoints?: Maybe<Scalars['Int']['output']>;
  /** Отмена записи на мероприятие */
  unsubscribeFromEvent: CalendarEvent;
  /**
   * Отмена записи на экзамен
   * @deprecated Use unsubscribeFromEvent(eventId: ID!)
   */
  unsubscribeFromExam: Exam;
  updatePortfolioDocumentComment: PortfolioDocumentComment;
  updatePortfolioDocumentReaction: PortfolioDocumentReaction;
  /** Обновление списка бейджей ученика за количество пройденных модулей с 4 целевым уровнем */
  updateStudentGoalsCountBadges: Scalars['Boolean']['output'];
  /** Обновление списка бейджей ученика за количество пройденных 'больших вызовов' */
  updateStudentPassedBigChallengeCountBadges: Scalars['Boolean']['output'];
  /** Обновление списка бейджей ученика за количество пройденных модулей выше чем выставлено учителем */
  updateStudentPassedLevelCount: Scalars['Boolean']['output'];
  updateTaskPlanDate: StudentTask;
  /** отозвать ответ */
  withdrawAnswer: Scalars['Boolean']['output'];
};


export type StudentMutationsAcceptInvitationArgs = {
  teamId: Scalars['UUID']['input'];
};


export type StudentMutationsAcceptStudentAnswerArgs = {
  answerId: Scalars['ID']['input'];
  governmentMarkId?: InputMaybe<Scalars['Int']['input']>;
  incomingAnswerContext?: InputMaybe<IncomingAnswerContextInput>;
  studentId: Scalars['ID']['input'];
};


export type StudentMutationsAcceptTheoryArgs = {
  taskId: Scalars['ID']['input'];
};


export type StudentMutationsAddBookingCodeReviewToEventSlotArgs = {
  startTime: Scalars['DateTime']['input'];
  studentGoalId: Scalars['ID']['input'];
};


export type StudentMutationsAddBookingP2PToEventSlotArgs = {
  answerId: Scalars['ID']['input'];
  isOnline?: InputMaybe<Scalars['Boolean']['input']>;
  startTime: Scalars['DateTime']['input'];
  wasStaffSlotChosen: Scalars['Boolean']['input'];
};


export type StudentMutationsAddBookingToEventSlotArgs = {
  answerId: Scalars['ID']['input'];
  startTime: Scalars['DateTime']['input'];
};


export type StudentMutationsAddEventToTimetableArgs = {
  end: Scalars['DateTime']['input'];
  start: Scalars['DateTime']['input'];
};


export type StudentMutationsAddTrajectoryPointArgs = {
  point: PersonalTrajectoryPointInput;
  trajectoryId: Scalars['ID']['input'];
};


export type StudentMutationsAttachTaskMessageFileArgs = {
  file?: InputMaybe<FileInput>;
  messageId: Scalars['ID']['input'];
};


export type StudentMutationsCancelInvitationArgs = {
  teamId: Scalars['UUID']['input'];
  userId: Scalars['ID']['input'];
};


export type StudentMutationsCapitulationFromTheCourseArgs = {
  localCourseId: Scalars['ID']['input'];
};


export type StudentMutationsChangeAnswerReviewerArgs = {
  answerId: Scalars['ID']['input'];
  reviewStudentId: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
};


export type StudentMutationsChangeEventSlotArgs = {
  end: Scalars['DateTime']['input'];
  eventSlotId: Scalars['ID']['input'];
  start: Scalars['DateTime']['input'];
};


export type StudentMutationsChangeGroupNameArgs = {
  newName: Scalars['String']['input'];
  teamId: Scalars['UUID']['input'];
};


export type StudentMutationsChangeStudentTaskStatusArgs = {
  governmentMarkId?: InputMaybe<Scalars['Int']['input']>;
  status: TaskStatusEnum;
  studentTaskId: Scalars['ID']['input'];
};


export type StudentMutationsChangeTaskProgressStatusArgs = {
  studentId: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
  taskStatus: TaskStatusEnum;
};


export type StudentMutationsCompleteFirstCodeReviewRoundArgs = {
  studentGoalId: Scalars['ID']['input'];
};


export type StudentMutationsCompleteP2pCheckArgs = {
  checklistFilledInput: ChecklistFilledInput;
};


export type StudentMutationsCreateCalendarEventFeedbackArgs = {
  studentFeedback: StudentEventFeedbackInput;
};


export type StudentMutationsCreateDeadlineShiftRequestArgs = {
  deadlineRequest: DeadlineShiftRequestInput;
};


export type StudentMutationsCreateGoalLevelTestAttemptArgs = {
  goalLevelTestId: Scalars['ID']['input'];
};


export type StudentMutationsCreatePortfolioDocumentCommentArgs = {
  documentDate: Scalars['DateTime']['input'];
  parentId?: InputMaybe<Scalars['UUID']['input']>;
  portfolioDocumentId: Scalars['UUID']['input'];
  senderId: Scalars['UUID']['input'];
  text: Scalars['String']['input'];
  userId: Scalars['UUID']['input'];
};


export type StudentMutationsCreatePortfolioDocumentReactionArgs = {
  documentDate: Scalars['DateTime']['input'];
  portfolioDocumentId: Scalars['UUID']['input'];
  portfolioReactionId: Scalars['UUID']['input'];
  senderId: Scalars['UUID']['input'];
  userId: Scalars['UUID']['input'];
};


export type StudentMutationsCreateReviewFeedbackArgs = {
  reviewFeedbackInput: ReviewFeedbackInput;
};


export type StudentMutationsCreateStageGroupStudentRequestArgs = {
  stageGroupId: Scalars['ID']['input'];
};


export type StudentMutationsCreateTaskMessageArgs = {
  files: Array<FileInput>;
  studentId?: InputMaybe<Scalars['ID']['input']>;
  taskId: Scalars['ID']['input'];
  text: Scalars['String']['input'];
};


export type StudentMutationsCreateTaskMessageReadFactsArgs = {
  messageIds: Array<Scalars['ID']['input']>;
};


export type StudentMutationsCreateTeamArgs = {
  taskId: Scalars['ID']['input'];
};


export type StudentMutationsDeattachTaskMessageFileArgs = {
  messageFileId: Scalars['ID']['input'];
};


export type StudentMutationsDeleteEventArgs = {
  eventId: Scalars['ID']['input'];
};


export type StudentMutationsDeleteEventSlotArgs = {
  eventSlotId: Scalars['ID']['input'];
};


export type StudentMutationsDeletePersonalObjectiveByIdArgs = {
  id: Scalars['ID']['input'];
};


export type StudentMutationsDeletePortfolioDocumentCommentArgs = {
  portfolioDocumentCommentId: Scalars['UUID']['input'];
  portfolioDocumentId: Scalars['UUID']['input'];
};


export type StudentMutationsDeletePortfolioDocumentReactionArgs = {
  portfolioDocumentId: Scalars['UUID']['input'];
  portfolioDocumentReactionId: Scalars['UUID']['input'];
};


export type StudentMutationsDeletePortfolioDocumentsArgs = {
  portfolioDocumentIds: Array<InputMaybe<Scalars['UUID']['input']>>;
};


export type StudentMutationsDisbandTeamArgs = {
  teamId: Scalars['UUID']['input'];
};


export type StudentMutationsEditAnswerArgs = {
  answer: Scalars['String']['input'];
  answerId: Scalars['ID']['input'];
};


export type StudentMutationsEditTaskMessageArgs = {
  files: Array<FileInput>;
  messageId: Scalars['ID']['input'];
  text: Scalars['String']['input'];
};


export type StudentMutationsEvaluateCodeReviewProjectAndReviewersArgs = {
  finalMark: Scalars['Boolean']['input'];
  studentGoalId: Scalars['ID']['input'];
  studentMarks: Array<CodeReviewersMarksInput>;
};


export type StudentMutationsEvaluateInfoTaskAnswerArgs = {
  answers: Array<AnswerToWidgetInput>;
  studentTaskId: Scalars['ID']['input'];
};


export type StudentMutationsEvaluateInfoTaskAnswersArgs = {
  answers: Array<AnswerToWidgetInput>;
  taskId: Scalars['ID']['input'];
};


export type StudentMutationsEvaluateTaskPreviewStudentAnswerArgs = {
  answers: Array<TaskPreviewEvaluationWidgetInput>;
};


export type StudentMutationsExitStudentFromTeamArgs = {
  exitReasonDescription?: InputMaybe<Scalars['String']['input']>;
  exitReasonId?: InputMaybe<Scalars['Int']['input']>;
  teamId: Scalars['UUID']['input'];
};


export type StudentMutationsFailGoalLevelTestAttemptArgs = {
  studentGoalLevelTestAttemptId: Scalars['ID']['input'];
};


export type StudentMutationsGenerateTrajectoryArgs = {
  goalId: Scalars['ID']['input'];
};


export type StudentMutationsMarkAbsenceInProtocolArgs = {
  bookingId: Scalars['ID']['input'];
};


export type StudentMutationsMarkNotificationsAsReadArgs = {
  taskId: Scalars['ID']['input'];
};


export type StudentMutationsMarkTaskMessageAsRemovedArgs = {
  messageId: Scalars['ID']['input'];
};


export type StudentMutationsMarkTournamentResultAsShownArgs = {
  userTournamentResultIds: Array<Scalars['UUID']['input']>;
};


export type StudentMutationsPostPythonTranslationArgs = {
  sourceCode: Scalars['String']['input'];
};


export type StudentMutationsReadNotificationArgs = {
  notificationId: Scalars['ID']['input'];
};


export type StudentMutationsReadNotificationsArgs = {
  notificationIds: Array<Scalars['ID']['input']>;
};


export type StudentMutationsRejectInvitationArgs = {
  teamId: Scalars['UUID']['input'];
};


export type StudentMutationsRejectStudentAnswerArgs = {
  answerId: Scalars['ID']['input'];
  finalTry: Scalars['Boolean']['input'];
  governmentMarkId?: InputMaybe<Scalars['Int']['input']>;
  studentId: Scalars['ID']['input'];
};


export type StudentMutationsRemoveBookingFromEventSlotArgs = {
  bookingId: Scalars['ID']['input'];
};


export type StudentMutationsRemoveBookingToCodeReviewArgs = {
  eventId: Scalars['ID']['input'];
};


export type StudentMutationsRemoveTrajectoryByIdArgs = {
  trajectoryId: Scalars['ID']['input'];
};


export type StudentMutationsRemoveTrajectoryByIdAndRegenerateTrajectoryArgs = {
  trajectoryId: Scalars['ID']['input'];
};


export type StudentMutationsRemoveTrajectoryByIdAndRestartCreatingTrajectoryArgs = {
  trajectoryId: Scalars['ID']['input'];
};


export type StudentMutationsRemoveTrajectoryPointArgs = {
  pointId: Scalars['ID']['input'];
  trajectoryId: Scalars['ID']['input'];
};


export type StudentMutationsResetRunnersTokenArgs = {
  taskId: Scalars['ID']['input'];
};


export type StudentMutationsRetryCreatePrivateGitlabProjectArgs = {
  studentAnswerId: Scalars['ID']['input'];
};


export type StudentMutationsSaveAnswerArgs = {
  answer?: InputMaybe<Scalars['String']['input']>;
  checkBucketId?: InputMaybe<Scalars['UUID']['input']>;
  externalResult?: InputMaybe<Scalars['String']['input']>;
  externalSurvey?: InputMaybe<ExternalSurveyAnswerInput>;
  files?: InputMaybe<Array<FileInput>>;
  incomingAnswerContext?: InputMaybe<IncomingAnswerContextInput>;
  lessonId?: InputMaybe<Scalars['ID']['input']>;
  lessonPlanId?: InputMaybe<Scalars['ID']['input']>;
  reviewStudentId?: InputMaybe<Scalars['ID']['input']>;
  taskId: Scalars['ID']['input'];
  testAnswer?: InputMaybe<Scalars['String']['input']>;
};


export type StudentMutationsSaveMotivationBlockAnswerArgs = {
  answer: Scalars['String']['input'];
  goalId: Scalars['ID']['input'];
};


export type StudentMutationsSaveNewDataAndEndTimeCheckArgs = {
  filledChecklistInput: FilledChecklistInput;
};


export type StudentMutationsSaveNewPersonalObjectiveCatchUpOnSubjectArgs = {
  dayWorkTimeForObjective: Scalars['Int']['input'];
  replaceExisting: Scalars['Boolean']['input'];
  subjectId: Scalars['ID']['input'];
};


export type StudentMutationsSaveOrUpdatePortfolioDocumentArgs = {
  categoryCode: Scalars['String']['input'];
  documentDate: Scalars['Date']['input'];
  documentName: Scalars['String']['input'];
  fields: Array<PortfolioDocumentFieldsInput>;
  files?: InputMaybe<Array<PortfolioDocumentFileInput>>;
  portfolioDocumentId?: InputMaybe<Scalars['UUID']['input']>;
  typeCode: Scalars['String']['input'];
};


export type StudentMutationsSaveP2PAnswersArgs = {
  taskIds: Array<Scalars['ID']['input']>;
};


export type StudentMutationsSaveSelfAssessmentAverageValueArgs = {
  selfAssessmentAverageInputList: Array<SelfAssessmentAverageInput>;
};


export type StudentMutationsSaveSelfCheckInStudInfoBtcArgs = {
  studentsInfo: BtcStudentsInfoInputModel;
  trajectoryTemplateId: Scalars['ID']['input'];
};


export type StudentMutationsSaveStudentAnswerArgs = {
  answerBody?: InputMaybe<Scalars['String']['input']>;
  answersToWidgets?: InputMaybe<Array<AnswerToWidgetInput>>;
  files: Array<FileInput>;
  incomingAnswerContext?: InputMaybe<IncomingAnswerContextInput>;
  lessonId?: InputMaybe<Scalars['ID']['input']>;
  lessonPlanId?: InputMaybe<Scalars['ID']['input']>;
  reviewUserId?: InputMaybe<Scalars['ID']['input']>;
  taskId: Scalars['ID']['input'];
  widgetAnswers: Array<WidgetAnswerInput>;
};


export type StudentMutationsSaveStudentBullyingComplaintArgs = {
  studentBullyingComplaintInput: StudentBullyingComplaintInput;
};


export type StudentMutationsSaveStudentEffortEstimationArgs = {
  studentEffortEstimationInput: StudentEffortEstimationInput;
};


export type StudentMutationsSaveStudentGoalLevelTestAnswerArgs = {
  answer?: InputMaybe<Scalars['String']['input']>;
  answersToWidgets?: InputMaybe<Array<AnswerToWidgetInput>>;
  taskId: Scalars['ID']['input'];
};


export type StudentMutationsSaveStudentGoalReflectionArgs = {
  studentGoalReflectionInput: StudentGoalReflectionInput;
};


export type StudentMutationsSaveStudentSoftSkillGoalsArgs = {
  studentSoftSkillGoalInputs: Array<StudentSoftSkillGoalInput>;
};


export type StudentMutationsSaveStudentTooltipStatusArgs = {
  studentTooltipStatus: StudentTooltipStatusInput;
};


export type StudentMutationsSaveStudentUniversityEmailArgs = {
  studentUniversityEmailInputModel: StudentUniversityEmailInputModel;
};


export type StudentMutationsSaveTargetGoalLevelArgs = {
  goalId: Scalars['ID']['input'];
  targetedGoalLevel: Scalars['Float']['input'];
};


export type StudentMutationsSaveTrajectoryArgs = {
  points: Array<PersonalTrajectoryPointInput>;
  trajectoryId: Scalars['ID']['input'];
};


export type StudentMutationsSendInvitationArgs = {
  teamId: Scalars['UUID']['input'];
  userId: Scalars['ID']['input'];
};


export type StudentMutationsSendTeamDisbandRequestArgs = {
  comment: Scalars['String']['input'];
  goalId?: InputMaybe<Scalars['ID']['input']>;
  teamId: Scalars['UUID']['input'];
  urlFileComment?: InputMaybe<Scalars['String']['input']>;
};


export type StudentMutationsSetEmailConfirmationStatusArgs = {
  status: EmailConfirmationStatus;
  studentId: Scalars['UUID']['input'];
};


export type StudentMutationsSetExternalStudentTaskStatusArgs = {
  taskId: Scalars['ID']['input'];
  taskStatus: TaskStatusEnum;
};


export type StudentMutationsSetIsVisibleEmailVerificationPageFlagArgs = {
  isVisible?: InputMaybe<Scalars['Boolean']['input']>;
  studentId: Scalars['UUID']['input'];
};


export type StudentMutationsSetMotivationBlockOpenedArgs = {
  goalId: Scalars['ID']['input'];
};


export type StudentMutationsSetNewDesignUsageFlagArgs = {
  isNewDesignEnabled: Scalars['Boolean']['input'];
};


export type StudentMutationsSetStudentTaskFirstViewTimeArgs = {
  taskId: Scalars['ID']['input'];
};


export type StudentMutationsSetTaskCompletionTimeArgs = {
  actualLaboriousness?: InputMaybe<Scalars['Int']['input']>;
  endDateTime?: InputMaybe<Scalars['DateTime']['input']>;
  startDateTime: Scalars['DateTime']['input'];
  studentId: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
};


export type StudentMutationsSetTaskCriteriaConformityArgs = {
  studentCriteriaValueWrappers?: InputMaybe<Array<StudentCriteriaValueInput>>;
};


export type StudentMutationsSetTaskCriteriaValueArgs = {
  criteriaId: Scalars['ID']['input'];
  criteriaValue: CriteriaValue;
  studentId: Scalars['ID']['input'];
};


export type StudentMutationsSetTaskCriteriaValueConfirmArgs = {
  studentId: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
};


export type StudentMutationsStartCreatingTrajectoryArgs = {
  goalId: Scalars['ID']['input'];
};


export type StudentMutationsStartP2pCheckArgs = {
  filledChecklistId: Scalars['ID']['input'];
};


export type StudentMutationsSubscribeToEventArgs = {
  eventId: Scalars['ID']['input'];
};


export type StudentMutationsSubscribeToExamArgs = {
  eventId: Scalars['ID']['input'];
};


export type StudentMutationsTryDecreaseCodeReviewPointsArgs = {
  goalId: Scalars['ID']['input'];
};


export type StudentMutationsUnsubscribeFromEventArgs = {
  eventId: Scalars['ID']['input'];
};


export type StudentMutationsUnsubscribeFromExamArgs = {
  eventId: Scalars['ID']['input'];
};


export type StudentMutationsUpdatePortfolioDocumentCommentArgs = {
  portfolioDocumentCommentId: Scalars['UUID']['input'];
  text: Scalars['String']['input'];
};


export type StudentMutationsUpdatePortfolioDocumentReactionArgs = {
  portfolioDocumentReactionId: Scalars['UUID']['input'];
  portfolioReactionId: Scalars['UUID']['input'];
};


export type StudentMutationsUpdateTaskPlanDateArgs = {
  newPlanDate?: InputMaybe<Scalars['DateTime']['input']>;
  studentTaskId: Scalars['ID']['input'];
};


export type StudentMutationsWithdrawAnswerArgs = {
  answerId: Scalars['ID']['input'];
};

/** Пропуски за прошедшие периоды */
export type StudentPastPeriodAttendance = {
  __typename?: 'StudentPastPeriodAttendance';
  /** Кол-во пропусков */
  absenceCount: Scalars['Int']['output'];
  /** Кол-во пропусков по болезни */
  sicknessAbsenceCount: Scalars['Int']['output'];
  /** Период */
  studyPeriodId: Scalars['ID']['output'];
};

/** Информация по плановым и фактическим трудозатратам студента и его прогрессе за текущий учебный период */
export type StudentPerformanceDetails = {
  __typename?: 'StudentPerformanceDetails';
  /** Идентификатор ученика */
  studentId: Scalars['ID']['output'];
  /** Идентификатор текущего учебного периода */
  studyPeriodId?: Maybe<Scalars['ID']['output']>;
  /** Имя учебного периода (1 четверть) */
  studyPeriodName?: Maybe<Scalars['String']['output']>;
  /** Информация по плановым и фактическим трудозатратам студента и его прогрессе за текущий учебный период по предметам, которые есть в плане студента */
  subjectPerformanceInfoItems?: Maybe<Array<Maybe<SubjectPerformanceInfo>>>;
};

/** Этот enum содержит коды групп учеников по успеваемости. */
export enum StudentPerformanceGroupEnum {
  /** Отличники */
  Excellent = 'EXCELLENT',
  /** Отстающие */
  FallingBehind = 'FALLING_BEHIND',
  /** Хорошисты */
  Good = 'GOOD',
  /** Нет оценок */
  NotRated = 'NOT_RATED'
}

/** Оценки за учебный период */
export type StudentPeriodMarks = {
  __typename?: 'StudentPeriodMarks';
  /** Оценки */
  marks: Array<Maybe<JournalCellMark>>;
  /** ID учебного периода */
  studyPeriodId: Scalars['ID']['output'];
};

/** Прогресс ученика по модулям */
export type StudentPersonalProgress = {
  __typename?: 'StudentPersonalProgress';
  actualLaboriousness?: Maybe<Scalars['Int']['output']>;
  /** Имя Буткемп-мастера */
  bootcampMaster?: Maybe<Scalars['String']['output']>;
  /** Email ученика */
  email?: Maybe<Scalars['String']['output']>;
  /** Имя ученика */
  firstName: Scalars['String']['output'];
  /** Формат обучения */
  isStudyOnline?: Maybe<Scalars['Boolean']['output']>;
  laboriousness?: Maybe<Scalars['Int']['output']>;
  laboriousnessDays?: Maybe<Scalars['Int']['output']>;
  /** Дата последнего входа */
  lastAuthorizationDate?: Maybe<Scalars['DateTime']['output']>;
  /** Фамилия ученика */
  lastName: Scalars['String']['output'];
  /** Логин ученика */
  login: Scalars['String']['output'];
  /** Отчество ученика */
  middleName?: Maybe<Scalars['String']['output']>;
  personalEndDate?: Maybe<Scalars['Date']['output']>;
  personalStartDate?: Maybe<Scalars['Date']['output']>;
  planStartDate?: Maybe<Scalars['DateTime']['output']>;
  /** Прогресс прохождения всех модулей в процентах. (пройденные уровени модулей / запланированные уровени модулей) */
  progress: Scalars['Int']['output'];
  progressByFilter?: Maybe<Scalars['Int']['output']>;
  progressByTrajectory?: Maybe<Scalars['Int']['output']>;
  /** информация пользователя из АС Пульс */
  pulsePerson?: Maybe<PulsePersonSmallModel>;
  realEndDate?: Maybe<Scalars['DateTime']['output']>;
  realStartDate?: Maybe<Scalars['DateTime']['output']>;
  /** Город ученика */
  studentCity?: Maybe<Scalars['String']['output']>;
  /** Идентификатор студента (students.student_id) */
  studentId: Scalars['ID']['output'];
  /** Прогресс по модулям */
  studyModuleProgress: Array<StudentStudyModuleProgress>;
  trajectory?: Maybe<Scalars['String']['output']>;
  /** Идентификатор пользователя (users.user_id) */
  userId: Scalars['ID']['output'];
};

/** Прогресс ученика по модулям и траекториям */
export type StudentPersonalProgressByTrajectory = {
  __typename?: 'StudentPersonalProgressByTrajectory';
  actualLaboriousness?: Maybe<Scalars['Int']['output']>;
  /** Имя Буткемп-мастера */
  bootcampMaster?: Maybe<Scalars['String']['output']>;
  /** Email ученика */
  email?: Maybe<Scalars['String']['output']>;
  /** Имя ученика */
  firstName: Scalars['String']['output'];
  /** Формат обучения */
  isStudyOnline?: Maybe<Scalars['Boolean']['output']>;
  laboriousness?: Maybe<Scalars['Int']['output']>;
  laboriousnessDays?: Maybe<Scalars['Int']['output']>;
  /** Дата последнего входа */
  lastAuthorizationDate?: Maybe<Scalars['DateTime']['output']>;
  /** Фамилия ученика */
  lastName: Scalars['String']['output'];
  /** Логин ученика */
  login?: Maybe<Scalars['String']['output']>;
  /** Отчество ученика */
  middleName?: Maybe<Scalars['String']['output']>;
  personalEndDate?: Maybe<Scalars['Date']['output']>;
  personalStartDate?: Maybe<Scalars['Date']['output']>;
  planStartDate?: Maybe<Scalars['DateTime']['output']>;
  progressByFilter?: Maybe<Scalars['Int']['output']>;
  /** Прогресс прохождения всех модулей в процентах. (пройденные уровени модулей / запланированные уровени модулей) */
  progressByTrajectory?: Maybe<Scalars['Int']['output']>;
  /** информация пользователя из АС Пульс */
  pulsePerson?: Maybe<PulsePersonSmallModel>;
  realEndDate?: Maybe<Scalars['DateTime']['output']>;
  realStartDate?: Maybe<Scalars['DateTime']['output']>;
  /** Город ученика */
  studentCity?: Maybe<Scalars['String']['output']>;
  /** Идентификатор студента (students.student_id) */
  studentId: Scalars['ID']['output'];
  /** Прогресс по модулям */
  studyModuleProgress?: Maybe<Array<Maybe<StudentStudyModuleProgress>>>;
  trajectory?: Maybe<Scalars['String']['output']>;
  /** Идентификатор пользователя (users.user_id) */
  userId: Scalars['ID']['output'];
};

/** Данные фильтра для эскпорта данных по прогрессу студентов для Отчета БМ */
export type StudentPersonalProgressExportBtcInput = {
  /** Буткемп-мастер */
  bootcampMaster?: InputMaybe<Scalars['UUID']['input']>;
  /** Фильтры */
  filters?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Идентификаторы модулей */
  goalIds: Array<Scalars['ID']['input']>;
  /** Формат обучения */
  isStudyOnline?: InputMaybe<Scalars['Boolean']['input']>;
  /** Начало диапазона плановой даты начала обучения */
  planStartDateFrom?: InputMaybe<Scalars['Date']['input']>;
  /** Конец диапазона плановой даты начала обучения */
  planStartDateTo?: InputMaybe<Scalars['Date']['input']>;
  /** Идентификаторы классов */
  stageGroupIds: Array<Scalars['ID']['input']>;
  /** Идентификаторы параллелей */
  stageIds: Array<Scalars['ID']['input']>;
  /** Город ученика */
  studentCity?: InputMaybe<Scalars['String']['input']>;
  /** Траектории, фильтр по траекториям. Null, если не нужно фильтровать по траекториям */
  trajectories?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Идентификаторы пользователей */
  userIds: Array<Scalars['ID']['input']>;
};

/** Данные фильтра для эскпорта данных по прогрессу студентов */
export type StudentPersonalProgressExportInput = {
  /** Учебные годы */
  academicYearIds: Array<Scalars['ID']['input']>;
  /** Фильтры */
  filters?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Идентификаторы модулей */
  goalIds: Array<Scalars['ID']['input']>;
  /** Начало диапазона плановой даты начала обучения */
  planStartDateFrom?: InputMaybe<Scalars['Date']['input']>;
  /** Конец диапазона плановой даты начала обучения */
  planStartDateTo?: InputMaybe<Scalars['Date']['input']>;
  /** Идентификатор школы */
  schoolId: Scalars['ID']['input'];
  /** Идентификаторы классов */
  stageGroupIds: Array<Scalars['ID']['input']>;
  /** Идентификаторы параллелей */
  stageIds: Array<Scalars['ID']['input']>;
  /** Траектории, фильтр по траекториям. Null, если не нужно фильтровать по траекториям */
  trajectories?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Идентификаторы пользователей */
  userIds: Array<Scalars['ID']['input']>;
};

/** Результат эскпорта прогресса учеников в файл */
export type StudentPersonalProgressReport = {
  __typename?: 'StudentPersonalProgressReport';
  /** true , пустой отчет или нет. Null, если объект создает логика ШЦП а не Bootcamp и не знает, что ставить. Значение не определено. */
  empty?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Относительный путь к файлу отчета в файловый сервис
   * null , если отчет не содержит данных
   */
  filePath?: Maybe<Scalars['String']['output']>;
};

/** тип Персонального Плана обучения, по которому будет идти учебный процесс ученика */
export type StudentPlan = {
  __typename?: 'StudentPlan';
  id: Scalars['ID']['output'];
  /** список Учебных Модулей в Плане с привязкой к датам и необходимому для достижения уровню */
  modules: Array<StudentModule>;
};

/** Тип содержит комбинацию ИД модуля и ИД системы заданий */
export type StudentPlanGoalWithTaskSet = {
  __typename?: 'StudentPlanGoalWithTaskSet';
  /** Признак, что система задания модуля является текущей в данный момент времени. */
  currentGoal: Scalars['Boolean']['output'];
  /** Модуль входит только в персональные планы */
  goalFromPersonalPlans: Scalars['Boolean']['output'];
  /** Id модуля */
  goalId: Scalars['ID']['output'];
  /** Название модуля */
  goalName: Scalars['String']['output'];
  /** Тип системы заданий */
  playlistType: PlaylistType;
  /** Id системы заданий */
  taskSetId: Scalars['ID']['output'];
  /** Название системы заданий */
  taskSetName: Scalars['String']['output'];
};

/** Тип платформы студента - Edu, Intra */
export enum StudentPlatformType {
  /** ЩЦП или Ш21 */
  Edu = 'EDU',
  /** французская платформа Intra */
  Intra = 'INTRA'
}

/** Фильтр для запроса прогресса учащихся (по пересечению) */
export type StudentProgressFilterBtcInput = {
  /** Буткемп-мастер */
  bootcampMaster?: InputMaybe<Scalars['UUID']['input']>;
  /** Имена колонок, которые следует возвращать */
  filters?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Идентификаторы модулей */
  goalIds: Array<Scalars['ID']['input']>;
  /** Формат прохождения */
  isStudyOnline?: InputMaybe<Scalars['Boolean']['input']>;
  /** Пагинация */
  paging: PagingInput;
  /** Начало диапазона плановой даты начала обучения */
  planStartDateFrom?: InputMaybe<Scalars['Date']['input']>;
  /** Конец диапазона плановой даты начала обучения */
  planStartDateTo?: InputMaybe<Scalars['Date']['input']>;
  /** Идентификаторы классов */
  stageGroupIds: Array<Scalars['ID']['input']>;
  /** Идентификаторы параллелей */
  stageIds: Array<Scalars['ID']['input']>;
  /** Город ученика */
  studentCity?: InputMaybe<Scalars['String']['input']>;
  /** Траектории, фильтр по траекториям. Null, если не нужно фильтровать по траекториям */
  trajectories?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Идентификаторы пользоваталей */
  userIds: Array<Scalars['ID']['input']>;
};

export type StudentProgressFilterBtcInputModelV2 = {
  /** Буткемп-мастер */
  bootcampMaster?: InputMaybe<Scalars['UUID']['input']>;
  /** Детализация фильтра (Если не null -> По траектории студента) */
  detailTrajectory?: InputMaybe<DetailTrajectoryBtcInputModel>;
  /** Имена колонок, которые следует возвращать */
  filters?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Идентификаторы модулей */
  goalIds: Array<Scalars['ID']['input']>;
  /** Формат прохождения */
  isStudyOnline?: InputMaybe<Scalars['Boolean']['input']>;
  /** Пагинация */
  paging: PagingInput;
  /** Идентификаторы классов */
  stageGroupIds: Array<Scalars['ID']['input']>;
  /** Идентификаторы параллелей */
  stageIds: Array<Scalars['ID']['input']>;
  /** Город ученика */
  studentCity?: InputMaybe<Scalars['String']['input']>;
  /** Идентификаторы пользоваталей */
  userIds: Array<Scalars['ID']['input']>;
};

/** Фильтр для запроса прогресса учащихся (по пересечению) */
export type StudentProgressFilterInput = {
  /** Учебные годы */
  academicYearIds: Array<Scalars['ID']['input']>;
  /** Имена колонок, которые следует возвращать */
  filters?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Идентификаторы модулей */
  goalIds: Array<Scalars['ID']['input']>;
  /** Пагинация */
  paging: PagingInput;
  /** Начало диапазона плановой даты начала обучения */
  planStartDateFrom?: InputMaybe<Scalars['Date']['input']>;
  /** Конец диапазона плановой даты начала обучения */
  planStartDateTo?: InputMaybe<Scalars['Date']['input']>;
  /** Идентификатор школы */
  schoolId: Scalars['ID']['input'];
  /** Сортировка */
  sortingFields: Array<SortingField>;
  /** Идентификаторы классов */
  stageGroupIds: Array<Scalars['ID']['input']>;
  /** Идентификаторы параллелей */
  stageIds: Array<Scalars['ID']['input']>;
  /** Траектории, фильтр по траекториям. Null, если не нужно фильтровать по траекториям */
  trajectories?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Идентификаторы пользоваталей */
  userIds: Array<Scalars['ID']['input']>;
};

export type StudentProgressForBtcModel = {
  __typename?: 'StudentProgressForBTCModel';
  /** Фактическая трудоемкость (часы) */
  actualLaboriousness?: Maybe<Scalars['Int']['output']>;
  /** Имя Буткемп-мастера */
  bootcampMaster?: Maybe<Scalars['String']['output']>;
  /** Email ученика */
  email?: Maybe<Scalars['String']['output']>;
  /** Имя ученика */
  firstName: Scalars['String']['output'];
  /** Формат обучения */
  isStudyOnline?: Maybe<Scalars['Boolean']['output']>;
  /** Плановая трудоёмкость (часы) */
  laboriousness?: Maybe<Scalars['Int']['output']>;
  /** Плановая трудоёмкость (дни) */
  laboriousnessDays?: Maybe<Scalars['Int']['output']>;
  /** Дата последнего входа */
  lastAuthorizationDate?: Maybe<Scalars['DateTime']['output']>;
  /** Фамилия ученика */
  lastName: Scalars['String']['output'];
  /** Логин ученика */
  login?: Maybe<Scalars['String']['output']>;
  /** Отчество ученика */
  middleName?: Maybe<Scalars['String']['output']>;
  /** Плановая дата окончания */
  personalEndDate?: Maybe<Scalars['DateTime']['output']>;
  personalStartDate?: Maybe<Scalars['Date']['output']>;
  /** Плановая дата начла */
  planStartDate?: Maybe<Scalars['DateTime']['output']>;
  /**
   * Прогресс прохождения всех запланированных модулей в процентах.
   * (достигнутый уровень/целевой уровень)
   */
  progress?: Maybe<Scalars['Int']['output']>;
  /** Прогресс по фильтру относительно выбранных в фильтре модулей */
  progressByFilter?: Maybe<Scalars['Int']['output']>;
  /** Прогресс прохождения всех модулей в процентах. (пройденные уровени модулей / запланированные уровени модулей) */
  progressByTrajectory?: Maybe<Scalars['Int']['output']>;
  /** информация пользователя из АС Пульс */
  pulsePerson?: Maybe<PulsePersonSmallModel>;
  /** Фактическая дата окончания */
  realEndDate?: Maybe<Scalars['DateTime']['output']>;
  /** Фактическая дата начала */
  realStartDate?: Maybe<Scalars['DateTime']['output']>;
  /** Город ученика */
  studentCity?: Maybe<Scalars['String']['output']>;
  /** Идентификатор студента (students.student_id) */
  studentId: Scalars['ID']['output'];
  /** Прогресс по модулям */
  studyModuleProgress?: Maybe<Array<Maybe<StudentStudyModuleProgress>>>;
  /** Траектория */
  trajectory?: Maybe<Scalars['String']['output']>;
  /** Идентификатор пользователя (users.user_id) */
  userId: Scalars['ID']['output'];
};

/** Фильтр для запроса доступных модулей для прогресса учащихся */
export type StudentProgressSearchModulesInput = {
  /** Учебные годы */
  academicYearIds: Array<Scalars['ID']['input']>;
  /** Идентификатор школы */
  schoolId: Scalars['ID']['input'];
  /** Идентификаторы классов */
  stageGroupIds: Array<Scalars['ID']['input']>;
  /** Идентификаторы параллелей */
  stageIds: Array<Scalars['ID']['input']>;
  /** Идентификаторы предметов */
  subjectIds?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Идентификаторы пользоваталей */
  userIds: Array<Scalars['ID']['input']>;
};

/** Проект студента с привязкой к планам */
export type StudentProjectForBa = {
  __typename?: 'StudentProjectForBA';
  /** Процент выполнения */
  finalPercentage?: Maybe<Scalars['Int']['output']>;
  /** Начисленный фактический бал выполнения задания */
  finalPoint?: Maybe<Scalars['Int']['output']>;
  /** Максимальный бал за задание (основная секция) */
  pointTask: Scalars['Int']['output'];
  /** Тип модуля */
  projectExecutionType: S21ProjectExecutionType;
  /** ID проекта (goalId, localCourseId) */
  projectId: Scalars['ID']['output'];
  /** Наименования модуля */
  projectName: Scalars['String']['output'];
  /** Информация о параллели */
  stage: Stage;
  /** Информация о классе */
  stageGroup: StageGroup;
  /** Дата перевода проекта в текущий статус */
  statusCreationTime?: Maybe<Scalars['Date']['output']>;
  /** Статус проекта студента */
  studentProjectStatus?: Maybe<StudentProjectStatus>;
  /** Список проектов в курсе */
  studentProjectsInCourse: Array<StudentProjectInCourse>;
};

export type StudentProjectInCourse = {
  __typename?: 'StudentProjectInCourse';
  /** Процент выполнения */
  finalPercentage?: Maybe<Scalars['Int']['output']>;
  /** ID модуля */
  goalId: Scalars['ID']['output'];
  /** Тип модуля */
  projectExecutionType: S21ProjectExecutionType;
  /** Наименования модуля */
  projectName: Scalars['String']['output'];
  /** Дата перевода проекта в текущий статус */
  statusCreationTime?: Maybe<Scalars['Date']['output']>;
  /** Идентификатор модуля студента (student_goal_id) */
  studentGoalId: Scalars['ID']['output'];
  /** Статус проекта студента */
  studentProjectStatus?: Maybe<StudentProjectStatus>;
};

/** Информация о проекте студента (в том числе не начатого) */
export type StudentProjectInfo = {
  __typename?: 'StudentProjectInfo';
  /** Тип проекта (exam, individual..) */
  executionType?: Maybe<ModuleExecutionType>;
  /** Процент выполнения */
  finalPercentage?: Maybe<Scalars['Int']['output']>;
  /** Начисленный фактический бал выполнения задания */
  finalPoint?: Maybe<Scalars['Int']['output']>;
  /** Дата завершения проекта студентом */
  finishDate?: Maybe<Scalars['DateTime']['output']>;
  /** Дата принудительной проверки */
  forcedDate?: Maybe<Scalars['DateTime']['output']>;
  /** Идентификатор проверяющего */
  forcedVerifierUserId?: Maybe<Scalars['ID']['output']>;
  /** Ожидаемое время проверки задания в минутах */
  periodOfVerification?: Maybe<Scalars['Int']['output']>;
  /** Максимальный бал за задание (основная секция) */
  pointTask?: Maybe<Scalars['Int']['output']>;
  /** Информация о модуле */
  project: Goal;
  /** Дата сброса оценки */
  resetDate?: Maybe<Scalars['DateTime']['output']>;
  /** Статус проекта */
  status?: Maybe<DisplayedGoalStatus>;
  /** Идентификатор модуля студента (student_goal_id) */
  studentGoalId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор задания относительно студента (student_task_id) */
  studentTaskId?: Maybe<Scalars['ID']['output']>;
  /** Информация о задании */
  task?: Maybe<Task>;
};

/** DTO со статиской студента по проекту */
export type StudentProjectStatisticModel = {
  __typename?: 'StudentProjectStatisticModel';
  /** среднее время выполнения проекта в часах */
  avgProjectLeadTime?: Maybe<Scalars['Int']['output']>;
  /** среднее количество попыток студентов по проекту для сдачи */
  avgRetryCountByCampus?: Maybe<Scalars['Int']['output']>;
  /** комментарий после прохождения p2p */
  comment?: Maybe<Scalars['String']['output']>;
  /** средняя оценка по проекту */
  finalPoint?: Maybe<Scalars['Int']['output']>;
  /** средняя оценка по проекту */
  finalPointAvgByCampus?: Maybe<Scalars['Int']['output']>;
  /** статус проекта */
  goalStatus: GoalStatus;
  /** время выполнения проекта в часах */
  projectLeadTime?: Maybe<Scalars['Int']['output']>;
  /** Полученнный при p2p проверке балл */
  receivedPoint?: Maybe<Scalars['Int']['output']>;
  /** количество попыток которые использовал студент для сдачи проекта */
  retryCount?: Maybe<Scalars['Int']['output']>;
  /**
   * сколько % скилов студент набрал за проект
   * @deprecated unused
   */
  studentSkillPointsOnProject?: Maybe<Scalars['Int']['output']>;
  /** количество студентов закончивших проект */
  studentsFinishedCount: Scalars['Int']['output'];
  /** количество студентов выполняющих проект */
  studentsPerformingCount: Scalars['Int']['output'];
  /** количество зарегистрированых студентов на проекте */
  studentsRegisteredCount: Scalars['Int']['output'];
  /** остальные члены команды, в случае группового проекта */
  teamMembers: Array<Maybe<TeamMember>>;
  /**
   * сколько % скилов всего можно набрать за проект
   * @deprecated unused
   */
  totalAmountSkillPointsOnProject?: Maybe<Scalars['Int']['output']>;
};

/** Статус проекта студента */
export enum StudentProjectStatus {
  /** Пройден */
  Accepted = 'ACCEPTED',
  /** Назначен */
  Assigned = 'ASSIGNED',
  /** Провален */
  Failed = 'FAILED',
  /** В процессе прохождения */
  InProgress = 'IN_PROGRESS',
  /** Зарегистрирован */
  Registered = 'REGISTERED'
}

/** Публичный профиль ученика */
export type StudentPublicProfile = {
  __typename?: 'StudentPublicProfile';
  avatarUrl?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  firstName: Scalars['String']['output'];
  /** классный руководитель */
  formMaster?: Maybe<FormMasterPublicData>;
  id: Scalars['ID']['output'];
  lastName: Scalars['String']['output'];
  middleName?: Maybe<Scalars['String']['output']>;
  parents: Array<ParentPublicData>;
  /** класс ученика */
  stageGroupName?: Maybe<Scalars['String']['output']>;
  teachers: Array<TeacherPublicData>;
};

export type StudentQueries = {
  __typename?: 'StudentQueries';
  /** Статистика. Успеваемость ученика расширенная по аттестационным периодам. Выгрузка в Excel. */
  downloadStudentAcademicPerformanceByAttestationPeriodExpandedExcel: ReportExcelFile;
  /** Статистика. Успеваемость ученика. Выгрузка в Excel */
  downloadStudentAcademicPerformanceExcel: ReportExcelFile;
  /** Статистика. Успеваемость ученика расширенная. Выгрузка в Excel. */
  downloadStudentAcademicPerformanceExpandedExcel: ReportExcelFile;
  /** Отчет "Успеваемость по эл.журналу" выгрузка в Excel */
  downloadStudentJournalPerformanceExcel: ReportExcelFile;
  /**
   * Статистика. Успеваемость ученика по модулям за год по аттестационным периодам. Выгрузка в Excel.
   * @deprecated Под удаление. EDU-48885
   */
  downloadStudentModulePerformanceByAttestationPeriodExcel: ReportExcelFile;
  /** Отчет "Успеваемость" выгрузка в Excel успеваемости по модулям за год */
  downloadStudentModulePerformanceExcel: ReportExcelFile;
  /** Отчет "Итоговые оценки. Детальный" с датами Выгрузка в Excel */
  downloadStudentsMarksResultDetailedExcel: ReportExcelFile;
  /** Выгрузка сертификата ученика */
  exportCertificate: IssuedCertificatePdf;
  /** Возвращает список академических лет школы. Если не передать schoolId, выдаст по текущей */
  getAcademicYears: Array<AcademicYear>;
  /** Возвращает агрегированные данные для диаграммы Радар (Паутинка) */
  getAggregatedStudentRadarChartData: AggregatedStudentRadarChart;
  /**
   * Возвращает все запланированные Учебные Модули Студента по всем предметам
   * @deprecated Use getStudentStageSubjects. Will be deleted in 0.12.0
   */
  getAllPlannedModules: Array<StudentModule>;
  /** Получить все ключевые слова для формирования промпт-строк */
  getAllPortfolioAvatarPromptDetails: Array<Maybe<PortfolioAvatarPromptDetailModel>>;
  /** Получить список всех существующих бейджей */
  getAllPortfolioBadges: Array<Maybe<PortfolioBadge>>;
  /** Получение списка всех университетов для Bootcamp */
  getAllUniversities: Array<UniversityModel>;
  getAllWidgetNotificationsByTypes: Array<DeckWidgetNotification>;
  /** Получить данные для аналитического виджета */
  getAnalyticsDataAcademicPerformance?: Maybe<AnalyticsDataAcademicPerformance>;
  /** S21. получение статуса ответа студента по данной задаче */
  getAnswerStatusById?: Maybe<AnswerStatusEnum>;
  /**
   * Получить доступные для код-ревью студенческие проекты
   * @deprecated getAvailableCodeReviewProjectsV2
   */
  getAvailableCodeReviewProjects: Array<CodeReview>;
  getAvailableCodeReviewProjectsV2: AvailableCodeReviews;
  /** Получение студентов, которые не состоят в других командах, для выполнения группового задания */
  getAvailableStudentsForTeam: Array<StudentInvitationInfo>;
  /**
   * S21. Публичный профиль студента. Получение ссылки на автар по UserId
   * @deprecated use school21 query
   */
  getAvatarByUserId?: Maybe<Scalars['String']['output']>;
  getAvatarHistories: Array<UserAvatarHistory>;
  getAvatarHistoryById: Array<UserAvatarHistory>;
  getAvatars: Array<UserAvatar>;
  /** История получения наград пользователем */
  getAwardHistories: Array<UserAwardHistory>;
  /** История получения награды пользователем */
  getAwardHistoryById: Array<UserAwardHistory>;
  /** Все мои награды */
  getAwards: Array<UserAward>;
  /** Получение информации об учениках Bootcamp */
  getBTCStudentsInfoByStudentId?: Maybe<BtcStudentsInfoModel>;
  /** История получения бейджей */
  getBadgeHistories: Array<UserBadgeAwardHistory>;
  getBadgeHistoryById: Array<UserBadgeAwardHistory>;
  /** Все бейджи, с флагом, выданные или нет */
  getBadges: Array<UserBadgeAward>;
  /**
   * S21. Публичный профиль студента. Получение достижений для публиличного профиля
   * @deprecated use school21 query
   */
  getBadgesPublicProfile: Array<UserBadgeAward>;
  /**
   * S21. Публичный профиль студента. Получение всех доступных достижений пользователя, включая не полученные
   * @deprecated use school21 query
   */
  getBadgesWithFakePublicProfile: Array<UserBadgeAward>;
  /** Получение одноклассников студента, у которых день рождения в переданную дату */
  getBirthdayClassmates: Array<User>;
  /** Возращает здания кабинетами */
  getBuildings: Array<Building>;
  /**
   * S21. Публичный профиль студента. Возращает здания с кабинетами. Для текущего студента, если schoolId не передан
   * @deprecated использовать getStudentByLogin
   */
  getBuildingsBySchoolId: Array<Building>;
  getCalendar: Calendar;
  /** Запрос событий за период на которые студент не оставил отзыва */
  getCalendarEventsWithoutFeedback: Array<Maybe<CalendarEvent>>;
  /** Получение сертификатов доступных студенту */
  getCertificatesForStudent?: Maybe<Array<Maybe<IssuedCertificateModel>>>;
  /**
   * S21. Публичный профиль студента. Получение класса в котором авторизован студент по его логину
   * @deprecated use school21 query
   */
  getClassRoomByLogin?: Maybe<ClassRoom>;
  /** Получить список однокласников, которые делают такое же задание в том же периоде что и ученик. */
  getClassmatesWithSameTask: Array<StudentWithSameTask>;
  /** Получить инфо о ближайшем дедлайне, о котором еще не было уведомления */
  getClosestDeadlinePopup?: Maybe<DeadlineStudentInfo>;
  /**
   * Информация о студентах на плане кластера
   * @deprecated do not use. Will be deleted in 29.0
   */
  getClusterPlanStudents: ClusterPlanStudents;
  /** Информация о студентах на плане кластера по идентификатору кластера (кабинета) */
  getClusterPlanStudentsByClusterId: ClusterPlanStudents;
  /**
   * S21. Публичный профиль студента. Получение коалиции по UserId
   * @deprecated use school21 query
   */
  getCoalitionPublicProfile?: Maybe<CoalitionMember>;
  /**
   * Списаны ли CRP со студента за проведение проверки код-ревью
   * {false} - не списаны
   * {true} - списаны
   */
  getCodeReviewPointChargedOff: Scalars['Boolean']['output'];
  /**
   * Получение всех проектов по код-ревью доступных для студента
   * @deprecated Will be deleted in 41.0.0
   */
  getCodeReviewProjects: CodeReviewProjects;
  /**
   * Получение этапа код-ревью по идентификатору учебного модуля студента
   * @deprecated Use getMyStudentCodeReview. Will be deleted in 40.0.0
   */
  getCodeReviewRoundsByStudentGoalId: Array<CodeReviewRound>;
  /** Возвращает количество непрочитанных текущим пользователем комментариев по заданию. Комментарии пользователя не учитываются */
  getCountUnreadMessages: Scalars['Int']['output'];
  getCurrentAcademicYearStudyPeriods: Array<StudyPeriod>;
  /** Возвращает информацию о Предметах Ученика в рамках данного Учебного Года */
  getCurrentAcademicYearSubjects: AcademicYearSubjects;
  /** S21 получение всех текущих проектов */
  getCurrentGoals?: Maybe<Array<GoalDto>>;
  /** Возвращает текущий турнир. Если текущего нет, возвращает последний турнир ученика. Либо null если нет обоих */
  getCurrentOrLastTournament?: Maybe<GameTournament>;
  /** Возвращает урок в контексте конкретного студента с сокращенной персональной информацией. */
  getCurrentStudentLesson: StudentLessonCompact;
  getCurrentTasks?: Maybe<Array<StudentTask>>;
  getCurrentTasksForCalendar: Array<StudentTask>;
  /** Турнир для студента */
  getCurrentTournament: GameTournament;
  getDaySchedule: Array<Event>;
  /** Получение списка дедлайнов Ш21 по фильтрам */
  getDeadlines: Array<Maybe<DeadlineStudentInfo>>;
  /** Получение количество дедлайнов Ш21 по фильтрам */
  getDeadlinesCount: Scalars['Int']['output'];
  /** Аналог getNotifications возвращающий только те нотификации, которые имеют привязку к предмету */
  getDeckWidgetNotificationsByTypes: Array<DeckWidgetNotification>;
  /** Аналог getNotifications возвращающий только те нотификации, которые имеют привязку к предмету и текущему учебному году */
  getDeckWidgetNotificationsForCurrentAcademicYear: Array<DeckWidgetNotification>;
  /**
   * S21. Публичный профиль студента. Получение email по UserId
   * @deprecated use school21 query
   */
  getEmailbyUserId?: Maybe<Scalars['String']['output']>;
  /** S21.Запрос обогащенного события для агенды студента */
  getEnrichedBooking: CalendarBooking;
  /** S21. Запрос экзамена для агенды студента */
  getEnrichedCalendar: CalendarEvent;
  /** Все полученные шмотки текущего пользователя */
  getEquipments: Array<UserEquipmentAward>;
  getExamTestStudentAnswer?: Maybe<StudentTaskWidgetAnswers>;
  /** Получение списка экзаменов */
  getExams: Array<Exam>;
  /** Опыт пользователя */
  getExperience: UserExperience;
  getExperienceHistory: Array<Maybe<UserExperienceHistory>>;
  /** Получение истории изменения опыта */
  getExperienceHistoryDate: UserExperienceHistoryDate;
  /**
   * S21. Публичный профиль студента. Получение опыта по UserId
   * @deprecated use school21 query
   */
  getExperiencePublicProfile?: Maybe<UserExperience>;
  getExperienceWithValueSomeDaysAgo: UserExperience;
  /** Возвращает информацию о не завершенных в сорк Домашних Работах ученика */
  getExpiredStudentHomeworks: ExpiredStudentHomeworksInfo;
  /** Получение данных о количестве P2P проверок и средней оценке пользователя как ревьюера */
  getFeedbackStatisticsAverageScore: FeedbackStatisticsAverageScore;
  /** Получить заполненный чек-лист по id */
  getFilledChecklistById?: Maybe<FilledChecklist>;
  /** Получить заполненный чек-лист по id проверяемого ответа на задание */
  getFilledChecklistsByStudentAnswerId: Array<FilledChecklist>;
  /**
   * S21. Публичный профиль студента. Получение списка завершенных проектов с датами завершения
   * @deprecated use school21 query
   */
  getFinishedGoalsPublicProfile: Array<GoalFinished>;
  /** Получить студенческие проекты в раунде 1 по код-ревью */
  getFirstRoundCodeReviewProjects: Array<CodeReview>;
  getGenericTestTaskById: StudentTask;
  /** отправить запрос в GigaChat и получить ответ */
  getGigaChatResponse: Array<GigaChatResponse>;
  /** S21. получение ссылок на приватный студенческий Gitlab проект и статуса готовности к использованию по данной задаче */
  getGitlabLinksWithStatus: GitlabLinkWithStatus;
  /** Bootcamp-only метод возвращает историю ревью текущего пользователя, а так же ответы в статусе "На проверке" */
  getGivenReviewAnswersHistory: Array<StudentAnswer>;
  /** Bootcamp-only метод возвращает список заданий отправленных текущему пользователю на ревью P2P */
  getGivenReviewTasksHistory: Array<StudentTask>;
  /** Bootcamp-only метод возвращает историю ревью текущего пользователя, а так же задания учеников в статусе "Требуется проверка" */
  getGivenReviewTasksInV4History: Array<StudentTask>;
  /** Получение статистики по попыткам студента на модуле */
  getGoalAttemptStatistic?: Maybe<Array<Maybe<StudentGoalAttemptStatistic>>>;
  /** Получить информацию по ретраям студента определенного модуля */
  getGoalRetryInfo: StudentGoalRetryInfo;
  /** @deprecated Use getStudentStageSubjects. Will be deleted in 0.12.0 */
  getGridOfModulesBySubjectID: Array<StudentModule>;
  /** @deprecated Use getStudentStageSubjects. Will be deleted in 0.12.0 */
  getGridOfModulesBySubjectIDAndStudyPeriodIds: Array<StudentModule>;
  /** Возвращает данные, необходимые для запроса getStudentTasks (взаимопроверка STUDENT_BY_STUDENT) */
  getGroupCheckInfo: GroupCheckInfo;
  /** Получение списка групповых проектов */
  getGroupProjectsWithOpenTeams: Array<GroupProject>;
  /**
   * Возвращает информацию о Домашней Работе Ученика или null в случае,
   * когда Домашняя Работа не содержит доступных в данный момент для данного Ученика заданий, или текстовой заметки
   */
  getHomeworkInfoById?: Maybe<HomeworkInfo>;
  /** Получение всех учителей у пользователя(ученика) Иннополиса */
  getInnopolisTeachers: Array<InnopolisTeacher>;
  /** Получение флага заполненности данных стундента Bootcamp */
  getIsFilledStudInfoFlagBTC?: Maybe<Scalars['Boolean']['output']>;
  /** Награды, отсортированные по дате выдачи(сначала новые) */
  getLastAwards: Array<UserAward>;
  /**
   * Полученные бейджи, отсортированные по дате выдачи(сначала новые)
   * Если limit=null, то возвращаются все
   */
  getLastBadges: Array<UserBadgeAward>;
  /**
   * Полученные шмотки, отсортированные по дате выдачи(сначала новые)
   * Если limit=null, то возвращаются все
   */
  getLastEquipments: Array<UserEquipmentAward>;
  /** Возвращает заметки к уроку для ученика на следующий учебный день (может совпадать с переданной датой) */
  getLessonNotesForNextSchoolDay: Array<LessonNoteExtended>;
  /**
   * Получение статистики для dashboard (виджет Чанки-Лайт) на дату.
   * Если дата null, то на текущую дату
   * Если userId null, то для текущего пользователя
   */
  getLightTaskStatistics?: Maybe<StudentTaskLightStatisticsModel>;
  /** S21. получение ссылки на приватный студенческий Gitlab проект по данному ответу */
  getLinkToPrivateStudentGitlabProjectByAnswerId: GitlabLink;
  /** S21. получение ссылки на приватный студенческий Gitlab проект по данной задаче */
  getLinkToPrivateStudentGitlabProjectByTaskId: GitlabLink;
  /** S21. получение ссылки на публичный студенческий Gitlab проект по данной задаче */
  getLinkToPublicStudentGitlabProjectByTaskId: GitlabLink;
  /**
   * S21. при изменении публичного студенческого проекта Gitlab по задаче возвращает ссылку на него, если не изменился - null
   * @deprecated Field no longer supported
   */
  getLinkToRenewedPublicStudentProjectIfAny?: Maybe<GitlabLink>;
  /** Получение материалов к домашнему заданию и к уроку по идентификатору урока */
  getMediatekaContentByLessonId: StudentMaterialsForLessonModel;
  /** S21. получение время завершения последнего выполнения задачи студентом из атрибута edu_power_shard.student_tasks.last_need_check_status_time */
  getModifyTimeByTask?: Maybe<Scalars['DateTime']['output']>;
  getModuleById: StudentModule;
  /** Получение полной информации на странице проекта */
  getModuleCoverInformation?: Maybe<ModuleCoverInformation>;
  /**
   * Возвращает текущие Учебные Модуля Студента
   * ВНИМАНИЕ!!! Возвращаемый набор данных захардкожен на бэкенде,
   * при расгирении возвращаемого набора данных необходима доработка на бэке.
   * @deprecated Use getStudentStageSubjects. Will be deleted in 0.12.0
   */
  getModules: Array<StudentModulesInSubjectContext>;
  getMotivationBlockByGoalId?: Maybe<MotivationBlock>;
  getMotivationBlockSections: Array<MotivationBlockSection>;
  /** S21. Запрос записей на проверку студента для выбранного диапазона */
  getMyCalendarBookings: Array<CalendarBooking>;
  /** Получить участников моей коалиции */
  getMyCoalitionMembers: Array<CoalitionMember>;
  /** Получение списка групп, в которые приглашен студент */
  getMyInvitations: Array<GroupProjectInfo>;
  /**
   * Получение процесса код-ревью
   * {null} - если студент не проводит код-ревью
   */
  getMyStudentCodeReview?: Maybe<StudentCodeReview>;
  /**
   * S21. Запрос всех предстоящих событий для виджета "Проверки" вплоть до 'to'
   * Если 'to' не указано, будет подставлено текущее время + 12 часов
   * Если 'limit' не указан, будет возвращать весь список
   */
  getMyUpcomingBookings: Array<CalendarBooking>;
  /** S21. Запрос обезличенных таймслотов студентов, готовых выполнить проверку */
  getNameLessStudentTimeslotsForReview: CalendarNamelessTimeSlotResponse;
  /** Возвращает информацию о текущих и завершенных Домашних Работах ученика */
  getNonExpiredStudentHomeworks: NonExpiredStudentHomeworksInfo;
  /** Получение сертификатов не доступных к скачиванию ученику */
  getNotReceivedCertificatesForStudent?: Maybe<Array<Maybe<CertificateOfParticipationInfoModel>>>;
  getNotifications: Array<Notification>;
  getNotificationsByTypes: Array<Notification>;
  getNotificationsCount: Scalars['Int']['output'];
  /** Получение информации по проверкам проекта */
  getP2PChecksInfo?: Maybe<P2PChecksInfo>;
  /** S21. Получение информации о P2P проверке (заполненный чек-лист по ответу студента) */
  getP2pInfo: FilledChecklist;
  /** Возвращает Персональную Контрольную Работу по идентификатору */
  getPersonalControlWorkById: PersonalControlWork;
  /** Получение Персональных Целей ученика с определёнными статусами */
  getPersonalObjectivesByStatuses: Array<PersonalObjective>;
  /** Получение цели по ее id */
  getPersonalObjectivesDetailedById?: Maybe<PersonalObjective>;
  getPersonalObjectivesDetailedByStatuses: Array<PersonalObjective>;
  getPersonalTrajectory?: Maybe<PersonalTrajectory>;
  getPlaylist: Playlist;
  /** Получить справочник категорий документов портфолио */
  getPortfolioCategories: Array<PortfolioDocumentCategory>;
  /** Получить комментарии и реакции документов портфолио */
  getPortfolioDocumentReactionsComments?: Maybe<Array<Maybe<PortfolioDocumentReactionsComments>>>;
  /** Получить комментарии и реакции документов портфолио другого пользователя */
  getPortfolioDocumentReactionsCommentsAnotherUser?: Maybe<Array<Maybe<PortfolioDocumentReactionsComments>>>;
  /** Получить данные документа/документов портфолио */
  getPortfolioDocuments?: Maybe<Array<Maybe<PortfolioDocument>>>;
  /** Получить данные документа/документов портфолио другого пользователя */
  getPortfolioDocumentsAnotherUser?: Maybe<Array<Maybe<PortfolioDocument>>>;
  /** Получить список справочников портфолио по ID категории документа (с возможностью фильтрации по type и value) */
  getPortfolioFieldValueListByDocumentCategoryId: Array<PortfolioFieldValueList>;
  /** Получить список справочников портфолио (с возможностью поиска по documentCategoryIds, type и value) */
  getPortfolioFieldValueLists: Array<PortfolioFieldValueList>;
  /** S21. получение ссылки на приватный студенческий Gitlab проект по данному ответу */
  getPrivateGitlabProjectLinkInfoByAnswerId: GitlabLinksWithReadinessStatus;
  /** получение параметров для прокторинга */
  getProctoringParameters: ProctoringParameters;
  /** Получение информации о проверках по проекту */
  getProjectAttemptEvaluationsInfo: Array<ProjectAttemptEvaluationsInfo>;
  getProjectEvaluationsInfo: ProjectEvaluationsInfo;
  /**
   * Получение статистики по проекту (для индивидуальных и групповых проектов)
   * @deprecated Актуальная версия квери getProjectAttemptEvaluationsInfo_V1
   */
  getProjectStatistics?: Maybe<ProjectStatistics>;
  /** Получение информации о команде в групповом задании */
  getProjectTeamMembers?: Maybe<ProjectTeamMembers>;
  /** Получение команды, в которой состоит пользователь, выполняющий групповой проект */
  getProjectTeamWithMembers?: Maybe<ProjectTeamWithMembers>;
  /** Получение списка школьных психологов */
  getPsychologistEmails: Array<Scalars['String']['output']>;
  /** Получить результат выполнения питон-кода внешним сервисом */
  getPythonTranslation: PythonTranslationResult;
  /** Рендомный бейдж из справочника бейджей */
  getRandomBadge?: Maybe<Badge>;
  /** Рендомная шмотка из справочника шмоток */
  getRandomEquipment?: Maybe<Equipment>;
  /** Возвращает список Уведомлений ученика, по его заданиям */
  getRecentTaskNotifications: RecentTaskNotifications;
  /** Получение рекомендуемых студенту проектов и курсов */
  getRecommendedProjects: Array<Maybe<StudentItem>>;
  /** Получение заданий на взаимопроверку учеником */
  getReviewedStudentTasks: Array<StudentTask>;
  getSchedule: Schedule;
  /** Коалиция по ID */
  getSchoolGameCoalition?: Maybe<GameCoalition>;
  /**
   * S21. Публичный профиль студента. Получение SchoolId по Login пользователя, если нет schoolId - EMPTY_UUID
   * @deprecated использовать getStudentByLogin
   */
  getSchoolIdByLogin?: Maybe<Scalars['UUID']['output']>;
  /** Получить студенческие проекты в раунде 2 по код-ревью */
  getSecondRoundCodeReviewProjects: Array<CodeReview>;
  /** Возврашает краткую информацию о прогрессе студента по текущему пользователю */
  getShortStudentProgress: ShortStudentProgress;
  /** Возврашает краткую информацию о прогрессе студента по текущему пользователю для Bootcamp */
  getShortStudentProgressForBTC: ShortStudentProgress;
  /** Получить соответствия критериям по скилам */
  getSkillsTaskCriteriaValues: Array<SkillsTaskCriteriaValue>;
  /** Возвращает информацию о Гибких навыках с примерами заданий ученика */
  getSoftSkillsAbout: Array<StudentSoftSkillAbout>;
  /**
   * S21. Публичный профиль студента. Получение навыков для публиличного профиля
   * @deprecated use school21 query
   */
  getSoftSkillsByStudentId: Array<SoftSkillPower>;
  /**
   * S21. Поиск одноклассников студента по параллели
   * @deprecated use school21 query
   */
  getStageClassmates: Array<User>;
  /** Получение email на класс для помощи студентам Bootcamp */
  getStageGroupHelpEmail?: Maybe<StageGroupHelpEmailModel>;
  /**
   * S21. Публичный профиль студента. Получение волны (аналог stage_group_name) и формы обучения (аналог stage_name) по StudentId
   * @deprecated use school21 query
   */
  getStageGroupS21PublicProfile?: Maybe<StageGroupS21>;
  /** Возвращает список заявок для вступления в класс */
  getStageGroupStudentRequests: Array<StageGroupStudentRequest>;
  /**
   * S21. Публичный профиль студента. Получение всех волн (аналог stage_group_name) и форм обучения (аналог stage_name) по StudentId
   * @deprecated use school21 query
   */
  getStageGroupsS21PublicProfile?: Maybe<Array<Maybe<StageGroupS21>>>;
  /**
   * Статистика. Успеваемость ученика
   * @deprecated Использовать getStudentAcademicPerformanceExpandedV2
   */
  getStudentAcademicPerformance: Array<StudentAcademicPerformance>;
  /** Отчет "Успеваемость" по Аттестационным периодам */
  getStudentAcademicPerformanceByAttestationPeriod: Array<StudentAcademicPerformance>;
  /** Отчет "Успеваемость" по Аттестационным периодам расширенный */
  getStudentAcademicPerformanceByAttestationPeriodExpanded: Array<StudentAcademicPerformanceExpandedV2>;
  getStudentAcademicPerformanceExpanded: Array<StudentAcademicPerformanceExpanded>;
  getStudentAcademicPerformanceExpandedV2: Array<StudentAcademicPerformanceExpandedV2>;
  getStudentAssessmentsTest: Array<SelfAssessmentTest>;
  /** Возвращает результаты по тестам с начала года и с конца, сгруппировав по софт скилам */
  getStudentAssessmentsTestsResults: SelfAssessmentAllTestsResults;
  /** Получение посещаемости студента */
  getStudentAttendance: Array<Maybe<StudentAttendanceBySubject>>;
  /** Получить статус просмотра тултипа по буллингу */
  getStudentBullyingTooltipViewStatus: Scalars['Boolean']['output'];
  /** S21 получение студентов которые выполняют/выполнили тот же проект по проекту пользователя */
  getStudentByProjectAndCampus: StudentsInSameProjectByCampusModel;
  /** Получение процессов код ревью студенческого проекта по его id */
  getStudentCodeReviewByGoalId: StudentCodeReviewsWithCountRound;
  /** Получение процессов код-ревью студенческого проекта, проводимые другими студентами */
  getStudentCodeReviewByStudentGoalId: Array<StudentCodeReview>;
  /** Получение процессов код ревью студенческого проекта, проводимые другими студентами, с датой начала раунда 2 */
  getStudentCodeReviews: StudentCodeReviewsWithPlaneSecondRound;
  /** Получить классные и домашние работы по id урока */
  getStudentCurrentLessonCWorkHWorkByLessonId: StudentCurrentLessonCWorkHWork;
  /** Получение всех текущих проектов студента */
  getStudentCurrentProjects: Array<Maybe<StudentItem>>;
  /** Получение информации о параллели студента */
  getStudentCurrentStage?: Maybe<Stage>;
  /**
   * Получение информации о параллели студента
   * @deprecated Одному пользователю может соответствовать более одного студента, поэтому используем getStudentCurrentStage
   */
  getStudentCurrentStageGroup?: Maybe<Stage>;
  getStudentDashboard: StudentDashboard;
  /** Неагрегированый вариант getStudentDashboard */
  getStudentDashboardParts: StudentDashboard;
  /** Возвращает данные для построения дневника ученика */
  getStudentDiary: StudentDiary;
  /** Возвращает данные для построения дневника ученика за период с учетом временной зоны */
  getStudentDiaryByPeriod: StudentDiary;
  /**
   * Запрос наиболее длительной домашней работы из дневника за период.
   * Если возвращает null, значит нет длительной домашней работы.
   * Длительная домашняя работы та, у которой время выполнения более 20 минут.
   */
  getStudentDiaryLengthyHomework?: Maybe<StudentDiaryLengthyHomework>;
  /** Получение реальной оценки трудоемкости задания */
  getStudentEffortEstimation?: Maybe<StudentEffortEstimation>;
  /** Получение всех завершенных студентом проектов */
  getStudentFinishedProjects: Array<Maybe<StudentItem>>;
  /** Получение закрывающего теста по его ID в контексте студента */
  getStudentGoalLevelTest?: Maybe<StudentGoalLevelTest>;
  getStudentGoalLevelTestAnswers?: Maybe<StudentGoalLevelTestTaskAttemptAnswers>;
  /** Получение информации для виджетов закрывающего теста для всех уровней модуля (сейчас только 2.0) */
  getStudentGoalLevelTestWidgets: Array<StudentGoalLevelTestWidget>;
  /**
   * Получить ответы виджетов в рамках определенного закрывающего теста, определенной задачи
   * @deprecated Рекомендуется getStudentGoalLevelTestAnswers, возвращает не только ответы виджет но и старого конструктора
   */
  getStudentGoalLevelTestWidgetsWithAnswers?: Maybe<Array<Maybe<GoalLevelTestAttemptTaskWidget>>>;
  /** Получение рефлексии по итогам модуля */
  getStudentGoalReflection: StudentGoalReflection;
  /** Загрузить информацию о итогах модуля. */
  getStudentGoalSummary: StudentGoalSummary;
  /**
   * S21. Публичный профиль студента. Получение StudentId по Login пользователя, если нет studetnId - EMPTY_UUID
   * @deprecated использовать getStudentByLogin
   */
  getStudentIdByLogin?: Maybe<Scalars['UUID']['output']>;
  /** Отчет "Успеваемость по эл.журналу" */
  getStudentJournalPerformance: Array<StudentJournalPerformance>;
  /** Возвращает урок в контексте конкретного студента с персональной информацией. */
  getStudentLessonById: StudentLesson;
  /** Данные для виджета оценок ученика(Лайт) */
  getStudentLightMarks?: Maybe<Array<StudentLightMarkModel>>;
  /** Получение студенческого модуля в контексте студента по идентификатору */
  getStudentModuleByStudentGoalId: StudentModule;
  /** Получение информации о плановых и фактических трудозатратах студента и его прогрессе за текущий учебный период */
  getStudentPerformanceDetails: StudentPerformanceDetails;
  /** PMO Возвращает итоговую оценку ученика по предмету для учебных периодов */
  getStudentPmoStudyPeriodFinalMark: Array<Maybe<StudentStudyPeriodFinalMark>>;
  getStudentProfile: Student;
  getStudentProfileByUserId: Student;
  /** S21 получение статистики по проекту пользователя */
  getStudentProjectStatistic: StudentProjectStatisticModel;
  /** Получение всех проектов по userId и stageGroupId */
  getStudentProjectsByStageGroup: Array<Maybe<StudentItem>>;
  /** Возвращает данные для диаграммы Радар (Паутинка) */
  getStudentRadarChartData: Array<StudentRadarChart>;
  /** Ранг текущего студента коалиции в турнире */
  getStudentRankInTournament?: Maybe<CoalitionMemberPowerRank>;
  /** Данные для виджет Рейтинг ученика */
  getStudentRating: Array<Maybe<StudentRatingBySubjectModel>>;
  getStudentRoles: GetStudentRolesResponse;
  /** Возвращает агрегированные данные по навыкам для диаграммы Радар (Паутинка) */
  getStudentSkillRadarChartData: AggregatedSkillStudentRadarChart;
  getStudentSoftSkillGoals: Array<StudentSoftSkillGoal>;
  /** Возвращает класс текущего студента */
  getStudentStageGroup?: Maybe<StageGroup>;
  /** Вернуть все модули по предмету ученика */
  getStudentStageSubjectBySubjectId: StudentStageSubject;
  /** Вернуть все предметы изучаемые учеником в текущем учебном году */
  getStudentStageSubjects: Array<StudentStageSubject>;
  /** LIGHT Возвращает итоговую оценку ученика по предмету для учебных периодов */
  getStudentStudyPeriodFinalMark: Array<Maybe<StudentStudyPeriodFinalMark>>;
  /** получение прогресса и оценок ученика за четверть */
  getStudentStudyPeriodsPerformance: Array<StudentStudyPeriodsPerformanceResponse>;
  /** Вернуть данные по прогрессу ученика до указанной даты */
  getStudentSubjectInfo: Array<StudentStageSubject>;
  /** Получение информации о состоянии прогресса ученика по предмету */
  getStudentSubjectProgressState: StudentSubjectProgressState;
  /**
   * Получение детальной информации о состоянии прогресса ученика по предмету (с понедельным планом или детальной информацией по цели)
   * Выводится детальная информация о цели по отстающему предмету в случае ее наличия или понедельный план с данными по заданиям
   */
  getStudentSubjectProgressStateWithDetails: StudentSubjectProgressState;
  /** Возвращает предметы ученика, участвующие в 'большом вызове' */
  getStudentSubjectsFromBigChallenge: Array<Subject>;
  /** Возвращает модули в контексте студента вместе с уровнями для страницы успеваемости */
  getStudentTaskByModulePlaylist: Array<StudentTaskByModulePlaylist>;
  /** Возвращает Задания в контексте студента по фильтрам */
  getStudentTasks: GetStudentTasksResponse;
  /** Возвращает Задания и нотификации о взаимопроверках в контексте студента по фильтрам */
  getStudentTasksByFilters: GetStudentTasksDashboardResponse;
  /** Получение задач студента по идентификаторам */
  getStudentTasksByIds?: Maybe<Array<Maybe<StudentTask>>>;
  /** Возвращает Задания в контексте студента по фильтрам */
  getStudentTasksByTaskStatus: GetStudentTasksResponse;
  /** Получить список заданий с трудоемкостью и гибкими навыками для попапа на странице "Предметы" */
  getStudentTasksForCurrentModulePopup: Array<StudentModuleWithTasksModel>;
  /** Загрузить оффлайн задания из траектории для текущего студента. */
  getStudentTasksForOfflineTab: Array<SubjectWithModule>;
  /** Получение всей информации для градусников ПМО */
  getStudentThermometerPMO?: Maybe<StudentThermometerPmo>;
  /** Получения статусов тултипов по списку модулей */
  getStudentTooltipStatuses: Array<StudentTooltipStatus>;
  /** получение информации по посещаемости студента в школе и за рабочей станцией, за неделю (пн-вс) входящую в date */
  getStudentTraffic: StudentTraffic;
  /**
   * Получение информации об университетской почте ученика по идентификатору ученика
   * @deprecated Unused. Will be deleted in a release
   */
  getStudentUniversityEmailInfo: StudentUniversityEmailModel;
  /** Получение информации об университетской почте ученика по идентификатору ученика */
  getStudentUniversityEmailInfoV2?: Maybe<StudentUniversityEmailModel>;
  /** Получение посещаемости студента за текущий год */
  getStudentYearAttendance: Array<Maybe<StudentAttendanceBySubject>>;
  /**
   * Возвращает перечень пользователей в соответствии с параметрами и с дополнительными условиями: роль=УЧЕНИК, школы=школа пользователя, который делает запрос
   * Если параметры для запроса не переданы, то вернет пустой список
   */
  getStudentsByParams: Array<Maybe<User>>;
  /** Bootcamp-only Возвращает список студентов, которым можно отправить задание на проверку */
  getStudentsForReview: Array<Student>;
  /** Возвращает полную информацию о студенте по userId */
  getStudentsInfo: Array<Student>;
  getStudentsMarksSubjectsDetailed: StudentFinalMarkSubjectsModel;
  /** Отчет "Итоговые оценки. Детальный" по ученику и всем предметам с датами */
  getStudentsMarksSubjectsDetailedByDates: StudentFinalMarkSubjectsModel;
  /** Получение данных для виджета Градусник Light */
  getSubjectsFinalMarks: Array<Maybe<SubjectFinalMarkModel>>;
  /** Вернуть предметы изучаемые учеником в текущем учебном году для урока на заданную дату */
  getSubjectsForLesson: Array<StudentStageSubject>;
  /** Получить желаемый целевой уровень модуля */
  getTargetGoalLevel?: Maybe<StudentTargetGoalLevel>;
  /** получение списка отправленных ответов на задание текущим учеником */
  getTaskAnswers: Array<StudentAnswer>;
  /** получение списка отправленных ответов на ревью (опциально - по заданному статусу) */
  getTaskAnswersForReview: Array<StudentAnswer>;
  /** Получение всех возможных критериев */
  getTaskCriteria: Array<Criteria>;
  /**
   * Получить оценку по критериям
   * @deprecated Field no longer supported
   */
  getTaskCriteriaGrade: CriteriaRecommendedValue;
  /** Получить соответствия критериям */
  getTaskCriteriaValues: Array<StudentCriteriaValue>;
  /** Bootcamp: получить ссылку на внешнее задание sbercode */
  getTaskExternalLink?: Maybe<Scalars['String']['output']>;
  /** метод возвращает одну studentTaskModel с ответом и контентом проверяемого ученика в статусе "На проверке" */
  getTaskForReview?: Maybe<StudentTask>;
  getTaskMessages: Array<TaskMessage>;
  /** Bootcamp-only получение всех комментариев по задаче, оставленных конкретным студентом, это метод для ревьювера буткемпа */
  getTaskMessagesForReview: Array<TaskMessage>;
  /** S21. Запрос на получение информации о требуемых и запланированных записях на проверку */
  getTaskReviewCountInfo: TaskReviewCountInfo;
  /** Получение статистики по заданиям для dashboard (виджет Чанки-ПМО) облегченный возвращаются только идентификаторы заданий */
  getTaskStatisticsIds?: Maybe<StudentTaskPmoStatisticsLightweightModel>;
  /** S21. получение статуса по данной задаче  для студента */
  getTaskStatusById?: Maybe<TaskStatusEnum>;
  /** получение статуса задания студента по id */
  getTaskStatusByStudentTaskId?: Maybe<TaskStatusEnum>;
  /** получение списка отправленных ответов на виджеты задания текущим учеником */
  getTaskWidgetAnswers: Array<StudentTaskWidgetAnswer>;
  getTasksByIds?: Maybe<Array<Maybe<StudentTask>>>;
  /** Bootcamp-only получение истории отправленных текущим студентом заданий на ревью P2P с указанными статусами ответов */
  getTasksOfMineForReviewHistory: Array<StudentTask>;
  /** Получение настроек периодов группового проекта для тимлида */
  getTeamLeadPeriodSettings?: Maybe<TeamLeadGoalPeriodSettings>;
  /** Получение формирующихся команд по групповым проектам, в которых текущий пользователь имеет требуемую роль */
  getTeamsForCurrentUserBy: Array<ProjectTeamWithMembers>;
  /** Ранг текущего студента и ранги ТОП-5 участников коалиции в турнире */
  getTop5AndMeCoalitionTournamentMembers: Top5AndMeCoalitionTournamentMembers;
  /** Запрос результатов участия студента в турнирах */
  getTournamentResults: Array<UserTournamentResult>;
  /** Получение списка доменов запрашиваемого университета для Bootcamp */
  getUniversityDomains: Array<UniversityDomainModel>;
  getUserBgStickers: Array<UserBgSticker>;
  /** Просмотр истории изменения кол-ва coins */
  getUserCoinsHistory?: Maybe<Array<UserCoinsHistoryItemModel>>;
  /** Просмотр надетого снаряжения другого студента */
  getUserDressedEquipment: Array<UserEquipmentAward>;
  /** Просмотр опыта другого студента */
  getUserExperience: UserExperienceShort;
  /**
   * S21. Публичный профиль студента. Получение UserId по Login пользователя
   * @deprecated use school21 query
   */
  getUserIdByLogin?: Maybe<Scalars['UUID']['output']>;
  /** Возвращает список идентификаторов пользователей, у которых любимый предмет (хотя бы один!) входит в данный список */
  getUserIdsByFavoriteSubjectIds: Array<Scalars['UUID']['output']>;
  /** Возвращает список идентификаторов пользователей, у которых увлечение (хотя бы одно!) входит в данный список */
  getUserIdsByInterests: Array<Scalars['UUID']['output']>;
  /** Получить список бейджей за достижения ученика по userId */
  getUserPortfolioBadgesByUserId: UserPortfolioBadges;
  getUserTournamentWidget: UserTournamentWidget;
  /** Возвращает ссылку на вебинар в Webinar.ru */
  getWebinarRuLink: Scalars['String']['output'];
  /**
   * S21. Публичный профиль студента. Получение рабочей станции за которой авторизован студент по его логин
   * @deprecated do not use. Will be deleted in 31.0
   */
  getWorkstationByLogin?: Maybe<WorkstationModel>;
  /**
   * S21. Публичный профиль студента. Получение рабочей станции за которой авторизован студент по идентификатору студента
   * @deprecated use school21 query
   */
  getWorkstationByUserId?: Maybe<WorkstationModel>;
  /** Включены ли дедлайны для параллели студента? */
  isDeadlinesEnabled: Scalars['Boolean']['output'];
  /** Доступен ли для класса ученика емейл психолога для оказания помощи при издевательствах */
  isPsyEmailExistsByStageGroupId: Scalars['Boolean']['output'];
  /** Проверка существования заявки пользователя на расформирование указанной команды */
  isRequestBeenSentToTeamDisband: Scalars['Boolean']['output'];
  /**
   * Проходит ли ученик модуль вне плана
   * @deprecated Field no longer supported
   */
  isStudentModuleOutOfPlan: Scalars['Boolean']['output'];
  /**
   * Проверить, находится ли таск в траектории или в запланированном модуле
   * @deprecated Field no longer supported
   */
  isTaskInTrajectoryOrPlannedModule: Scalars['Boolean']['output'];
  /** получение условий выполнения проекта */
  loadTaskEvaluationRules: Array<StudentEvaluationRuleGroup>;
  /** Подготовка набора вариантов для новой Персональной Цели ученика, распланированных для разных значений ежедневной нагрузки */
  prepareNewPersonalObjectiveCatchUpOnSubject: PersonalObjectiveCandidates;
};


export type StudentQueriesDownloadStudentAcademicPerformanceByAttestationPeriodExpandedExcelArgs = {
  closeModuleDate: Scalars['Date']['input'];
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  reportDateTime: Scalars['String']['input'];
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type StudentQueriesDownloadStudentAcademicPerformanceExcelArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  reportDateTime: Scalars['String']['input'];
  startDate: Scalars['DateTime']['input'];
};


export type StudentQueriesDownloadStudentAcademicPerformanceExpandedExcelArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  reportDateTime: Scalars['String']['input'];
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type StudentQueriesDownloadStudentJournalPerformanceExcelArgs = {
  studentJournalPerformanceExcelInput: StudentJournalPerformanceExcelInput;
};


export type StudentQueriesDownloadStudentModulePerformanceByAttestationPeriodExcelArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  reportDateTime: Scalars['String']['input'];
  startDate: Scalars['DateTime']['input'];
};


export type StudentQueriesDownloadStudentModulePerformanceExcelArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  reportDateTime: Scalars['String']['input'];
  startDate: Scalars['DateTime']['input'];
};


export type StudentQueriesDownloadStudentsMarksResultDetailedExcelArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  currentRole?: InputMaybe<Scalars['String']['input']>;
  periodEndDate: Scalars['Date']['input'];
  periodStartDate: Scalars['Date']['input'];
  reportDateTime: Scalars['String']['input'];
};


export type StudentQueriesExportCertificateArgs = {
  issuedId: Scalars['ID']['input'];
};


export type StudentQueriesGetAcademicYearsArgs = {
  schoolId?: InputMaybe<Scalars['ID']['input']>;
};


export type StudentQueriesGetAggregatedStudentRadarChartDataArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  studyPeriodId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
};


export type StudentQueriesGetAllWidgetNotificationsByTypesArgs = {
  paging?: InputMaybe<PagingInput>;
  typeIds: Array<Scalars['ID']['input']>;
};


export type StudentQueriesGetAnalyticsDataAcademicPerformanceArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  startDate: Scalars['DateTime']['input'];
};


export type StudentQueriesGetAnswerStatusByIdArgs = {
  taskId: Scalars['ID']['input'];
};


export type StudentQueriesGetAvailableCodeReviewProjectsArgs = {
  paging?: InputMaybe<PagingInput>;
};


export type StudentQueriesGetAvailableCodeReviewProjectsV2Args = {
  paging?: InputMaybe<PagingInput>;
};


export type StudentQueriesGetAvailableStudentsForTeamArgs = {
  goalId: Scalars['ID']['input'];
};


export type StudentQueriesGetAvatarByUserIdArgs = {
  userId: Scalars['UUID']['input'];
};


export type StudentQueriesGetAvatarHistoryByIdArgs = {
  avatarId: Scalars['ID']['input'];
};


export type StudentQueriesGetAwardHistoryByIdArgs = {
  awardId: Scalars['ID']['input'];
};


export type StudentQueriesGetAwardsArgs = {
  awardType?: InputMaybe<AwardTypeEnum>;
};


export type StudentQueriesGetBtcStudentsInfoByStudentIdArgs = {
  userId: Scalars['UUID']['input'];
};


export type StudentQueriesGetBadgeHistoryByIdArgs = {
  badgeId: Scalars['ID']['input'];
};


export type StudentQueriesGetBadgesPublicProfileArgs = {
  userId: Scalars['UUID']['input'];
};


export type StudentQueriesGetBadgesWithFakePublicProfileArgs = {
  userId?: InputMaybe<Scalars['UUID']['input']>;
};


export type StudentQueriesGetBirthdayClassmatesArgs = {
  filterBirthday: Scalars['Date']['input'];
};


export type StudentQueriesGetBuildingsBySchoolIdArgs = {
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
};


export type StudentQueriesGetCalendarArgs = {
  weekEnd: Scalars['String']['input'];
  weekStart: Scalars['String']['input'];
};


export type StudentQueriesGetCalendarEventsWithoutFeedbackArgs = {
  from: Scalars['DateTime']['input'];
  to: Scalars['DateTime']['input'];
};


export type StudentQueriesGetClassRoomByLoginArgs = {
  login: Scalars['String']['input'];
};


export type StudentQueriesGetClassmatesWithSameTaskArgs = {
  goalId: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
};


export type StudentQueriesGetClusterPlanStudentsByClusterIdArgs = {
  clusterId?: InputMaybe<Scalars['ID']['input']>;
};


export type StudentQueriesGetCoalitionPublicProfileArgs = {
  userId: Scalars['UUID']['input'];
};


export type StudentQueriesGetCodeReviewPointChargedOffArgs = {
  goalId: Scalars['ID']['input'];
};


export type StudentQueriesGetCodeReviewRoundsByStudentGoalIdArgs = {
  studentGoalId: Scalars['ID']['input'];
};


export type StudentQueriesGetCountUnreadMessagesArgs = {
  taskId: Scalars['ID']['input'];
};


export type StudentQueriesGetCurrentStudentLessonArgs = {
  lessonId: Scalars['ID']['input'];
};


export type StudentQueriesGetDayScheduleArgs = {
  date: Scalars['String']['input'];
};


export type StudentQueriesGetDeadlinesArgs = {
  deadlineFrom?: InputMaybe<Scalars['DateTime']['input']>;
  deadlineStatuses: Array<DeadlineStatus>;
  deadlineTo?: InputMaybe<Scalars['DateTime']['input']>;
  page: PagingInput;
  sorting?: InputMaybe<Array<InputMaybe<SortingField>>>;
};


export type StudentQueriesGetDeadlinesCountArgs = {
  deadlineFrom?: InputMaybe<Scalars['DateTime']['input']>;
  deadlineStatuses: Array<DeadlineStatus>;
  deadlineTo?: InputMaybe<Scalars['DateTime']['input']>;
};


export type StudentQueriesGetDeckWidgetNotificationsByTypesArgs = {
  paging?: InputMaybe<PagingInput>;
  typeIds: Array<Scalars['ID']['input']>;
  wasReadIncluded?: InputMaybe<Scalars['Boolean']['input']>;
};


export type StudentQueriesGetDeckWidgetNotificationsForCurrentAcademicYearArgs = {
  paging?: InputMaybe<PagingInput>;
  typeIds: Array<Scalars['ID']['input']>;
  wasReadIncluded?: InputMaybe<Scalars['Boolean']['input']>;
};


export type StudentQueriesGetEmailbyUserIdArgs = {
  userId: Scalars['UUID']['input'];
};


export type StudentQueriesGetEnrichedBookingArgs = {
  bookingId: Scalars['ID']['input'];
};


export type StudentQueriesGetEnrichedCalendarArgs = {
  eventId: Scalars['ID']['input'];
};


export type StudentQueriesGetExamTestStudentAnswerArgs = {
  examEventId: Scalars['ID']['input'];
  id: Scalars['ID']['input'];
};


export type StudentQueriesGetExamsArgs = {
  from?: InputMaybe<Scalars['DateTime']['input']>;
  page?: InputMaybe<PagingInput>;
  to?: InputMaybe<Scalars['DateTime']['input']>;
};


export type StudentQueriesGetExperienceHistoryDateArgs = {
  schoolId?: InputMaybe<Scalars['ID']['input']>;
  userId: Scalars['UUID']['input'];
};


export type StudentQueriesGetExperiencePublicProfileArgs = {
  userId: Scalars['UUID']['input'];
};


export type StudentQueriesGetExperienceWithValueSomeDaysAgoArgs = {
  daysAgo: Scalars['Int']['input'];
};


export type StudentQueriesGetExpiredStudentHomeworksArgs = {
  paging: PagingInput;
  sorting: Array<SortingField>;
  subjectId?: InputMaybe<Scalars['ID']['input']>;
};


export type StudentQueriesGetFeedbackStatisticsAverageScoreArgs = {
  studentId: Scalars['UUID']['input'];
};


export type StudentQueriesGetFilledChecklistByIdArgs = {
  filledChecklistId: Scalars['ID']['input'];
};


export type StudentQueriesGetFilledChecklistsByStudentAnswerIdArgs = {
  studentAnswerId: Scalars['ID']['input'];
};


export type StudentQueriesGetFinishedGoalsPublicProfileArgs = {
  studentId: Scalars['UUID']['input'];
};


export type StudentQueriesGetFirstRoundCodeReviewProjectsArgs = {
  paging?: InputMaybe<PagingInput>;
};


export type StudentQueriesGetGenericTestTaskByIdArgs = {
  examEventId?: InputMaybe<Scalars['ID']['input']>;
  id: Scalars['ID']['input'];
};


export type StudentQueriesGetGigaChatResponseArgs = {
  messages: Array<GigaChatMessageInput>;
};


export type StudentQueriesGetGitlabLinksWithStatusArgs = {
  taskId: Scalars['ID']['input'];
};


export type StudentQueriesGetGivenReviewAnswersHistoryArgs = {
  limit: Scalars['Int']['input'];
  offset: Scalars['Int']['input'];
  searchString: Scalars['String']['input'];
};


export type StudentQueriesGetGivenReviewTasksHistoryArgs = {
  includeOnlyCurrentYear?: InputMaybe<Scalars['Boolean']['input']>;
};


export type StudentQueriesGetGivenReviewTasksInV4HistoryArgs = {
  limit: Scalars['Int']['input'];
  offset: Scalars['Int']['input'];
  searchString: Scalars['String']['input'];
};


export type StudentQueriesGetGoalAttemptStatisticArgs = {
  goalId: Scalars['ID']['input'];
};


export type StudentQueriesGetGoalRetryInfoArgs = {
  goalId: Scalars['ID']['input'];
};


export type StudentQueriesGetGridOfModulesBySubjectIdArgs = {
  subjectId: Scalars['ID']['input'];
};


export type StudentQueriesGetGridOfModulesBySubjectIdAndStudyPeriodIdsArgs = {
  studyPeriodIds: Array<Scalars['Int']['input']>;
  subjectId: Scalars['ID']['input'];
};


export type StudentQueriesGetHomeworkInfoByIdArgs = {
  homeworkId?: InputMaybe<Scalars['ID']['input']>;
};


export type StudentQueriesGetIsFilledStudInfoFlagBtcArgs = {
  userId: Scalars['UUID']['input'];
};


export type StudentQueriesGetLastAwardsArgs = {
  awardType?: InputMaybe<AwardTypeEnum>;
  limit: Scalars['Int']['input'];
};


export type StudentQueriesGetLastBadgesArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type StudentQueriesGetLastEquipmentsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
};


export type StudentQueriesGetLessonNotesForNextSchoolDayArgs = {
  lessonsDate: Scalars['Date']['input'];
};


export type StudentQueriesGetLightTaskStatisticsArgs = {
  atDate?: InputMaybe<Scalars['Date']['input']>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
};


export type StudentQueriesGetLinkToPrivateStudentGitlabProjectByAnswerIdArgs = {
  answerId: Scalars['ID']['input'];
};


export type StudentQueriesGetLinkToPrivateStudentGitlabProjectByTaskIdArgs = {
  taskId: Scalars['ID']['input'];
};


export type StudentQueriesGetLinkToPublicStudentGitlabProjectByTaskIdArgs = {
  taskId: Scalars['ID']['input'];
};


export type StudentQueriesGetLinkToRenewedPublicStudentProjectIfAnyArgs = {
  taskId: Scalars['ID']['input'];
};


export type StudentQueriesGetMediatekaContentByLessonIdArgs = {
  lessonId: Scalars['ID']['input'];
};


export type StudentQueriesGetModifyTimeByTaskArgs = {
  taskId: Scalars['ID']['input'];
};


export type StudentQueriesGetModuleByIdArgs = {
  goalId: Scalars['ID']['input'];
};


export type StudentQueriesGetModuleCoverInformationArgs = {
  goalId: Scalars['ID']['input'];
};


export type StudentQueriesGetMotivationBlockByGoalIdArgs = {
  id: Scalars['ID']['input'];
};


export type StudentQueriesGetMotivationBlockSectionsArgs = {
  id: Scalars['ID']['input'];
};


export type StudentQueriesGetMyCalendarBookingsArgs = {
  from: Scalars['DateTime']['input'];
  to: Scalars['DateTime']['input'];
};


export type StudentQueriesGetMyCoalitionMembersArgs = {
  page?: InputMaybe<PagingInput>;
};


export type StudentQueriesGetMyStudentCodeReviewArgs = {
  studentGoalId: Scalars['ID']['input'];
};


export type StudentQueriesGetMyUpcomingBookingsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>;
  to?: InputMaybe<Scalars['DateTime']['input']>;
};


export type StudentQueriesGetNameLessStudentTimeslotsForReviewArgs = {
  from: Scalars['DateTime']['input'];
  taskId: Scalars['ID']['input'];
  to: Scalars['DateTime']['input'];
};


export type StudentQueriesGetNonExpiredStudentHomeworksArgs = {
  deadlineFromDate: Scalars['Date']['input'];
  deadlineToDate: Scalars['Date']['input'];
  subjectId?: InputMaybe<Scalars['ID']['input']>;
};


export type StudentQueriesGetNotificationsArgs = {
  paging?: InputMaybe<PagingInput>;
  wasReadIncluded?: InputMaybe<Scalars['Boolean']['input']>;
};


export type StudentQueriesGetNotificationsByTypesArgs = {
  includeOnlyCurrentYearNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  paging?: InputMaybe<PagingInput>;
  typeIds: Array<Scalars['ID']['input']>;
  wasReadIncluded?: InputMaybe<Scalars['Boolean']['input']>;
};


export type StudentQueriesGetNotificationsCountArgs = {
  wasReadIncluded?: InputMaybe<Scalars['Boolean']['input']>;
};


export type StudentQueriesGetP2PChecksInfoArgs = {
  goalId: Scalars['ID']['input'];
};


export type StudentQueriesGetP2pInfoArgs = {
  filledChecklistId: Scalars['ID']['input'];
  languageCodeType?: InputMaybe<LanguageCodeType>;
};


export type StudentQueriesGetPersonalControlWorkByIdArgs = {
  personalControlWorkId: Scalars['ID']['input'];
};


export type StudentQueriesGetPersonalObjectivesByStatusesArgs = {
  statuses: Array<PersonalObjectiveStatusEnum>;
};


export type StudentQueriesGetPersonalObjectivesDetailedByIdArgs = {
  id: Scalars['ID']['input'];
};


export type StudentQueriesGetPersonalObjectivesDetailedByStatusesArgs = {
  statuses: Array<PersonalObjectiveStatusEnum>;
};


export type StudentQueriesGetPersonalTrajectoryArgs = {
  goalId?: InputMaybe<Scalars['ID']['input']>;
  taskId?: InputMaybe<Scalars['ID']['input']>;
};


export type StudentQueriesGetPlaylistArgs = {
  goalId: Scalars['ID']['input'];
};


export type StudentQueriesGetPortfolioDocumentReactionsCommentsArgs = {
  documentCategory?: InputMaybe<Scalars['String']['input']>;
  documentType?: InputMaybe<Scalars['String']['input']>;
  portfolioDocumentId?: InputMaybe<Scalars['String']['input']>;
};


export type StudentQueriesGetPortfolioDocumentReactionsCommentsAnotherUserArgs = {
  documentCategory?: InputMaybe<Scalars['String']['input']>;
  documentType?: InputMaybe<Scalars['String']['input']>;
  portfolioDocumentId?: InputMaybe<Scalars['String']['input']>;
  userId: Scalars['UUID']['input'];
};


export type StudentQueriesGetPortfolioDocumentsArgs = {
  documentAmount?: InputMaybe<Scalars['String']['input']>;
  documentCategory?: InputMaybe<Scalars['String']['input']>;
  documentType?: InputMaybe<Scalars['String']['input']>;
};


export type StudentQueriesGetPortfolioDocumentsAnotherUserArgs = {
  documentAmount?: InputMaybe<Scalars['String']['input']>;
  documentCategory?: InputMaybe<Scalars['String']['input']>;
  documentType?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
};


export type StudentQueriesGetPortfolioFieldValueListByDocumentCategoryIdArgs = {
  documentCategoryId: Scalars['ID']['input'];
  types?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  values?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


export type StudentQueriesGetPortfolioFieldValueListsArgs = {
  documentCategoryIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
  types?: InputMaybe<Array<Scalars['String']['input']>>;
  values?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type StudentQueriesGetPrivateGitlabProjectLinkInfoByAnswerIdArgs = {
  answerId: Scalars['ID']['input'];
};


export type StudentQueriesGetProctoringParametersArgs = {
  examId: Scalars['ID']['input'];
  sessionURL: Scalars['String']['input'];
};


export type StudentQueriesGetProjectAttemptEvaluationsInfoArgs = {
  goalId: Scalars['ID']['input'];
};


export type StudentQueriesGetProjectEvaluationsInfoArgs = {
  studentAnswerId: Scalars['ID']['input'];
};


export type StudentQueriesGetProjectStatisticsArgs = {
  goalId: Scalars['ID']['input'];
};


export type StudentQueriesGetProjectTeamMembersArgs = {
  studentTaskId: Scalars['ID']['input'];
};


export type StudentQueriesGetProjectTeamWithMembersArgs = {
  goalId: Scalars['ID']['input'];
};


export type StudentQueriesGetPythonTranslationArgs = {
  sessionId: Scalars['String']['input'];
};


export type StudentQueriesGetRecentTaskNotificationsArgs = {
  notificationTypes: Array<NotificationEnum>;
  paging: PagingInput;
};


export type StudentQueriesGetRecommendedProjectsArgs = {
  userId: Scalars['ID']['input'];
};


export type StudentQueriesGetReviewedStudentTasksArgs = {
  subjectIds: Array<Scalars['ID']['input']>;
};


export type StudentQueriesGetScheduleArgs = {
  lessonsFromDate: Scalars['Date']['input'];
  lessonsToDate: Scalars['Date']['input'];
  personalControlWorksFromTime: Scalars['DateTime']['input'];
  personalControlWorksToTime: Scalars['DateTime']['input'];
};


export type StudentQueriesGetSchoolGameCoalitionArgs = {
  gameCoalitionId: Scalars['Int']['input'];
};


export type StudentQueriesGetSchoolIdByLoginArgs = {
  login: Scalars['String']['input'];
};


export type StudentQueriesGetSecondRoundCodeReviewProjectsArgs = {
  paging?: InputMaybe<PagingInput>;
};


export type StudentQueriesGetSkillsTaskCriteriaValuesArgs = {
  studentId: Scalars['ID']['input'];
};


export type StudentQueriesGetSoftSkillsByStudentIdArgs = {
  studentId: Scalars['UUID']['input'];
};


export type StudentQueriesGetStageClassmatesArgs = {
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type StudentQueriesGetStageGroupHelpEmailArgs = {
  stageGroupId: Scalars['ID']['input'];
};


export type StudentQueriesGetStageGroupS21PublicProfileArgs = {
  studentId: Scalars['UUID']['input'];
};


export type StudentQueriesGetStageGroupStudentRequestsArgs = {
  stageGroupId?: InputMaybe<Scalars['ID']['input']>;
};


export type StudentQueriesGetStageGroupsS21PublicProfileArgs = {
  studentId: Scalars['UUID']['input'];
};


export type StudentQueriesGetStudentAcademicPerformanceArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type StudentQueriesGetStudentAcademicPerformanceByAttestationPeriodArgs = {
  closeModuleDate: Scalars['Date']['input'];
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type StudentQueriesGetStudentAcademicPerformanceByAttestationPeriodExpandedArgs = {
  closeModuleDate: Scalars['Date']['input'];
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type StudentQueriesGetStudentAcademicPerformanceExpandedArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  startDate: Scalars['DateTime']['input'];
};


export type StudentQueriesGetStudentAcademicPerformanceExpandedV2Args = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type StudentQueriesGetStudentAssessmentsTestArgs = {
  stageId: Scalars['ID']['input'];
  studentId: Scalars['ID']['input'];
};


export type StudentQueriesGetStudentAssessmentsTestsResultsArgs = {
  studentId: Scalars['ID']['input'];
};


export type StudentQueriesGetStudentAttendanceArgs = {
  currentPeriodId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
  studyPeriodIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  subjectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type StudentQueriesGetStudentByProjectAndCampusArgs = {
  goalId: Scalars['ID']['input'];
};


export type StudentQueriesGetStudentCodeReviewByGoalIdArgs = {
  goalId: Scalars['ID']['input'];
};


export type StudentQueriesGetStudentCodeReviewByStudentGoalIdArgs = {
  studentGoalId: Scalars['ID']['input'];
};


export type StudentQueriesGetStudentCodeReviewsArgs = {
  studentGoalId: Scalars['ID']['input'];
};


export type StudentQueriesGetStudentCurrentLessonCWorkHWorkByLessonIdArgs = {
  lessonId: Scalars['ID']['input'];
  userId?: InputMaybe<Scalars['UUID']['input']>;
};


export type StudentQueriesGetStudentCurrentProjectsArgs = {
  userId: Scalars['ID']['input'];
};


export type StudentQueriesGetStudentCurrentStageArgs = {
  schoolId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};


export type StudentQueriesGetStudentDashboardArgs = {
  date: Scalars['DateTime']['input'];
};


export type StudentQueriesGetStudentDashboardPartsArgs = {
  date: Scalars['DateTime']['input'];
};


export type StudentQueriesGetStudentDiaryArgs = {
  fromDate: Scalars['Date']['input'];
  toDate: Scalars['Date']['input'];
};


export type StudentQueriesGetStudentDiaryByPeriodArgs = {
  calendarEventCategoryIds?: InputMaybe<Array<Scalars['Int']['input']>>;
  fromDateTime: Scalars['DateTime']['input'];
  toDateTime: Scalars['DateTime']['input'];
};


export type StudentQueriesGetStudentDiaryLengthyHomeworkArgs = {
  fromDate: Scalars['Date']['input'];
  toDate: Scalars['Date']['input'];
};


export type StudentQueriesGetStudentEffortEstimationArgs = {
  studentTaskId: Scalars['ID']['input'];
};


export type StudentQueriesGetStudentFinishedProjectsArgs = {
  userId: Scalars['ID']['input'];
};


export type StudentQueriesGetStudentGoalLevelTestArgs = {
  goalLevelTestId: Scalars['ID']['input'];
};


export type StudentQueriesGetStudentGoalLevelTestAnswersArgs = {
  attemptId: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
};


export type StudentQueriesGetStudentGoalLevelTestWidgetsArgs = {
  goalId: Scalars['ID']['input'];
};


export type StudentQueriesGetStudentGoalLevelTestWidgetsWithAnswersArgs = {
  attemptId: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
};


export type StudentQueriesGetStudentGoalReflectionArgs = {
  goalId: Scalars['ID']['input'];
};


export type StudentQueriesGetStudentGoalSummaryArgs = {
  goalId: Scalars['ID']['input'];
};


export type StudentQueriesGetStudentIdByLoginArgs = {
  login: Scalars['String']['input'];
};


export type StudentQueriesGetStudentJournalPerformanceArgs = {
  stageId: Scalars['Int']['input'];
  studyPeriodId: Scalars['Int']['input'];
};


export type StudentQueriesGetStudentLessonByIdArgs = {
  lessonId: Scalars['ID']['input'];
};


export type StudentQueriesGetStudentLightMarksArgs = {
  studentId: Scalars['ID']['input'];
  studyPeriodId: Scalars['ID']['input'];
};


export type StudentQueriesGetStudentModuleByStudentGoalIdArgs = {
  language?: InputMaybe<Scalars['String']['input']>;
  studentGoalId: Scalars['ID']['input'];
};


export type StudentQueriesGetStudentPmoStudyPeriodFinalMarkArgs = {
  studyPeriodIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  subjectId?: InputMaybe<Scalars['ID']['input']>;
};


export type StudentQueriesGetStudentProfileByUserIdArgs = {
  userId: Scalars['UUID']['input'];
};


export type StudentQueriesGetStudentProjectStatisticArgs = {
  goalId: Scalars['ID']['input'];
};


export type StudentQueriesGetStudentProjectsByStageGroupArgs = {
  stageGroupId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type StudentQueriesGetStudentRadarChartDataArgs = {
  atDate?: InputMaybe<Scalars['Date']['input']>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
};


export type StudentQueriesGetStudentRankInTournamentArgs = {
  gameTournamentId: Scalars['Int']['input'];
};


export type StudentQueriesGetStudentRatingArgs = {
  studyPeriodIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  subjectIds: Array<InputMaybe<Scalars['ID']['input']>>;
};


export type StudentQueriesGetStudentSkillRadarChartDataArgs = {
  softSkillId?: InputMaybe<Scalars['ID']['input']>;
};


export type StudentQueriesGetStudentStageSubjectBySubjectIdArgs = {
  currentDate: Scalars['Date']['input'];
  subjectId: Scalars['ID']['input'];
};


export type StudentQueriesGetStudentStageSubjectsArgs = {
  currentDate: Scalars['Date']['input'];
};


export type StudentQueriesGetStudentStudyPeriodFinalMarkArgs = {
  studyPeriodIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  subjectId?: InputMaybe<Scalars['ID']['input']>;
};


export type StudentQueriesGetStudentStudyPeriodsPerformanceArgs = {
  attestationPeriodIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  studyPeriodIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type StudentQueriesGetStudentSubjectInfoArgs = {
  currentDate: Scalars['Date']['input'];
};


export type StudentQueriesGetStudentSubjectProgressStateArgs = {
  subjectId: Scalars['ID']['input'];
};


export type StudentQueriesGetStudentSubjectProgressStateWithDetailsArgs = {
  subjectId: Scalars['ID']['input'];
};


export type StudentQueriesGetStudentTaskByModulePlaylistArgs = {
  moduleIds: Array<Scalars['ID']['input']>;
};


export type StudentQueriesGetStudentTasksArgs = {
  moduleIds: Array<Scalars['ID']['input']>;
  onlyCurrentYear?: InputMaybe<Scalars['Boolean']['input']>;
  paging: PagingInput;
  sorting: Array<SortingField>;
  stageSubjectGroupIds: Array<Scalars['ID']['input']>;
  statuses: Array<TaskStatusEnum>;
  studentIds: Array<Scalars['UUID']['input']>;
  subjectIds: Array<Scalars['ID']['input']>;
  taskTypes: Array<TaskTypeEnum>;
};


export type StudentQueriesGetStudentTasksByFiltersArgs = {
  checkTypes?: InputMaybe<Array<TaskCheckEnum>>;
  haveComments?: InputMaybe<Scalars['Boolean']['input']>;
  moduleDebt?: InputMaybe<Scalars['Boolean']['input']>;
  paging: PagingInput;
  sorting?: InputMaybe<Array<SortingField>>;
  statuses?: InputMaybe<Array<TaskStatusEnum>>;
  subjectIds: Array<Scalars['ID']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
};


export type StudentQueriesGetStudentTasksByIdsArgs = {
  tasksIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type StudentQueriesGetStudentTasksByTaskStatusArgs = {
  paging: PagingInput;
  statuses: Array<TaskStatusEnum>;
};


export type StudentQueriesGetStudentTasksForCurrentModulePopupArgs = {
  currentDate: Scalars['Date']['input'];
};


export type StudentQueriesGetStudentTasksForOfflineTabArgs = {
  currentDate: Scalars['Date']['input'];
};


export type StudentQueriesGetStudentThermometerPmoArgs = {
  userId: Scalars['UUID']['input'];
};


export type StudentQueriesGetStudentTooltipStatusesArgs = {
  goalIds: Array<Scalars['ID']['input']>;
};


export type StudentQueriesGetStudentTrafficArgs = {
  date: Scalars['Date']['input'];
  login: Scalars['String']['input'];
  schoolID: Scalars['UUID']['input'];
};


export type StudentQueriesGetStudentUniversityEmailInfoArgs = {
  studentId?: InputMaybe<Scalars['UUID']['input']>;
};


export type StudentQueriesGetStudentUniversityEmailInfoV2Args = {
  studentId?: InputMaybe<Scalars['UUID']['input']>;
};


export type StudentQueriesGetStudentsByParamsArgs = {
  stageGroupId?: InputMaybe<Scalars['ID']['input']>;
  userIds?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
};


export type StudentQueriesGetStudentsForReviewArgs = {
  taskId: Scalars['ID']['input'];
};


export type StudentQueriesGetStudentsInfoArgs = {
  userId: Array<Scalars['UUID']['input']>;
};


export type StudentQueriesGetStudentsMarksSubjectsDetailedArgs = {
  studyPeriodId: Scalars['Int']['input'];
};


export type StudentQueriesGetStudentsMarksSubjectsDetailedByDatesArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  periodEndDate: Scalars['Date']['input'];
  periodStartDate: Scalars['Date']['input'];
};


export type StudentQueriesGetSubjectsFinalMarksArgs = {
  atDate?: InputMaybe<Scalars['Date']['input']>;
  studyPeriodId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
};


export type StudentQueriesGetSubjectsForLessonArgs = {
  currentDate: Scalars['Date']['input'];
};


export type StudentQueriesGetTargetGoalLevelArgs = {
  goalId: Scalars['ID']['input'];
};


export type StudentQueriesGetTaskAnswersArgs = {
  taskId: Scalars['ID']['input'];
};


export type StudentQueriesGetTaskAnswersForReviewArgs = {
  answerStatus?: InputMaybe<AnswerStatusEnum>;
  studentId: Scalars['UUID']['input'];
  taskId: Scalars['ID']['input'];
};


export type StudentQueriesGetTaskCriteriaArgs = {
  taskId: Scalars['ID']['input'];
};


export type StudentQueriesGetTaskCriteriaGradeArgs = {
  studentId: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
};


export type StudentQueriesGetTaskCriteriaValuesArgs = {
  isConfirmed?: InputMaybe<Scalars['Boolean']['input']>;
  studentId?: InputMaybe<Scalars['ID']['input']>;
  taskId: Scalars['ID']['input'];
};


export type StudentQueriesGetTaskExternalLinkArgs = {
  externalSystemCode: Scalars['String']['input'];
  externalTaskPath: Scalars['String']['input'];
  studentId: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
};


export type StudentQueriesGetTaskForReviewArgs = {
  studentId: Scalars['UUID']['input'];
  taskId: Scalars['ID']['input'];
};


export type StudentQueriesGetTaskMessagesArgs = {
  taskId: Scalars['ID']['input'];
};


export type StudentQueriesGetTaskMessagesForReviewArgs = {
  studentId: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
};


export type StudentQueriesGetTaskReviewCountInfoArgs = {
  taskId: Scalars['ID']['input'];
};


export type StudentQueriesGetTaskStatisticsIdsArgs = {
  subjectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
};


export type StudentQueriesGetTaskStatusByIdArgs = {
  taskId: Scalars['ID']['input'];
};


export type StudentQueriesGetTaskStatusByStudentTaskIdArgs = {
  studentTaskId: Scalars['String']['input'];
};


export type StudentQueriesGetTaskWidgetAnswersArgs = {
  taskId: Scalars['ID']['input'];
};


export type StudentQueriesGetTasksByIdsArgs = {
  ids: Array<Scalars['ID']['input']>;
};


export type StudentQueriesGetTasksOfMineForReviewHistoryArgs = {
  answerStatuses: Array<InputMaybe<AnswerStatusEnum>>;
  searchString: Scalars['String']['input'];
};


export type StudentQueriesGetTeamLeadPeriodSettingsArgs = {
  currentStudentLocalCourseId: Scalars['ID']['input'];
  goalId: Scalars['ID']['input'];
  location: LocationEnum;
  teamLeadUserId: Scalars['UUID']['input'];
};


export type StudentQueriesGetTeamsForCurrentUserByArgs = {
  teamRole: TeamRole;
};


export type StudentQueriesGetTop5AndMeCoalitionTournamentMembersArgs = {
  gameCoalitionId: Scalars['Int']['input'];
  gameTournamentId: Scalars['Int']['input'];
};


export type StudentQueriesGetTournamentResultsArgs = {
  isShown: Scalars['Boolean']['input'];
};


export type StudentQueriesGetUniversityDomainsArgs = {
  universityId: Scalars['ID']['input'];
};


export type StudentQueriesGetUserDressedEquipmentArgs = {
  userId: Scalars['ID']['input'];
};


export type StudentQueriesGetUserExperienceArgs = {
  userId: Scalars['ID']['input'];
};


export type StudentQueriesGetUserIdByLoginArgs = {
  login: Scalars['String']['input'];
};


export type StudentQueriesGetUserIdsByFavoriteSubjectIdsArgs = {
  favoriteSubjectIds: Array<Scalars['Int']['input']>;
};


export type StudentQueriesGetUserIdsByInterestsArgs = {
  interests: Array<Scalars['String']['input']>;
};


export type StudentQueriesGetUserPortfolioBadgesByUserIdArgs = {
  userId: Scalars['UUID']['input'];
};


export type StudentQueriesGetUserTournamentWidgetArgs = {
  schoolId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['UUID']['input']>;
};


export type StudentQueriesGetWebinarRuLinkArgs = {
  lessonPlanId: Scalars['ID']['input'];
};


export type StudentQueriesGetWorkstationByLoginArgs = {
  login: Scalars['String']['input'];
};


export type StudentQueriesGetWorkstationByUserIdArgs = {
  userId?: InputMaybe<Scalars['UUID']['input']>;
};


export type StudentQueriesIsRequestBeenSentToTeamDisbandArgs = {
  teamId: Scalars['UUID']['input'];
};


export type StudentQueriesIsStudentModuleOutOfPlanArgs = {
  goalId: Scalars['ID']['input'];
  studentId: Scalars['ID']['input'];
};


export type StudentQueriesIsTaskInTrajectoryOrPlannedModuleArgs = {
  taskId: Scalars['ID']['input'];
};


export type StudentQueriesLoadTaskEvaluationRulesArgs = {
  goalId: Scalars['ID']['input'];
};


export type StudentQueriesPrepareNewPersonalObjectiveCatchUpOnSubjectArgs = {
  subjectId: Scalars['ID']['input'];
};

/** Данные для диаграммы Радар */
export type StudentRadarChart = {
  __typename?: 'StudentRadarChart';
  /** Количество модулей, по которым достигнут целевой уровень */
  numberOfAchievedModules: Scalars['Int']['output'];
  /** Количество модулей, по которым установлен целевой уровень */
  numberOfTargetedModules: Scalars['Int']['output'];
  /** План, по которому студент изучает предмет (персональный или на группу по предмету) */
  plan?: Maybe<StudentPlan>;
  /** Признак вероятности провала сроков сдачи */
  probability: Scalars['Boolean']['output'];
  /** ID предмета для класса */
  stageSubjectGroupId: Scalars['ID']['output'];
  /** Предмет Студента */
  subject: Subject;
};

/** Агрегированные данные по навыку для диаграммы Радар (Паутинка) */
export type StudentRadarChartBySkill = {
  __typename?: 'StudentRadarChartBySkill';
  achievedLevel: Scalars['Float']['output'];
  completedTaskCount: Scalars['Int']['output'];
  goalLevelForSkill?: Maybe<Scalars['Float']['output']>;
  level3CompletedTasksCount: Scalars['Int']['output'];
  level4CompletedTasksCount: Scalars['Int']['output'];
  maxTaskCount: Scalars['Int']['output'];
  skillDescription?: Maybe<Scalars['String']['output']>;
  skillGroupDescription?: Maybe<Scalars['String']['output']>;
  skillGroupName?: Maybe<Scalars['String']['output']>;
  skillId: Scalars['ID']['output'];
  skillName: Scalars['String']['output'];
  skillShortDescription?: Maybe<Scalars['String']['output']>;
  stageGroupId: Scalars['ID']['output'];
};

/** Агрегированные данные по предмету для диаграммы Радар (Паутинка) */
export type StudentRadarChartBySubject = {
  __typename?: 'StudentRadarChartBySubject';
  /** Средний уровень по предмету */
  averageAchieveLevel: Scalars['Float']['output'];
  /** Предмет */
  subject: Subject;
};

export type StudentRatingBySubjectModel = {
  __typename?: 'StudentRatingBySubjectModel';
  finalMarks: Array<Maybe<JournalFinalStudentMark>>;
  stageSubjectGroupId: Scalars['ID']['output'];
  subjectId: Scalars['ID']['output'];
};

export type StudentReducedProgressFilterBtcInputModel = {
  /** Идентификаторы модулей */
  goalIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Пагинация */
  paging?: InputMaybe<PagingInput>;
  /** Начало диапазона плановой даты начала обучения */
  planStartDateFrom?: InputMaybe<Scalars['Date']['input']>;
  /** Конец диапазона плановой даты начала обучения */
  planStartDateTo?: InputMaybe<Scalars['Date']['input']>;
  /** Идентификаторы классов */
  stageGroupIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Идентификаторы предметов */
  subjectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Фильтр по траекториям */
  trajectories?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Идентификаторы пользоваталей */
  userIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type StudentReducedProgressForBtcModel = {
  __typename?: 'StudentReducedProgressForBtcModel';
  /** Дата создания УЗ */
  accountCreationDate: Scalars['DateTime']['output'];
  /** Email ученика */
  email?: Maybe<Scalars['String']['output']>;
  /** Фактическая дата окончания */
  factEndDate?: Maybe<Scalars['DateTime']['output']>;
  /** Фактическая дата начала */
  factStartDate?: Maybe<Scalars['DateTime']['output']>;
  /** Имя ученика */
  firstName: Scalars['String']['output'];
  /** Полное ФИО */
  fullName: Scalars['String']['output'];
  /** Дата последнего входа */
  lastAuthorizationDate?: Maybe<Scalars['DateTime']['output']>;
  /** Фамилия ученика */
  lastName: Scalars['String']['output'];
  /** Логин ученика */
  login: Scalars['String']['output'];
  /** Отчество ученика */
  middleName?: Maybe<Scalars['String']['output']>;
  /** Прогресс по траектории (в процентах) */
  progressPercentByTrajectory: Scalars['Int']['output'];
  /** Идентификатор студента (students.student_id) */
  studentId: Scalars['ID']['output'];
  /** Прогресс по модулям */
  studyModuleProgress?: Maybe<Array<StudentStudyModuleProgress>>;
  /** Траектория */
  trajectory?: Maybe<Scalars['String']['output']>;
  /** Идентификатор пользователя (users.user_id) */
  userId: Scalars['ID']['output'];
};

export type StudentRole = {
  __typename?: 'StudentRole';
  /** дата деактивации роли */
  dateEnd?: Maybe<Scalars['DateTime']['output']>;
  /** дата активации роли */
  dateStart?: Maybe<Scalars['DateTime']['output']>;
  /** Информация о выпуске/отчислении */
  dismissInfo?: Maybe<StudentDismissInfo>;
  /** дата выпуска */
  graduationDateTime?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  /** является ли роль дефолтной при входе пользователя в приложение */
  isDefault: Scalars['Boolean']['output'];
  orgUnitId?: Maybe<Scalars['ID']['output']>;
  /** основная информация по родителям */
  parentUserInfo: Array<ParentUserInfo>;
  productId?: Maybe<Scalars['ID']['output']>;
  /** название роли */
  role: Roles;
  school: SafeSchool;
  schoolId: Scalars['ID']['output'];
  /** класс ученика */
  stageGroup?: Maybe<StageGroup>;
  status: RoleStatus;
  /** Ш21. Ограничения ученика */
  studentRestrictions?: Maybe<Array<Maybe<UserRestriction>>>;
  /** Статус ученика */
  studentStatus?: Maybe<StudentStatus>;
  userId?: Maybe<Scalars['ID']['output']>;
};

export type StudentRoleInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  isGraduate: Scalars['Boolean']['input'];
  schoolId: Scalars['ID']['input'];
  /** класс (stage_group) ученика */
  stageGroup?: InputMaybe<StageGroupInput>;
  status?: InputMaybe<RoleStatus>;
  temporaryRoleInput?: InputMaybe<TemporaryRoleInput>;
};

export type StudentSchoolMetrics = {
  __typename?: 'StudentSchoolMetrics';
  entries?: Maybe<Array<SchoolMonitoringEntry>>;
  metricName: Scalars['String']['output'];
  stageGroupName: Scalars['String']['output'];
  studentFullName: Scalars['String']['output'];
};

/** Фильтр для запроса кол-ва учеников для прогресса в Bootcamp */
export type StudentSearchCountFilterBtcInput = {
  /** Буткемп-мастер */
  bootcampMaster?: InputMaybe<Scalars['UUID']['input']>;
  /** Формат прохождения */
  isStudyOnline?: InputMaybe<Scalars['Boolean']['input']>;
  /** Начало диапазона плановой даты начала обучения */
  planStartDateFrom?: InputMaybe<Scalars['Date']['input']>;
  /** Конец диапазона плановой даты начала обучения */
  planStartDateTo?: InputMaybe<Scalars['Date']['input']>;
  /** Идентификаторы классов */
  stageGroupIds: Array<Scalars['ID']['input']>;
  /** Идентификаторы параллелей */
  stageIds: Array<Scalars['ID']['input']>;
  /** Город ученика */
  studentCity?: InputMaybe<Scalars['String']['input']>;
  /** Траектории */
  trajectories?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Фильтр для запроса кол-ва учеников для прогресса */
export type StudentSearchCountFilterInput = {
  /** Учебные годы */
  academicYearIds: Array<Scalars['ID']['input']>;
  /** Начало диапазона плановой даты начала обучения */
  planStartDateFrom?: InputMaybe<Scalars['Date']['input']>;
  /** Конец диапазона плановой даты начала обучения */
  planStartDateTo?: InputMaybe<Scalars['Date']['input']>;
  /** Идентификатор школы */
  schoolId: Scalars['ID']['input'];
  /** Идентификаторы классов */
  stageGroupIds: Array<Scalars['ID']['input']>;
  /** Идентификаторы параллелей */
  stageIds: Array<Scalars['ID']['input']>;
  /** Траектории */
  trajectories?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Фильтр для запроса учеников */
export type StudentSearchFilterInput = {
  /** Учебные годы */
  academicYearIds: Array<Scalars['ID']['input']>;
  /** Пагинация */
  paging: PagingInput;
  /** Идентификатор школы */
  schoolId: Scalars['ID']['input'];
  /** Сортировка */
  sortingFields: Array<SortingField>;
  /** Идентификаторы классов */
  stageGroupIds: Array<Scalars['ID']['input']>;
  /** Идентификаторы параллелей */
  stageIds: Array<Scalars['ID']['input']>;
  /** Поиск по ФИО */
  textSearch: Scalars['String']['input'];
};

/** Информация о Гибком навыке, с примерами заданий для его развития */
export type StudentSoftSkillAbout = {
  __typename?: 'StudentSoftSkillAbout';
  /** Примеры заданий ученика для развития данного навыка */
  exampleTasks: Array<Task>;
  /** Гибкий навык */
  softSkillType: SoftSkillType;
};

export type StudentSoftSkillGoal = {
  __typename?: 'StudentSoftSkillGoal';
  /** Дата и время создания записи о цели */
  createdTs: Scalars['DateTime']['output'];
  /** Уникальный идентификатор цели студента по мягким навыкам */
  id: Scalars['ID']['output'];
  /** Уровень навыка, который студент стремится достичь */
  level: Scalars['Float']['output'];
  /** Идентификатор навыка, к которому относится цель */
  softSkillId: Scalars['ID']['output'];
  /** Идентификатор студента */
  studentId: Scalars['UUID']['output'];
  /** Дата и время последнего обновления записи о цели */
  updatedTs: Scalars['DateTime']['output'];
};

export type StudentSoftSkillGoalInput = {
  /** Уровень навыка, который студент стремится достичь */
  level: Scalars['Float']['input'];
  /** Идентификатор навыка, к которому относится цель */
  softSkillId: Scalars['ID']['input'];
  /** Идентификатор студента */
  studentId: Scalars['UUID']['input'];
};

/**
 * Описание события - перевода ученика между классами
 * (в пределе - события зачисления в первый по счету класс или выпуск ученика из школы)
 */
export type StudentStageGroupTransferInfo = {
  __typename?: 'StudentStageGroupTransferInfo';
  /**
   * информация о классе, из которого был переведен ученик
   * null в случае, если ученик добавляется в первый по счету класс или добавляется в класс после исключения/выпуска
   */
  stageGroupFrom?: Maybe<StageGroupCommonInfo>;
  /**
   * информация о классе, в который был переведен ученик
   * null в случае, если ученик выпускается из школы или исключается из класса
   */
  stageGroupTo?: Maybe<StageGroupCommonInfo>;
  /** идентификатор студента, который был переведен */
  studentId: Scalars['ID']['output'];
  /** дата события */
  transferDate: Scalars['DateTime']['output'];
};

export type StudentStageSubject = {
  __typename?: 'StudentStageSubject';
  /** Завершенная контрольная работа по данному предмету */
  closedControlWork?: Maybe<PersonalControlWork>;
  /** Уроки по данному предмету у ученика на сегодня */
  currentDaySubjectLessons: Array<StudentLesson>;
  id: Scalars['ID']['output'];
  /** Следующая контрольная работа по данному предмету */
  nextControlWork?: Maybe<PersonalControlWork>;
  /** Следующий урок у ученика по данному предмету */
  nextLesson?: Maybe<StudentLesson>;
  /** Прогресс ученика по предмету относительно плана */
  performance?: Maybe<PersonalPerformance>;
  /** План, по которому студент изучает предмет (персональный или на группу по предмету) */
  plan?: Maybe<StudentPlan>;
  /** Предмет Студента */
  subject: Subject;
  /** Учитель, который ведет предмет у ученика */
  subjectTeacher: Teacher;
};

export type StudentStageSubjectStudyPeriod = {
  __typename?: 'StudentStageSubjectStudyPeriod';
  classPlanCompletionPercentage?: Maybe<Scalars['Float']['output']>;
  externalWorks: Array<ExternalWork>;
  id: Scalars['ID']['output'];
  mark?: Maybe<SchoolMark>;
  modules: Array<StudentModule>;
  personalPlanCompletionPercentage?: Maybe<Scalars['Float']['output']>;
  recommendedMark?: Maybe<Scalars['Float']['output']>;
  stageSubjectId?: Maybe<Scalars['ID']['output']>;
  /** Информация о плановых и фактических трудозатратах ученика за этот учебный период */
  studentPerformanceDetails?: Maybe<StudentPerformanceDetails>;
  studyPeriod: StudyPeriod;
  studyPeriodId: Scalars['ID']['output'];
};

/** Текущий статус студента */
export enum StudentStateEnum {
  Active = 'ACTIVE',
  All = 'ALL',
  Blocked = 'BLOCKED',
  Expelled = 'EXPELLED',
  Frozen = 'FROZEN',
  NotActive = 'NOT_ACTIVE'
}

export enum StudentStatus {
  /** Выпущен */
  Graduated = 'GRADUATED',
  /** Не настроен */
  NotConfigured = 'NOT_CONFIGURED',
  /** Учится */
  Study = 'STUDY'
}

/** Статус ученика в группе (ГКпП) */
export enum StudentStatusInGroup {
  /**
   * Статус студентов, которые состоят в группе весь рассматриваемый период времени
   * или на текущий момент, если период еще длится в настоящем
   */
  Active = 'ACTIVE',
  /**
   * Статус студентов, которые так или иначе состоявших в группе в течение контекстного периода
   * ACTIVE + NONACTIVE
   */
  All = 'ALL',
  /**
   * Статус студентов, которые состояли в группе в течение рассматриваемого периода,
   * но не на момент его окончания или текущий момент, если период еще длится в настоящем
   */
  Nonactive = 'NONACTIVE'
}

/** Информация об уроках за определенную дату */
export type StudentStudyDate = {
  __typename?: 'StudentStudyDate';
  /** Дата в журнале */
  date: Scalars['Date']['output'];
  /** Уроки по заданному предмету в этот день */
  lessons: Array<Maybe<JournalCell>>;
};

/** Прогресс ученика по модулю */
export type StudentStudyModuleProgress = {
  __typename?: 'StudentStudyModuleProgress';
  /** Достигнутый уровень в модуле */
  achievedLevel?: Maybe<Scalars['Float']['output']>;
  /** Наименование модуля */
  moduleName: Scalars['String']['output'];
  /** Целевой уровень по модулю */
  plannedLevel: Scalars['Float']['output'];
  /** Идентификатор модуля (goals.goal_id) */
  studyModuleId: Scalars['ID']['output'];
  /** Наименование предмета */
  subjectName: Scalars['String']['output'];
};

export type StudentStudyPeriodFinalMark = {
  __typename?: 'StudentStudyPeriodFinalMark';
  mark?: Maybe<Scalars['Int']['output']>;
  studentId: Scalars['ID']['output'];
  studyPeriodId: Scalars['ID']['output'];
  subjectId: Scalars['ID']['output'];
};

export type StudentStudyPeriodWithSubjectThemes = {
  __typename?: 'StudentStudyPeriodWithSubjectThemes';
  /** список Учебных Модулей в Плане относящихся к учебному периоду */
  modules: Array<StudentModule>;
  /** Учебный период */
  studyPeriod: StudyPeriod;
};

export type StudentStudyPeriodsPerformanceResponse = {
  __typename?: 'StudentStudyPeriodsPerformanceResponse';
  marks: Array<StudentStageSubjectStudyPeriod>;
  subjectId: Scalars['ID']['output'];
};

/** Модель показателей успеваемости ученика по предмету за аттестационный период */
export type StudentSubjectAcademicPerformance = {
  __typename?: 'StudentSubjectAcademicPerformance';
  attestationPeriodId: Scalars['ID']['output'];
  externalWorks: Array<ExternalWork>;
  finalPeriodType: FinalPeriodType;
  mark?: Maybe<SchoolMark>;
  markAssigningMethodId?: Maybe<Scalars['ID']['output']>;
  markId?: Maybe<Scalars['ID']['output']>;
  markTeacherId?: Maybe<Scalars['ID']['output']>;
  markTime?: Maybe<Scalars['DateTime']['output']>;
  modules: Array<StudentModule>;
  personalSubjectPlanCompletionPercentage?: Maybe<Scalars['Float']['output']>;
  recommendedMark?: Maybe<Scalars['Float']['output']>;
  recommendedMarkLastRecalculationTime?: Maybe<Scalars['DateTime']['output']>;
  stageSubjectGroupPlanCompletionPercentage?: Maybe<Scalars['Float']['output']>;
  stageSubjectId: Scalars['ID']['output'];
  studentId: Scalars['ID']['output'];
  studentSubjectAcademicPerformanceForAttestationPeriodId: Scalars['ID']['output'];
};

/** Прогресс ученика по предмету относительно класса */
export enum StudentSubjectProgress {
  /** Прогресс ученика выше прогресса класса */
  High = 'HIGH',
  /** Прогресс ученика ниже прогресса класса */
  Low = 'LOW',
  /** Прогресс ученика равен прогрессу класса */
  Medium = 'MEDIUM'
}

/** Состояние прогресса ученика по предмету. */
export type StudentSubjectProgressState = {
  __typename?: 'StudentSubjectProgressState';
  /** Идентификатор ученика */
  studentId: Scalars['ID']['output'];
  /** Идентификатор текущего учебного периода */
  studyPeriodId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор предмета */
  subjectId: Scalars['ID']['output'];
  /** Информация о прогрессе ученика по данному предмету за текущий учебный период */
  subjectPerformanceInfo?: Maybe<SubjectPerformanceInfo>;
  /** Понедельный планы в рамках учебного периода по текущему предмету */
  weekSubjectPlans?: Maybe<Array<WeekSubjectPlan>>;
};

/** Выбранный студентом целевой уровень модуля */
export type StudentTargetGoalLevel = {
  __typename?: 'StudentTargetGoalLevel';
  /** Дата создания */
  createTime: Scalars['DateTime']['output'];
  /** Ид модуля */
  goalId: Scalars['ID']['output'];
  /** Ид */
  id: Scalars['ID']['output'];
  /** Дата изменения */
  modifyTime: Scalars['DateTime']['output'];
  /** Ид студента */
  studentId: Scalars['UUID']['output'];
  /** Желаемый уровень цели модуля */
  targetedGoalLevel: Scalars['Float']['output'];
};

/** Задание в контексте Студента с персональной информацией */
export type StudentTask = {
  __typename?: 'StudentTask';
  /** список всех ответов студента по заданию */
  answers: Array<StudentAnswer>;
  /** Идентификатор проверочной корзины */
  checkBucketId?: Maybe<Scalars['UUID']['output']>;
  /** Дата, когда учитель взял задание на проверку */
  checkingStartDate?: Maybe<Scalars['DateTime']['output']>;
  /** Учитель, проверяющий задание */
  checkingUserId?: Maybe<Scalars['UUID']['output']>;
  /** Группа, в рамках которой студент проходит это задание */
  classSubject?: Maybe<ClassSubject>;
  /** Список оценок по критериям */
  evaluatedTaskCriteria: Array<EvaluatedTaskCriterion>;
  /** Информация о студенте проверяющем задание в случае взаимопроверки */
  examiningStudent?: Maybe<Student>;
  /** Опыта получит за выполнение задания */
  experienceValue: Scalars['Int']['output'];
  /** Внешний конкурс */
  externalCompetition?: Maybe<ExternalCompetition>;
  /** Время первого просмотра задания учеником */
  firstViewTime?: Maybe<Scalars['DateTime']['output']>;
  /** Идентификатор группы, с которой связано задание (null, если не связано) */
  groupId?: Maybe<Scalars['ID']['output']>;
  /** доступно ли Задание на чтение текущему пользователю */
  hasReadAccess: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** последний отправленный ответ */
  lastAnswer?: Maybe<StudentAnswer>;
  /** Дата и Время последней отправки Задания на проверку */
  lastNeedCheckStatusTime?: Maybe<Scalars['DateTime']['output']>;
  /** Вопрос по заданию у ученика */
  lastStudentMessage?: Maybe<TaskMessage>;
  /** Время изменения */
  modifyTime?: Maybe<Scalars['DateTime']['output']>;
  /** Запланированная Студентом Дата выполнения Задания */
  planDate?: Maybe<Scalars['DateTime']['output']>;
  /** Сколько было попыток выполнения Задания */
  retryCount: Scalars['Int']['output'];
  /** != null при самопроверке (самооценке) */
  selfCheckInfo?: Maybe<SelfCheckInfo>;
  /** Текущий статус Задания */
  status: TaskStatusEnum;
  /** Признак изменения статуса задания */
  statusModified?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Последнее время изменения статуса
   * Это поле временно необязательное, пока таблица не будет заполнена - EDU-26567
   */
  statusModifyTime?: Maybe<Scalars['DateTime']['output']>;
  /** Ученик, выполняющий Задание */
  student: Student;
  /** != null при взаимопроверке */
  studentByStudentCheckInfo?: Maybe<StudentByStudentCheckInfo>;
  /** идентификатор студента */
  studentId: Scalars['ID']['output'];
  /** Результаты прохождения виджетов (ТОЛЬКО ДЛЯ ЗАДАЧ C GENERIC КОНТЕНТОМ) */
  studentTaskWidgets?: Maybe<Array<StudentTaskWidget>>;
  /** Мета-Задание */
  task: Task;
  /** Дедлайн Задания (для заданий по ВНЕплановым модулям дедлайном является окончание учебного года, isHardDeadline: false) */
  taskDeadline: TaskDeadline;
  /** идентификатор задания */
  taskId: Scalars['ID']['output'];
  /** Краткая информация о задании в контексте пользователя */
  taskInfo: TaskInfo;
  /** Оценка по Заданию */
  taskMark?: Maybe<SchoolMark>;
  /** список комментов по заданию */
  taskMessages: Array<TaskMessage>;
  /**
   * Учитель, проверяющий Задание
   *  Может не быть, если задание выполняется в рамках внепланового модуля
   */
  teacher?: Maybe<Teacher>;
  /**
   * Настройки команды, выполняющей групповой проект
   * @deprecated Use StudentModule.teamSettings
   */
  teamSettings?: Maybe<TeamSettings>;
  /** Количество непрочитанных сообщений к задаче */
  unreadTaskMessagesCount?: Maybe<Scalars['Int']['output']>;
};


/** Задание в контексте Студента с персональной информацией */
export type StudentTaskStudentByStudentCheckInfoArgs = {
  studentId?: InputMaybe<Scalars['ID']['input']>;
};

export type StudentTaskAdditionalAttributes = {
  __typename?: 'StudentTaskAdditionalAttributes';
  /** есть ли работа с CI/CD в задании и в каком виде */
  ciCdMode: GitlabCiCdType;
  /** Стоимость проверки (Code Review Points) */
  codeReviewCost: Scalars['Int']['output'];
  /** Длительность проверки (код-ревью, в минутах) */
  codeReviewDuration: Scalars['Int']['output'];
  cookiesCount: Scalars['Int']['output'];
  /** Максимальное количество проверяющих (код-ревью) */
  maxCodeReviewCount: Scalars['Int']['output'];
  periodOfVerification: Scalars['Int']['output'];
  pointTask?: Maybe<Scalars['Int']['output']>;
  reviewUserCount: Scalars['Int']['output'];
  taskId: Scalars['ID']['output'];
};

/** Требуемая информация о заданиях студента, выполнившем задания для страницы, отображающей проверенные задания */
export type StudentTaskAndTask = {
  __typename?: 'StudentTaskAndTask';
  modifyTime: Scalars['DateTime']['output'];
  moduleId?: Maybe<Scalars['ID']['output']>;
  moduleName?: Maybe<Scalars['String']['output']>;
  status: TaskStatusEnum;
  studentTaskId: Scalars['ID']['output'];
  taskId: Scalars['ID']['output'];
  taskName?: Maybe<Scalars['String']['output']>;
};

/** Возвращает уровни учебного модуля */
export type StudentTaskByModulePlaylist = {
  __typename?: 'StudentTaskByModulePlaylist';
  /** Идентификатор модуля */
  id: Scalars['ID']['output'];
  /** Уровни модуля */
  levels: Array<LevelModule>;
  /** Наименование модуля */
  name: Scalars['String']['output'];
};

export enum StudentTaskCheckAnswerDateAndNameSortingEnum {
  /** по возрастанию */
  Asc = 'ASC',
  /** по ФИО ученика */
  ByFio = 'BY_FIO',
  /** по убыванию */
  Desc = 'DESC'
}

/** Фильтр поиска Заданий на проверку по времени отправки на проверку */
export enum StudentTaskCheckFilterEnum {
  /** Задания на проверке за месяц */
  Month = 'MONTH',
  /** Только задания на проверке более 3-х дней */
  More_3Days = 'MORE_3DAYS',
  /** Только задания на проверке более 7 дней */
  More_7Days = 'MORE_7DAYS',
  /** Без фильтра */
  None = 'NONE',
  /** Не подсчитывать задания на проверке и с комментариями */
  NoCountTasks = 'NO_COUNT_TASKS',
  /** Задания на проверке за учебный год */
  StudyYear = 'STUDY_YEAR',
  /** Задания на проверке за сегодня */
  Today = 'TODAY',
  /** Задания на проверке за неделю */
  Week = 'WEEK'
}

/** Фильтр поиска Заданий на проверку НЕ по времени по свойствам Заданий */
export enum StudentTaskCheckNonTimeFilterEnum {
  /** Без фильтра */
  None = 'NONE',
  /** С комментариями */
  WithCommentsOnly = 'WITH_COMMENTS_ONLY'
}

/** Фильтр поиска Заданий на проверку НЕ по времени по свойствам запрашивающего их Учителя */
export enum StudentTaskCheckNonTimeTeacherFilterEnum {
  /** Только для роли Консультирующий учитель (CONSULTING_TEACHER) */
  ConsultOnly = 'CONSULT_ONLY',
  /** Без фильтра */
  None = 'NONE'
}

/** Фильтр-сортировка заданий для вкладки "по ученикам" */
export enum StudentTaskCheckSortingEnum {
  /** по фамилии (от "А" до "Я") */
  ByFio = 'BY_FIO',
  /** по количеству заданий (от большего к меньшему) */
  ByTaskCount = 'BY_TASK_COUNT'
}

/** Элемент группировки StudentTask. Например, по студенту: Абрамов_Лев.stage_subject_subgroup_student_id: [его StudentTask] */
export type StudentTaskGroup = {
  __typename?: 'StudentTaskGroup';
  /**
   * отображаемое имя, например: Абрамов Лев
   * формируется в зависимости от порядка переданных групп, например: [BY_CLASS, BY_STUDENT] -> "8А-Физика Абрамов Лев" / [BY_STUDENT, BY_CLASS] -> "Абрамов Лев 8А-Физика"
   * завязываться на фронте на это поле НЕ РЕКОМЕНДУЕТСЯ, лучше формировать нужное представление самостоятельно
   */
  displayName: Scalars['String']['output'];
  /** ключи группировки, например: [BY_STUDENT: Абрамов_Лев.stage_subject_subgroup_student_id] */
  keys: Array<StudentTaskGroupKey>;
  /** найденные Задания в контексте группировки */
  studentTasks: Array<StudentTask>;
};

/**
 * Тип, связывающий тип группировки с их значением. Также содержит метаинформацию о группировке
 * Пример: [BY_CLASS: class.id, BY_STUDENT: student.id]
 */
export type StudentTaskGroupKey = {
  __typename?: 'StudentTaskGroupKey';
  keyType: StudentTaskGroupTypeEnum;
  /** Представляет из себя ID типа группировки во всех случаях, кроме NONE - у него значение "NONE" */
  keyValue: Scalars['String']['output'];
  /**
   * Метаинформация о типе (например, ClassSubject для BY_CLASS)
   * В случае NONE возвращается null
   */
  meta?: Maybe<StudentTaskGroupMeta>;
};

/**
 * дополнительная информация о группировке, резолвится в зависимости от ключа группировки
 * при группировке BY_CLASS      нужна информация о ClassSubject
 * при группировке BY_STUDENT    нужна информация о ClassSubject
 * при группировке BY_TASK       нужна информация о Task
 * при группировке BY_MODULE     нужна информация о StudyModule
 * при группировке BY_COMPETITION нужна информация о ExternalCompetition
 * при группировке NONE          дополнительная информация не нужна
 */
export type StudentTaskGroupMeta = ClassSubject | ExternalCompetition | StudyModule | Task;

/** Тип группировки StudentTask */
export enum StudentTaskGroupTypeEnum {
  /** Группируется по stage_subject_group.stage_subject_group_id (classSubject.id) */
  ByClass = 'BY_CLASS',
  /** Группируется по student_tasks.check_bucket_id */
  ByCompetition = 'BY_COMPETITION',
  /** Группируется по goals.goal_id (study_module.id) */
  ByModule = 'BY_MODULE',
  /**
   * Группируется по stage_subject_subgroup_students.stage_subject_subgroup_student_id
   * Не по student.student_id, потому что возможна ситуация, когда у одного ученика есть задания по нескольким предметам,
   *  а выводиться они должны в разных группах - Абрамов Лев (Литература), Абрамов Лев (Русский язык)
   */
  ByStudent = 'BY_STUDENT',
  /** Группируется по tasks.task_id */
  ByTask = 'BY_TASK',
  /** Специальный тип для отсутствующей группировки, все таски буду сложены в группу "NONE" - ["NONE": [все StudentTask]] */
  None = 'NONE'
}

/** Полная информация по Заданию в контексте Студента */
export type StudentTaskInfo = {
  __typename?: 'StudentTaskInfo';
  /** Группа по Предмету, в рамках которой Студент в данный момент изучает Предмет, к которому относится Задание */
  currentClassSubject?: Maybe<ClassSubject>;
  /** Персональная информация по Учебному Модулю в контексте Студента, к которому привязано Задание */
  studentModule?: Maybe<StudentModule>;
  /** Персональная информация по Заданию в контексте Студента */
  studentTask?: Maybe<StudentTask>;
  /** Студент в Подгруппе, в рамках которой Студент в данный момент выполняет Задание */
  subgroupStudent?: Maybe<StudentInSubgroup>;
};

export type StudentTaskLessonInputModel = {
  lessonMarkInputModel: Array<LessonMarkInputModel>;
  /** Идентификатор студента */
  studentId: Scalars['UUID']['input'];
  /** Идентификатор задания */
  taskId: Scalars['ID']['input'];
};

/** Модель для Чанки Light */
export type StudentTaskLightStatisticsModel = {
  __typename?: 'StudentTaskLightStatisticsModel';
  /** @deprecated unused */
  acceptedTasks: Array<Maybe<StudentTask>>;
  /** @deprecated unused */
  amountOfAcceptedTasks: Scalars['Int']['output'];
  amountOfClassWorkTasks: Scalars['Int']['output'];
  amountOfHomework: Scalars['Int']['output'];
  homework: Array<Maybe<HomeworkInfo>>;
  /** @deprecated use lessonsCompact */
  lessons: Array<Maybe<StudentLesson>>;
  lessonsCompact: Array<Maybe<StudentLessonCompact>>;
};

/** Статистика по чанкам и таскам по предметам Облегченная версия используется SubjectTaskStatisticsLightweightModel вместо SubjectTaskStatisticsModel */
export type StudentTaskPmoStatisticsLightweightModel = {
  __typename?: 'StudentTaskPmoStatisticsLightweightModel';
  acceptedTasks?: Maybe<Array<Maybe<SubjectTaskStatisticsLightweightModel>>>;
  amountAccepted: Scalars['Int']['output'];
  amountCanToDo: Scalars['Int']['output'];
  amountNeedToCheck: Scalars['Int']['output'];
  amountNeedToDo: Scalars['Int']['output'];
  amountWantToDo: Scalars['Int']['output'];
  canToDoTasks?: Maybe<Array<Maybe<SubjectTaskStatisticsLightweightModel>>>;
  needToCheckTasks?: Maybe<Array<Maybe<SubjectTaskStatisticsLightweightModel>>>;
  needToDoTasks?: Maybe<Array<Maybe<SubjectTaskStatisticsLightweightModel>>>;
  wantToDoTasks?: Maybe<Array<Maybe<SubjectTaskStatisticsLightweightModel>>>;
};

/** Успеваемость ученика по системе заданий модуля */
export type StudentTaskSetPerformance = {
  __typename?: 'StudentTaskSetPerformance';
  /** максимально достигнутый уровень */
  achievedLevel?: Maybe<Scalars['Float']['output']>;
  /** модуль входит в учебный план ученика */
  goalInStudentPlan?: Maybe<Scalars['Boolean']['output']>;
  /** Признак, что у ученика есть персональный план */
  hasPersonalPlan?: Maybe<Scalars['Boolean']['output']>;
  /** по заданиям системы заданий модуля у ученика есть вопросы */
  hasQuestion?: Maybe<Scalars['Boolean']['output']>;
  /** дата окончания модуля в персональном плане */
  personalPlanEndDate?: Maybe<Scalars['DateTime']['output']>;
  /** дата начала модуля в персональном плане */
  personalPlanStartDate?: Maybe<Scalars['DateTime']['output']>;
  /** Тип системы заданий в плане ученика */
  personalPlaylistType?: Maybe<PlaylistType>;
  /** Id системы заданий в плане ученика */
  personalTaskSetId?: Maybe<Scalars['ID']['output']>;
  /** целевой уровень */
  plannedLevel?: Maybe<Scalars['Float']['output']>;
  /** Прогноз прохождения модуля */
  probability?: Maybe<Scalars['Boolean']['output']>;
  /** Мета информация об ученике, находящемся в группе по предмету */
  student: Student;
  /** система заданий назначена ученику */
  taskSetAssignedToStudent?: Maybe<Scalars['Boolean']['output']>;
};

export type StudentTaskStatus = {
  __typename?: 'StudentTaskStatus';
  /** вопрос по заданию у ученика */
  lastStudentMessage?: Maybe<TaskMessage>;
  /** оценка за задание */
  mark?: Maybe<SchoolMark>;
  /** id ученика */
  studentId: Scalars['UUID']['output'];
  /** статус задания */
  taskStatus?: Maybe<TaskStatusEnum>;
};

/** статистика по прохождению заданий по каждому модулю */
export type StudentTaskStatusGroup = {
  __typename?: 'StudentTaskStatusGroup';
  /** ID модуля */
  moduleId: Scalars['ID']['output'];
  /** количество заданий в каждом статусе */
  studentTaskStatusCounts: Array<TaskStatusWithQuantity>;
  /** общее количество заданий у учеников (из их траекторий) */
  totalCount: Scalars['Int']['output'];
};

/** Статус заданий для конкретного задания студента */
export type StudentTaskStatusesMap = {
  __typename?: 'StudentTaskStatusesMap';
  /** пара studentId + taskId */
  key: Scalars['String']['output'];
  /** идентификатор оценки */
  markId?: Maybe<Scalars['ID']['output']>;
  /** статус задания студента */
  value?: Maybe<TaskStatusEnum>;
};

export type StudentTaskToCheck = {
  __typename?: 'StudentTaskToCheck';
  /** Число непрочитанных Комментариев */
  countUnreadMessages?: Maybe<Scalars['Int']['output']>;
  /** превысило 3 дня в статусе (для статуса "на проверке") */
  expire3Days: Scalars['Boolean']['output'];
  /** превысило 7 дней в статусе (для статуса "на проверке") */
  expire7Days?: Maybe<Scalars['Boolean']['output']>;
  /** есть непрочитанный комментарий */
  haveComment: Scalars['Boolean']['output'];
  /** история оценок из электронного журнала */
  markHistory?: Maybe<Array<Maybe<MarkHistory>>>;
  /** список соответствия критериям */
  studentCriteriaValues?: Maybe<Array<Maybe<StudentCriteriaValue>>>;
  /** Задание ученика */
  studentTask: StudentTask;
};

export type StudentTaskToCheckInput = {
  /** ИД ученика для конкретного studentTask первым элементом */
  studentId: Scalars['UUID']['input'];
  /** ИД задания для загрузки конкретного studentTask первым элементом */
  taskId: Scalars['ID']['input'];
};

/** Результат прохождения виджета пользователем */
export type StudentTaskWidget = {
  __typename?: 'StudentTaskWidget';
  /** Ответы на виджет */
  answers: Array<StudentTaskWidgetAnswer>;
  /** Мета-виджет */
  contentWidget?: Maybe<Widget>;
  /** Дата и время создания */
  createTime: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  /** Дата и время последней модификации */
  modifyTime?: Maybe<Scalars['DateTime']['output']>;
  /** Текущий статус виджета */
  status: TaskWidgetStatusEnum;
  widget: ContentBodyWidget;
  /**
   * Идентифкатор виджета в контент-сервисе
   * @deprecated Use instead contentWidget
   */
  widgetId: Scalars['ID']['output'];
};

export type StudentTaskWidgetAnswer = {
  __typename?: 'StudentTaskWidgetAnswer';
  /** Идентификатор количества заданий во время сохранения ответа */
  amountOfStudentTaskWidget?: Maybe<Scalars['Int']['output']>;
  /** Тело ответа */
  answerBody?: Maybe<WidgetAnswerBody>;
  /**
   * Тело ответа
   * @deprecated Use instead answerBody
   */
  body?: Maybe<Scalars['String']['output']>;
  /** Дата и время создания */
  createTime: Scalars['DateTime']['output'];
  /** файлы */
  files: Array<File>;
  id: Scalars['ID']['output'];
  /** Дата и время последней модификации */
  modifyTime?: Maybe<Scalars['DateTime']['output']>;
  /** Был ли ли модуль внеплановым во время сохранения ответа */
  plannedGoal?: Maybe<Scalars['Boolean']['output']>;
  /** Идентификатор проверяющего пользователя (взаимопроверка) */
  reviewUserId?: Maybe<Scalars['UUID']['output']>;
  /** Инфо проверяющего пользователя */
  reviewUserInfo?: Maybe<UserInfo>;
  /** Текущий статус ответа */
  status: TaskWidgetAnswerStatusEnum;
  /** Идентификатор проверяющего учителя */
  teacherId?: Maybe<Scalars['UUID']['output']>;
  /** Идентификатор варианта вопроса тренажера */
  variantId?: Maybe<Scalars['String']['output']>;
};

/** Результат прохождения виджетов пользователем */
export type StudentTaskWidgetAnswers = {
  __typename?: 'StudentTaskWidgetAnswers';
  /** Текущая страница */
  currentPage?: Maybe<Scalars['Int']['output']>;
  /** Результат прохождения виджета пользователем */
  studentTaskWidgets?: Maybe<Array<Maybe<StudentTaskWidget>>>;
};

export type StudentTaskWithCounters = {
  __typename?: 'StudentTaskWithCounters';
  countStudentAnswers: Scalars['Int']['output'];
  countUnreadMessages: Scalars['Int']['output'];
  isExpired3Days: Scalars['Boolean']['output'];
  isExpired7Days: Scalars['Boolean']['output'];
  lastAnswerDate?: Maybe<Scalars['Date']['output']>;
  studentAnswerIds?: Maybe<Array<Scalars['ID']['output']>>;
  studentTask: StudentTask;
};

export type StudentTaskWithCriterias = {
  __typename?: 'StudentTaskWithCriterias';
  markHistory?: Maybe<Array<Maybe<MarkHistory>>>;
  studentCriteriaValues?: Maybe<Array<Maybe<StudentCriteriaValue>>>;
  studentTask: StudentTask;
};

export type StudentTasksByStageSubjectGroupForStudentsResponse = {
  __typename?: 'StudentTasksByStageSubjectGroupForStudentsResponse';
  shortSubjectName: Scalars['String']['output'];
  stageGroupName: Scalars['String']['output'];
  stageSubjectGroup: StageSubjectGroup;
  studentCount: Scalars['Int']['output'];
  studentsWithTasks?: Maybe<Array<StudentWithTasks>>;
  subjectName?: Maybe<Scalars['String']['output']>;
};

export type StudentTasksByStageSubjectGroupResponse = {
  __typename?: 'StudentTasksByStageSubjectGroupResponse';
  /** количество групп до пейджинга */
  countOfGroups: Scalars['Int']['output'];
  /**
   * сгруппированные задания на проверке.
   * Сгруппированы задания на проверке по ИД задания
   */
  groupedStudentTasks: Array<GroupedStudentTaskForTeacher>;
};

export type StudentTasksToCheckResponse = {
  __typename?: 'StudentTasksToCheckResponse';
  /** Назначенные задания студента */
  assignedStudentTasks: Array<StudentTaskWithCriterias>;
  /** Проверенные задания учеников */
  checkedStudentTasks: Array<StudentTaskWithCriterias>;
  defaultSchoolMarks: Array<Maybe<SchoolMark>>;
  studentMark?: Maybe<StudentMark>;
  /** количество заданий учеников */
  studentTaskCount: Scalars['Int']['output'];
  /** Задания учеников */
  studentTasks: Array<StudentTaskToCheck>;
  taskInfo?: Maybe<TaskInfoToCheck>;
};

export type StudentTasksWithAnswersAndCommentsCountResponse = {
  __typename?: 'StudentTasksWithAnswersAndCommentsCountResponse';
  shortSubjectName: Scalars['String']['output'];
  stageGroupName: Scalars['String']['output'];
  stageSubjectGroup: StageSubjectGroup;
  studentTaskCount: Scalars['Int']['output'];
  subjectName?: Maybe<Scalars['String']['output']>;
  tasks?: Maybe<Array<TaskWithCounters>>;
};

export type StudentTasksWithPerformance = {
  __typename?: 'StudentTasksWithPerformance';
  /** Успеваемость ученика по системе заданий модуля */
  studentTaskSetPerformance: Array<StudentTaskSetPerformance>;
  /** Задания учеников */
  studentTasks: Array<StudentTask>;
  /** Количество заданий с определенным статусом и количество заданий с вопросом от ученика */
  taskStatusQuantityWithQuestion?: Maybe<TaskStatusQuantityWithQuestion>;
};

/** Данные для отчета "Итоговые оценки. Детальный" */
export type StudentTestPercentDetail = {
  __typename?: 'StudentTestPercentDetail';
  attached?: Maybe<Scalars['String']['output']>;
  completed: Scalars['Date']['output'];
  test: Scalars['String']['output'];
  testPercent?: Maybe<Scalars['Int']['output']>;
};

export type StudentThemesQueries = {
  __typename?: 'StudentThemesQueries';
  /** Получить модуль лайт по айди */
  getModuleLightById: StudentModuleLight;
  /** Вернуть учебные периоды с темами */
  getStudentStudyPeriodWithSubjectThemesBySubjectId: Array<StudentStudyPeriodWithSubjectThemes>;
  /** Вернуть учебные периоды с темами с учетом фильтра по названию тем */
  getStudentStudyPeriodWithSubjectThemesByTextSearch: Array<StudentStudyPeriodWithSubjectThemes>;
};


export type StudentThemesQueriesGetModuleLightByIdArgs = {
  goalId: Scalars['ID']['input'];
};


export type StudentThemesQueriesGetStudentStudyPeriodWithSubjectThemesBySubjectIdArgs = {
  subjectId: Scalars['ID']['input'];
};


export type StudentThemesQueriesGetStudentStudyPeriodWithSubjectThemesByTextSearchArgs = {
  onlyCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  subjectId?: InputMaybe<Scalars['ID']['input']>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};

export type StudentThermometerInfoBySkill = {
  __typename?: 'StudentThermometerInfoBySkill';
  /** Среднее кол-во выполненных заданий в классе */
  averageCount: Scalars['Float']['output'];
  /** Средний процент выполненных заданий в классе */
  averagePercent: Scalars['Float']['output'];
  /** Влияние */
  influence?: Maybe<Scalars['Float']['output']>;
  /** Максимальное кол-во заданий в модуле */
  maxTaskCount: Scalars['Int']['output'];
  /** Идентификатор навыка */
  skillId: Scalars['ID']['output'];
  /** Название навыка */
  skillName?: Maybe<Scalars['String']['output']>;
  /** Кол-во выполненных заданий студентом */
  studentCount: Scalars['Int']['output'];
  /** Статус градусника */
  thermometerPMOStatus: ThermometerPmoStatusEnum;
};

export type StudentThermometerInfoBySubject = {
  __typename?: 'StudentThermometerInfoBySubject';
  /** Среднее кол-во выполненных заданий в классе */
  averageCount: Scalars['Float']['output'];
  /** Средний процент выполненных заданий в классе */
  averagePercent: Scalars['Float']['output'];
  /**
   * Дедлайн текущего модуля
   * @deprecated Use nullable parameter currentModuleDeadlineDate
   */
  currentModuleDeadline: Scalars['DateTime']['output'];
  /** Дедлайн текущего модуля */
  currentModuleDeadlineDate?: Maybe<Scalars['DateTime']['output']>;
  /** Влияние */
  influence?: Maybe<Scalars['Float']['output']>;
  /** Максимальное кол-во заданий в модуле */
  maxTaskCount: Scalars['Int']['output'];
  /** Кол-во выполненных заданий студентом */
  studentCount: Scalars['Int']['output'];
  /** Идентификатор предмета */
  subjectId: Scalars['ID']['output'];
  /** Статус градусника */
  thermometerPMOStatus: ThermometerPmoStatusEnum;
};

export type StudentThermometerPmo = {
  __typename?: 'StudentThermometerPMO';
  /** Информация для градусников ПМО по предметам */
  thermometerInfoByDigitalSkills?: Maybe<Array<StudentThermometerInfoBySkill>>;
  /** Информация для градусников ПМО по предметам */
  thermometerInfoBySoftSkills?: Maybe<Array<StudentThermometerInfoBySkill>>;
  /** Информация для градусников ПМО по предметам */
  thermometerInfoBySubjects?: Maybe<Array<StudentThermometerInfoBySubject>>;
};

export type StudentToBigChallengeV2 = {
  __typename?: 'StudentToBigChallengeV2';
  /** информация о БВ */
  bigChallenge: BigChallengeV2;
  /** дата и время, когда ученик принял БВ */
  bigChallengeStart: Scalars['String']['output'];
  /** статус БВ у ученика */
  bigChallengeStatus: Scalars['String']['output'];
  finalOverallProgress?: Maybe<Scalars['Float']['output']>;
  /** статус БВ у ученика */
  statusLastChange: Scalars['String']['output'];
  /** id ученика */
  studentId: Scalars['UUID']['output'];
  /** уровень студента в БВ */
  studentLevel: Scalars['String']['output'];
  /** количество дней до завершения триала */
  trialPeriodDaysLeft?: Maybe<Scalars['Int']['output']>;
};

export type StudentToCheck = {
  __typename?: 'StudentToCheck';
  /** превысило 3 дня в статусе (для статуса "на проверке") */
  expire3Days: Scalars['Boolean']['output'];
  /** есть непрочитанный комментарий */
  haveComment: Scalars['Boolean']['output'];
  /** дата последнего изменения статуса задания студентом */
  statusChangeDate: Scalars['DateTime']['output'];
  /** Ученик */
  student: Student;
};

/** Статус тултипов студента */
export type StudentTooltipStatus = {
  __typename?: 'StudentTooltipStatus';
  /** Ид модуля */
  goalId: Scalars['ID']['output'];
  /** Показан ли тултип "Поздравляем" после завершения модуля */
  reflectionCongratulationTooltipStatus?: Maybe<Scalars['Boolean']['output']>;
  /** Просмотрен ли тултип "Понятно" для сохранения рефлексии по модулю */
  reflectionPassTooltipStatus: Scalars['Boolean']['output'];
  /** Просмотрен ли тултип "Понятно" для просмотра рефлексии по модулю */
  reflectionReadTooltipStatus: Scalars['Boolean']['output'];
  /** Ид */
  statusId?: Maybe<Scalars['ID']['output']>;
};

/** Статус тултипов студента */
export type StudentTooltipStatusInput = {
  /** Ид модуля */
  goalId: Scalars['ID']['input'];
  /** Показан ли тултип "Поздравляем" после завершения модуля */
  reflectionCongratulationTooltipStatus?: InputMaybe<Scalars['Boolean']['input']>;
  /** Просмотрен ли тултип "Понятно" для сохранения рефлексии по модулю */
  reflectionPassTooltipStatus: Scalars['Boolean']['input'];
  /** Просмотрен ли тултип "Понятно" для просмотра рефлексии по модулю */
  reflectionReadTooltipStatus: Scalars['Boolean']['input'];
  /** Ид */
  statusId?: InputMaybe<Scalars['ID']['input']>;
};

/** Информация о посещаемости студента за неделю */
export type StudentTraffic = {
  __typename?: 'StudentTraffic';
  /** Информация о посещаемости за день */
  days: Array<DailyTraffic>;
  /** Последний день недели */
  endDate: Scalars['Date']['output'];
  /** Первый день недели */
  startDate: Scalars['Date']['output'];
};

/** Траектории назначенные на студента */
export type StudentTrajectorySlug = {
  __typename?: 'StudentTrajectorySlug';
  /** идентификатор студента */
  studentId: Scalars['ID']['output'];
  /** строка с перечнем траекторий разделенных запятой */
  trajectorySlugs?: Maybe<Scalars['String']['output']>;
};

/** Данные для формирования траектории обучения студента в классе в соответствие с шаблоном траектории */
export type StudentTrajectoryTemplateAssignmentInputModel = {
  /** Способ применения шаблона траектории */
  assignmentMode: TrajectoryAssignmentMode;
  /** Признак основной траектории */
  isPrimary: Scalars['Boolean']['input'];
  /** Плановая дата начала обучения по траектории */
  planStartDate: Scalars['Date']['input'];
  /** Идентификатор класса, в котором будет применяться шаблон */
  stageGroupId: Scalars['ID']['input'];
  /** Идентификатор студента, по которому будет сформирована траектория в соответствии с шаблоном */
  studentIds: Array<Scalars['ID']['input']>;
  /** Идентификатор применяемого шаблона траектории */
  trajectoryTemplateId: Scalars['ID']['input'];
};

/** Информация по верификации университетской почты ученика */
export type StudentUniversityEmailInputModel = {
  /** Комментарий с названием университета ученика, если такого не нашлось в справочнике с университетами */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** Статус подтверждения университетской почты учеником */
  confirmationStatus?: InputMaybe<EmailConfirmationStatus>;
  /** Университетская почта */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Флаг указания отсутсвия почты у ученика */
  isEmailAbsent?: InputMaybe<Scalars['Boolean']['input']>;
  /** Флаг показа страницы с верификацией университетской почты */
  isVisible?: InputMaybe<Scalars['Boolean']['input']>;
  /** Идентификатор ученика */
  studentId: Scalars['UUID']['input'];
  /** Идентификатор связи ученика и его университетской почты */
  studentUniversityEmailId?: InputMaybe<Scalars['ID']['input']>;
  /** Идентификатор университета ученика */
  universityId?: InputMaybe<Scalars['ID']['input']>;
};

/** Информация об университетской почте ученика */
export type StudentUniversityEmailModel = {
  __typename?: 'StudentUniversityEmailModel';
  /** Комментарий с названием университета ученика, если такого не нашлось в справочнике с университетами */
  comment?: Maybe<Scalars['String']['output']>;
  /** Статус подтверждения университетской почты учеником */
  confirmationStatus?: Maybe<EmailConfirmationStatus>;
  /** Время создания записи */
  createTs?: Maybe<Scalars['DateTime']['output']>;
  /** Университетская почта */
  email?: Maybe<Scalars['String']['output']>;
  /** Флаг показа страницы с верификацией университетской почты */
  isVisible?: Maybe<Scalars['Boolean']['output']>;
  /** Время модификации записи */
  modifyTs?: Maybe<Scalars['DateTime']['output']>;
  /** Идентификатор ученика */
  studentId: Scalars['UUID']['output'];
  /** Идентификатор связи ученика и его университетской почты */
  studentUniversityEmailId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор университета ученика */
  universityId?: Maybe<Scalars['ID']['output']>;
};

/** Запись о вузовской почте ученика Bootcamp */
export type StudentUniversityEmailModelBtc = {
  __typename?: 'StudentUniversityEmailModelBTC';
  /** Комментарий, содержащий название вуза, которое не было найдено среди существующего списка вузов */
  comment?: Maybe<Scalars['String']['output']>;
  /** Дата создания записи */
  createTs: Scalars['DateTime']['output'];
  /** Почта ученика в системе Bootcamp */
  email?: Maybe<Scalars['String']['output']>;
  /** Имя пользователя */
  firstName: Scalars['String']['output'];
  /** Флаг показа страницы верификации вузовской почты пользователю */
  isVisible?: Maybe<Scalars['Boolean']['output']>;
  /** Фамилия пользователя */
  lastName: Scalars['String']['output'];
  /** Отчество пользователя */
  middleName?: Maybe<Scalars['String']['output']>;
  /** Иденитификатор записи */
  studentUniversityEmailId: Scalars['ID']['output'];
  /** Вузовская почта ученика */
  universityEmail?: Maybe<Scalars['String']['output']>;
  /** Наименование вуза */
  universityName?: Maybe<Scalars['String']['output']>;
  /** Идентификатор пользователя */
  userId: Scalars['UUID']['output'];
};

export type StudentUserInfo = {
  __typename?: 'StudentUserInfo';
  fullName: Scalars['String']['output'];
  login: Scalars['String']['output'];
  studentId: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

/** Статус посещения урока студентом */
export enum StudentVisitStatus {
  /** Отсутствовал */
  Absent = 'ABSENT',
  /** Болел */
  WasIll = 'WAS_ILL',
  /** Опоздал */
  WasLate = 'WAS_LATE'
}

export type StudentWhiteListInputModel = {
  /** Признак разрешения */
  allowed?: InputMaybe<Scalars['Boolean']['input']>;
  /** E-mail */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Номер телефона */
  mobilePhone?: InputMaybe<Scalars['String']['input']>;
  /** Описание */
  note?: InputMaybe<Scalars['String']['input']>;
  /** Идентификатор шаблона траектории */
  trajectoryTemplateId?: InputMaybe<Scalars['ID']['input']>;
  /** Значение метки utm_source */
  utmSource?: InputMaybe<Scalars['String']['input']>;
};

export type StudentWhiteListModel = {
  __typename?: 'StudentWhiteListModel';
  /** Признак разрешения */
  allowed: Scalars['Boolean']['output'];
  /** Дата и время создания */
  createTs: Scalars['DateTime']['output'];
  /** E-mail */
  email?: Maybe<Scalars['String']['output']>;
  /** Дата и время последнего изменения */
  lastModifyTs?: Maybe<Scalars['DateTime']['output']>;
  /** Номер телефона */
  mobilePhone?: Maybe<Scalars['String']['output']>;
  /** Описание */
  note?: Maybe<Scalars['String']['output']>;
  /** Идентификатор шаблона траектории */
  trajectoryTemplateId?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор пользователя */
  userId?: Maybe<Scalars['UUID']['output']>;
  /** Значение метки utm_source */
  utmSource?: Maybe<Scalars['String']['output']>;
};

export type StudentWithLoginModel = {
  __typename?: 'StudentWithLoginModel';
  /** Логин студента */
  login: Scalars['String']['output'];
  /** Идентификатор студента */
  studentId: Scalars['ID']['output'];
};

/** Тип содержит информацию об учениках группы по предмету и их группе успеваемости */
export type StudentWithPerformance = {
  __typename?: 'StudentWithPerformance';
  /** Ученик группы по предмету */
  student: Student;
  /** Группа успеваемости ученика */
  studentPerformanceGroup: StudentPerformanceGroupEnum;
};

/** Модель для возврата данных по однокласникам с тем же заданием. Содержит модель студента и модель задания */
export type StudentWithSameTask = {
  __typename?: 'StudentWithSameTask';
  /** Студент-однокласник у которого в траектории есть задание */
  student: Student;
  /** Задание в конексте студента, необходимое для отображения статуса однокласнику */
  studentTask: StudentTask;
};

export type StudentWithStageSubjectGroup = {
  __typename?: 'StudentWithStageSubjectGroup';
  firstName: Scalars['String']['output'];
  itemsCount: Scalars['Int']['output'];
  lastName: Scalars['String']['output'];
  middleName?: Maybe<Scalars['String']['output']>;
  stageSubjectGroup?: Maybe<StageSubjectGroup>;
  studentId: Scalars['ID']['output'];
  studentUserId: Scalars['UUID']['output'];
};

export type StudentWithTasks = {
  __typename?: 'StudentWithTasks';
  student: Student;
  studentTaskCount: Scalars['Int']['output'];
  studentTasks?: Maybe<Array<StudentTaskWithCounters>>;
};

export type StudentWithUser = {
  __typename?: 'StudentWithUser';
  firstName: Scalars['String']['output'];
  itemsCount: Scalars['Int']['output'];
  lastName: Scalars['String']['output'];
  middleName?: Maybe<Scalars['String']['output']>;
  studentId: Scalars['ID']['output'];
  studentUserId: Scalars['UUID']['output'];
};

/** Данные для отчета "Мониторинг выполнения заданий учениками" */
export type StudentsGoalsResults = {
  __typename?: 'StudentsGoalsResults';
  levelHeaders: Array<StudentsGoalsResultsHeader>;
  studentAchievements: Array<StudentsGoalsResultsAchievements>;
};

export type StudentsGoalsResultsAchievements = {
  __typename?: 'StudentsGoalsResultsAchievements';
  studentAchievements: Array<Maybe<StudentsGoalsResultsAchievementsItem>>;
  studentId: Scalars['UUID']['output'];
  studentName: Scalars['String']['output'];
};

export type StudentsGoalsResultsAchievementsItem = {
  __typename?: 'StudentsGoalsResultsAchievementsItem';
  levelDescription?: Maybe<Scalars['String']['output']>;
  levelName?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  value: Scalars['Int']['output'];
};

export type StudentsGoalsResultsHeader = {
  __typename?: 'StudentsGoalsResultsHeader';
  level: Scalars['String']['output'];
  subLevels: Array<Scalars['String']['output']>;
};

export type StudentsGoalsTaskAchievements = {
  __typename?: 'StudentsGoalsTaskAchievements';
  studentAchievements: Array<Maybe<StudentsGoalsTaskAchievementsItem>>;
  studentId: Scalars['UUID']['output'];
  studentName: Scalars['String']['output'];
};

export type StudentsGoalsTaskAchievementsItem = {
  __typename?: 'StudentsGoalsTaskAchievementsItem';
  descriptions?: Maybe<Array<Scalars['String']['output']>>;
  name?: Maybe<Scalars['String']['output']>;
  taskTime?: Maybe<Scalars['DateTime']['output']>;
  value: Scalars['Int']['output'];
};

/** Данные для отчета "Мониторинг выполнения заданий учениками с состояниями" */
export type StudentsGoalsTaskStatus = {
  __typename?: 'StudentsGoalsTaskStatus';
  levelHeader: StudentsGoalsResultsHeader;
  studentAchievements: Array<StudentsGoalsTaskAchievements>;
};

export type StudentsInGroup = {
  __typename?: 'StudentsInGroup';
  isActive?: Maybe<Scalars['Boolean']['output']>;
  isNew?: Maybe<Scalars['Boolean']['output']>;
  studentInSubgroup: StudentInSubgroup;
};

/** DTO со студентами выполняющими тот же что проект что и залогиненный студент в его кампусе(и в остальных) */
export type StudentsInSameProjectByCampusModel = {
  __typename?: 'StudentsInSameProjectByCampusModel';
  /** студенты которые выполнили проект в кампусе студента */
  finishedInMyCampus: Array<Maybe<User>>;
  /** студенты которые выполнили проект тот же проект в других кампусах */
  finishedInNotMyCampus: Array<Maybe<User>>;
  /** студенты которые выполняют проект в кампусе студента */
  inProgressInMyCampus: Array<Maybe<User>>;
  /** студенты которые выполняют тот же проект в других кампусах */
  inProgressNotInMyCampus: Array<Maybe<User>>;
  /** студенты которые зарегистрированы на проекте в кампусе студента */
  registeredInMyCampus: Array<Maybe<User>>;
  /** студенты которые зарегистрированы на тот же проекте в других кампусах */
  registeredNotInMyCampus: Array<Maybe<User>>;
};

/** Постраничный список студентов в подгруппах (stage_subject_subgroup_students) */
export type StudentsInSubgroupPage = {
  __typename?: 'StudentsInSubgroupPage';
  studentsInSubgroups: Array<StudentInSubgroup>;
  /** общее количество без пагинации */
  total: Scalars['Int']['output'];
};

export type StudentsManagement = {
  __typename?: 'StudentsManagement';
  countOfProjects: Scalars['Int']['output'];
  countOfStudents: Scalars['Int']['output'];
};

export type StudyActivity = {
  __typename?: 'StudyActivity';
  /** Тип формы контроля */
  formControlTypes?: Maybe<Array<Maybe<FormControlTypeEnum>>>;
  /** Система оценивания */
  governmentMarkType?: Maybe<GovernmentMarkType>;
  /** Учебная активность */
  learningActivity?: Maybe<LearningActivity>;
  /** Система оценивания */
  schoolMarks?: Maybe<Array<Maybe<SchoolMark>>>;
};

/** Учебный Модуль без персональной информации */
export type StudyModule = {
  __typename?: 'StudyModule';
  /** Является ли архивированным */
  archived?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Учительский контекст, в котором содержится информация, на кого назначен этот модуль в тех группах,
   * в которых учитель ведет. Возвращается null, если текущий пользователь не имеет роль учителя в текущей школе.
   */
  assignContext?: Maybe<TeacherStudyModuleAssignContext>;
  /** Суммарное количество уникальных Заданий во всех Системах Заданий Учебного Модуля, которые доступны текущему пользователю */
  availableTasksCount: Scalars['Int']['output'];
  /** Ссылка на аватар модуля из JCR */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Награды */
  awards: Array<ModuleAward>;
  /** Книга, к которой относится данный Учебный Модуль (Тема) ИСПОЛЬЗУЕТСЯ ТОЛЬКО ДЛЯ ЛАЙТ-МОДУЛЕЙ */
  book?: Maybe<Book>;
  /** Ссылка на обложку Учебного Модуля (Темы) ИСПОЛЬЗУЕТСЯ ТОЛЬКО ДЛЯ ЛАЙТ-МОДУЛЕЙ */
  bookCoverUrl?: Maybe<Scalars['String']['output']>;
  /** Теги, которыми помечен Учебный Модуль */
  contentTags?: Maybe<Array<ContentTag>>;
  /**
   * Ссылка на обложку Учебного Модуля (Темы) ИСПОЛЬЗУЕТСЯ ТОЛЬКО ДЛЯ ЛАЙТ-МОДУЛЕЙ
   * @deprecated Will be deleted. Use instead bookCoverUrl
   */
  coverUrl?: Maybe<Scalars['URL']['output']>;
  /** Дата создания Учебного Модуля */
  createTime: Scalars['DateTime']['output'];
  /** Пользователь, создавший Учебный Модуль */
  createUser: User;
  /** Базовый дефолтный плейлист модуля */
  defaultBasePlaylist: TaskSet;
  /** Рекомендуемая трудоемкость в часах */
  duration: Scalars['Int']['output'];
  /** Тип выполнения */
  executionType?: Maybe<ModuleExecutionType>;
  /** Флаг о наличии мотивирующих заданий в базовом модуле */
  existMotivationTaskInBaseDefaultTaskSet?: Maybe<Scalars['Boolean']['output']>;
  /** Коды учебного модуля во внешней системе */
  externalCodes?: Maybe<Array<ContentExternalEntityCode>>;
  /** Список прикрепленных файлов */
  files: Array<TaskInfoFile>;
  /** группы проектов(Courses), в которых находится данный проект */
  goalCourses?: Maybe<Array<CourseMeta>>;
  /** Настройки завершающего теста для уровней модулей */
  goalLevelTests: Array<GoalLevelTest>;
  /** Балл за проект */
  goalPoint?: Maybe<Scalars['Int']['output']>;
  /** доступен ли Учебный Модуль на чтение текущему пользователю */
  hasReadAccess: Scalars['Boolean']['output'];
  /** Идентификатор (goals.goal_id) */
  id: Scalars['ID']['output'];
  /** Основная идея Учебного Модуля */
  idea: Scalars['String']['output'];
  /** Является ли импортированным */
  imported?: Maybe<Scalars['Boolean']['output']>;
  /** Флаг, означающий участвовал ли модуль в учебном процессе */
  inStudyProcess: Scalars['Boolean']['output'];
  /** Наличие связанных StudentModule в процессе прохождения */
  isStartedByStudents?: Maybe<Scalars['Boolean']['output']>;
  /** Шаблон модуля */
  landingTemplate: StudyModuleLandingTemplate;
  /** Количество уровней */
  levelCount: Scalars['Int']['output'];
  /** Уровни Учебного Модуля */
  levels: Array<StudyModuleLevel>;
  /** Общий замысел */
  mainIdea?: Maybe<Scalars['String']['output']>;
  /** Является ли обязательным */
  mandatory: Scalars['Boolean']['output'];
  /** Дата последнего изменения Учебного Модуля */
  modifyTime?: Maybe<Scalars['DateTime']['output']>;
  /** Пользователь, который последний раз модифицировал Учебный Модуль */
  modifyUser?: Maybe<User>;
  /** тип модуля */
  moduleType: ModuleType;
  /** UUID модуля */
  moduleUUID: Scalars['UUID']['output'];
  /** Есть ли мотивационный блок у модуля */
  motivationBlockPresent: Scalars['Boolean']['output'];
  /**
   * Рекомендация к названию Учебного Модуля (Темы),
   * в соответствии с которой этот Учебный Модуль (Тема) был назван ИСПОЛЬЗУЕТСЯ ТОЛЬКО ДЛЯ ЛАЙТ-МОДУЛЕЙ
   */
  nameRecommendation?: Maybe<StudyModuleNameRecommendation>;
  /** Заметка модуля */
  note?: Maybe<Scalars['String']['output']>;
  /** Информация о параллелях */
  planStages: Array<Stage>;
  /** Возможные трудности */
  possibleDifficulties?: Maybe<Scalars['String']['output']>;
  /**
   * Область видимости
   * @deprecated Не используется в бизнес-логике
   */
  preset?: Maybe<ScopePresetEnum>;
  /** Проблема, изучаемая в Учебном Модуле */
  problem: Scalars['String']['output'];
  /** Производственный статус Учебного Модуля */
  productionStatus?: Maybe<ContentEntityProductionStatus>;
  /** История изменений производственного статуса Учебного Модуля */
  productionStatusHistory: Array<ContentProductionStatusChangeLog>;
  /** Настройки повторного прохождения проекта (Ш21) */
  retrySettings?: Maybe<ModuleAttemptsSettings>;
  /** Область видимости */
  scope?: Maybe<ScopeEnum>;
  /** информация по скоуп */
  scopeInfo: StudyModuleScopeInfo;
  /** Количество навыков */
  skillCount: Scalars['Int']['output'];
  /** Параллель, для которой рекомендован Учебный Модуль */
  stage: Stage;
  /** Предмет, для которого создан Учебный Модуль */
  subject: Subject;
  /**
   * Теги
   * @deprecated Will be deleted. Use task.contentTags
   */
  tags: Array<Scalars['String']['output']>;
  /** Общее количество Заданий, привязанное к Учебному Модулю */
  taskCount: Scalars['Int']['output'];
  /** Базовые Плейлисты, созданные для Учебного Модуля */
  taskSets: Array<TaskSet>;
  /** Настройки формирования команд */
  teamSettings?: Maybe<TeamSettings>;
  /** Название Учебного Модуля */
  title: Scalars['String']['output'];
  /** Типовое распределение заданий по урокам */
  typicalLessonDistribution?: Maybe<Scalars['String']['output']>;
  /** Версия модуля. Пока что используется только для геймифицированных модулей (moduleType = PMO_CUSTOM) */
  version?: Maybe<Scalars['String']['output']>;
};

/** Элемент Цели (Навык) внутри Уровня Учебного Модуля */
export type StudyModuleGoalElement = {
  __typename?: 'StudyModuleGoalElement';
  containsForeignTasks?: Maybe<Scalars['Boolean']['output']>;
  /** Идентификатор (skill.skill_id) */
  id: Scalars['ID']['output'];
  letter: Scalars['String']['output'];
  number: Scalars['String']['output'];
  order?: Maybe<Scalars['Int']['output']>;
  /** Описание элемента. */
  studentDescription: Scalars['String']['output'];
  /** Пример достижения цели (Я могу...) */
  studentExample: Scalars['String']['output'];
  tasks: Array<Task>;
};

export type StudyModuleGoalElementInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  /** Для изменения информации по элементу цели */
  letter?: InputMaybe<Scalars['String']['input']>;
  /** Для изменения информации по элементу цели */
  levelId?: InputMaybe<Scalars['ID']['input']>;
  number?: InputMaybe<Scalars['String']['input']>;
  /** Число для сортировки элементов, абсолютное значение не важно, важно относительное значение */
  order?: InputMaybe<Scalars['Int']['input']>;
  studentDescription: Scalars['String']['input'];
  studentExample: Scalars['String']['input'];
};

/**
 * Шаблон лендинга для модуля
 * Simplified in EDU-69256
 */
export type StudyModuleLandingTemplate = {
  __typename?: 'StudyModuleLandingTemplate';
  attributes?: Maybe<StudyModuleLandingTemplateAttributes>;
  landingTemplate: LandingTemplate;
};

/** Атрибуты шаблона лендинга для модуля */
export type StudyModuleLandingTemplateAttributes = {
  __typename?: 'StudyModuleLandingTemplateAttributes';
  imageUrls: Array<Scalars['String']['output']>;
  moduleId: Scalars['ID']['output'];
};

export type StudyModuleLandingTemplateAttributesInput = {
  imageUrls: Array<Scalars['String']['input']>;
  landingTemplateId: Scalars['ID']['input'];
};

/** Уровни Учебного Модуля */
export type StudyModuleLevel = {
  __typename?: 'StudyModuleLevel';
  /** Элементы Цели с детализацией */
  goalElements: Array<StudyModuleGoalElement>;
  /** Настройки закрывающего теста для уровня модуля */
  goalLevelTest?: Maybe<GoalLevelTest>;
  /** Идентификатор (goal_levels.goal_level_id) */
  id: Scalars['ID']['output'];
  /** Численное обозначение Уровня Учебного Модуля (2.0, 3.0  и т.д.) */
  level: Scalars['Float']['output'];
  /** Идентификатор (goal_levels.goal_level_id) дублируем чтобы не возникало проблем с кэшем apollo */
  levelId: Scalars['ID']['output'];
};

export type StudyModuleLevelInput = {
  goalElements: Array<StudyModuleGoalElementInput>;
  level: Scalars['Float']['input'];
};

export type StudyModuleMetaInput = {
  /** Ссылка на аватар модуля из JCR */
  avatarUrl?: InputMaybe<Scalars['String']['input']>;
  /** Ссылка на обложку Учебного Модуля (Темы) ИСПОЛЬЗУЕТСЯ ТОЛЬКО ДЛЯ ЛАЙТ-МОДУЛЕЙ */
  bookCoverUrl?: InputMaybe<Scalars['String']['input']>;
  /** Идентификатор книги, к которой относится данный Учебный МОдуль (Тема) ИСПОЛЬЗУЕТСЯ ТОЛЬКО ДЛЯ ЛАЙТ-МОДУЛЕЙ */
  bookId?: InputMaybe<Scalars['ID']['input']>;
  /** Ссылка на обложку Учебного Модуля (Темы) ИСПОЛЬЗУЕТСЯ ТОЛЬКО ДЛЯ ЛАЙТ-МОДУЛЕЙ */
  coverUrl?: InputMaybe<Scalars['URL']['input']>;
  duration: Scalars['Int']['input'];
  /** Тип выполнения */
  executionType?: InputMaybe<ModuleExecutionType>;
  /** Список файлов */
  files?: InputMaybe<Array<TaskInfoFileInput>>;
  /** массив тестов с добавлением в инпуты level: Float */
  goalLevelTests?: InputMaybe<Array<GoalLevelTestInput>>;
  idea: Scalars['String']['input'];
  /** ID шаблона модуля */
  landingTemplateId: Scalars['ID']['input'];
  /** Общий замысел */
  mainIdea?: InputMaybe<Scalars['String']['input']>;
  /** Обязательная ли цель */
  mandatory: Scalars['Boolean']['input'];
  /** Тип модуля */
  moduleType: ModuleType;
  /**
   * Идентификатор рекомендации к названию Учебного Модуля (Темы),
   * в соответствии с которой этот Учебный Модуль (Тема) был назван ИСПОЛЬЗУЕТСЯ ТОЛЬКО ДЛЯ ЛАЙТ-МОДУЛЕЙ
   */
  nameRecommendationId?: InputMaybe<Scalars['ID']['input']>;
  /** Заметка */
  note?: InputMaybe<Scalars['String']['input']>;
  /** Возможные трудности */
  possibleDifficulties?: InputMaybe<Scalars['String']['input']>;
  problem: Scalars['String']['input'];
  /** Информация для установки скоупа */
  scope?: InputMaybe<ScopeForSet>;
  stageId: Scalars['Int']['input'];
  subjectId: Scalars['ID']['input'];
  title: Scalars['String']['input'];
  /** Типовое распределение заданий по урокам */
  typicalLessonDistribution?: InputMaybe<Scalars['String']['input']>;
};

/** Рекомендация к наименованию Учебного Модуля */
export type StudyModuleNameRecommendation = {
  __typename?: 'StudyModuleNameRecommendation';
  /** @deprecated Use instead bookIds */
  bookId?: Maybe<Scalars['Int']['output']>;
  /** Массив идентификаторов книг, к которым относится рекомендуемое название */
  bookIds?: Maybe<Array<Scalars['Int']['output']>>;
  /** Идентификатор рекомендации */
  id: Scalars['ID']['output'];
  /** Имя рекомендации */
  name: Scalars['String']['output'];
};

/**
 * информация по скоуп
 * depreacted: использовать ScopeInfo
 */
export type StudyModuleScopeInfo = {
  __typename?: 'StudyModuleScopeInfo';
  /** @deprecated Не корректное название. Использовать schoolShortNames */
  schoolIdShortNames?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  schoolIds: Array<Scalars['ID']['output']>;
  schoolShortNames?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  scope: ScopeEnum;
  userIds: Array<Scalars['ID']['output']>;
};

/** Учебный период (четверти/семестры...) */
export type StudyPeriod = {
  __typename?: 'StudyPeriod';
  /** Дата создания учебного периода */
  createTime: Scalars['DateTime']['output'];
  /** Окончание учебного периода */
  end: Scalars['Date']['output'];
  id: Scalars['ID']['output'];
  /** Флаг: активный период / удаленный */
  isActive: Scalars['Boolean']['output'];
  /** Является ли учебный период текущим */
  isCurrent: Scalars['Boolean']['output'];
  /** признак, рабочий период или каникулы */
  isWorkDays: Scalars['Boolean']['output'];
  /** Дата изменения учебного периода */
  modifyTime: Scalars['DateTime']['output'];
  /** Наименовани учебного периода */
  name: Scalars['String']['output'];
  /** Начало учебного периода */
  start: Scalars['Date']['output'];
};

export type StudyPeriodDailyStudentSubject = {
  __typename?: 'StudyPeriodDailyStudentSubject';
  subjectId: Scalars['Int']['output'];
  subjectName: Scalars['String']['output'];
};

export type StudyPeriodInput = {
  end: Scalars['String']['input'];
  id?: InputMaybe<Scalars['ID']['input']>;
  isActive: Scalars['Boolean']['input'];
  isWorkDays: Scalars['Boolean']['input'];
  name: Scalars['String']['input'];
  start: Scalars['String']['input'];
};

/** Данные для отчета "Оценки по учебным периодам" */
export type StudyPeriodMark = {
  __typename?: 'StudyPeriodMark';
  entries?: Maybe<Array<MarkEntry>>;
  stageGroup: Scalars['String']['output'];
  stageGroupId?: Maybe<Scalars['Int']['output']>;
  stageSubjectGroup: Scalars['String']['output'];
  studentFullName: Scalars['String']['output'];
  studentId: Scalars['UUID']['output'];
  subjectId?: Maybe<Scalars['Int']['output']>;
  subjectName: Scalars['String']['output'];
  teacherFullName: Scalars['String']['output'];
  teacherId: Scalars['UUID']['output'];
};

/** Набор учебных периодов */
export type StudyPeriodSet = {
  __typename?: 'StudyPeriodSet';
  /** Дата создания периода */
  createTime: Scalars['DateTime']['output'];
  id: Scalars['ID']['output'];
  /** Флаг: активный период / удаленный */
  isActive: Scalars['Boolean']['output'];
  /** Дата изменения периода */
  modifyTime: Scalars['DateTime']['output'];
  /** Наименование набора учебных периодов */
  name: Scalars['String']['output'];
  /** Параллели для которых создан набор учебных периодов */
  stages?: Maybe<Array<Scalars['Int']['output']>>;
  /** Учебные периоды в наборе */
  studyPeriods: Array<StudyPeriod>;
};

export type StudyPeriodSetInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  isActive: Scalars['Boolean']['input'];
  name: Scalars['String']['input'];
  stages: Array<Scalars['Int']['input']>;
  studyPeriods: Array<StudyPeriodInput>;
};

/** Данные для отчета Оценки по предмету и параллели */
export type StudyPeriodSubjectMarks = {
  __typename?: 'StudyPeriodSubjectMarks';
  headers: Array<Scalars['String']['output']>;
  values: Array<Array<Scalars['String']['output']>>;
};

/** Данные для отчета Оценки по предмету */
export type StudyPeriodSubjectSchoolMarks = {
  __typename?: 'StudyPeriodSubjectSchoolMarks';
  footer: Array<Array<Scalars['String']['output']>>;
  headers: Array<Scalars['String']['output']>;
  values: Array<Array<Scalars['String']['output']>>;
};

/** Данные для отчета Оценки по учителю и параллели */
export type StudyPeriodTeacherMarks = {
  __typename?: 'StudyPeriodTeacherMarks';
  headers: Array<StudyPeriodTeacherMarksHeader>;
  subjects?: Maybe<Array<StudyPeriodDailyStudentSubject>>;
  values: Array<Array<Scalars['String']['output']>>;
};

export type StudyPeriodTeacherMarksHeader = {
  __typename?: 'StudyPeriodTeacherMarksHeader';
  subjectName: Scalars['String']['output'];
  teacherId: Scalars['UUID']['output'];
  teacherName: Scalars['String']['output'];
};

export type StudyProcessFile = {
  __typename?: 'StudyProcessFile';
  /** Логин студента, который загрузил данный файл */
  creatorLogin: Scalars['String']['output'];
  /** Расширение файла без точки */
  fileExtension: Scalars['String']['output'];
  /** Размер файла в байтах */
  fileSize?: Maybe<Scalars['Int']['output']>;
  /** Ссылка на файл */
  link: Scalars['String']['output'];
  /** Статус загрузки */
  status: StudyProcessFileStatusEnum;
  /** Описание статуса */
  statusDetails?: Maybe<Scalars['String']['output']>;
  /** Идентификатор файла */
  studyProcessFileId: Scalars['ID']['output'];
  /** Дата создания/обновления */
  updateDateTime: Scalars['DateTime']['output'];
};

/** S21. Входные данные для создания файла, который пытаются загрузить в файловый сервис */
export type StudyProcessFileInitialInput = {
  /** Имя файла */
  fileName: Scalars['String']['input'];
  /** fileSize */
  fileSize?: InputMaybe<Scalars['Int']['input']>;
  /** Путь к файлу в файловом сервисе */
  relativePath: Scalars['String']['input'];
};

export enum StudyProcessFileStatusEnum {
  /** Отменено */
  Canceled = 'CANCELED',
  /** Удалено */
  Deleted = 'DELETED',
  /** Ошибка при загрузке */
  FailedToUpload = 'FAILED_TO_UPLOAD',
  /** Не подтверждено */
  NotConfirmed = 'NOT_CONFIRMED',
  /** Загружено */
  Uploaded = 'UPLOADED'
}

/** S21. Событие для файла после загрузки */
export type StudyProcessFileUploadInput = {
  /** Размер файла */
  fileSize: Scalars['Int']['input'];
  /** Идентификатор файла */
  studyProcessFileId: Scalars['ID']['input'];
};

export type StudyProgram = {
  __typename?: 'StudyProgram';
  /** академический год */
  academicYear: AcademicYear;
  id: Scalars['ID']['output'];
  /** статус */
  status: StudyProgramStatus;
  /** список часов и сверхурочных по предмету у класса */
  subjectStudyHours: Array<SubjectStudyHours>;
};

export type StudyProgramInput = {
  /** идентификатор академического года */
  academicYearId: Scalars['ID']['input'];
  /** идентификатор программы. Если пусто - создаем новую */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** статус */
  status: StudyProgramStatus;
  /** список часов и сверхурочных по предмету у класса */
  subjectStudyHours: Array<SubjectStudyHoursInput>;
};

export enum StudyProgramStatus {
  /** Утверждлен */
  Approved = 'APPROVED',
  /** Черновик */
  Draft = 'DRAFT'
}

/** Учебная Ступень (начальная школа, средняя школа и т д) */
export type StudyStep = {
  __typename?: 'StudyStep';
  /** Идентификатор (study_steps.study_step_id) */
  id: Scalars['ID']['output'];
  /** Название (начальная школа, средняя школа и т д) */
  name: Scalars['String']['output'];
  /** Короткое название */
  shortname?: Maybe<Scalars['String']['output']>;
};

/** Предмет, который преподают в рамках Учебной Ступени(начальная школа, средня школа и т д) в конкретной Школе */
export type StudyStepSubject = {
  __typename?: 'StudyStepSubject';
  /** План на Учебную Ступень по Предмету */
  plan?: Maybe<StudyStepSubjectPlan>;
  stageSubjects: Array<StageSubject>;
  /** Учебная Ступень (начальная школа, средняя школа и т д) */
  studyStep: StudyStep;
  /** Предмет */
  subject: Subject;
};

/** Формы контроля для предмета и уровня образования */
export type StudyStepSubjectLearningActivities = {
  __typename?: 'StudyStepSubjectLearningActivities';
  /** Уровень образования */
  studyStep: StudyStep;
  /** Формы контроля для предмета */
  subjectLearningActivities: Array<SubjectLearningActivitiesV2>;
};

/** Результат привязки элемента набора к предмету и уровню образования */
export type StudyStepSubjectLearningActivitiesAdditionResult = {
  __typename?: 'StudyStepSubjectLearningActivitiesAdditionResult';
  /** Сообщение об ошибка, NULL если привязка выполнена */
  errorMessage?: Maybe<Scalars['String']['output']>;
  /** Идентификатор элемента набора форм контроля */
  learningActivitySetElementId: Scalars['ID']['output'];
  /** Идентификатор уровня образования */
  studyStepId: Scalars['ID']['output'];
  /** Идентификатор предмета */
  subjectId: Scalars['ID']['output'];
};

/** Форма контроля для предмета и уровня образования */
export type StudyStepSubjectLearningActivity = {
  __typename?: 'StudyStepSubjectLearningActivity';
  /** Тип формы контроля */
  formControlType: FormControlTypeEnum;
  /** Система оценивания */
  governmentMarkType: GovernmentMarkType;
  /** Идентификатор формы контроля для предмета и уровня образования */
  id: Scalars['ID']['output'];
  /** Форма контроля */
  learningActivity: LearningActivity;
  /** Уровень образования */
  studyStep: StudyStep;
  /** Предмет */
  subject: Subject;
  /** Вес формы контроля */
  weight: Scalars['Float']['output'];
};

/**
 * План на Учебную Ступень по конкретному Предмету в конкретной Школе, например
 * план по английскому языку в школе 1747 по параллелям начальной школы (study_step_subject_plans)
 */
export type StudyStepSubjectPlan = {
  __typename?: 'StudyStepSubjectPlan';
  /** Идентификатор (study_step_subject_plans.study_step_subect_plan_id) */
  id: Scalars['ID']['output'];
  /** Планы на Параллель в рамках Плана на Cтупень, (план по английскому языку в школе 1747 для 3ей параллели) */
  plans: Array<StagePlan>;
  /** Статус плана */
  status: PlanStatusEnum;
};

/** Подгруппа по успеваемости внутри Группы по предмету */
export type Subgroup = {
  __typename?: 'Subgroup';
  /** Идентификатор (stage_subject_subgroup.stage_subject_subgroup_id) */
  id: Scalars['ID']['output'];
  /**
   * Флаг - является ли Подгруппа дефолтной (первой подгруппой, в которую попадают все ученики после создания Группы по Предмету и
   * куда они переводятся при удалении из Подгруппы)
   */
  isDefault: Scalars['Boolean']['output'];
  /** Название подгруппы */
  name: Scalars['String']['output'];
  /** Студенты внутри Подгруппы (stage_subject_subgroup_students) */
  students: Array<StudentInSubgroup>;
};

/** Студент подгруппы гкпп */
export type SubgroupStudent = {
  __typename?: 'SubgroupStudent';
  /** URL аватара */
  avatarUrl: Scalars['String']['output'];
  /** Имя */
  firstName: Scalars['String']['output'];
  /** Фамилия */
  lastName: Scalars['String']['output'];
  /** Идентификатор студента */
  studentId: Scalars['ID']['output'];
};

export type Subject = {
  __typename?: 'Subject';
  avatar?: Maybe<Scalars['String']['output']>;
  colour?: Maybe<Scalars['String']['output']>;
  fullName?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  orgUnitId: Scalars['String']['output'];
  /** Тип предмета */
  subjectType?: Maybe<SubjectType>;
  tenantId?: Maybe<Scalars['ID']['output']>;
  tenantShortName?: Maybe<Scalars['String']['output']>;
  /** Признак видимости предмета */
  visible: Scalars['Boolean']['output'];
};

export type SubjectCategoryProgressV2 = {
  __typename?: 'SubjectCategoryProgressV2';
  /** Название категории школьного предмета */
  name: Scalars['String']['output'];
  /** Прогресс */
  progressInfo: ProgressInfo;
  /** Идентификатор категории школьного предмета */
  subjectCategoryId: Scalars['ID']['output'];
};

/** Общая информация по предмету */
export type SubjectCommonInfo = {
  __typename?: 'SubjectCommonInfo';
  /** Идентификатор предмета */
  subjectId: Scalars['ID']['output'];
  /** Название предмета */
  subjectName: Scalars['String']['output'];
};

/** Набор параметров для создания материала из каталога */
export type SubjectContentInput = {
  /** Категории, к которым принадлежит материал */
  categoryIds: Array<Scalars['ID']['input']>;
  /** Автор дополнительного материала (например, автор книги). */
  contentAuthor: Scalars['String']['input'];
  /** Название дополнительного материала (книги, ссылки...). */
  contentName: Scalars['String']['input'];
  /** Издатель материала (например, видеохостинг) */
  contentPublisher?: InputMaybe<Scalars['String']['input']>;
  /** Тип дополнительного контента */
  contentType: AdditionalContentType;
  /** Полный URL дополнительного материала */
  contentUrl: Scalars['String']['input'];
  /** Описание */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Учебный материал (Учебник) */
  educational?: InputMaybe<Scalars['Boolean']['input']>;
  /** Дата окончания */
  endDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Онлайн/Офлайн */
  format?: InputMaybe<AdditionalContentFormat>;
  /** Информационный материал (Учусь учиться) */
  informational?: InputMaybe<Scalars['Boolean']['input']>;
  /** Подготовительный материал (Для подготовки к олимпиадам и экзаменам) */
  preparative?: InputMaybe<Scalars['Boolean']['input']>;
  /** URL файла предпросмотра дополнительного материала (изображения). */
  previewUrl?: InputMaybe<Scalars['String']['input']>;
  /** Регионы */
  regions?: InputMaybe<Array<Scalars['UUID']['input']>>;
  /** Уровень видимости материала */
  scope?: InputMaybe<ScopeEnum>;
  /**
   * Идентификаторы учебной параллели, к которой относится данный материал.
   * Может быть пусто, если материал не предназначен конкретной параллели
   */
  stageIds?: InputMaybe<Array<AdditionalContentStage>>;
  /** Идентификаторы учебных параллелей (Stage), может быть пустым */
  stageIdsV2?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Дата начала */
  startDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Идентификаторы предметов, к которым относится данный материал */
  subjectIds: Array<Scalars['ID']['input']>;
  /** Субтитры для видео */
  subtitleLink?: InputMaybe<Scalars['String']['input']>;
  /** Ссылка на файл субтитров для определенного языка */
  subtitleLinks?: InputMaybe<Array<SubtitleLinkForLanguageInput>>;
  /** Теги V2 */
  tagIdsV2?: InputMaybe<Array<Scalars['ID']['input']>>;
  /**
   * Теги материала для загрузки в каталог
   * deprecated "Use tagsV2"
   */
  tags: Array<Scalars['String']['input']>;
};

/** Информация о предметах и классах для публичного профиля учителя */
export type SubjectData = {
  __typename?: 'SubjectData';
  /** классы, в которых преподает этот предмет */
  stageGroups: Array<Scalars['String']['output']>;
  subject: Subject;
};

/**
 * Модель для Градусники Light
 * Итоговая оценка по предмету за период
 */
export type SubjectFinalMarkModel = {
  __typename?: 'SubjectFinalMarkModel';
  academicYearId: Scalars['ID']['output'];
  studentAverageMark: Scalars['Float']['output'];
  studyPeriodId?: Maybe<Scalars['ID']['output']>;
  subjectGroupAverageMark: Scalars['Float']['output'];
  subjectId: Scalars['ID']['output'];
  subjectName: Scalars['String']['output'];
  subjectStatus?: Maybe<SubjectStatusEnum>;
};

export type SubjectGroupsTeacherResponse = {
  __typename?: 'SubjectGroupsTeacherResponse';
  /** считаем или кол-во заданий на проверке в текущем предмете ИЛИ количество классов ГКПП по данному предмету для текущего учителя */
  counterForCurrentSubject: Scalars['Int']['output'];
  stageModel: Array<StageBySubjectResponse>;
  subject: Subject;
};

export type SubjectHours = {
  __typename?: 'SubjectHours';
  /** Количество часов по Предмету Учебного Модуля за Учебный Год */
  subjectStudyHoursOfYear: Scalars['Int']['output'];
};

export type SubjectInput = {
  avatar?: InputMaybe<Scalars['String']['input']>;
  colour?: InputMaybe<Scalars['String']['input']>;
  fullName: Scalars['String']['input'];
  id?: InputMaybe<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
  orgUnitId: Scalars['ID']['input'];
  /** Тип предмета, если не передано по дефолту будет проставляться USUAL */
  subjectType?: InputMaybe<SubjectType>;
};

/** Формы контроля для предмета */
export type SubjectLearningActivities = {
  __typename?: 'SubjectLearningActivities';
  /** Формы контроля для предмета */
  learningActivities: Array<LearningActivity>;
  /** Предмет */
  subject: Subject;
};

/** Формы контроля для предмета */
export type SubjectLearningActivitiesV2 = {
  __typename?: 'SubjectLearningActivitiesV2';
  /** Формы контроля для предмета и уровня образования */
  studyStepSubjectLearningActivities: Array<StudyStepSubjectLearningActivity>;
  /** Предмет */
  subject: Subject;
};

export type SubjectMarks = {
  __typename?: 'SubjectMarks';
  subjectName: Scalars['String']['output'];
};

/** Информация по плановым и фактическим трудозатратам студента и его прогрессе за текущий учебный период по предмету */
export type SubjectPerformanceInfo = {
  __typename?: 'SubjectPerformanceInfo';
  /** Фактический прогресс ученика на сегодняшний день в процентах */
  currentProgressInPercents: Scalars['Int']['output'];
  /** День с начала учебного периода */
  dayInStudyPeriod: Scalars['Int']['output'];
  /** Ожидаемый прогресс ученика на сегодняшний день с учетом плана в процентах */
  expectedCurrentProgressInPercents: Scalars['Int']['output'];
  /** Трудоемкость не входящих в персональную траекторию студента выполненных заданий по предмету за учебный период (content.tasks.laboriousness) */
  outOfPlanFactLaboriousness: Scalars['Float']['output'];
  /** Цель по отстающему предмету */
  personalObjective?: Maybe<PersonalObjective>;
  /** Трудоемкость входящих в персональную траекторию студента выполненных заданий по предмету за учебный период (content.tasks.laboriousness) */
  planFactLaboriousness: Scalars['Float']['output'];
  /** Общая планируемая трудоемкость заданий по предмету за учебный период (content.tasks.laboriousness) */
  planLaboriousness: Scalars['Float']['output'];
  /** Предмет */
  subject: Subject;
  /** Id предмета */
  subjectId: Scalars['ID']['output'];
  /** Информация о фактических и ожидаемых (для будущих недель) трудозатратам студента, разбитая по неделям в учебном периоде */
  subjectPerformancePerWeekInfoItems: Array<SubjectPerformancePerWeekInfo>;
};

/** Информация о фактических и ожидаемых (для будущих недель) трудозатратам студента, разбитая по неделям в учебном периоде */
export type SubjectPerformancePerWeekInfo = {
  __typename?: 'SubjectPerformancePerWeekInfo';
  /**
   * Аккумулированная трудоёмкость зачтённых на этой, и всех предыдущих неделях данного учебного периода заданий.
   * Данное поле - агрегат поля acceptedTasksLaboriousnessTotalMinutes
   */
  acceptedTasksLaboriousnessAccumulativeTotalMinutes?: Maybe<Scalars['Int']['output']>;
  /**
   * Суммарная трудоёмкость зачтённых на этой неделе заданий (относящихся к модулям данного учебного периода)
   * Может включать трудоёмкость дополнительных заданий -
   * если это последняя неделя последнего модуля в периоде но модуль кончается ДО окончания периода - может включать
   * трудоёмкость задания которое было зачтено после окончания данной недели/модуля, но до окончаничя периода
   * Аналогично для случая первой недели первого модуля в периоде и заданиям зачтённым до начала данной недели/модуля
   */
  acceptedTasksLaboriousnessTotalMinutes?: Maybe<Scalars['Int']['output']>;
  /**
   * Дата окончания недели (для последней недели в периоде - дата окончания периода ИЛИ последнего модуля
   * для данного периода, если модуль заканчивается раньше. Может быть любым днём недели)
   */
  endDate: Scalars['DateTime']['output'];
  /**
   * Дата начала недели (для первой недели в периоде - дата начала периода ИЛИ первого модуля
   * для данного периода, если модуль начинаетя позже. Может быть любым днём недели)
   */
  startDate: Scalars['DateTime']['output'];
  /** Началась-ли на данный момент данная неделя. Также будет true для прошедших недель */
  weekAlreadyStarted?: Maybe<Scalars['Boolean']['output']>;
};

export type SubjectQuery = {
  __typename?: 'SubjectQuery';
  subjectWithProgressByCategory?: Maybe<ChallengeSubjectV2>;
};


export type SubjectQuerySubjectWithProgressByCategoryArgs = {
  bigChallengeId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
  subjectCategoryId: Scalars['ID']['input'];
};

/** Успеваемость по предмету */
export enum SubjectStatusEnum {
  /** Плохо */
  Bad = 'BAD',
  /** Хорошо */
  Good = 'GOOD',
  /** Отлично */
  Perfect = 'PERFECT'
}

/** Академические Часы в год, выделенные на предмет для определенного класса в определенной школе */
export type SubjectStudyHours = {
  __typename?: 'SubjectStudyHours';
  /** Кол-во урочных академических часов, выделенных на предмет в неделю */
  academicStudyHoursForSubjectPerWeek: Scalars['Int']['output'];
  /** @deprecated используйте academicStudyHoursForSubjectPerWeek */
  academicStudyHoursForSubjectPerYear: Scalars['Int']['output'];
  /** Идентификатор класса */
  classId: Scalars['ID']['output'];
  /** Наименование класса (5А) */
  className: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** Идентификатор предмета */
  subject: Subject;
};

export type SubjectStudyHoursInput = {
  /** количество учебных часов в неделю. по факту поле обязательное, но из-за обратной совместимости сделано необязательным */
  academicStudyHoursForSubjectPerWeek?: InputMaybe<Scalars['Int']['input']>;
  academicStudyHoursForSubjectPerYear?: InputMaybe<Scalars['Int']['input']>;
  classId: Scalars['ID']['input'];
  /** идентификатор записи. Если пусто - создаем новую */
  id?: InputMaybe<Scalars['ID']['input']>;
  subjectId: Scalars['ID']['input'];
};

/** Информация о задаче, входящей в понедельный план */
export type SubjectTask = {
  __typename?: 'SubjectTask';
  /** Трудоемкость задачи в минутах */
  laboriousness: Scalars['Int']['output'];
  /** Сквозной порядоковый номер задания согласно плэйлисту */
  order: Scalars['Int']['output'];
  /** Информация о навыках, которыми протегировано данное задание */
  softSkills?: Maybe<Array<SoftSkillType>>;
  /** Идентификатор задачи */
  taskId: Scalars['ID']['output'];
  /** Краткая информация о задании в контексте пользователя */
  taskInfo: TaskInfo;
  /** Текущий Статус Задания в контексте Студента */
  taskStatus: TaskStatusEnum;
  /** Наименование задачи */
  title?: Maybe<Scalars['String']['output']>;
};

/** Облегченная версия без самих тасок, заместо возвращаются идентификаторы */
export type SubjectTaskStatisticsLightweightModel = {
  __typename?: 'SubjectTaskStatisticsLightweightModel';
  amount: Scalars['Int']['output'];
  subjectId: Scalars['ID']['output'];
  subjectName: Scalars['String']['output'];
  tasksIds?: Maybe<Array<Maybe<Scalars['ID']['output']>>>;
};

/** Тип предмета */
export enum SubjectType {
  /** Предмет с физической нагрузкой */
  PhysicalExercise = 'PHYSICAL_EXERCISE',
  /** Обычный предмет */
  Usual = 'USUAL',
  /** Письменный предмет */
  Writing = 'WRITING'
}

/** тип агрегированных данных из плана обучения, который напрямую связывает предмет с модулями для конкретного студента. Такакая агрегация нужна для шторы офлайн заданий */
export type SubjectWithModule = {
  __typename?: 'SubjectWithModule';
  /** Модули которые относятся к данному предмету у студента */
  moudulesWithTasks: Array<StudentModuleWithTasksModel>;
  /** Предмет */
  subject: Subject;
};

export type SubstituteFormMaster = {
  /** Идентификатор класса */
  stageGroupId: Scalars['ID']['input'];
  /** Идентификатор пользователя на замену классного руководителя */
  userId: Scalars['ID']['input'];
};

export type SubstituteStageSubjectGroupTeacher = {
  /** Идентификатор класса или ГКпП */
  stageSubjectGroupId: Scalars['ID']['input'];
  /** Идентификатор учителя на замену */
  teacherId: Scalars['ID']['input'];
};

export type SubstituteTeachersInput = {
  stageGroupFormMasters?: InputMaybe<Array<SubstituteFormMaster>>;
  stageSubjectGroupTeachers?: InputMaybe<Array<SubstituteStageSubjectGroupTeacher>>;
};

/** Ссылка на файл субтитров для определенного языка */
export type SubtitleLinkForLanguage = {
  __typename?: 'SubtitleLinkForLanguage';
  /** Код языка */
  languageCode: Scalars['String']['output'];
  /** Cсылка на субтитры для видео */
  subtitleLink: Scalars['String']['output'];
};

/** Ссылка на файл субтитров для определенного языка */
export type SubtitleLinkForLanguageInput = {
  /** Код языка */
  languageCode: Scalars['String']['input'];
  /** Cсылка на субтитры для видео */
  subtitleLink: Scalars['String']['input'];
};

/** Модель опроса */
export type Survey = {
  __typename?: 'Survey';
  /** Дата начала опроса */
  beginDate: Scalars['DateTime']['output'];
  /** Кол-во отрицательных оценок (от 0-6 NPS, по CSAT-ужасно, плохо, нормально) */
  countNegative: Scalars['Int']['output'];
  /** Кол-во нейтральных оценок (только по NPS 7-8) */
  countNeutral?: Maybe<Scalars['Int']['output']>;
  /** Кол-во прошедших опрос */
  countPass: Scalars['Int']['output'];
  /** Кол-во положительных оценок (отлично,хорошо-по СSAT, по NPS 9-10) */
  countPositive: Scalars['Int']['output'];
  /** Общее кол-во пользователей в школе */
  countTotal: Scalars['Int']['output'];
  /** Дата окончания опроса */
  endDate: Scalars['DateTime']['output'];
  /** Идентификатор опроса */
  id: Scalars['UUID']['output'];
  /** Наименование метрики */
  metricId: AcceleratorMetric;
  /** Название опроса */
  name: Scalars['String']['output'];
  /** Идентификатор образовательного учреждения */
  orgUnitId: Scalars['UUID']['output'];
  /** Статус */
  status: Scalars['String']['output'];
  /** Расчетное значение метрики по формуле */
  value: Scalars['Float']['output'];
};

/** Статус опроса Акселератора */
export enum SurveyStatus {
  Delete = 'DELETE',
  Finish = 'FINISH',
  Open = 'OPEN',
  Run = 'RUN',
  Stop = 'STOP'
}

export type SystemAdminMigrationResult = {
  __typename?: 'SystemAdminMigrationResult';
  otherAdmins: Scalars['Int']['output'];
  school21Admins: Scalars['Int']['output'];
};

export type SystemAdminMutations = {
  __typename?: 'SystemAdminMutations';
  /** Добавить пользователей в группы */
  addUsersToUserGroups: Array<UserGroup>;
  archiveAward: Award;
  /** Заархивировать группу проектов (курс), вернет true если смена статуса произошла успешно */
  archiveCourse: CourseMeta;
  /** savedFrames - новые или измененные фреймы, deletedFrames - фреймы на удаление */
  changeGlobalStagePlan: GlobalStagePlan;
  /**
   * Изменяет существующий План на Параллель по ID (stage_subject_plans.stage_subject_plan_id)
   * @deprecated Field no longer supported
   */
  changeStagePlan: StagePlan;
  /** Копирование награды по идентификатору */
  copyBadgeAward: Award;
  /**
   * Копирование модуля, возвращает скопированный модуль
   * @deprecated Под удаление. Использовать новую схему content.graphqls, метод copyModule
   */
  copyModule: StudyModule;
  createAvatar: Scalars['ID']['output'];
  createBadgeAward: Award;
  /** создание нового набора функциональных ролей */
  createFunctionalRoleSet?: Maybe<FunctionalRoleSet>;
  /** Cоздание файла по пути в репозитории gitlab */
  createGitlabFileAtPath: GitlabFileCreationStatus;
  /** Создание тэга в репозитории gitlab */
  createGitlabRepositoryTag: GitlabRepositoryTag;
  /** Создание глобального плана */
  createGlobalPlan: GlobalPlan;
  /** создание глобального плана */
  createGlobalStagePlan: GlobalStagePlan;
  /** Создание нового проекта в gitlab */
  createNewGitlabProject: GitlabProject;
  /**
   * Создание нового проекта в gitlab для данного пользователя
   * @deprecated C фронта не создаем проекты для пользователей. Используется createPrivateGitlabProject. Под удаление
   */
  createNewGitlabProjectForUser: GitlabProject;
  /**
   * Создает План на Параллель по Предмету
   * @deprecated Field no longer supported
   */
  createStagePlan: StagePlan;
  /** Удаление секции баннеров */
  deleteBannerSection: BannerSection;
  /** Удаление файла по пути в репозитории gitlab */
  deleteGitlabFileAtPath?: Maybe<GitlabResponseMessage>;
  /** Удалить проект из gitlab */
  deleteGitlabProject?: Maybe<GitlabResponseMessage>;
  deleteSchool?: Maybe<Scalars['Boolean']['output']>;
  deleteSystemNotification: Scalars['ID']['output'];
  editAvatar: Scalars['Boolean']['output'];
  editBadgeAward: Award;
  editExperienceLevelRange: Scalars['Boolean']['output'];
  /** выдача роли БА */
  grantBusinessAdminRole?: Maybe<Scalars['Boolean']['output']>;
  /** выдача роли родителя */
  grantParentRole?: Maybe<Scalars['Boolean']['output']>;
  /** выдача роли студента */
  grantStudentRole?: Maybe<Scalars['Boolean']['output']>;
  /** выдача роли учителя */
  grantTeacherRole?: Maybe<Scalars['Boolean']['output']>;
  /** Импорт / Публикация гитлаб контента в файловой системе */
  publishGitlabContent: PublishContentResponse;
  /** Публикация глобального курса */
  publishGlobalCourse: GlobalCourse;
  /** Публикация глобального плана */
  publishGlobalPlan: GlobalPlan;
  /**
   * Публикует План на параллель по идентификатору Плана на параллель (stage_subject_plans.stage_subject_plan_id)
   * @deprecated Field no longer supported
   */
  publishStagePlan: StagePlan;
  /**
   * Публикация Плана на Ступень для текущей школы(!Идентификатор текущей школы не передается в schoolIds).
   * Копирование и публикация плана на ступень на ДОПОЛНИТЕЛЬНЫЕ школы,
   * если в schoolIds были переданы идентификаторы школ на которые ДОПОЛНИТЕЛЬНО нужно скопировать и опубликовать план на ступень
   */
  publishStudyStepSubjectPlan: StudyStepSubjectPlan;
  /** Удалить пользователей из групп */
  removeUsersFromUserGroups: Array<UserGroup>;
  /** Перепрогон автотестов по новому тегу для всех студентов. Поиск проходит по старому тегу */
  rerunAutotestsWithNewTag: ExcelWithAffectedStudentsModel;
  /**
   * Запуск тестового пайплайна при публикации в гитлабе
   * @deprecated Под удаление. Не используется нигде в проекте. Делалась для пробы интеграции с гитлаб пайплайнамми
   */
  runTrialAutotestsPipelineForTask: GitlabPipeline;
  /** Создание/изменение секции баннеров */
  saveBannerSection: BannerSection;
  /** Сохранение настроек последовательнсти и автопроверки */
  saveCheckSequenceSettings: CheckSequenceSettings;
  /** Сохранение ссылки на общий для системы файл */
  saveCommonFile: Scalars['Boolean']['output'];
  /** Создание/обнавление конфигурации */
  saveConfiguration: Scalars['Boolean']['output'];
  /** Сохранение настроек условий фильтрации для курса (группы проектов) в глобальном плане */
  saveCourseEvaluationRulesForGlobalPlan: Array<EvaluationRuleGroup>;
  /** Сохранение настроек условий фильтрации для курса (группы проектов) в плане на параллель */
  saveCourseEvaluationRulesForStageSubjectPlan: Array<EvaluationRuleGroup>;
  /** Сохранение мета-информации по группе проектов (курсу) */
  saveCourseMeta: CourseMeta;
  /** Сохранение весов за проекты в курсе */
  saveCourseProjectsWeights: CourseGoalsWeights;
  /** Изменение дефолтной аватарки пользователя */
  saveDefaultUserAvatarUrl: Scalars['Boolean']['output'];
  /** Сохранение настроек условий фильтрации для модуля (проекта, цели) в глобальном курсе (группе проектов) */
  saveEvaluationRulesForGlobalCourseGoal: Array<EvaluationRuleGroup>;
  /** Сохранение настроек условий фильтрации для модуля (проекта, цели) в глобальном плане */
  saveEvaluationRulesForGlobalPlan: Array<EvaluationRuleGroup>;
  /** Сохранение настроек условий фильтрации для модуля (проекта, цели) в плане на параллель */
  saveEvaluationRulesForStageSubjectPlan: Array<EvaluationRuleGroup>;
  /** Редактирование глобального курса */
  saveGlobalCourse: GlobalCourse;
  /**
   * сохранение школы
   * schoolId - если null, то создаем новую школу, иначе редактируем
   */
  saveSchool: ValidatedSchool;
  /** Сохранение настроек параллелей */
  saveStageConfigurations: Array<StageConfiguration>;
  /** сохранение/изменение предмета */
  saveSubjects: Array<Subject>;
  /**
   * createUser(user: UserInput!) : User!
   * updateUser(user: UserInput!) : User!
   */
  saveSystemNotification: SystemNotification;
  /** Cохранение настроек команды для модуля (проекта, цели) глобального курса */
  saveTeamSettingsInGlobalCourseGoal: Scalars['Boolean']['output'];
  /** Сохранение параметров команды в модуле глобального плана */
  saveTeamSettingsInGlobalPlanGoal: Scalars['Boolean']['output'];
  /** сохранение/изменение бизнес-пользователя (с ролями БА, СА) */
  saveUser: User;
  sendNotificationAfterSystemUpdate: Scalars['Boolean']['output'];
  /**
   * Изменение статуса Плана на Ступень по ID (study_step_subject_plans.study_step_subject_plan_id)
   * @deprecated Field no longer supported
   */
  setStudyStepPlanStatus: StudyStepSubjectPlan;
  /**
   * Пометить звездой данный проект в gitlab
   * @deprecated Не используется и никогда не использовалось. Делалось в первой версии интеграции с гитлабом. Под удаление
   */
  starGitlabProject: GitlabProject;
  /**
   * Запустить экспортирования проекта в gitlab (формируется ссылка при успешном завершении)
   * @deprecated Не используется и никогда не использовалось. Делалось в первой версии интеграции с гитлабом. Под удаление
   */
  startGitlabProjectExport?: Maybe<GitlabResponseMessage>;
  /** Обновление весов автотестов по заданию */
  updateAutotestWeights: Array<AutotestInfo>;
  updateFunctionalRoleSet: FunctionalRoleSet;
  /** Обновление файла по пути в репозитории gitlab */
  updateGitlabFileAtPath: GitlabFileCreationStatus;
  /** Редактирование глобального плана */
  updateGlobalPlan: GlobalPlan;
  /** Устанавливаем второй фактор при аутентификации пользователя. */
  updateUserSecondFactorAuth: Scalars['Boolean']['output'];
};


export type SystemAdminMutationsAddUsersToUserGroupsArgs = {
  request: ManageUserGroupsInput;
};


export type SystemAdminMutationsArchiveAwardArgs = {
  awardId: Scalars['ID']['input'];
};


export type SystemAdminMutationsArchiveCourseArgs = {
  courseId: Scalars['ID']['input'];
  unarchive?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SystemAdminMutationsChangeGlobalStagePlanArgs = {
  active: Scalars['Boolean']['input'];
  avatarUrl?: InputMaybe<Scalars['String']['input']>;
  deletedFrames: Array<Scalars['ID']['input']>;
  itemId: Scalars['ID']['input'];
  savedFrames: Array<StagePlanFrameInput>;
  stageIds: Array<Scalars['ID']['input']>;
  status: PlanStatusEnum;
  subjectIds: Array<Scalars['ID']['input']>;
  title: Scalars['String']['input'];
};


export type SystemAdminMutationsChangeStagePlanArgs = {
  frames: Array<StagePlanFrameInput>;
  planId: Scalars['ID']['input'];
};


export type SystemAdminMutationsCopyBadgeAwardArgs = {
  awardId: Scalars['ID']['input'];
};


export type SystemAdminMutationsCopyModuleArgs = {
  moduleId: Scalars['ID']['input'];
};


export type SystemAdminMutationsCreateAvatarArgs = {
  avatarInput: AvatarInput;
};


export type SystemAdminMutationsCreateBadgeAwardArgs = {
  badgeInput: BadgeAwardInput;
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
};


export type SystemAdminMutationsCreateFunctionalRoleSetArgs = {
  functionalRoleSetInput: FunctionalRoleSetInput;
};


export type SystemAdminMutationsCreateGitlabFileAtPathArgs = {
  branchName?: InputMaybe<Scalars['String']['input']>;
  commitMessage?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<Scalars['String']['input']>;
  filePath?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
};


export type SystemAdminMutationsCreateGitlabRepositoryTagArgs = {
  branchName?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
  tagName?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminMutationsCreateGlobalPlanArgs = {
  stageId: Scalars['ID']['input'];
};


export type SystemAdminMutationsCreateGlobalStagePlanArgs = {
  avatarUrl?: InputMaybe<Scalars['String']['input']>;
  stageFrames: Array<StagePlanFrameInput>;
  stageIds: Array<Scalars['ID']['input']>;
  status: PlanStatusEnum;
  subjectIds: Array<Scalars['ID']['input']>;
  title: Scalars['String']['input'];
};


export type SystemAdminMutationsCreateNewGitlabProjectArgs = {
  projectName?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminMutationsCreateNewGitlabProjectForUserArgs = {
  projectName?: InputMaybe<Scalars['String']['input']>;
  userId: Scalars['ID']['input'];
};


export type SystemAdminMutationsCreateStagePlanArgs = {
  frames: Array<StagePlanFrameInput>;
  stageSubjectId: Scalars['ID']['input'];
};


export type SystemAdminMutationsDeleteBannerSectionArgs = {
  bannerSectionId: Scalars['ID']['input'];
};


export type SystemAdminMutationsDeleteGitlabFileAtPathArgs = {
  branchName?: InputMaybe<Scalars['String']['input']>;
  commitMessage?: InputMaybe<Scalars['String']['input']>;
  filePath?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
};


export type SystemAdminMutationsDeleteGitlabProjectArgs = {
  projectId: Scalars['ID']['input'];
};


export type SystemAdminMutationsDeleteSchoolArgs = {
  schoolId: Scalars['ID']['input'];
};


export type SystemAdminMutationsDeleteSystemNotificationArgs = {
  id: Scalars['ID']['input'];
};


export type SystemAdminMutationsEditAvatarArgs = {
  avatarId: Scalars['ID']['input'];
  avatarInput: AvatarInput;
};


export type SystemAdminMutationsEditBadgeAwardArgs = {
  awardId: Scalars['ID']['input'];
  badgeAwardInput: BadgeAwardInput;
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
};


export type SystemAdminMutationsEditExperienceLevelRangeArgs = {
  expLevelId: Scalars['ID']['input'];
  rangeInputModel?: InputMaybe<ExperienceLevelRangeInput>;
};


export type SystemAdminMutationsGrantBusinessAdminRoleArgs = {
  schoolId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};


export type SystemAdminMutationsGrantParentRoleArgs = {
  childrenIds: Array<Scalars['UUID']['input']>;
  schoolId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};


export type SystemAdminMutationsGrantStudentRoleArgs = {
  schoolId: Scalars['ID']['input'];
  stageGroupId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};


export type SystemAdminMutationsGrantTeacherRoleArgs = {
  schoolId: Scalars['ID']['input'];
  subjectIds: Array<Scalars['ID']['input']>;
  userId: Scalars['ID']['input'];
};


export type SystemAdminMutationsPublishGitlabContentArgs = {
  dockerImageName?: InputMaybe<Scalars['String']['input']>;
  languages?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  ref?: InputMaybe<Scalars['String']['input']>;
  taskId: Scalars['ID']['input'];
};


export type SystemAdminMutationsPublishGlobalCourseArgs = {
  courseGoalInputModels: Array<GlobalCourseGoalInput>;
  courseId: Scalars['ID']['input'];
  isAutoWeightsSetting?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SystemAdminMutationsPublishGlobalPlanArgs = {
  globalPlanId: Scalars['ID']['input'];
};


export type SystemAdminMutationsPublishStagePlanArgs = {
  stagePlanId: Scalars['ID']['input'];
};


export type SystemAdminMutationsPublishStudyStepSubjectPlanArgs = {
  planId: Scalars['ID']['input'];
  schoolIds?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type SystemAdminMutationsRemoveUsersFromUserGroupsArgs = {
  request: ManageUserGroupsInput;
};


export type SystemAdminMutationsRerunAutotestsWithNewTagArgs = {
  endPeriod: Scalars['DateTime']['input'];
  newTag: Scalars['String']['input'];
  oldTag: Scalars['String']['input'];
  startPeriod: Scalars['DateTime']['input'];
  taskId: Scalars['ID']['input'];
};


export type SystemAdminMutationsRunTrialAutotestsPipelineForTaskArgs = {
  taskId: Scalars['ID']['input'];
};


export type SystemAdminMutationsSaveBannerSectionArgs = {
  bannerSection: BannerSectionInput;
};


export type SystemAdminMutationsSaveCheckSequenceSettingsArgs = {
  checkSequenceSettings: CheckSequenceSettingsInput;
};


export type SystemAdminMutationsSaveCommonFileArgs = {
  commonFile: CommonFileInput;
};


export type SystemAdminMutationsSaveConfigurationArgs = {
  configuration: Array<ConfigurationInput>;
  deletedConfiguration?: InputMaybe<Array<ConfigurationDeleteInput>>;
};


export type SystemAdminMutationsSaveCourseEvaluationRulesForGlobalPlanArgs = {
  conditionType: ConditionType;
  evaluationRules: Array<EvaluationRuleGroupInput>;
  globalPlanCourseId: Scalars['ID']['input'];
};


export type SystemAdminMutationsSaveCourseEvaluationRulesForStageSubjectPlanArgs = {
  conditionType: ConditionType;
  evaluationRules: Array<EvaluationRuleGroupInput>;
  stageSubjectPlanCourseId: Scalars['ID']['input'];
};


export type SystemAdminMutationsSaveCourseMetaArgs = {
  courseMeta: CourseMetaInput;
};


export type SystemAdminMutationsSaveCourseProjectsWeightsArgs = {
  courseId: Scalars['ID']['input'];
  courseProjectsWeights: Array<CourseGoalWeightInput>;
};


export type SystemAdminMutationsSaveDefaultUserAvatarUrlArgs = {
  avatarUrl: Scalars['String']['input'];
};


export type SystemAdminMutationsSaveEvaluationRulesForGlobalCourseGoalArgs = {
  conditionType: ConditionType;
  evaluationRules: Array<EvaluationRuleGroupInput>;
  globalCourseGoalId: Scalars['ID']['input'];
};


export type SystemAdminMutationsSaveEvaluationRulesForGlobalPlanArgs = {
  conditionType: ConditionType;
  evaluationRules: Array<EvaluationRuleGroupInput>;
  globalPlanGoalId: Scalars['ID']['input'];
};


export type SystemAdminMutationsSaveEvaluationRulesForStageSubjectPlanArgs = {
  conditionType: ConditionType;
  evaluationRules: Array<EvaluationRuleGroupInput>;
  stageSubjectPlanGoalId: Scalars['ID']['input'];
};


export type SystemAdminMutationsSaveGlobalCourseArgs = {
  courseGoalInputModels: Array<GlobalCourseGoalInput>;
  courseId: Scalars['ID']['input'];
  isAutoWeightsSetting?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SystemAdminMutationsSaveSchoolArgs = {
  schoolId?: InputMaybe<Scalars['ID']['input']>;
  schoolUpdate: SchoolUpdateInput;
};


export type SystemAdminMutationsSaveStageConfigurationsArgs = {
  stageConfigurations: Array<StageConfigurationInput>;
};


export type SystemAdminMutationsSaveSubjectsArgs = {
  subjects: Array<SubjectInput>;
};


export type SystemAdminMutationsSaveSystemNotificationArgs = {
  systemNotification?: InputMaybe<SystemNotificationInput>;
};


export type SystemAdminMutationsSaveTeamSettingsInGlobalCourseGoalArgs = {
  globalCourseGoalId: Scalars['ID']['input'];
  teamSettings: TeamSettingsInput;
};


export type SystemAdminMutationsSaveTeamSettingsInGlobalPlanGoalArgs = {
  globalPlanGoalId: Scalars['ID']['input'];
  teamSettings: TeamSettingsInput;
};


export type SystemAdminMutationsSaveUserArgs = {
  user: UserInput;
};


export type SystemAdminMutationsSendNotificationAfterSystemUpdateArgs = {
  versionEPS: Scalars['String']['input'];
};


export type SystemAdminMutationsSetStudyStepPlanStatusArgs = {
  planId: Scalars['ID']['input'];
  status: PlanStatusEnum;
};


export type SystemAdminMutationsStarGitlabProjectArgs = {
  projectId: Scalars['ID']['input'];
};


export type SystemAdminMutationsStartGitlabProjectExportArgs = {
  projectId: Scalars['ID']['input'];
};


export type SystemAdminMutationsUpdateAutotestWeightsArgs = {
  autotests: Array<AutotestWithWeightInput>;
  taskId: Scalars['ID']['input'];
};


export type SystemAdminMutationsUpdateFunctionalRoleSetArgs = {
  functionalRoleSet: FunctionalRoleSetInput;
};


export type SystemAdminMutationsUpdateGitlabFileAtPathArgs = {
  branchName?: InputMaybe<Scalars['String']['input']>;
  commitMessage?: InputMaybe<Scalars['String']['input']>;
  content?: InputMaybe<Scalars['String']['input']>;
  filePath?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
};


export type SystemAdminMutationsUpdateGlobalPlanArgs = {
  globalPlanId: Scalars['ID']['input'];
  planGoalInputModels: Array<GlobalPlanGoalInput>;
};


export type SystemAdminMutationsUpdateUserSecondFactorAuthArgs = {
  smsAction?: InputMaybe<UserSecondFactorAuthSmsAction>;
  totpAction?: InputMaybe<UserSecondFactorAuthTotpAction>;
  userId: Scalars['ID']['input'];
};

export type SystemAdminQueries = {
  __typename?: 'SystemAdminQueries';
  /** Проверка наличия привязанных заданий к модулям */
  checkGoalsContainTasks: Scalars['Boolean']['output'];
  /**
   * Получение всех конфигураций с бэкенда
   * @deprecated Have to be removed after ui for parameters with tariff. Remove after a new API version is rolled out that takes into account the Product configurations
   */
  getAllBackendConfigurations: Array<Configuration>;
  /**
   * Получение всех конфигураций для бэкенда сгрупированные по тарифам
   * @deprecated Remove after a new API version is rolled out that takes into account the Product configurations
   */
  getAllBackendConfigurationsByTariff: Array<ConfigurationByTariff>;
  /** Получение всех конфигураций для бэкенда сгрупированные по тарифам */
  getAllBackendConfigurationsByTariffV2: Array<ConfigurationByTariff>;
  /**
   * Получение всех конфигураций с бэкенда для вкладки "Параметры" -> "Дефолтные"
   * @deprecated Remove after a new API version is rolled out that takes into account the Product configurations
   */
  getAllBackendConfigurationsOnDefaultTab: Array<ConfigurationEntity>;
  /** Получение всех конфигураций с бэкенда для вкладки "Параметры" -> "Дефолтные" */
  getAllBackendConfigurationsOnDefaultTabV2: Array<ConfigurationEntity>;
  /**
   * Получение всех конфигураций для бэкенда с учетом тарифов
   * @deprecated Remove after a new API version is rolled out that takes into account the Product configurations
   */
  getAllBackendConfigurationsTariffCompatible: Array<Configuration>;
  /** Получение всех конфигураций для бэкенда с учетом тарифов */
  getAllBackendConfigurationsTariffCompatibleV2: Array<Configuration>;
  /** Получение всех конфигураций с бэкенда */
  getAllBackendConfigurationsV2: Array<Configuration>;
  /** Возвращает все секции баннеров */
  getAllBannerSections: Array<BannerSection>;
  /** Получить всех пользователей данного gitlab проекта */
  getAllGitlabProjectUsers: Array<GitlabUser>;
  /**
   * Возвращает список регионов России
   * @deprecated Запрос для получения всех регионов в UserQueries
   */
  getAllRegions: Array<Region>;
  /** Возвращает список регионов */
  getAllRegionsV2: Array<Region>;
  /** Возвращает все школы (безопасные, без доп.инфы) */
  getAllSafeSchool: Array<SafeSchool>;
  /**
   * Получение build info основного приложения и дополнительных микросервисов
   * @deprecated Field no longer supported
   */
  getApplicationBuildInfos: Array<ApplicationInfo>;
  /** Получение всех тегов за временной промежуток, по которым были запущены пайпалайны по автотестам у студентов по заданию */
  getAutotestTagsByTaskIdInThePeriod: Array<Scalars['String']['output']>;
  /** Получение весов автотестов по заданию */
  getAutotestWeights: Array<AutotestInfo>;
  /** список доступных пермишенов */
  getAvailablePermissions: Array<Scalars['String']['output']>;
  getAvatars: Array<Avatar>;
  /** Получение награды по идентификатору */
  getAwardById: Award;
  /** Доступные награды для выдачи */
  getAwards: Array<Award>;
  /** количество доступных наград для выдачи */
  getAwardsCount: Scalars['Int']['output'];
  /**
   * Получение списка конфигураций c бэкенда по фильтрам для вкладки "Параметры" -> "Региональные"
   * @deprecated Remove after a new API version is rolled out that takes into account the Product configurations
   */
  getBackendConfigurationsByFiltersOnRegionalTab: Array<ConfigurationEntity>;
  /** Получение списка конфигураций c бэкенда по фильтрам для вкладки "Параметры" -> "Региональные" */
  getBackendConfigurationsByFiltersOnRegionalTabV2: Array<ConfigurationEntity>;
  getBadges: Array<Badge>;
  /** Возвращает секцию баннеров по ID */
  getBannerSectionById: BannerSection;
  /** Возвращает справочную информацию по секциям баннеров */
  getBannerSectionInfo: Array<BannerSectionInfo>;
  /** Возвращает здания c кабинетами по идентификатору школы, необходимо для определения предпочитаемых кабинетов учителя */
  getBuildingsBySchoolId: Array<Building>;
  /** Получение текущих настроек */
  getCheckSequenceSettings: CheckSequenceSettings;
  /**
   * Информация о студентах на плане кластера
   * @deprecated do not use. Will be deleted in 29.0
   */
  getClusterPlanStudents: ClusterPlanStudents;
  /** получение файлов (общих для системы) */
  getCommonFiles: Array<CommonFile>;
  /**
   * Получение всех запрошенных конфигураций.
   * @deprecated Have to be removed after ui for parameters with tariff. Remove after a new API version is rolled out that takes into account the Product configurations
   */
  getConfigurations: Array<Configuration>;
  /**
   * Получение всех запрошенных конфигураций сгруппированые по тарифам
   * @deprecated Remove after a new API version is rolled out that takes into account the Product configurations
   */
  getConfigurationsByTariff: Array<ConfigurationByTariff>;
  /** Получение всех запрошенных конфигураций сгруппированые по тарифам */
  getConfigurationsByTariffV2: Array<ConfigurationByTariff>;
  /**
   * Получение всех запрошенных конфигураций c учетом тарифов
   * @deprecated Remove after a new API version is rolled out that takes into account the Product configurations
   */
  getConfigurationsTariffCompatible: Array<Configuration>;
  /** Получение всех запрошенных конфигураций c учетом тарифов */
  getConfigurationsTariffCompatibleV2: Array<Configuration>;
  /** Получение всех запрошенных конфигураций. */
  getConfigurationsV2: Array<Configuration>;
  /** Получение атрибутов консистентности группы проектов (курса) */
  getCourseConsistencyInfo: CourseMeta;
  /** Получение мета-информации о группе проектов (курсе) */
  getCourseMeta: CourseMeta;
  /** Получение сохраненных весов и XP за проекты в курсе */
  getCourseProjectsWeights: CourseGoalsWeights;
  /** Получение курсов с учетом фильтров */
  getCourses: CourseSearchResult;
  /** Получение истории изменения опыта */
  getExperienceHistoryDate: UserExperienceHistoryDate;
  /** Получение данных о количестве P2P проверок и средней оценке пользователя как ревьюера */
  getFeedbackStatisticsAverageScore: FeedbackStatisticsAverageScore;
  /** Профиль доступа */
  getFunctionalRoleSet: FunctionalRoleSet;
  /** список доступных профилей доступа */
  getFunctionalRoleSets: Array<FunctionalRoleSet>;
  /** Количество доступных профилей доступа */
  getFunctionalRoleSetsCount: Scalars['Int']['output'];
  /** список функциоальных ролей по ролям и школам */
  getFunctionalRoles: Array<FunctionalRole>;
  /** Возвращает список функциональных ролей по фильтру */
  getFunctionalRolesByFilter: Array<FunctionalRole>;
  /** Количество доступных функциональных ролей по фильтру */
  getFunctionalRolesByFilterCount: Scalars['Int']['output'];
  /**
   * список функциоальных ролей по оргструктуре
   * @deprecated Использовать getFunctionalRolesByFilter
   */
  getFunctionalRolesByOrgUnitIds: Array<FunctionalRole>;
  /** Получение активной версии контента проекта в гитлабе */
  getGitlabActiveProjectVersion: Scalars['String']['output'];
  /** Получение всех docker образов с автотестами в gitlab */
  getGitlabDockerImagesForAutoQA: Array<GitlabDockerImage>;
  /** Получение файла из репозитория gitlab */
  getGitlabFileFromRepository?: Maybe<GitlabFile>;
  /** Получение всех темплейтов файлов по типу */
  getGitlabFileTemplates: Array<GitlabFileTemplate>;
  /** Получение всех доступных языков для публикации */
  getGitlabLanguagesToPublish: Array<Scalars['String']['output']>;
  /** Получение ссылки на мастер проект в гитлабе */
  getGitlabMasterProjectLink: GitlabLink;
  /**
   * Получить экспорт проекта из gitlab (с сформированными ссылками на download)
   * @deprecated Не используется и никогда не использовалась. Делалась в первой версии интеграции с гитлабом. Под удаление
   */
  getGitlabProjectExport?: Maybe<GitlabProject>;
  /** Получить все форки данного gitlab проекта */
  getGitlabProjectForks: Array<GitlabProject>;
  /**
   * Получение списка проектов из gitlab
   * @deprecated Слишком тяжеловесная кваря - не используется. Под удаление.
   */
  getGitlabProjects: Array<GitlabProject>;
  /** Получение всех тэгов из репозитория gitlab */
  getGitlabRepositoryTags: Array<GitlabRepositoryTag>;
  /** Получение ссылки на студенческий проект в гитлабе */
  getGitlabStudentProjectLink: GitlabLink;
  /** Возвращает глобальный курс по идентификатору */
  getGlobalCourse: GlobalCourse;
  /** Возвращает глобальный план по идентификатору */
  getGlobalPlan: GlobalPlan;
  /**
   * Возвращает все существующие глобальные планы Ш21, если includeExternalLearningPlans = false или NULL
   * Если includeExternalLearningPlans = true, то возвращает планы Конкурсов и Обучения учителей
   */
  getGlobalPlans: Array<GlobalPlan>;
  /** Возвращает глобальный план по идентификатору */
  getGlobalStagePlan: GlobalStagePlan;
  /** Получение base64 excel со списком студентов, на которых повлияет перепубликация контента из гита */
  getListOfAffectedStudentsByReImport: ExcelWithAffectedStudentsModel;
  /** возвращает всех тенанты уровня типа продукт */
  getProductLevelTenants: Array<School>;
  /** Получение рекомендуемого кол-ва дней на  учебный модуь в соотношении (Идентификатор цели, кол-во дне на  учебный модуь) */
  getRecommendedDurationForModules: Array<GoalDurationMap>;
  getSafeSchoolsByIds: Array<SafeSchool>;
  getSchool: School;
  getSchools: Array<School>;
  getSchoolsCount: Scalars['Int']['output'];
  getSchoolsCountWithStudyStepSubjects: Scalars['Int']['output'];
  getSchoolsOfSchool21: Array<School>;
  getSchoolsOfSchool21Count: Scalars['Int']['output'];
  /** получение списка школ с входящими планами на ступень с входящими предметами по параллелям */
  getSchoolsWithStageSubjects: Array<School>;
  /** получение списка школ с входящими планами на ступень */
  getSchoolsWithStudyStepSubjects: Array<School>;
  /** Список мягких навыков */
  getSoftSkillTypes: Array<SoftSkillType>;
  /** Получить список пользователей-сотрудников с полномочиями администраторов */
  getStaff: Array<Maybe<User>>;
  /** Количество записей для запроса getStaff */
  getStaffCount: Scalars['Int']['output'];
  getStageById: Stage;
  getStageConfigurations: Array<StageConfiguration>;
  /**
   * S21. Публичный профиль студента. Получение всех волн (аналог stage_group_name) и форм обучения (аналог stage_name) по StudentId
   * @deprecated use school21 query
   */
  getStageGroupsS21PublicProfile?: Maybe<Array<Maybe<StageGroupS21>>>;
  getStagePlansByIds: Array<StagePlan>;
  getStages: Array<Stage>;
  /** Получение всех проектов по userId и stageGroupId */
  getStudentProjectsByStageGroup: Array<Maybe<StudentItem>>;
  /** Получить список пользователей-студентов */
  getStudents: Array<Maybe<User>>;
  /** Количество записей для запроса getStudents */
  getStudentsCount: Scalars['Int']['output'];
  /** Возвращает школу с Планами на ступень по идентфиикатору Школы */
  getStudyStepPlansBySchoolId: School;
  getSubjects?: Maybe<Array<Subject>>;
  getSubjectsByIds: Array<Subject>;
  /** Получение списка предметов в соответствии с признаком видимости (берется из конфигурации: глобальный, локальный для данного ОУ, все предметы) */
  getSubjectsByOrgUnitId: Array<Subject>;
  /** Получение системного уведомления */
  getSystemNotification: SystemNotification;
  /** Получение списка системных уведомлений глобальных (плашка) */
  getSystemNotificationsCommon: Array<SystemNotification>;
  /** Получение количества системных уведомлений для текущей школы, включая плашку */
  getSystemNotificationsCountWithCommon: Scalars['Int']['output'];
  /** Получение количество системных уведомлений для текущей школы без плашки */
  getSystemNotificationsCountWithoutCommon: Scalars['Int']['output'];
  /** Получение списка системных уведомлений для текущей школы на период, включая системные */
  getSystemNotificationsForPeriodWithCommon: Array<SystemNotification>;
  /** Получение списка системных уведомлений для текущей школы на период без системных */
  getSystemNotificationsForPeriodWithoutCommon: Array<SystemNotification>;
  /** Получение списка системных уведомлений для текущей школы, включая плашку */
  getSystemNotificationsWithCommon: Array<SystemNotification>;
  /** Получение списка системных уведомлений для текущей школы без плашки */
  getSystemNotificationsWithoutCommon: Array<SystemNotification>;
  /** Получение флага опубликованности контента по данному заданию */
  getTaskContentImportFlag: Scalars['Boolean']['output'];
  /** Запрос настроек команды для модуля (проекта, цели) в глобальном курсе (группе проектов) */
  getTeamSettingsFromGlobalCourseGoal?: Maybe<TeamSettings>;
  /** Запрос настроек команды для модуля из глобального плана */
  getTeamSettingsFromGlobalPlanGoal?: Maybe<TeamSettings>;
  /** получение тенанта, id которого передан в хэдере запроса "tenantId", для отображения его полей на UI */
  getTenant?: Maybe<School>;
  /** получение тенанта пользователя с функциональной ролью "СА тенанта", "userId" которого передан в параметре метода */
  getTenantOfUserWithSaTenantFunctionalRoleByUserId?: Maybe<School>;
  /** возвращает всех тенантов (пока это тип School) */
  getTenants: Array<School>;
  /** возвращает список тенантов */
  getTenantsList: Array<Maybe<School>>;
  /**
   * возвращает список тенантов
   * @deprecated Использовать запрос getTenants:[School]!. Под удаление.
   */
  getTenantsOfProductAndGlobalLevels: Array<Maybe<School>>;
  /** получить пользователя с ролями (только СА, БА), статусами и ролеспецифичными данными. */
  getUser: User;
  /** Запрос истории получения ачивки */
  getUserAwardHistoryByAwardId: Array<UserAwardHistory>;
  getUserAwardHistoryByAwardIdCount: Scalars['Int']['output'];
  /** Запрос истории получения ачивки c возможностью сортировать по awardDate */
  getUserAwardHistoryByAwardIdV2: Array<UserAwardHistory>;
  /** получить информацию об настроенных типах аутентификации пользователя */
  getUserCredentialsInfo: UserCredentialsInfo;
  /**
   * получить список пользователей с ролями, статусами и ролеспецифичными данными.
   * Фильтры: роли - только СА, БА
   */
  getUsers: Array<Maybe<User>>;
  /** количество записей для getUsers */
  getUsersCount: Scalars['Int']['output'];
  /** Получить список пользователей с фильтрацией по профилям доступа */
  getUsersV2: Array<Maybe<User>>;
  /** количество записей для getUsersV2 */
  getUsersV2Count: Scalars['Int']['output'];
  /** Проверка было ли задание прогнано на автотесты для студентов В прошедшие 6 месяцев */
  isTaskAutotestedInLastSixMonths: Scalars['Boolean']['output'];
  /** Запрос настроек условий заданного типа для курса (группы проектов) в плане на параллель */
  loadCourseEvaluationRuleGroupsFromStageSubjectPlan: EvaluationRuleGroupsWithEquivalentFlag;
  /** Запрос настроек условий заданного типа для курса (группы проектов) в глобальном плане */
  loadCourseEvaluationRulesFromGlobalPlan: Array<EvaluationRuleGroup>;
  loadDictsForChecklist: TaskContentAggregationResponse;
  /** Получение списка правил для конструктора курсов */
  loadEvaluationCourseRuleFieldOptions: Array<EvaluationRuleFieldOption>;
  /** Запрос списка всех доступных условий заданного типа */
  loadEvaluationRuleFieldOptions: Array<EvaluationRuleFieldOption>;
  /** Запрос настроек условий заданного типа для модуля (проекта, цели) в плане на параллель */
  loadTaskEvaluationRuleGroupsFromStageSubjectPlan: EvaluationRuleGroupsWithEquivalentFlag;
  /** Запрос настроек условий заданного типа для модуля (проекта, цели) в глобальном курсе (группе проектов) */
  loadTaskEvaluationRulesFromGlobalCourse: Array<EvaluationRuleGroup>;
  /** Запрос настроек условий заданного типа для модуля (проекта, цели) в глобальном плане */
  loadTaskEvaluationRulesFromGlobalPlan: Array<EvaluationRuleGroup>;
  /**
   * Запрос настроек условий заданного типа для плана на параллель
   * @deprecated Использовать запрос loadTaskEvaluationRuleGroupsFromStageSubjectPlan. Под удаление.
   */
  loadTaskEvaluationRulesFromStageSubjectPlan: Array<EvaluationRuleGroup>;
  /** Поиск тегов. В поле тег записывается тег или его часть по которому делается поиск. По умолчанию пустая строка */
  searchTags: Array<Scalars['String']['output']>;
};


export type SystemAdminQueriesCheckGoalsContainTasksArgs = {
  goalIds: Array<InputMaybe<Scalars['ID']['input']>>;
};


export type SystemAdminQueriesGetAllBackendConfigurationsArgs = {
  entityIdList: Array<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type SystemAdminQueriesGetAllBackendConfigurationsByTariffArgs = {
  entityIdList: Array<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type SystemAdminQueriesGetAllBackendConfigurationsByTariffV2Args = {
  entityId: Scalars['String']['input'];
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type SystemAdminQueriesGetAllBackendConfigurationsOnDefaultTabArgs = {
  entityIdList: Array<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type SystemAdminQueriesGetAllBackendConfigurationsOnDefaultTabV2Args = {
  entityId: Scalars['String']['input'];
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type SystemAdminQueriesGetAllBackendConfigurationsTariffCompatibleArgs = {
  entityIdList: Array<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type SystemAdminQueriesGetAllBackendConfigurationsTariffCompatibleV2Args = {
  entityId: Scalars['String']['input'];
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type SystemAdminQueriesGetAllBackendConfigurationsV2Args = {
  entityId: Scalars['String']['input'];
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type SystemAdminQueriesGetAllBannerSectionsArgs = {
  schoolId?: InputMaybe<Scalars['ID']['input']>;
  stageId?: InputMaybe<Scalars['ID']['input']>;
};


export type SystemAdminQueriesGetAllGitlabProjectUsersArgs = {
  projectId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetAllSafeSchoolArgs = {
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  organizationType?: InputMaybe<OrganizationType>;
};


export type SystemAdminQueriesGetAutotestTagsByTaskIdInThePeriodArgs = {
  endPeriod: Scalars['DateTime']['input'];
  startPeriod: Scalars['DateTime']['input'];
  taskId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetAutotestWeightsArgs = {
  taskId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetAwardByIdArgs = {
  awardId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetAwardsArgs = {
  assignmentTypeId?: InputMaybe<Scalars['Int']['input']>;
  awardName?: InputMaybe<Scalars['String']['input']>;
  badgeKindTypeId?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<PagingInput>;
  schoolId?: InputMaybe<Scalars['ID']['input']>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
};


export type SystemAdminQueriesGetAwardsCountArgs = {
  assignmentTypeId?: InputMaybe<Scalars['Int']['input']>;
  awardName?: InputMaybe<Scalars['String']['input']>;
  badgeKindTypeId?: InputMaybe<Scalars['Int']['input']>;
  schoolId?: InputMaybe<Scalars['ID']['input']>;
};


export type SystemAdminQueriesGetBackendConfigurationsByFiltersOnRegionalTabArgs = {
  configurationFilterInput?: InputMaybe<ConfigurationFilterInput>;
};


export type SystemAdminQueriesGetBackendConfigurationsByFiltersOnRegionalTabV2Args = {
  configurationFilterInput?: InputMaybe<ConfigurationFilterInput>;
};


export type SystemAdminQueriesGetBannerSectionByIdArgs = {
  bannerSectionId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetBannerSectionInfoArgs = {
  bannerSectionCode?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminQueriesGetBuildingsBySchoolIdArgs = {
  schoolId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetCheckSequenceSettingsArgs = {
  taskId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetConfigurationsArgs = {
  entityIdList: Array<Scalars['ID']['input']>;
  frontConfigurationInput: Array<FrontConfigurationInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type SystemAdminQueriesGetConfigurationsByTariffArgs = {
  entityIdList: Array<Scalars['ID']['input']>;
  frontConfigurationInput: Array<FrontConfigurationInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type SystemAdminQueriesGetConfigurationsByTariffV2Args = {
  entityId: Scalars['String']['input'];
  frontConfigurationInput: Array<FrontConfigurationInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type SystemAdminQueriesGetConfigurationsTariffCompatibleArgs = {
  entityIdList: Array<Scalars['ID']['input']>;
  frontConfigurationInput: Array<FrontConfigurationInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type SystemAdminQueriesGetConfigurationsTariffCompatibleV2Args = {
  entityId: Scalars['String']['input'];
  frontConfigurationInput: Array<FrontConfigurationInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type SystemAdminQueriesGetConfigurationsV2Args = {
  entityId: Scalars['String']['input'];
  frontConfigurationInput: Array<FrontConfigurationInput>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type SystemAdminQueriesGetCourseConsistencyInfoArgs = {
  courseId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetCourseMetaArgs = {
  courseId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetCourseProjectsWeightsArgs = {
  courseId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetCoursesArgs = {
  courseType?: InputMaybe<CourseType>;
  filterExceptCourses?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  name?: InputMaybe<Scalars['String']['input']>;
  paging?: InputMaybe<PagingInput>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
};


export type SystemAdminQueriesGetExperienceHistoryDateArgs = {
  schoolId?: InputMaybe<Scalars['ID']['input']>;
  userId: Scalars['UUID']['input'];
};


export type SystemAdminQueriesGetFeedbackStatisticsAverageScoreArgs = {
  studentId: Scalars['UUID']['input'];
};


export type SystemAdminQueriesGetFunctionalRoleSetArgs = {
  functionalRoleSetId: Scalars['UUID']['input'];
};


export type SystemAdminQueriesGetFunctionalRoleSetsArgs = {
  filterFunctionalRoleNames?: InputMaybe<Array<Scalars['String']['input']>>;
  filterFunctionalRoleSetNames?: InputMaybe<Array<Scalars['String']['input']>>;
  paging?: InputMaybe<PagingInput>;
  sortingFields?: InputMaybe<Array<SortingField>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminQueriesGetFunctionalRoleSetsCountArgs = {
  filterFunctionalRoleNames?: InputMaybe<Array<Scalars['String']['input']>>;
  filterFunctionalRoleSetNames?: InputMaybe<Array<Scalars['String']['input']>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminQueriesGetFunctionalRolesArgs = {
  request: Array<SchoolFunctionalRoleInput>;
};


export type SystemAdminQueriesGetFunctionalRolesByFilterArgs = {
  applicableRole?: InputMaybe<Scalars['String']['input']>;
  isScopeGlobal?: InputMaybe<Scalars['Boolean']['input']>;
  isScopeProduct?: InputMaybe<Scalars['Boolean']['input']>;
  isScopeSchool?: InputMaybe<Scalars['Boolean']['input']>;
  orgUnitIds: Array<Scalars['ID']['input']>;
  paging?: InputMaybe<PagingInput>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminQueriesGetFunctionalRolesByFilterCountArgs = {
  applicableRole?: InputMaybe<Scalars['String']['input']>;
  isScopeGlobal?: InputMaybe<Scalars['Boolean']['input']>;
  isScopeProduct?: InputMaybe<Scalars['Boolean']['input']>;
  isScopeSchool?: InputMaybe<Scalars['Boolean']['input']>;
  orgUnitIds: Array<Scalars['ID']['input']>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminQueriesGetFunctionalRolesByOrgUnitIdsArgs = {
  orgUnitIds: Array<Scalars['ID']['input']>;
};


export type SystemAdminQueriesGetGitlabActiveProjectVersionArgs = {
  taskId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetGitlabFileFromRepositoryArgs = {
  branchName?: InputMaybe<Scalars['String']['input']>;
  filePath?: InputMaybe<Scalars['String']['input']>;
  projectId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetGitlabFileTemplatesArgs = {
  projectId: Scalars['ID']['input'];
  templateType: TemplateType;
};


export type SystemAdminQueriesGetGitlabLanguagesToPublishArgs = {
  ref: Scalars['String']['input'];
  taskId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetGitlabMasterProjectLinkArgs = {
  taskId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetGitlabProjectExportArgs = {
  projectId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetGitlabProjectForksArgs = {
  projectId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetGitlabRepositoryTagsArgs = {
  taskId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetGitlabStudentProjectLinkArgs = {
  taskId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetGlobalCourseArgs = {
  globalCourseId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetGlobalPlanArgs = {
  globalPlanId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetGlobalPlansArgs = {
  includeExternalLearningPlans?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SystemAdminQueriesGetGlobalStagePlanArgs = {
  itemId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetListOfAffectedStudentsByReImportArgs = {
  taskId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetRecommendedDurationForModulesArgs = {
  goalIds: Array<Scalars['ID']['input']>;
  stageSubjectId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetSafeSchoolsByIdsArgs = {
  ids: Array<Scalars['UUID']['input']>;
};


export type SystemAdminQueriesGetSchoolArgs = {
  schoolId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetSchoolsArgs = {
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  paging?: InputMaybe<PagingInput>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminQueriesGetSchoolsCountArgs = {
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminQueriesGetSchoolsCountWithStudyStepSubjectsArgs = {
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminQueriesGetSchoolsOfSchool21Args = {
  includingProduct?: InputMaybe<Scalars['Boolean']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  paging?: InputMaybe<PagingInput>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminQueriesGetSchoolsOfSchool21CountArgs = {
  includingProduct?: InputMaybe<Scalars['Boolean']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminQueriesGetSchoolsWithStudyStepSubjectsArgs = {
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  paging?: InputMaybe<PagingInput>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminQueriesGetSoftSkillTypesArgs = {
  isArchive?: InputMaybe<Scalars['Boolean']['input']>;
  sortingFields?: InputMaybe<Array<SortingField>>;
};


export type SystemAdminQueriesGetStaffArgs = {
  creationDateTimeEnd?: InputMaybe<Scalars['DateTime']['input']>;
  creationDateTimeStart?: InputMaybe<Scalars['DateTime']['input']>;
  entityIds?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  filterBlockedAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  filterIsAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  filterNoFroleSet?: InputMaybe<Scalars['Boolean']['input']>;
  froleSetIds?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  paging?: InputMaybe<PagingInput>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminQueriesGetStaffCountArgs = {
  creationDateTimeEnd?: InputMaybe<Scalars['DateTime']['input']>;
  creationDateTimeStart?: InputMaybe<Scalars['DateTime']['input']>;
  entityIds?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  filterBlockedAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  filterIsAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  filterNoFroleSet?: InputMaybe<Scalars['Boolean']['input']>;
  froleSetIds?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminQueriesGetStageByIdArgs = {
  stageId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetStageConfigurationsArgs = {
  isSchool21?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SystemAdminQueriesGetStageGroupsS21PublicProfileArgs = {
  studentId: Scalars['UUID']['input'];
};


export type SystemAdminQueriesGetStagePlansByIdsArgs = {
  ids: Array<Scalars['ID']['input']>;
};


export type SystemAdminQueriesGetStagesArgs = {
  isSchool21?: InputMaybe<Scalars['Boolean']['input']>;
};


export type SystemAdminQueriesGetStudentProjectsByStageGroupArgs = {
  stageGroupId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type SystemAdminQueriesGetStudentsArgs = {
  creationDateTimeEnd?: InputMaybe<Scalars['DateTime']['input']>;
  creationDateTimeStart?: InputMaybe<Scalars['DateTime']['input']>;
  filterBlockedStudents?: InputMaybe<Scalars['Boolean']['input']>;
  filterExpellingStudents?: InputMaybe<Scalars['Boolean']['input']>;
  filterFreezingStudents?: InputMaybe<Scalars['Boolean']['input']>;
  filterInactiveStudents?: InputMaybe<Scalars['Boolean']['input']>;
  filterNoFroleSet?: InputMaybe<Scalars['Boolean']['input']>;
  filterSchools?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterStageGroups?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterStages?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  paging?: InputMaybe<PagingInput>;
  restrictDateEnd?: InputMaybe<Scalars['DateTime']['input']>;
  restrictDateStart?: InputMaybe<Scalars['DateTime']['input']>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminQueriesGetStudentsCountArgs = {
  creationDateTimeEnd?: InputMaybe<Scalars['DateTime']['input']>;
  creationDateTimeStart?: InputMaybe<Scalars['DateTime']['input']>;
  filterBlockedStudents?: InputMaybe<Scalars['Boolean']['input']>;
  filterExpellingStudents?: InputMaybe<Scalars['Boolean']['input']>;
  filterFreezingStudents?: InputMaybe<Scalars['Boolean']['input']>;
  filterInactiveStudents?: InputMaybe<Scalars['Boolean']['input']>;
  filterNoFroleSet?: InputMaybe<Scalars['Boolean']['input']>;
  filterSchools?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterStageGroups?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterStages?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  restrictDateEnd?: InputMaybe<Scalars['DateTime']['input']>;
  restrictDateStart?: InputMaybe<Scalars['DateTime']['input']>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminQueriesGetStudyStepPlansBySchoolIdArgs = {
  schoolId: Scalars['UUID']['input'];
};


export type SystemAdminQueriesGetSubjectsArgs = {
  organizationHierarchyTypes: Array<InputMaybe<OrganizationHierarchyType>>;
};


export type SystemAdminQueriesGetSubjectsByIdsArgs = {
  ids: Array<Scalars['ID']['input']>;
};


export type SystemAdminQueriesGetSubjectsByOrgUnitIdArgs = {
  orgUnitId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetSystemNotificationArgs = {
  id: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetSystemNotificationsCommonArgs = {
  paging?: InputMaybe<PagingInput>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminQueriesGetSystemNotificationsCountWithCommonArgs = {
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminQueriesGetSystemNotificationsCountWithoutCommonArgs = {
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminQueriesGetSystemNotificationsForPeriodWithCommonArgs = {
  endDate: Scalars['String']['input'];
  startDate: Scalars['String']['input'];
};


export type SystemAdminQueriesGetSystemNotificationsForPeriodWithoutCommonArgs = {
  endDate: Scalars['String']['input'];
  startDate: Scalars['String']['input'];
};


export type SystemAdminQueriesGetSystemNotificationsWithCommonArgs = {
  paging?: InputMaybe<PagingInput>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminQueriesGetSystemNotificationsWithoutCommonArgs = {
  paging?: InputMaybe<PagingInput>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminQueriesGetTaskContentImportFlagArgs = {
  taskId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetTeamSettingsFromGlobalCourseGoalArgs = {
  globalCourseGoalId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetTeamSettingsFromGlobalPlanGoalArgs = {
  globalPlanGoalId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetTenantOfUserWithSaTenantFunctionalRoleByUserIdArgs = {
  userId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetTenantsArgs = {
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  paging?: InputMaybe<PagingInput>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminQueriesGetUserArgs = {
  userId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetUserAwardHistoryByAwardIdArgs = {
  awardId: Scalars['ID']['input'];
  login?: InputMaybe<Scalars['String']['input']>;
  paging: PagingInput;
};


export type SystemAdminQueriesGetUserAwardHistoryByAwardIdCountArgs = {
  awardId: Scalars['ID']['input'];
  login?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminQueriesGetUserAwardHistoryByAwardIdV2Args = {
  awardId: Scalars['ID']['input'];
  login?: InputMaybe<Scalars['String']['input']>;
  paging: PagingInput;
  sortingFields: Array<SortingField>;
};


export type SystemAdminQueriesGetUserCredentialsInfoArgs = {
  userId: Scalars['ID']['input'];
};


export type SystemAdminQueriesGetUsersArgs = {
  birthdayEnd?: InputMaybe<Scalars['Date']['input']>;
  birthdayStart?: InputMaybe<Scalars['Date']['input']>;
  creationDateTimeEnd?: InputMaybe<Scalars['DateTime']['input']>;
  creationDateTimeStart?: InputMaybe<Scalars['DateTime']['input']>;
  dismissDateEnd?: InputMaybe<Scalars['DateTime']['input']>;
  dismissDateStart?: InputMaybe<Scalars['DateTime']['input']>;
  dismissTypeId?: InputMaybe<Scalars['Int']['input']>;
  entityIds?: InputMaybe<Array<Scalars['String']['input']>>;
  filterConfiguredUsers?: InputMaybe<Scalars['Boolean']['input']>;
  filterRoleStatus?: InputMaybe<RoleStatus>;
  filterRoles?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filterSchools?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterStageGroups?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterSubjects?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterUserStatus?: InputMaybe<UserStatus>;
  froleSetIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
  graduationDateTimeEnd?: InputMaybe<Scalars['DateTime']['input']>;
  graduationDateTimeStart?: InputMaybe<Scalars['DateTime']['input']>;
  paging?: InputMaybe<PagingInput>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminQueriesGetUsersCountArgs = {
  birthdayEnd?: InputMaybe<Scalars['Date']['input']>;
  birthdayStart?: InputMaybe<Scalars['Date']['input']>;
  creationDateTimeEnd?: InputMaybe<Scalars['DateTime']['input']>;
  creationDateTimeStart?: InputMaybe<Scalars['DateTime']['input']>;
  dismissDateEnd?: InputMaybe<Scalars['DateTime']['input']>;
  dismissDateStart?: InputMaybe<Scalars['DateTime']['input']>;
  dismissTypeId?: InputMaybe<Scalars['Int']['input']>;
  entityIds?: InputMaybe<Array<Scalars['String']['input']>>;
  filterConfiguredUsers?: InputMaybe<Scalars['Boolean']['input']>;
  filterRoleStatus?: InputMaybe<RoleStatus>;
  filterRoles?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filterSchools?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterStageGroups?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterSubjects?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterUserStatus?: InputMaybe<UserStatus>;
  froleSetIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
  graduationDateTimeEnd?: InputMaybe<Scalars['DateTime']['input']>;
  graduationDateTimeStart?: InputMaybe<Scalars['DateTime']['input']>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminQueriesGetUsersV2Args = {
  filterFroleSets?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  filterNonConfiguredUsers?: InputMaybe<Scalars['Boolean']['input']>;
  filterSchools?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  paging?: InputMaybe<PagingInput>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminQueriesGetUsersV2CountArgs = {
  filterFroleSets?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  filterNonConfiguredUsers?: InputMaybe<Scalars['Boolean']['input']>;
  filterSchools?: InputMaybe<Array<InputMaybe<Scalars['UUID']['input']>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type SystemAdminQueriesIsTaskAutotestedInLastSixMonthsArgs = {
  taskId: Scalars['ID']['input'];
};


export type SystemAdminQueriesLoadCourseEvaluationRuleGroupsFromStageSubjectPlanArgs = {
  conditionType: ConditionType;
  stageSubjectPlanCourseId: Scalars['ID']['input'];
};


export type SystemAdminQueriesLoadCourseEvaluationRulesFromGlobalPlanArgs = {
  conditionType: ConditionType;
  globalPlanCourseId: Scalars['ID']['input'];
};


export type SystemAdminQueriesLoadEvaluationCourseRuleFieldOptionsArgs = {
  planGoalId?: InputMaybe<Scalars['ID']['input']>;
  planTypeForCondition?: InputMaybe<PlanTypeForCondition>;
};


export type SystemAdminQueriesLoadEvaluationRuleFieldOptionsArgs = {
  conditionType: ConditionType;
  courseGoalId?: InputMaybe<Scalars['ID']['input']>;
  planGoalId?: InputMaybe<Scalars['ID']['input']>;
  planTypeForCondition?: InputMaybe<PlanTypeForCondition>;
};


export type SystemAdminQueriesLoadTaskEvaluationRuleGroupsFromStageSubjectPlanArgs = {
  conditionType: ConditionType;
  stageSubjectPlanGoalId: Scalars['ID']['input'];
};


export type SystemAdminQueriesLoadTaskEvaluationRulesFromGlobalCourseArgs = {
  conditionType: ConditionType;
  globalCourseGoalId: Scalars['ID']['input'];
};


export type SystemAdminQueriesLoadTaskEvaluationRulesFromGlobalPlanArgs = {
  conditionType: ConditionType;
  globalPlanGoalId: Scalars['ID']['input'];
};


export type SystemAdminQueriesLoadTaskEvaluationRulesFromStageSubjectPlanArgs = {
  conditionType: ConditionType;
  stageSubjectPlanGoalId: Scalars['ID']['input'];
};


export type SystemAdminQueriesSearchTagsArgs = {
  limit: Scalars['Int']['input'];
  offset: Scalars['Int']['input'];
  tag: Scalars['String']['input'];
};

export type SystemAdminRole = {
  __typename?: 'SystemAdminRole';
  /** дата деактивации роли */
  dateEnd?: Maybe<Scalars['DateTime']['output']>;
  /** дата активации роли */
  dateStart?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  /** является ли роль дефолтной при входе пользователя в приложение */
  isDefault: Scalars['Boolean']['output'];
  orgUnitId?: Maybe<Scalars['ID']['output']>;
  productId?: Maybe<Scalars['ID']['output']>;
  /** название роли */
  role: Roles;
  status: RoleStatus;
  /**
   * тенант
   * @deprecated Сисадмин всегда привязан к корневому узлу иерархии
   */
  tenantId?: Maybe<Scalars['ID']['output']>;
};

export type SystemAdminRoleInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  status?: InputMaybe<RoleStatus>;
  temporaryRoleInput?: InputMaybe<TemporaryRoleInput>;
  tenantId?: InputMaybe<Scalars['ID']['input']>;
};

export type SystemError = {
  __typename?: 'SystemError';
  /** ссылка на архив с информацией */
  archiveUrl?: Maybe<Scalars['String']['output']>;
  /** браузер */
  browser: Scalars['String']['output'];
  /** дата создания */
  createTs: Scalars['Date']['output'];
  /** сообщение об исключении */
  exceptionMessage: Scalars['String']['output'];
  /** stackTrace */
  exceptionStacktrace?: Maybe<Scalars['String']['output']>;
  /** Уникальный бизнесовый тип ошибки */
  exceptionType: Scalars['String']['output'];
  /** уникальный идентификатор исключения */
  exceptionUniqueCode?: Maybe<Scalars['UUID']['output']>;
  /** комментарий исполнителя */
  executorComment?: Maybe<Scalars['String']['output']>;
  /** ID ошибки */
  id: Scalars['ID']['output'];
  /** логин пользователя */
  login?: Maybe<Scalars['String']['output']>;
  /** метод в котором произошла ошибка */
  method: Scalars['String']['output'];
  /** версия приложения */
  routeInfo?: Maybe<Scalars['String']['output']>;
  /** id школы */
  schoolId?: Maybe<Scalars['UUID']['output']>;
  /** Статус ошибки */
  status: ComplaintAndSystemErrorStatus;
  /** тип исключения */
  systemErrorType: SystemErrorType;
  /** версия системы */
  systemVersion: Scalars['String']['output'];
  /** url страницы, на которой произошла ошибка */
  targetPageUrl: Scalars['String']['output'];
  /** Пользователь, у которого произошла ошибка */
  user?: Maybe<User>;
};

export type SystemErrorInput = {
  /** ссылка на архив с информацией */
  archiveUrl: Scalars['String']['input'];
  /** браузер */
  browser: Scalars['String']['input'];
  /** сообщение об исключении */
  exceptionMessage: Scalars['String']['input'];
  /** stackTrace */
  exceptionStacktrace?: InputMaybe<Scalars['String']['input']>;
  /** Уникальный бизнесовый тип ошибки */
  exceptionType: Scalars['String']['input'];
  /** уникальный идентификатор исключения */
  exceptionUniqueCode: Scalars['String']['input'];
  /** логин пользователя */
  login: Scalars['String']['input'];
  /** метод в котором произошла ошибка */
  method: Scalars['String']['input'];
  /** версия приложения */
  routeInfo?: InputMaybe<Scalars['String']['input']>;
  /** id школы */
  schoolId?: InputMaybe<Scalars['UUID']['input']>;
  /** тип исключения */
  systemErrorType: SystemErrorType;
  /** версия системы */
  systemVersion: Scalars['String']['input'];
  /** ссылка на страницу на которой произошла ошибка */
  targetPageUrl: Scalars['String']['input'];
  /** id пользователя */
  userId: Scalars['UUID']['input'];
};

/** Источники системных ошибок */
export enum SystemErrorType {
  Back = 'BACK',
  Front = 'FRONT'
}

export type SystemNotification = {
  __typename?: 'SystemNotification';
  /** Автор. Необязательное, так как при запросе БА данное поле удаляется из ответа */
  author?: Maybe<User>;
  /** Возможность закрыть */
  closable: Scalars['Boolean']['output'];
  /** ID записи */
  id: Scalars['ID']['output'];
  /** Дата-время окончания отображения сообщения */
  notificationDisplayEnd: Scalars['Date']['output'];
  /** Дата-время начала отображения сообщения */
  notificationDisplayStart: Scalars['Date']['output'];
  /** Заголовок сообщения */
  notificationHeader: Scalars['String']['output'];
  /** Текст сообщения */
  notificationText: Scalars['String']['output'];
  /** ID школы, если не задано, то показываем всем */
  schoolId?: Maybe<Scalars['ID']['output']>;
};

export type SystemNotificationInput = {
  /** Возможность закрыть */
  closable?: InputMaybe<Scalars['Boolean']['input']>;
  /** ID записи, если не задано, то создаем новую */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** Дата-время окончания отображения сообщения */
  notificationDisplayEnd: Scalars['String']['input'];
  /** Дата-время начала отображения сообщения */
  notificationDisplayStart: Scalars['String']['input'];
  /** Заголовок сообщения */
  notificationHeader: Scalars['String']['input'];
  /** Текст сообщения */
  notificationText: Scalars['String']['input'];
  /** Флаг создания глобальных уведомлений */
  notify?: InputMaybe<Scalars['Boolean']['input']>;
  /** ID школы, если не задано, то показываем всем */
  schoolId?: InputMaybe<Scalars['ID']['input']>;
};

export type TagHierarchyElement = {
  __typename?: 'TagHierarchyElement';
  children?: Maybe<Array<TagHierarchyElement>>;
  name: Scalars['String']['output'];
  tagId: Scalars['ID']['output'];
  tagType: MediatekaTagType;
};

/** Теггируемая сущность */
export enum TaggedEntityTypeEnum {
  /** Группа проектов (курс) */
  Course = 'COURSE',
  /** Модуль */
  Module = 'MODULE',
  /** Задание */
  Task = 'TASK'
}

export enum TaggedObjectsEnum {
  /** учебный модуль */
  StudyModule = 'STUDY_MODULE',
  /** задание */
  Task = 'TASK'
}

export type Tariffs = {
  __typename?: 'Tariffs';
  /** время создания тарифа */
  createTs: Scalars['DateTime']['output'];
  /** идентификатор тарифа */
  id: Scalars['UUID']['output'];
  /** название тарифа */
  name: Scalars['String']['output'];
};

export type TariffsConfigurationsOfSchool = {
  __typename?: 'TariffsConfigurationsOfSchool';
  /** набор конфигурации данного тарифа */
  propertyCodes: Array<Maybe<Scalars['String']['output']>>;
  /** тариф */
  tariff: Tariffs;
};

export type TariffsConfigurationsOfSchoolInput = {
  /** набор конфигурации данного тарифа или нул значение в наборе если нужно привязать/удалить все фф из тарифа */
  propertyCodes: Array<InputMaybe<Scalars['String']['input']>>;
  /** идентификатор тарифа */
  tariffId: Scalars['UUID']['input'];
};

export type TariffsInput = {
  /** идентификатор тарифа */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** название тарифа */
  name: Scalars['String']['input'];
};

export type TariffsMutations = {
  __typename?: 'TariffsMutations';
  /** Изменяет(добавляем обновляет или удаляет) набор конфигурации указанного тарифа */
  changeConfigurationsToTariffsBinding: Scalars['Boolean']['output'];
  /** Изменяет(добавляем обновляет или удаляет) конфигурации тарифов у школы */
  changeTariffsConfigurationToSchoolBinding: Scalars['Boolean']['output'];
  /** Сохранение/обновление тарифа */
  saveTariff: Scalars['UUID']['output'];
};


export type TariffsMutationsChangeConfigurationsToTariffsBindingArgs = {
  configurationForAdd: Array<InputMaybe<ConfigurationsOfTariffInput>>;
  configurationForRemove: Array<InputMaybe<ConfigurationsOfTariffInput>>;
  tariffId: Scalars['UUID']['input'];
};


export type TariffsMutationsChangeTariffsConfigurationToSchoolBindingArgs = {
  schoolId: Scalars['UUID']['input'];
  tariffsConfigurationsOfSchoolForAdd: Array<InputMaybe<TariffsConfigurationsOfSchoolInput>>;
  tariffsConfigurationsOfSchoolForRemove: Array<InputMaybe<TariffsConfigurationsOfSchoolInput>>;
};


export type TariffsMutationsSaveTariffArgs = {
  tariffs: TariffsInput;
};

export type TariffsQueries = {
  __typename?: 'TariffsQueries';
  /** получить тариф соотвествующий школе */
  getTariffBySchoolId?: Maybe<Tariffs>;
  /** Получить все тарифы */
  loadAllTariffs: Array<Maybe<Tariffs>>;
  /** Получить список конфигураций тарифа по умолчанию */
  loadConfigurationsByTariffId: Array<Maybe<ConfigurationsOfTariff>>;
  /** Получить набор конфигураций и тарифов привязанных к школе(если школа относится к полному тарифу, то его фф раскрываются ) */
  loadTariffsConfigurationsBySchoolId: Array<Maybe<TariffsConfigurationsOfSchool>>;
};


export type TariffsQueriesGetTariffBySchoolIdArgs = {
  schoolId: Scalars['UUID']['input'];
};


export type TariffsQueriesLoadConfigurationsByTariffIdArgs = {
  tariffId: Scalars['UUID']['input'];
};


export type TariffsQueriesLoadTariffsConfigurationsBySchoolIdArgs = {
  schoolId: Scalars['UUID']['input'];
};

export type Task = {
  __typename?: 'Task';
  /** % правильных ответов для приемки задания при автопроверке */
  acceptancePercent?: Maybe<Scalars['Int']['output']>;
  /** Трудоемкость фактическая (в секундах) */
  actualLaboriousness?: Maybe<Scalars['Float']['output']>;
  /** Признак архивности */
  archived: Scalars['Boolean']['output'];
  /** Формат выполнения (Групповой/Индивидуальный) */
  assignmentType: TaskAssignmentEnum;
  /** Файлы, прикрепленные к Заданию */
  attachmentFiles: Array<TaskFile>;
  /** Количество попыток */
  attemptsNumber?: Maybe<Scalars['Int']['output']>;
  /**
   * Владелец интеллектуальной собственности (например, автор учебника, из которого задание перенесено на Платформу)
   * Кастомная запись, которую можно отредактировать на UI.
   * НИ НА ЧТО НЕ ВЛИЯЕТ
   */
  author: Scalars['String']['output'];
  /**
   * Признак принаджелит ли задание к геймифицированному модулю
   * @deprecated Will be deleted in 26.0.
   */
  belongsToCustomModule: Scalars['Boolean']['output'];
  /**
   * Тип проверки задания (Онлайн/Оффлайн)
   * @deprecated Will be deleted. Use instead checkTypes
   */
  checkType: TaskCheckEnum;
  /** Типы проверки задания (Онлайн/Оффлайн) */
  checkTypes: Array<TaskCheckEnum>;
  /** Соавторы. В потенциале в этом массиве будут лежать цензоры, редакторы и прочие участники процесса производства контента */
  coAuthors: Array<User>;
  /**
   * Код
   * @deprecated Field no longer supported
   */
  code: Scalars['String']['output'];
  /** Контент */
  content?: Maybe<TaskContent>;
  /** Теги, которыми помечено задание */
  contentTags?: Maybe<Array<ContentTag>>;
  copyFromTaskId?: Maybe<Scalars['ID']['output']>;
  /** Дата создания */
  createTime: Scalars['DateTime']['output'];
  /** Создатель задания. (ТОТ КТО ПЕРВЫМ НАЖАЛ НА КНОПКУ!!!!!!!!!!!!!!!) */
  createUser: User;
  criteriaSet?: Maybe<CriteriaSet>;
  /** Описание */
  description: Scalars['String']['output'];
  /** Уровень сложности */
  difficultyLevel?: Maybe<DifficultyLevelEnum>;
  /** Код внешней системы для проверки */
  externalSystemCode?: Maybe<Scalars['String']['output']>;
  /** Признак синхронности/асинхронности внешней системы для проверки */
  externalSystemSync?: Maybe<Scalars['Boolean']['output']>;
  /** Активная версия контента проекта в гитлабе */
  gitlabActiveProjectVersion?: Maybe<Scalars['String']['output']>;
  /**
   * Название элемента цели
   * @deprecated Will be deleted in 0.14.0. Use task.linkedGoalElementInfos
   */
  goalElementName: Array<Scalars['String']['output']>;
  /** ID модуля */
  goalId?: Maybe<Scalars['ID']['output']>;
  goalLevels?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Название модуля */
  goalName: Scalars['String']['output'];
  /** шкала оценивания */
  gradingScales: Array<GradingScale>;
  /**
   * Наличие доступа у текущего пользователя
   * @deprecated Will be deleted in 0.13.0
   */
  hasAccess?: Maybe<Scalars['Boolean']['output']>;
  /** доступно ли Задание на чтение текущему пользователю */
  hasReadAccess: Scalars['Boolean']['output'];
  /** ID задания */
  id: Scalars['ID']['output'];
  /** Полезная информация ученику */
  info: Scalars['String']['output'];
  /** Файлы, прикрепленные к полю Задания "Правильный ответ и критерии оценивания" */
  infoAttachmentFiles: Array<TaskInfoFile>;
  /**
   * Признак является ли задание офлайновым
   * @deprecated Field no longer supported
   */
  isOffline?: Maybe<Scalars['Boolean']['output']>;
  /** Наличие заданий в модуле в процессе прохождения */
  isStartedByStudents?: Maybe<Scalars['Boolean']['output']>;
  /** Трудоемкость (в минутах) */
  laboriousness: Scalars['Int']['output'];
  /** Уровень */
  level?: Maybe<Scalars['Float']['output']>;
  /**
   * Лицензия
   * @deprecated Field no longer supported
   */
  license: License;
  /** информация о Элемента Цели, к которым привязано Задание */
  linkedGoalElementInfos: Array<LinkedGoalElementInfo>;
  /** Источники */
  links: Scalars['String']['output'];
  /** Дата последнего изменения */
  modifyTime?: Maybe<Scalars['DateTime']['output']>;
  /** Пользователь который произвел последнее изменение */
  modifyUser?: Maybe<User>;
  /**
   * Заметка задания
   * @deprecated Field no longer supported
   */
  note?: Maybe<Scalars['String']['output']>;
  /** Идентификатор родительского Задания */
  parentTaskId?: Maybe<Scalars['ID']['output']>;
  /**
   * Файл педтехники
   * @deprecated Field no longer supported
   */
  pedagogicalTechnique?: Maybe<PedagogicalTechnique>;
  /** Рекомендация к выполнению */
  recommendationToExecution?: Maybe<RecommendationToExecutionEnum>;
  /** скоуп видимости */
  scope: ScopeEnum;
  /** Информация о скоупе */
  scopeInfo?: Maybe<ScopeInfo>;
  /** короткая ссылка на задание (относительный путь) */
  shortcut: Scalars['String']['output'];
  /** Использовать taskConfig */
  showAnswerInput: Scalars['Boolean']['output'];
  /**
   * Навыки
   * @deprecated Will be deleted in 0.14.0. Use instead task.linkedGoalElementInfos
   */
  skills: Array<Scalars['String']['output']>;
  /** Типы гибких навыков */
  softSkillTypes: Array<TaskSoftSkillType>;
  /** Параллель */
  stage?: Maybe<Stage>;
  /** Подсказка для ученика */
  studentHint: Scalars['String']['output'];
  /** Параметры задания */
  studentTaskAdditionalAttributes: StudentTaskAdditionalAttributes;
  /** id предмета */
  subjectId?: Maybe<Scalars['Int']['output']>;
  /** Название предмета */
  subjectName: Scalars['String']['output'];
  /**
   * Список тегов
   * @deprecated Will be deleted. Use task.contentTags
   */
  tags: Array<Scalars['String']['output']>;
  /** конфигурация задания */
  taskConfig?: Maybe<TaskConfig>;
  /** Тип контента задания */
  taskContentType?: Maybe<TaskContentTypeEnum>;
  /** список критериев, по которым можно ценить Задание */
  taskCriteria: Array<TaskCriterion>;
  /** Дубль идентификатора, решает проблемы, связанные с Apollo cache */
  taskId: Scalars['ID']['output'];
  /** Перечень модулей, к которым прикреплено задание */
  taskModules?: Maybe<Array<TaskModulesInfo>>;
  /** Ш21. Тип загружаемого решения */
  taskSolutionType?: Maybe<TaskSolutionTypeEnum>;
  /** UUID задания */
  taskUUID: Scalars['UUID']['output'];
  /** Идентификатор группы по заданию в user group service */
  taskUserGroupId?: Maybe<Scalars['UUID']['output']>;
  /** Подсказка для учителя */
  teacherHint: Scalars['String']['output'];
  /** Настройки команды в групповом задании в школе 21 */
  teamSettingTask?: Maybe<TeamSettingTask>;
  /** Наименование */
  title: Scalars['String']['output'];
  /** Перевод контента задания на другой язык, если он был запрошен */
  translatedData?: Maybe<Scalars['String']['output']>;
  /** Тип */
  type: TaskTypeEnum;
  /** Неограниченное количество попыток */
  unlimitedAttempts: Scalars['Boolean']['output'];
  /** Версия задания */
  version?: Maybe<Scalars['String']['output']>;
};

/** Форма работы */
export enum TaskAssignmentEnum {
  /** в группах */
  Group = 'GROUP',
  /** индивидуально */
  Individual = 'INDIVIDUAL',
  /** в стажировке */
  Internship = 'INTERNSHIP',
  /** в классе */
  InClassroom = 'IN_CLASSROOM',
  /** в парах */
  InPairs = 'IN_PAIRS'
}

/** Количество заданий с определенным статусом */
export type TaskCardsStatusesWithQuantity = {
  __typename?: 'TaskCardsStatusesWithQuantity';
  /** Статус задания */
  amountTaskStatus?: Maybe<AmountTasksInStatusesEnum>;
  /** Количество новых заданий по этому статусу */
  newTasksQuantity?: Maybe<Scalars['Int']['output']>;
  /** Количество заданий по этому статусу */
  quantity: Scalars['Int']['output'];
  taskDataModel?: Maybe<Array<TaskDataModel>>;
};

/** Тип проверки задания */
export enum TaskCheckEnum {
  /** Автоматическая проверка */
  AutoCheck = 'AUTO_CHECK',
  /** Проверка учителем */
  ByTeacher = 'BY_TEACHER',
  /** Код ревью */
  CodeReview = 'CODE_REVIEW',
  /** Обратная связи наставника */
  MentorFeedback = 'MENTOR_FEEDBACK',
  /** Cамооценка */
  SelfCheck = 'SELF_CHECK',
  /** Взаимооценка */
  StudentByStudent = 'STUDENT_BY_STUDENT',
  /** Без проверки */
  WithoutCheck = 'WITHOUT_CHECK'
}

export type TaskCheckQueries = {
  __typename?: 'TaskCheckQueries';
  getStageSubjectGroupBySubjectsForTeacher: StageSubjectGroupsBySubjectTeacherResponse;
  /** Получение списка выполненных заданий для учеников в ГКПП */
  getStageSubjectGroupCompletedTasksInfo: StudentCheckedTasksWithGoalsFilter;
  /** получение количества Заданий на проверке по всем доступным (после применения фильтров) Учителю ГкПП */
  getStageSubjectGroupsForTeacher: StageSubjectGroupsByTeacherResponse;
  /** получение заданий студентов по группе по предмету и заданию */
  getStudentTaskInfos: StudentTasksToCheckResponse;
  /** получение заданий на проверке и непрочитанных сообщений */
  getStudentTasksByStageSubjectGroup: StudentTasksByStageSubjectGroupResponse;
  /** получение заданий студентов по группе по предмету и заданию */
  getStudentTasksByStageSubjectGroupAndTask: StudentTasksToCheckResponse;
  /** получение заданий на проверке c количеством ответов и количеством непрочитанных комментариев */
  getStudentTasksByStageSubjectGroupForStudents: StudentTasksByStageSubjectGroupForStudentsResponse;
  /** получение заданий на проверке c количеством ответов и количеством непрочитанных комментариев */
  getStudentTasksByStageSubjectGroupWithAnswersAndCommentCount: StudentTasksWithAnswersAndCommentsCountResponse;
  getVerifiedTasksByStageSubjectGroupsForTeacher: StageSubjectGroupsBySubjectTeacherResponse;
};


export type TaskCheckQueriesGetStageSubjectGroupBySubjectsForTeacherArgs = {
  filterStages?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterSubjects?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  studentTaskFilter?: InputMaybe<StudentTaskCheckFilterEnum>;
  studentTaskNonTimeFilter?: InputMaybe<StudentTaskCheckNonTimeFilterEnum>;
  studentTaskNonTimeTeacherFilter?: InputMaybe<StudentTaskCheckNonTimeTeacherFilterEnum>;
};


export type TaskCheckQueriesGetStageSubjectGroupCompletedTasksInfoArgs = {
  byLastNameFilterDesc: Scalars['Boolean']['input'];
  byTaskNumberFilterDesc: Scalars['Boolean']['input'];
  endDate: Scalars['Date']['input'];
  filterByStatus: Array<TaskStatusEnum>;
  goalIds: Array<Scalars['ID']['input']>;
  nameOrTitleFilter?: InputMaybe<Scalars['String']['input']>;
  stageSubjectGroupId: Scalars['ID']['input'];
  startDate: Scalars['Date']['input'];
};


export type TaskCheckQueriesGetStageSubjectGroupsForTeacherArgs = {
  groupNameFilter?: InputMaybe<Scalars['String']['input']>;
  studentTaskFilter?: InputMaybe<StudentTaskCheckFilterEnum>;
  studentTaskNonTimeFilter?: InputMaybe<StudentTaskCheckNonTimeFilterEnum>;
  studentTaskNonTimeTeacherFilter?: InputMaybe<StudentTaskCheckNonTimeTeacherFilterEnum>;
};


export type TaskCheckQueriesGetStudentTaskInfosArgs = {
  nameFilter?: InputMaybe<Scalars['String']['input']>;
  stageSubjectGroupId: Scalars['ID']['input'];
  studentTaskCheckAnswerDateAndNameSorting?: InputMaybe<StudentTaskCheckAnswerDateAndNameSortingEnum>;
  studentTaskFilter?: InputMaybe<StudentTaskCheckFilterEnum>;
  studentTaskNonTimeFilter?: InputMaybe<StudentTaskCheckNonTimeFilterEnum>;
  taskId: Scalars['ID']['input'];
};


export type TaskCheckQueriesGetStudentTasksByStageSubjectGroupArgs = {
  directStudentTask?: InputMaybe<StudentTaskToCheckInput>;
  page: PagingInput;
  stageSubjectGroupId: Scalars['ID']['input'];
  studentTaskFilter?: InputMaybe<StudentTaskCheckFilterEnum>;
  studentTaskNonTimeFilter?: InputMaybe<StudentTaskCheckNonTimeFilterEnum>;
  studentTaskNonTimeTeacherFilter?: InputMaybe<StudentTaskCheckNonTimeTeacherFilterEnum>;
  taskNameFilter?: InputMaybe<Scalars['String']['input']>;
};


export type TaskCheckQueriesGetStudentTasksByStageSubjectGroupAndTaskArgs = {
  page: PagingInput;
  stageSubjectGroupId: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
};


export type TaskCheckQueriesGetStudentTasksByStageSubjectGroupForStudentsArgs = {
  stageSubjectGroupId: Scalars['ID']['input'];
  studentTaskCheckSorting?: InputMaybe<StudentTaskCheckSortingEnum>;
  studentTaskFilter?: InputMaybe<StudentTaskCheckFilterEnum>;
  studentTaskNonTimeFilter?: InputMaybe<StudentTaskCheckNonTimeFilterEnum>;
  taskNameFilter?: InputMaybe<Scalars['String']['input']>;
};


export type TaskCheckQueriesGetStudentTasksByStageSubjectGroupWithAnswersAndCommentCountArgs = {
  stageSubjectGroupId: Scalars['ID']['input'];
  studentTaskFilter?: InputMaybe<StudentTaskCheckFilterEnum>;
  studentTaskNonTimeFilter?: InputMaybe<StudentTaskCheckNonTimeFilterEnum>;
  taskNameFilter?: InputMaybe<Scalars['String']['input']>;
};


export type TaskCheckQueriesGetVerifiedTasksByStageSubjectGroupsForTeacherArgs = {
  filterStages?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterSubjects?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/** Данные для отчета "Метрики на вкладке задания" */
export type TaskCompletedMetrics = {
  __typename?: 'TaskCompletedMetrics';
  accepted1: Scalars['Int']['output'];
  accepted1BySchool: Scalars['Int']['output'];
  accepted2: Scalars['Int']['output'];
  accepted2BySchool: Scalars['Int']['output'];
  acceptedMoreThen2: Scalars['Int']['output'];
  acceptedMoreThen2BySchool: Scalars['Int']['output'];
  failed: Scalars['Int']['output'];
  failedBySchool: Scalars['Int']['output'];
  negativeFeedbacks: Scalars['Int']['output'];
  negativeFeedbacksBySchool: Scalars['Int']['output'];
  percentAccepted1: Scalars['Int']['output'];
  percentAccepted1BySchool: Scalars['Int']['output'];
  percentAccepted2: Scalars['Int']['output'];
  percentAccepted2BySchool: Scalars['Int']['output'];
  percentAcceptedMoreThen2: Scalars['Int']['output'];
  percentAcceptedMoreThen2BySchool: Scalars['Int']['output'];
  percentFailed: Scalars['Int']['output'];
  percentFailedBySchool: Scalars['Int']['output'];
  positiveFeedbacks: Scalars['Int']['output'];
  positiveFeedbacksBySchool: Scalars['Int']['output'];
  students: Scalars['Int']['output'];
  studentsBySchool: Scalars['Int']['output'];
  taskCreated: Scalars['Date']['output'];
};

/** Конфигурация задания */
export type TaskConfig = {
  __typename?: 'TaskConfig';
  /** Разрешен или нет отзыв ответа */
  allowWithdrawAnswer?: Maybe<Scalars['Boolean']['output']>;
  /** Показывать или нет правильный ответ после отправки задания на проверку */
  showRightAnswer?: Maybe<Scalars['Boolean']['output']>;
  /** Без поля ввода ответа */
  withoutAnswerInput?: Maybe<Scalars['Boolean']['output']>;
};

/** Конфигурация задания */
export type TaskConfigInput = {
  /** Разрешен или нет отзыв ответа */
  allowWithdrawAnswer?: InputMaybe<Scalars['Boolean']['input']>;
  /** Показывать или нет правильный ответ после отправки задания на проверку */
  showRightAnswer?: InputMaybe<Scalars['Boolean']['input']>;
  /** Без поля ввода ответа */
  withoutAnswerInput?: InputMaybe<Scalars['Boolean']['input']>;
};

export type TaskContent = {
  __typename?: 'TaskContent';
  /**
   * Содержимое задания
   * @deprecated Will be deleted in 26.0.0
   */
  body?: Maybe<Scalars['String']['output']>;
  /** Тип представления контента */
  contentViewType?: Maybe<ContentViewTypeEnum>;
  /** Данные внешнего задания */
  external?: Maybe<ExternalTask>;
  /**
   * html из external survey (base64)
   * @deprecated Will be deleted in 0.14
   */
  externalSurvey?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** Список секций мотоблока */
  mbSectionList?: Maybe<Array<ContentMbSection>>;
  /** Представление контента в мотивирующих заданияс с мигрированным мотивационным блоком */
  motivationView?: Maybe<ContentMotivationView>;
  /** Информация о страницах задания и их содержимом */
  pages: Array<ContentBodyPage>;
  /** Представление контента в расширенном виде */
  proView?: Maybe<ContentProView>;
  /** Список страниц для контента ш21 */
  s21PageList?: Maybe<Array<ContentS21Page>>;
  /** Представление контента для ш21 */
  s21View?: Maybe<ContentS21View>;
  /** Список секций контента */
  sectionList?: Maybe<Array<ContentSection>>;
  /** Представление контента в стандартном виде */
  simpleView?: Maybe<ContentSimpleView>;
  /** Тип контента, содержащегося в задании */
  type: ContentTypeEnum;
  /** Список виджетов контента */
  widgetList?: Maybe<Array<ContentWidget>>;
};

export type TaskContentAggregationResponse = {
  __typename?: 'TaskContentAggregationResponse';
  criterionScale?: Maybe<Array<CriterionScale>>;
  kindQuestions?: Maybe<Array<KindQuestion>>;
  language?: Maybe<Array<KeyValue>>;
};

/** Тип контента задания */
export enum TaskContentTypeEnum {
  /** Все типы заданий, создаваемые/используемые с контентом, созданным на платформе ПМО. */
  Game = 'GAME',
  /** Кусок внешнего гейммодуля */
  GameGoalPart = 'GAME_GOAL_PART',
  /** Внешнее задание, импортируемое как отдельный архив с компилированным приложением - интерактивом. */
  Inner = 'INNER'
}

export type TaskCriteriaValue = {
  __typename?: 'TaskCriteriaValue';
  /** Степень соответствия критерию */
  criteriaValue: CriteriaValue;
  /** Количество заданий, с данным уровнем соответствия */
  criteriaValueCount: Scalars['Int']['output'];
};

/** Критерий оценивания задания со шкалой */
export type TaskCriterion = {
  __typename?: 'TaskCriterion';
  /** Мета-критерий */
  criterion: Criterion;
  /** Приоритет критерия */
  criterionPriority: Scalars['Int']['output'];
  /** Шкала оценок */
  scale: CriterionScale;
  /** Идентификатор (xref_task_assessment_criteria_scales.task_criteria_scale_id) */
  taskCriterionId: Scalars['ID']['output'];
};

/** Данные для добавления нового критерия к заданию (xref_task_assessment_criteria_scales) */
export type TaskCriterionInput = {
  /** Идентификатор критерия (task_assessment_criteria.task_assessment_criteria_id) */
  criterionId: Scalars['ID']['input'];
  /** Идентификатор шкалы (task_assessment_scales.task_assessment_scale_id) */
  criterionScaleId: Scalars['ID']['input'];
};

export type TaskDataModel = {
  __typename?: 'TaskDataModel';
  stageSubjectGroupId: Scalars['ID']['output'];
  stageSubjectGroupName: Scalars['String']['output'];
  taskCount: Scalars['ID']['output'];
};

export type TaskDeadline = {
  __typename?: 'TaskDeadline';
  /**
   * Для заданий по ВНЕплановым модулям дедлайном является окончание учебного года, isHardDeadline: false
   * Дата дедлайна задания
   */
  deadline: Scalars['DateTime']['output'];
  /** Является ли дедлайл жестким. После истечения жесткого дедлайна нельзять отправить задание на проверку */
  isHardDeadline: Scalars['Boolean']['output'];
};

export type TaskEvaluationInput = {
  /** Критерий приемки */
  acceptancePercent: Scalars['Int']['input'];
  /** Шкала оценивания */
  gradingScales: Array<GradingScaleInput>;
};

/** Контекст выполнения задания */
export type TaskExecutionContext = {
  __typename?: 'TaskExecutionContext';
  /** Флаг - можно ли выполнять задание */
  canExecute: Scalars['Boolean']['output'];
  /** Список причин, по которым выполнение задания запрещено */
  executeDenyInfos: Array<ExecuteDenyInfo>;
  /** информации о проводимых внешних обучениях в рамках текущей школы пользователя, в которых участвует данное задание */
  schoolLearningProgramInfos?: Maybe<Array<LearningProgramInfo>>;
};

/** Файл, прикладываемый к заданию */
export type TaskFile = {
  __typename?: 'TaskFile';
  /** Байты */
  extension: FileExtensionEnum;
  fileName: Scalars['String']['output'];
  fileOrder: Scalars['Int']['output'];
  filePath: Scalars['String']['output'];
  fileSize: Scalars['Int']['output'];
  /** Для студента */
  forStudent: Scalars['Boolean']['output'];
  /** Для ученика */
  forTeacher: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
};

export type TaskFileInput = {
  /** Байты */
  extension: FileExtensionEnum;
  fileName: Scalars['String']['input'];
  fileOrder: Scalars['Int']['input'];
  filePath: Scalars['String']['input'];
  fileSize: Scalars['Int']['input'];
  forStudent: Scalars['Boolean']['input'];
  forTeacher: Scalars['Boolean']['input'];
};

/** Отношение неуспешно переведенных ИД заданий к возникшей ошибке */
export type TaskIdToErrorMapModel = {
  __typename?: 'TaskIdToErrorMapModel';
  /** Причина по которой задание не было переведено */
  errorMessage: Scalars['String']['output'];
  /** Идентификатор задания */
  taskId: Scalars['ID']['output'];
  /** Название задания */
  taskName: Scalars['String']['output'];
};

/** Тип содержит сопоставление ["ИД задания" -> "признак консистентности задания"] */
export type TaskIdToTaskConsistency = {
  __typename?: 'TaskIdToTaskConsistency';
  /** Признак консистентности аттрибутов задания, не зависящих от типа проекта */
  isCommonAttributesConsistent: Scalars['Boolean']['output'];
  /** Признак консистентности задания в контексте экзамена */
  isExamContextConsistent: Scalars['Boolean']['output'];
  /** Признак консистентности задания */
  isTaskConsistent: Scalars['Boolean']['output'];
  /** Порядковый номер уровня */
  taskId: Scalars['ID']['output'];
};

/** Атрибуты "консистентности" задания в проекте (необходимы для проверки возможности Публикации проекта) */
export type TaskInModuleConsistency = {
  __typename?: 'TaskInModuleConsistency';
  /** Признак наличия всех параметров консистентности по код-ревью */
  hasAllCodeReviewParameters: Scalars['Boolean']['output'];
  /** Признак наличия автопроверки для задания */
  hasAutocheck: Scalars['Boolean']['output'];
  /** Признак того, что присутствуют веса вопросов ОСНОВНОЙ части в автотестах и сумма весов для ОСНОВНОЙ части составляет 100% */
  hasAutocheckBasicKindQuestionsWeightsSumEquals100: Scalars['Boolean']['output'];
  /** Признак того, что присутствуют веса вопросов БОНУСНОЙ части в автотестах и сумма весов для БОНУСНОЙ части составляет 100% */
  hasAutocheckBonusKindQuestionsWeightsSumEquals100: Scalars['Boolean']['output'];
  /** Признак наличия автопроверки и отсутствия P2P-Проверки для Экзаменационного задания */
  hasAutocheckOnlyInExam: Scalars['Boolean']['output'];
  /** Признак наличия для задания (в таблице task_parameter_values) ненулевого параметра автопроверки с типом: percentage_of_bonus_auto */
  hasAutocheckParamPercentageOfBonusAutoNotEmpty: Scalars['Boolean']['output'];
  /** Признак того, что в автотестах присутствует БОНУСНАЯ часть */
  hasAutocheckParameterPercentageOfBonusAuto: Scalars['Boolean']['output'];
  /** Признак наличия автотестов для задания */
  hasAutotests: Scalars['Boolean']['output'];
  /** Признак наличия чек-листа для p2p-проверки */
  hasChecklist: Scalars['Boolean']['output'];
  /** Признак наличия код-ревью (определяется по edu_power_content.task_check_type_links.task_check_type_id = 9) */
  hasCodeReview: Scalars['Boolean']['output'];
  /** Признак наличия параметра код-ревью "Стоимость проверки" */
  hasCodeReviewCost: Scalars['Boolean']['output'];
  /** Признак наличия ненулевого параметра код-ревью "Длительность проверки (в минутах)" */
  hasCodeReviewDurationNotZero: Scalars['Boolean']['output'];
  /** Признак наличия ненулевого параметра код-ревью "Процент навыка "Код ревью"" */
  hasCodeReviewSkillPercentageNotZero: Scalars['Boolean']['output'];
  /** Признак соответствия количества отображаемых виджетов экзаменационного теста установленному порогу */
  hasExamTestNumberOfWidgetsDoesNotExceedThreshold?: Maybe<Scalars['Boolean']['output']>;
  /** Признак равенства суммы распределения процентов по навыкам 100 процентам с учетом текущих страниц */
  hasExamTestSoftSkillPercentagesSumEquals100?: Maybe<Scalars['Boolean']['output']>;
  /** Есть ли в for_forks хоть что-нибудь */
  hasForForksAnyFile?: Maybe<Scalars['Boolean']['output']>;
  /** Признак наличия параметра "ID формулы подсчета оценки за все p2p-проверки" для задания */
  hasFormulaOfP2pResult: Scalars['Boolean']['output'];
  /** Признак наличия ненулевого параметра код-ревью "Максимальное количество проверок" */
  hasMaxCodeReviewCountNotZero: Scalars['Boolean']['output'];
  /** Признак наличия неотрицательного параметра p2p-проверки "Стоимость проверки (Evaluation Points)" */
  hasNonNegativeP2pEvaluationCost: Scalars['Boolean']['output'];
  /** Признак наличия неотрицательного параметра p2p-проверки "Процент за бонусную часть" */
  hasNonNegativeP2pPercentageOfBonus: Scalars['Boolean']['output'];
  /** Признак заполнения навыка "Лидерство" (вычисляется только для групповых проектов) */
  hasNotEmptyGroupRoleSkillPercentage: Scalars['Boolean']['output'];
  /** Признак наличия ненулевого значения процентов выпонения */
  hasNotZeroPercentageOfCompletion: Scalars['Boolean']['output'];
  /** Признак наличия ненулевого количества баллов за задание */
  hasNotZeroPointsForTask: Scalars['Boolean']['output'];
  /** Признак наличия p2p-проверки для задания// Assign tenantId of "creator"-user with SA_TENANT functional role to new or editing user with SUPER_ADM role, */
  hasP2pCheck: Scalars['Boolean']['output'];
  /** Признак наличия параметра p2p-проверки "Количество требуемых проверок" */
  hasP2pCheckParamReviewUserCountNotEmpty: Scalars['Boolean']['output'];
  /** Признак наличия ненулевых параметров p2p-проверки для задания */
  hasP2pCheckParametersNotEmpty: Scalars['Boolean']['output'];
  /** Признак наличия чек-листа для задания */
  hasP2pCheckQuestionsWeights: Scalars['Boolean']['output'];
  /** Признак того, что веса вопросов по навыкам в окне "Настройка весов за р2р проверку" в рамках одной секции в сумме составляют 100% */
  hasP2pCheckQuestionsWeightsSumInSectionEqualTo100: Scalars['Boolean']['output'];
  /** Признак наличия положительного параметра p2p-проверки "Длительность проверки (в минутах)" */
  hasPositiveP2pDuration: Scalars['Boolean']['output'];
  /** Признак того, что список навыков в блоке "Расчет оценки за задания" идентичен списку навыков в окне "Настройка весов за р2р проверку" */
  hasSkillsInTaskPointsFrameMatchToP2pChecklistSkills: Scalars['Boolean']['output'];
  /** Признак равенства суммы распределения процентов по навыкам 100 процентам */
  hasSoftSkillPercentagesSum100: Scalars['Boolean']['output'];
  /** Признак наличия обязательного набора параметров проверок задания */
  hasTaskCheckParameters: Scalars['Boolean']['output'];
  /**
   *  Признак наличия контента задания
   * hasContent: Boolean!
   *  Признак наличия проверок задания
   */
  hasTaskChecks: Scalars['Boolean']['output'];
  /** Признак равенства суммы весов проверок разных типов для задания 100% */
  hasTaskChecksWeightsSum100: Scalars['Boolean']['output'];
  /** В задаче присутствует контент */
  hasTaskContent?: Maybe<Scalars['Boolean']['output']>;
  /** Признак консистентности аттрибутов задания, не зависящих от типа проекта */
  isCommonAttributesConsistent: Scalars['Boolean']['output'];
  /** Признак консистентности задания */
  isConsistent: Scalars['Boolean']['output'];
  /** Признак консистентности задания в контексте экзамена */
  isExamContextConsistent: Scalars['Boolean']['output'];
  /** Признак принадлежности задания экзаменационному проекту */
  isExamTask: Scalars['Boolean']['output'];
  /** Признак опубликованности задания */
  isPublished: Scalars['Boolean']['output'];
  /** Признак того, что задание является Индивидуальным */
  isTaskIndividual: Scalars['Boolean']['output'];
  /** Название задания */
  name: Scalars['String']['output'];
  /** Идентификатор задания */
  taskId: Scalars['ID']['output'];
};

/**
 * Краткая информация о задании в контексте пользователя
 * Если объект запрашивает родитель, то он возвращается в контексте ребенка, по которому родитель
 * запрашивает информацию
 */
export type TaskInfo = {
  __typename?: 'TaskInfo';
  /** Может ли текущий пользователь изменять контент и мета-информацию задания */
  canEdit: Scalars['Boolean']['output'];
  /**
   * Может ли текущий пользователь читать контент Задания, определяется через скоуп задания,
   * права пользователя и авторство
   */
  canRead: Scalars['Boolean']['output'];
  /** Контекст выполнения задания */
  executionContext: TaskExecutionContext;
  /** Найдено ли такое задание в БД */
  found: Scalars['Boolean']['output'];
  goalProductionStatus?: Maybe<ContentEntityProductionStatus>;
  /** Может ли пользователь смотреть задания из внешнего конкурса */
  hasPermissionForExternalContest?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Находится ли задание в траектории у ученика. Если запрашивает родитель, то возврщается значение
   * в контесте его ребенка
   * ВНИМАНИЕ! Если ученик не может читать контент задания => он не может его проходить.
   */
  inTrajectory: Scalars['Boolean']['output'];
  /** Является ли задание обязательным */
  mandatory?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Запланирован ли модуль, к которому относится задание, у текущего пользователя.
   * Запланирован модуль может быть у студента и родителя. Если запланирован у студента => запланирован у его родителя.
   */
  planned: Scalars['Boolean']['output'];
  /** информация о сессиях печати задания в контексте пользователя */
  printTaskMeta?: Maybe<PrintTaskMeta>;
  /** Скоуп видимости задания (Приватный, Кастомный, Глобальный) */
  scope: ScopeEnum;
};

/** Файл, прикрепленный к полю Задания "Правильный ответ и критерии оценивания" */
export type TaskInfoFile = {
  __typename?: 'TaskInfoFile';
  /** Байты */
  extension: FileExtensionEnum;
  fileName: Scalars['String']['output'];
  fileOrder: Scalars['Int']['output'];
  filePath: Scalars['String']['output'];
  fileSize: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
};

export type TaskInfoFileInput = {
  /** Байты */
  extension: FileExtensionEnum;
  fileName: Scalars['String']['input'];
  fileOrder: Scalars['Int']['input'];
  filePath: Scalars['String']['input'];
  fileSize: Scalars['Int']['input'];
};

export type TaskInfoToCheck = {
  __typename?: 'TaskInfoToCheck';
  shortSubjectName?: Maybe<Scalars['String']['output']>;
  stageGroupName?: Maybe<Scalars['String']['output']>;
  stageSubjectGroupName?: Maybe<Scalars['String']['output']>;
  subjectName?: Maybe<Scalars['String']['output']>;
  task?: Maybe<Task>;
};

/** Задание внутри Слота */
export type TaskIntoSlot = {
  __typename?: 'TaskIntoSlot';
  /** Идентификатор (base_playlist_slot_tasks.base_laylist_slot_task_id или teacher_playlist_slot_task.teacher_playlist_slot_task_id) */
  id: Scalars['ID']['output'];
  /** Флаг - обязательно ли это Задание в рамках этого Слота */
  mandatory: Scalars['Boolean']['output'];
  /** Сквозной порядковый номер задания в плэйлисте */
  order: Scalars['ID']['output'];
  /** Задание */
  task: Task;
  /** Идентификатор (base_playlist_slot_tasks.base_laylist_slot_task_id или teacher_playlist_slot_task.teacher_playlist_slot_task_id) */
  taskIntoSlotId: Scalars['ID']['output'];
};

export type TaskIntoSlotInput = {
  mandatory: Scalars['Boolean']['input'];
  /** Сквозной порядковый номер задания в плэйлисте */
  order: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
};

/** Задания уровней учебного модуля */
export type TaskLevelModule = {
  __typename?: 'TaskLevelModule';
  /** Ссылка на задание similar task\id\ */
  link: Scalars['String']['output'];
  /** Статус задания */
  status?: Maybe<TaskStatusEnum>;
  /** Идентификатор задания */
  taskId: Scalars['ID']['output'];
  /** Название задания */
  taskName: Scalars['String']['output'];
};

/** Сообщение в рамках обсуждения Задания */
export type TaskMessage = {
  __typename?: 'TaskMessage';
  /** файлы прикрепленные к сообщению */
  files: Array<File>;
  id: Scalars['ID']['output'];
  /** само сообщение */
  message: Message;
  /** источник сообщения (Учитель, Студент, Внешняя система) */
  messageSource?: Maybe<MessageSource>;
  /** факты прочтения комментария */
  readFacts: Array<TaskMessageReadFact>;
  /** идентификатор задания */
  taskId: Scalars['ID']['output'];
};

/** факт прочтения комментария */
export type TaskMessageReadFact = {
  __typename?: 'TaskMessageReadFact';
  /** время прочтения сообщения */
  createTime: Scalars['DateTime']['output'];
  /** идентификатор факта прочтения комментария */
  id: Scalars['ID']['output'];
  /** идентификатор комментария */
  messageId: Scalars['ID']['output'];
  /** пользователь */
  user: User;
};

export type TaskMetaInput = {
  /** Признак архивности */
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  assignmentType: TaskAssignmentEnum;
  /** Файлы, прикрепленные к Заданию */
  attachmentFiles: Array<TaskFileInput>;
  /** Количество попыток */
  attemptsNumber?: InputMaybe<Scalars['Int']['input']>;
  author: Scalars['String']['input'];
  checkType: TaskCheckEnum;
  checkTypes?: InputMaybe<Array<TaskCheckEnum>>;
  /** Со-авторы задания. Пользователи, которым задание будет доступно для чтения даже в приватном скоупе. */
  coAuthorIds: Array<Scalars['UUID']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  /** Тэги */
  contentTags?: InputMaybe<Array<ContentTagInput>>;
  criteriaSet?: InputMaybe<CriteriaSetInput>;
  /** Уровень сложности */
  difficultyLevel?: InputMaybe<DifficultyLevelEnum>;
  externalSystemCode?: InputMaybe<Scalars['String']['input']>;
  externalSystemSync?: InputMaybe<Scalars['Boolean']['input']>;
  info: Scalars['String']['input'];
  /** Файлы, прикрепленные к полю Задания "Правильный ответ и критерии оценивания" */
  infoAttachmentFiles: Array<TaskInfoFileInput>;
  /** Признак является ли задание оффлайновым */
  isOffline?: InputMaybe<Scalars['Boolean']['input']>;
  laboriousness: Scalars['Int']['input'];
  licenseId?: InputMaybe<Scalars['ID']['input']>;
  links: Scalars['String']['input'];
  /** Заметка */
  note?: InputMaybe<Scalars['String']['input']>;
  /** идентификатор педтехники */
  pedagogicalTechniqueId?: InputMaybe<Scalars['ID']['input']>;
  /** Рекомендация к выполнению */
  recommendationToExecution?: InputMaybe<RecommendationToExecutionEnum>;
  /** Информация для установки скоупа */
  scope?: InputMaybe<ScopeForSet>;
  showAnswerInput?: InputMaybe<Scalars['Boolean']['input']>;
  softSkillTypes: Array<SoftSkillTypePowerInput>;
  studentHint: Scalars['String']['input'];
  /** Список тегов */
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Конфигурация задания */
  taskConfig?: InputMaybe<TaskConfigInput>;
  /** Список пар "критерий-шкала" для Задания */
  taskCriteriaInput: Array<TaskCriterionInput>;
  /** Ш21. Тип загружаемого решения */
  taskSolutionType?: InputMaybe<TaskSolutionTypeEnum>;
  teacherHint: Scalars['String']['input'];
  teamSettingTask?: InputMaybe<TeamSettingTaskInput>;
  title: Scalars['String']['input'];
  type: TaskTypeEnum;
  /** Неограниченное количество попыток */
  unlimitedAttempts: Scalars['Boolean']['input'];
};

/** Перечень модулей, к которым прикреплено задание, сгруппированные по типу */
export type TaskModulesInfo = {
  __typename?: 'TaskModulesInfo';
  executionType: ModuleExecutionType;
  modules: Array<Goal>;
};

/** Непрочитанные уведомление по заданию */
export type TaskNotification = {
  __typename?: 'TaskNotification';
  /** Задание, в связи с действием по которому было отправлено уведомление */
  task: Task;
  /** Статус Задания на момент отправки Уведомления */
  taskStatusOnNotificationTime?: Maybe<TaskStatusEnum>;
  /** Непрочитанное уведомление по заданию */
  unreadTaskNotification: Notification;
};

export type TaskOnCheckDetailed = {
  __typename?: 'TaskOnCheckDetailed';
  answerDate: Scalars['Date']['output'];
  goalId: Scalars['Int']['output'];
  goalName: Scalars['String']['output'];
  stageGroupId: Scalars['Int']['output'];
  stageGroupName: Scalars['String']['output'];
  stageId: Scalars['Int']['output'];
  stageName: Scalars['String']['output'];
  stageSubjectGroupId: Scalars['Int']['output'];
  stageSubjectGroupName: Scalars['String']['output'];
  studentId: Scalars['UUID']['output'];
  studentName: Scalars['String']['output'];
  subjectId: Scalars['Int']['output'];
  subjectName: Scalars['String']['output'];
  taskId: Scalars['Int']['output'];
  taskName: Scalars['String']['output'];
  teacherId: Scalars['UUID']['output'];
  teacherName: Scalars['String']['output'];
};

export type TaskPreviewEvaluationWidgetInput = {
  /** Ответ на виджет */
  answer: AnswerToWidgetInput;
  /** Тело виджета */
  widgetBody: WidgetInput;
};

export type TaskPreviewEvaluationWidgetResult = {
  __typename?: 'TaskPreviewEvaluationWidgetResult';
  /** Тело ответа */
  answerBody: WidgetAnswerBody;
  /** Статус ответа на виджет */
  status: TaskWidgetAnswerStatusEnum;
  /** Идентифкатор виджета */
  widgetId: Scalars['ID']['output'];
};

/** Данные для отчета "Публичные метрики по заданию" */
export type TaskPublicMetrics = {
  __typename?: 'TaskPublicMetrics';
  accepted: Scalars['Int']['output'];
  acceptedBySchool: Scalars['Int']['output'];
  failed: Scalars['Int']['output'];
  failedBySchool: Scalars['Int']['output'];
  negativeFeedbacks: Scalars['Int']['output'];
  negativeFeedbacksBySchool: Scalars['Int']['output'];
  percentAccepted: Scalars['Float']['output'];
  percentAcceptedBySchool: Scalars['Float']['output'];
  percentFailed: Scalars['Float']['output'];
  percentFailedBySchool: Scalars['Float']['output'];
  positiveFeedbacks: Scalars['Int']['output'];
  positiveFeedbacksBySchool: Scalars['Int']['output'];
  students: Scalars['Int']['output'];
  studentsBySchool: Scalars['Int']['output'];
};

/** Ответ на запрос обезличенных таймслотов для календаря s21 */
export type TaskReviewCountInfo = {
  __typename?: 'TaskReviewCountInfo';
  /** Количество запланированных проверок */
  relevantReviewUsersCount: Scalars['Int']['output'];
  /** Количество проверок для сдачи проекта */
  reviewUsersCount: Scalars['Int']['output'];
};

export enum TaskSearchTypeEnum {
  /** Классные */
  Classwork = 'CLASSWORK',
  /** Домашние */
  Homework = 'HOMEWORK',
  /** Остальные */
  Other = 'OTHER'
}

/** Набор Заданий для Учебного Модуля */
export type TaskSet = {
  __typename?: 'TaskSet';
  /**
   * Учительский контекст, в котором содержится информация, на кого назначена эта система заданий в тех группах,
   * в которых учитель ведет. Возвращается null, если текущий пользователь не имеет роль учителя в текущей школе.
   */
  assignContext?: Maybe<TeacherTaskSetAssignContext>;
  /** Пользователь создавший набор заданий */
  createUser: User;
  /** Идентификатор (base_playlists.base_playlist_id или teacher_playlists.teacher_playlist_id) */
  id: Scalars['ID']['output'];
  /** Название плейлиста */
  name: Scalars['String']['output'];
  /** Уровни Учебного Модуля с детализацией */
  slots: Array<TaskSetSlot>;
  /** Идентификатор (base_playlists.base_playlist_id или teacher_playlists.teacher_playlist_id) */
  taskSetId: Scalars['ID']['output'];
  /** Тип Набора Заданий */
  type: PlaylistType;
};

export type TaskSetInput = {
  /** Идентификатор Учебного Модуля Плейлиста (goals.goal_id) */
  moduleId: Scalars['ID']['input'];
  /** Название Плейлиста */
  name: Scalars['String']['input'];
  /** Слоты Плейлиста */
  slots: Array<TaskSetSlotInput>;
  /** Идентифкатор Плейлиста, необходим при изменении */
  taskSetId?: InputMaybe<Scalars['ID']['input']>;
  /** Тип Плейлиста */
  taskSetType: PlaylistType;
};

/** Тип содержит успеваемость учеников группы по предмету по определенной системе заданий модуля */
export type TaskSetPerformance = {
  __typename?: 'TaskSetPerformance';
  /** Количество проверочных заданий в системе заданий модуля */
  checkTaskCount?: Maybe<Scalars['Int']['output']>;
  /** Признак, что система задания модуля является текущей в данный момент времени в общем плане класса */
  currentGoal: Scalars['Boolean']['output'];
  /** по плану класса дата окончания модуля, к которому относится система заданий */
  endDate?: Maybe<Scalars['DateTime']['output']>;
  /** Количество элементов целей в системе заданий модуля */
  goalElementsCount?: Maybe<Scalars['Int']['output']>;
  /** Идентификатор модуля */
  goalId: Scalars['ID']['output'];
  /** Успеваемость учеников по уровням системы заданий модуля */
  levelPerformance: Array<LevelPerformance>;
  /** дата начала модуля, к которому относится система заданий, по плану класса */
  startDate?: Maybe<Scalars['DateTime']['output']>;
  /** Успеваемость ученика по системе заданий модуля */
  studentTaskSetPerformance: Array<StudentTaskSetPerformance>;
  /** Идентификатор системы заданий */
  taskSetId: Scalars['ID']['output'];
  /** Название системы заданий */
  taskSetName: Scalars['String']['output'];
  /** Название учебного модуля */
  title: Scalars['String']['output'];
  /** Количество учебных заданий в системе заданий модуля */
  trainingTaskCount?: Maybe<Scalars['Int']['output']>;
  /** Тип системы заданий */
  type: PlaylistType;
};

/** Набор слотов внутри Набора Заданий */
export type TaskSetSlot = {
  __typename?: 'TaskSetSlot';
  /** Идентификатор Элемента Цели, по которому создан этот Слот */
  goalElementId: Scalars['ID']['output'];
  /** Идентификатор (base_playlist_slots.base_playlist_slot_id или teacher_playlist_slots.teacher_playlist_slot_id) */
  id: Scalars['ID']['output'];
  /** Флаг - Слот для проверочных Заданий */
  isCheck: Scalars['Boolean']['output'];
  /** Минимальное количество Заданий, которое необходимо выполнить */
  minimumNumberOfTasks: Scalars['Int']['output'];
  /** Идентификатор (base_playlist_slots.base_playlist_slot_id или teacher_playlist_slots.teacher_playlist_slot_id) */
  slotId: Scalars['ID']['output'];
  /** тип слота */
  slotType?: Maybe<PlaylistSlotTypeEnum>;
  /** Задания внутри Слота */
  tasks: Array<TaskIntoSlot>;
};

export type TaskSetSlotInput = {
  check: Scalars['Boolean']['input'];
  goalElementId: Scalars['ID']['input'];
  minimumNumberOfTasks: Scalars['Int']['input'];
  /** тип слота */
  slotType?: InputMaybe<PlaylistSlotTypeEnum>;
  tasks: Array<TaskIntoSlotInput>;
};

/** Группа гибких навыков в связке с весом */
export type TaskSoftSkillType = {
  __typename?: 'TaskSoftSkillType';
  /** В архиве */
  archive: Scalars['Boolean']['output'];
  /** Категория */
  category: SoftSkillCategoryEnum;
  /** Код */
  code: Scalars['String']['output'];
  /** Описание */
  description: Scalars['String']['output'];
  /** Дескриптор */
  descriptor: Scalars['String']['output'];
  /** Группа */
  group: SoftSkillGroupEnum;
  /** Цветовая кодировка */
  hueSaturationLightness: Scalars['String']['output'];
  /** Идентификатор */
  id: Scalars['ID']['output'];
  /** Относительное ссылка в файловый сервис на изображением мягкого навыка */
  imageUrl: Scalars['String']['output'];
  /** Наименование */
  name: Scalars['String']['output'];
  /** Вес (временно int - для интеграции с фронтом, верный тип double) */
  power: Scalars['Int']['output'];
  /** Идентификатор гибкого навыка */
  softSkillTypeId: Scalars['ID']['output'];
  /** Идентификатор задания */
  taskId: Scalars['ID']['output'];
};

/** S21. Тип загружаемого решения */
export enum TaskSolutionTypeEnum {
  Gitlab = 'GITLAB',
  Platform = 'PLATFORM'
}

/**
 * Входные параметры <идентификатор студента, идентифкатор задания, новый статус задания, новый статус ответа>
 * в рамках миграции этому студенту будет проставлен новый статус зтого задания и новый статус ответа на это задание
 */
export type TaskStatusAndAnswerStatusForChangeInput = {
  newAnswerStatus: AnswerStatusEnum;
  newTaskStatus: TaskStatusEnum;
  /** edu_power_global.students.student_id */
  studentId: Scalars['UUID']['input'];
  /** edu_power_content.tasks.task_id */
  taskId: Scalars['ID']['input'];
};

export enum TaskStatusEnum {
  /** Задание зачтено */
  Accepted = 'ACCEPTED',
  /** Назначено */
  Assigned = 'ASSIGNED',
  /** Задание провалено */
  Failed = 'FAILED',
  /** Задание в работе (прохождение тренажера) */
  InProgress = 'IN_PROGRESS',
  /** Требуется проверка учителем */
  NeedCheck = 'NEED_CHECK',
  /** Задание провалено, но у пользователя есть еще попытки его пройти */
  TryAgain = 'TRY_AGAIN'
}

/** Тип содержит количество заданий с определенным статусом и количество заданий с вопросом от ученика */
export type TaskStatusQuantityWithQuestion = {
  __typename?: 'TaskStatusQuantityWithQuestion';
  /** количество заданий с вопросом от ученика */
  questionsQuantity: Scalars['Int']['output'];
  /** Количество заданий в определенном статусе */
  statusesQuantity: Array<TaskStatusWithQuantity>;
};

/** Количество заданий с определенным статусом */
export type TaskStatusWithQuantity = {
  __typename?: 'TaskStatusWithQuantity';
  /** Количество заданий по этому статусу */
  quantity: Scalars['Int']['output'];
  /** Статус задания */
  taskStatus?: Maybe<TaskStatusEnum>;
};

/** Информация о типах заданий */
export type TaskType = {
  __typename?: 'TaskType';
  /** ID */
  id: Scalars['ID']['output'];
  /** Название типа */
  name: Scalars['String']['output'];
  /** Тип задния */
  type: TaskTypeEnum;
};

export enum TaskTypeEnum {
  /** Проверочное */
  Check = 'CHECK',
  /** Мотивационное */
  Motivation = 'MOTIVATION',
  /** Теория */
  Theory = 'THEORY',
  /** Учебное */
  Training = 'TRAINING'
}

/** Статус ответа на виджет */
export enum TaskWidgetAnswerStatusEnum {
  /** Правильно */
  Accepted = 'ACCEPTED',
  /** Создан */
  Created = 'CREATED',
  /** Неправильно */
  Rejected = 'REJECTED'
}

/** Статус виджета задания пользователя */
export enum TaskWidgetStatusEnum {
  /** Ответил правильно */
  Accepted = 'ACCEPTED',
  /** Не отвечал */
  Assigned = 'ASSIGNED',
  /** Ответил неправильно */
  Failed = 'FAILED',
  /** На проверке */
  NeedCheck = 'NEED_CHECK'
}

/** Задание с колличеством студентов группы выполнивших его */
export type TaskWithCompletedByStudentsInGroupAttribute = {
  __typename?: 'TaskWithCompletedByStudentsInGroupAttribute';
  /** Колличество студентов группы выполнивших его */
  quantityOfStudentsInGroupCompletedThisTask: Scalars['Int']['output'];
  /** Задание */
  task: Task;
};

export type TaskWithCounters = {
  __typename?: 'TaskWithCounters';
  countStudentAnswers: Scalars['Int']['output'];
  countUnreadMessages: Scalars['Int']['output'];
  isExpired3Days: Scalars['Boolean']['output'];
  isExpired7Days: Scalars['Boolean']['output'];
  minExpiredDate?: Maybe<Scalars['Date']['output']>;
  studentAnswerIds?: Maybe<Array<Scalars['ID']['output']>>;
  task: Task;
};

/** тип агрегированных данных из плана обучения, который связывает задание и его уровень цели у студента. Такакая агрегация нужна для шторы офлайн заданий */
export type TaskWithLevel = {
  __typename?: 'TaskWithLevel';
  /** Уровень цели по заданию у студента */
  level: Scalars['Float']['output'];
  /** Задание */
  task: StudentTask;
};

/** Количество заданий по уровню цели */
export type TasksCountByGoalLevel = {
  __typename?: 'TasksCountByGoalLevel';
  goalLevelValueId: Scalars['Int']['output'];
  goalLevelValueName: Scalars['String']['output'];
  tasksCount: Scalars['Int']['output'];
};

/** Количество заданий по типу проверки */
export type TasksCountByTaskCheckType = {
  __typename?: 'TasksCountByTaskCheckType';
  taskCheckType: Scalars['Int']['output'];
  taskCheckTypeDescription: Scalars['String']['output'];
  tasksCount: Scalars['Int']['output'];
};

/** Данные по кол-ву заданий с разными типами проверки и уровнями целей */
export type TasksCountInfo = {
  __typename?: 'TasksCountInfo';
  tasksCountByGoalLevels: Array<TasksCountByGoalLevel>;
  tasksCountByTaskCheckTypes: Array<TasksCountByTaskCheckType>;
};

export type TasksOnCheck = {
  __typename?: 'TasksOnCheck';
  goalId?: Maybe<Scalars['Int']['output']>;
  goalName?: Maybe<Scalars['String']['output']>;
  stageGroup: Scalars['String']['output'];
  stageSubjectGroup: Scalars['String']['output'];
  stageSubjectGroupId?: Maybe<Scalars['Int']['output']>;
  subjectId?: Maybe<Scalars['Int']['output']>;
  subjectName: Scalars['String']['output'];
  tasksOnCheck: Scalars['Int']['output'];
  teacherId: Scalars['UUID']['output'];
  teacherName?: Maybe<Scalars['String']['output']>;
};

export type TasksOnCheckInput = {
  endDate: Scalars['DateTime']['input'];
  reportDate?: InputMaybe<Scalars['DateTime']['input']>;
  stageGroupId?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageSubjectGroupId?: InputMaybe<Scalars['Int']['input']>;
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  taskAnswerEndDate?: InputMaybe<Scalars['DateTime']['input']>;
  taskAnswerStartDate?: InputMaybe<Scalars['DateTime']['input']>;
  teacherId?: InputMaybe<Scalars['UUID']['input']>;
};

export type TasksWithCount = {
  __typename?: 'TasksWithCount';
  /** Общее количество заданий */
  count: Scalars['Int']['output'];
  /** Список заданий на страницу (используется в запросах с пагинацией) */
  tasks: Array<Task>;
};

/** Учитель */
export type Teacher = {
  __typename?: 'Teacher';
  /** Кабинет учителя */
  classroom?: Maybe<ClassRoom>;
  /** @deprecated Используйте classroom */
  classrooms: Array<ClassRoom>;
  /** ID учителя (teacherId) */
  id: Scalars['ID']['output'];
  /** Список предметов учителя, которые он может преподавать */
  subjects: Array<Subject>;
  /** Учитель как пользователь */
  user: User;
};

export type TeacherCommentInfo = {
  __typename?: 'TeacherCommentInfo';
  /** Аватар Учителя */
  teacherAvatarUrl: Scalars['String']['output'];
  /** Комментарий Учителя при зачтении Уровня */
  teacherComment: Scalars['String']['output'];
  /** Имя и Фамилия Учителя */
  teacherFullName: Scalars['String']['output'];
};

/** Общая информация по учителю */
export type TeacherCommonInfo = {
  __typename?: 'TeacherCommonInfo';
  teacherId: Scalars['UUID']['output'];
  userId: Scalars['UUID']['output'];
};

/** Модель для расписания учителя */
export type TeacherDiary = {
  __typename?: 'TeacherDiary';
  /** перечень уроков */
  lessons: Array<TeacherDiaryLesson>;
  userEvents: Array<TeacherDiaryEvent>;
};

/** Элемент события для расписания учителя */
export type TeacherDiaryEvent = {
  __typename?: 'TeacherDiaryEvent';
  /** Признак события на весь день */
  allDayEvent: Scalars['Boolean']['output'];
  /** Категория события */
  calendarEventCategory?: Maybe<CalendarEventCategory>;
  /** Временная метка создания события */
  createdTs?: Maybe<Scalars['DateTime']['output']>;
  /** Идентификатор пользователя - создателя события */
  creatorId?: Maybe<Scalars['UUID']['output']>;
  /** Описание события */
  description?: Maybe<Scalars['String']['output']>;
  /** Дата и время окончания события */
  endTime: Scalars['DateTime']['output'];
  /** Тип события */
  eventType?: Maybe<CalendarEventType>;
  /** Идентификатор события */
  id: Scalars['ID']['output'];
  /** Местонахождение (локация) */
  location: Scalars['String']['output'];
  /** Название события */
  name: Scalars['String']['output'];
  /** Идентификатор основного повторяющегося события для события-исключения из правила */
  parentCalendarEventId?: Maybe<Scalars['UUID']['output']>;
  /** Идентификатор типа групп, которые могут быть участниками события */
  participantGroupTypeId?: Maybe<Scalars['UUID']['output']>;
  /** До какого числа действует правило для повторяющегося события */
  recurrenceEndTs?: Maybe<Scalars['DateTime']['output']>;
  /** Правило для повторяющегося события */
  recurrenceRule?: Maybe<Scalars['String']['output']>;
  /** Дата и время начала события */
  startTime: Scalars['DateTime']['output'];
};

/** Элемент расписания(урок) учителя */
export type TeacherDiaryLesson = {
  __typename?: 'TeacherDiaryLesson';
  /** Название (номер) кабинета */
  classRoomName: Scalars['String']['output'];
  /** Дата и время окончания */
  endTs: Scalars['DateTime']['output'];
  /** Признак контрольной на уроке */
  hasControlWork: Scalars['Boolean']['output'];
  /** Идентификатор урока */
  lessonId: Scalars['ID']['output'];
  /** Модуль по предмету, соответствующий плану */
  module?: Maybe<StudentDiaryModule>;
  /** Номер элемента в расписании (урока) */
  number: Scalars['String']['output'];
  /** Признак online урока */
  onlineLesson: Scalars['Boolean']['output'];
  /** Ссылка на онлайн-урок */
  onlineLessonLink?: Maybe<Scalars['String']['output']>;
  /** План урока */
  plan?: Maybe<TeacherDiaryLessonPlan>;
  /** Наименование класса */
  stageGroupName: Scalars['String']['output'];
  /** Идентификатор группы по предмету */
  stageSubjectGroupId: Scalars['ID']['output'];
  /** Дата и время начала */
  startTs: Scalars['DateTime']['output'];
  /** Предмет */
  subject: Subject;
  /** Название расписания(группы временных слотов) */
  timeslotName?: Maybe<Scalars['String']['output']>;
};

/** План урока для расписания учителя */
export type TeacherDiaryLessonPlan = {
  __typename?: 'TeacherDiaryLessonPlan';
  /** Идентификатор плана */
  id?: Maybe<Scalars['ID']['output']>;
  /** Название плана */
  name?: Maybe<Scalars['String']['output']>;
};

export type TeacherMonitoring = {
  __typename?: 'TeacherMonitoring';
  entries?: Maybe<Array<SchoolMonitoringEntry>>;
  level: Scalars['Int']['output'];
  metricCode?: Maybe<Scalars['String']['output']>;
  metricName: Scalars['String']['output'];
  orderNumber: Scalars['Int']['output'];
  totalUniqueCount: Scalars['Int']['output'];
};

export type TeacherMutations = {
  __typename?: 'TeacherMutations';
  /** Ответ принят, задание зачтено */
  acceptStudentAnswer: StudentTaskInfo;
  /** Выдать награду ученику */
  addAward: UserAward;
  addBadge?: Maybe<Scalars['Boolean']['output']>;
  addCookies: Scalars['Int']['output'];
  /** добавить итоговую оценку в электронный журнал */
  addJournalFinalStudentMark: JournalFinalStudentMark;
  /** добавить итоговую оценку в электронный журнал */
  addJournalFinalStudentMarkV4: UpdatedJournalFinalStudentMark;
  addJournalStudentMark: JournalStudentMark;
  addLessonLearningActivity?: Maybe<LessonLearningActivity>;
  /** Перенос плана урока в архив */
  addLessonPlanToArchive?: Maybe<Scalars['Boolean']['output']>;
  /** Добавить заметку к плану урока */
  addNoteToLessonPlan: LessonNoteToLessonPlan;
  /** Добавить ссылку на онлайн-урок ко всем будущим урокам по этому предмету-классу-учителю */
  addOnlineLessonForAllFutureLessons: Scalars['Int']['output'];
  /** Добавить ссылку на онлайн-урок к плану урока */
  addOnlineLessonToLessonPlan: OnlineLessonToLessonPlan;
  /** Создание заметок */
  addOrUpdateNotes?: Maybe<Scalars['Int']['output']>;
  /** Добавить тему к плану урока */
  addTopicToLessonPlan: LessonTopicToLessonPlan;
  /** Добавить Вариант в Контрольную Работу Группы по Предмету */
  addVariantToControlWork: ClassSubjectControlWork;
  /** Назначить Варианты Контрольной Работы Группы по Предмету на Студентов */
  assignControlWorkToStudentsInSubgroup: Array<PersonalControlWork>;
  /** Назначить Набор Заданий на Студента */
  assignTaskSetToStudent: AssignTaskSetToStudentResponse;
  /** Добавить файл во внешнюю работу */
  attachExternalWorkFile: ExternalWork;
  attachTaskMessageFile: File;
  /**
   * Изменение Плана на Класс по Предмету по идентификатору (stage_subject_group_plan_id) с проверками.
   * в случае isNeedToCheckAffecting = true план будет изменен только если не изменился целевой уровень ни одного модуля
   * к выполнению которого приступил ученик, при isNeedToCheckAffecting = false план будет изменен в любом случае
   */
  changeClassPlanWithChecking: ClassPlanChangeResponse;
  /** Изменяет статус Контрольной работы для Группы по Предмету. */
  changeControlWorkStatus: ClassSubjectControlWork;
  /** Переименовать внешнюю работу */
  changeExternalWorkName: ExternalWork;
  /**
   * Заменяет активность на уроке, привязанные к ней оценки
   * выполняет пересчет средних оценок в уч. периоде по всем затронутым ученикам
   * проверка если к активности привязаны активные оценки выполнение метода прерывается если skipCheck != true
   */
  changeLessonLearningActivity: ChangeLessonLearningActivityResult;
  /** Изменить заметку к плану урока */
  changeLessonNoteToLessonPlan: LessonNoteToLessonPlan;
  /** Изменить тему к плану урока */
  changeLessonTopicToLessonPlan: LessonTopicToLessonPlan;
  /** Изменить ссылку на онлайн-урок к плану урока */
  changeOnlineLessonToLessonPlanLink: OnlineLessonToLessonPlan;
  /**
   * Изменение персонального плана по идентификатору (personal_subject_plans.personal_subject_plan_id) с проверками.
   * в случае isNeedToCheckAffecting = true план будет изменен только если не изменился целевой уровень ни одного модуля
   * к выполнению которого приступил ученик, при isNeedToCheckAffecting = false план будет изменен в любом случае
   */
  changePersonalPlanWithChecking: PersonalPlanChangeResponse;
  /**
   * Bootcamp - changePersonalPlanWithChecking
   * @deprecated same with changePersonalPlanWithChecking
   */
  changePersonalPlanWithCheckingForBTC: PersonalPlanChangeResponse;
  /** Изменение учителем статуса задания с типом контента дженерик */
  changeStudentGenericTaskStatus: StudentTaskInfo;
  /** Изменение учителем статусов заданий с типом контента дженерик */
  changeStudentGenericTaskStatuses: ChangeStudentTaskStatusesResponse;
  /** Изменить необходимый Уровень для достижения Учебного Модуля */
  changeStudentModuleGoalLevelForAchieve: ChangeStudentModuleGoalLevelForAchieveResponse;
  /** Изменить трудоемкость и даты Учебного Модуля Студента */
  changeStudentModuleLaboriousnessAndDates: ChangeStudentModuleLaboriousnessAndDatesResponse;
  /**
   * Изменить состав Подгруппы по идентификатору Подгруппы (stage_subject_subgroups.stage_subject_subgroup_id)
   * и идентфикаторам ВСЕХ студентов(students.student_id), которые должны в итоге оказаться в Подгруппе
   * а также изменить название Подгруппы (stage_subject_subgroups.name)
   */
  changeSubgroup: ClassSubject;
  /** Изменяет статус задания в контексте студента */
  changeTaskProgressStatus: StudentTaskInfo;
  /** Изменение существующего Набора Заданий */
  changeTaskSet: StudyModule;
  /** Изменить имя Набора Заданий */
  changeTaskSetName: TaskSet;
  /** Изменить Слот Набора Заданий */
  changeTaskSetSlot: ChangeTaskSetSlotResponse;
  /** Изменить несколько Слотов Набора Заданий */
  changeTaskSetSlots: ChangeTaskSetSlotsResponse;
  changeTaskSetSlotsV2: ChangeTaskSetSlotsResponse;
  /** Стиражировать Базовый Плейлист */
  copyBasePlaylist: TaskSet;
  /** Стиражировать групповой План на Группы по Предмету или на Студентов как персональный */
  copyClassPlan: ClassPlan;
  /** Копирует Контрольную работу для Группы по Предмету. Возвращает копию Контрольной Работы */
  copyControlWork: ClassSubjectControlWork;
  /**
   * Копирование модуля, возвращает скопированный модуль
   * @deprecated Под удаление. Использовать новую схему content.graphqls, метод copyModule
   */
  copyModule: StudyModule;
  /** Стиражировать Персональный План на Группы по Предмету или на Студентов */
  copyPersonalPlan: PersonalPlan;
  /** Стиражировать Учительский Плейлист */
  copyTeacherTaskSet: TaskSet;
  /** Стиражировать Учительский Плейлист */
  copyTeacherTaskSetV2: TaskSet;
  /** Создание Плана на Класс по Предмету с назначением плану определенного статуса(stage_subject_group_plans) */
  createClassPlan: ClassPlan;
  /** Создает Контрольную Работу для Учебного Модуля */
  createControlWorkForModule: ClassSubjectControlWork;
  /** Создание Пустого Набора Заданий для Учебного Модуля */
  createEmptyTaskSet: TaskSet;
  createEmptyTaskSetV2: TaskSet;
  /** Создать внешнюю работу */
  createExternalWork: StudentInSubgroup;
  /** Создать и тиражировать внешнюю работу на всех учеников в классе */
  createExternalWorkForClassSubject: Array<Maybe<StudentStageSubjectStudyPeriod>>;
  /** Создать рекомендацию к поурочному планированию */
  createLessonPlanRecommendation: LessonPlanRecommendation;
  /**
   * Создание Персонального Плана по идентификатору Студента внутри Группы по Предмету(stage_subject_subgroup_students.stage_subject_subgroup_student_id)
   *  c проверками. в случае isNeedToCheckAffecting = true план будет создан только если
   * в результате создания персонального плана не изменится целевой уровень ни одного модуля к выполнению которого приступил ученик,
   *  при isNeedToCheckAffecting = false план будет создан в любом случае
   *  startDate - планируемая дата начала выполнения персонального
   *  endDate - планируемая дата окончания выполнения персонального
   */
  createPersonalPlanWithChecking: PersonalPlanChangeResponse;
  /**
   * Создание Персонального Плана по идентификатору Студента внутри Группы по Предмету(stage_subject_subgroup_students.stage_subject_subgroup_student_id)
   * c проверками и без учета наличия плана на класс.
   * в случае isNeedToCheckAffecting = true план будет создан только если
   * в результате создания персонального плана не изменится целевой уровень ни одного модуля к выполнению которого приступил ученик,
   * при isNeedToCheckAffecting = false план будет создан в любом случае
   * startDate - планируемая дата начала выполнения персонального
   * endDate - планируемая дата окончания выполнения персонального
   */
  createPersonalPlanWithCheckingWithoutClassPlan: PersonalPlanChangeResponse;
  /**
   * Создать Подгруппу по идентификатору Группы по Предмету (stage_subject_groups.stage_subject_group_id)
   *  присвоить ей имя, и добавить в нее студентов по идентификаторам студентов (students.student_id)
   */
  createSubgroup: ClassSubject;
  /** Создать сообщение к заданию */
  createTaskMessage: TaskMessage;
  /** Создать факты прочтения комментариев */
  createTaskMessageReadFacts: Array<TaskMessageReadFact>;
  /**
   * Создать Слот Набора Заданий
   * @deprecated Will be deleted in 0.15.0
   */
  createTaskSetSlot: CreateTaskSetSlotResponse;
  /** Создать Учительский Плейлист, скопировав другой Плейлист (Базовый или Учительский) */
  createTeacherTaskSetFromAnotherTaskSet: TaskSet;
  createTeacherTaskSetFromAnotherTaskSetV2: TaskSet;
  createWebinarRuWebinar: Scalars['String']['output'];
  deattachTaskMessageFile: Scalars['ID']['output'];
  /** Удаление архивных планов урока учителя */
  deleteArchivedLessonPlans?: Maybe<Scalars['Boolean']['output']>;
  /** Удалить заметку к уроку */
  deleteLessonNote: Scalars['Boolean']['output'];
  /** Удаление плана урока */
  deleteLessonPlan?: Maybe<Scalars['Boolean']['output']>;
  /** Удаление плана урока */
  deleteLessonPlanById?: Maybe<Scalars['Boolean']['output']>;
  /** удалить мотивационный блок по id модуля */
  deleteMotivationBlockByModuleId: Scalars['Boolean']['output'];
  /** Создание заметок */
  deleteNotesByIds: Array<Note>;
  /** Удалить ссылки на онлайн-уроки по всем будущим урокам по этому предмету-классу-учителю */
  deleteOnlineLessonForAllFutureLessons: Scalars['Int']['output'];
  deletePortfolioDocuments: Scalars['Boolean']['output'];
  /** Изменить сообщение к заданию и/или прикрепленные к сообщению файлы. */
  editTaskMessage: TaskMessage;
  /** Извлечение плана урока из архива */
  getLessonPlanFromArchive?: Maybe<Scalars['Boolean']['output']>;
  /** Отметить версию плана на класс просмотренной */
  markClassPlanVersionAsViewed: Scalars['Boolean']['output'];
  /** Пометить уведомления учителя как прочитанные в рамках задания и ученика */
  markNotificationsAsRead: Array<Notification>;
  /** Отметить версию персонального плана просмотренной */
  markPersonalPlanVersionAsViewed: Scalars['Boolean']['output'];
  /** Пометить сообщение к заданию как удаленное */
  markTaskMessageAsRemoved: TaskMessage;
  /**
   * Персонализировать Учебный Модуль студента
   * @deprecated Will be deleted in 0.15.0
   */
  personalizeStudentModuleAndChangeTeacherTaskSets: PersonalizeStudentModuleAndChangeTeacherTaskSetsResponse;
  /** @deprecated Will be deleted in 0.15.0 */
  personalizeStudentModuleAndChangeTeacherTaskSetsV2: PersonalizeStudentModuleAndChangeTeacherTaskSetsResponse;
  /** Опубликовать план урока */
  publishLessonPlan: LessonPlanPublishingResult;
  readAllNotifications: Scalars['Boolean']['output'];
  /** Пометить прочитанными все Уведомления связанные с изменениями расписания для данного Учителя */
  readChangeScheduleNotifications: Scalars['Boolean']['output'];
  readNotification: Scalars['ID']['output'];
  /** Ответ не принят, задание провалено */
  rejectStudentAnswer: StudentTaskInfo;
  /** Удаляет Контрольную работу для Группы по Предмету */
  removeControlWork: ClassSubjectControlWork;
  /** Удалить вариант из Контрольной Работы Группы по Предмету */
  removeControlWorkVariant: ControlWorkVariantRemoveResult;
  /** Удалить внешнюю работу */
  removeExternalWork: StudentInSubgroup;
  /** Удалить файл из внешней работы */
  removeExternalWorkFile: Scalars['ID']['output'];
  /**
   * Удаляет активность на уроке, привязанные к ней оценки
   * выполняет пересчет средних оценок в уч. периоде по всем затронутим ученикам, если были удалены активные оценки
   * проверка если к активности привязаны активные оценки выполнение метода прерывается если skipCheck != true
   */
  removeLessonLearningActivity: RemoveLessonLearningActivityRespose;
  /** Удаление модулей из Плана на Класс по Предмету по идентификатору (stage_subject_group_plan_id) с проверками */
  removeModulesFromPlan: ClassPlanChangeResponse;
  /**
   * Удаляет существующий персональный план ученика c проверками. в случае isNeedToCheckAffecting = true план будет удален только если
   * в результате удаления персонального плана не изменится целевой уровень ни одного модуля к выполнению которого приступил ученик,
   *  при isNeedToCheckAffecting = false план будет удален в любом случае
   */
  removePersonalPlanWithChecking: PersonalPlanChangeResponse;
  /** Удалить Подгруппу по идентфикатору Подгруппы (stage_subject_subgroups.stage_subject_subgroup_id) */
  removeSubgroup: ClassSubject;
  /**
   * Удаление Плейлиста по идентификатору (base_playlists.base_playlist_id)
   * @deprecated Use removeTaskSetWithChecking instead. Will be deleted in 0.12.0
   */
  removeTaskSet: Scalars['Boolean']['output'];
  /** Удаление Плейлиста по идентификатору с проверками (base_playlists.base_playlist_id или teacher_playlists.teacher_playlist_id) */
  removeTaskSetWithChecking: RemoveTaskSetResponse;
  /** Удаление Плейлиста по идентификатору с проверками (base_playlists.base_playlist_id или teacher_playlists.teacher_playlist_id) */
  removeTaskSetWithCheckingV2: RemoveTaskSetResponse;
  /** Сбросить все назначения Варинтов Контрольной Работы на Группу по Предмету */
  resetControlWorkAssignments: ClassSubjectControlWork;
  /** Создание и редактирование "Общей информации" о проекте */
  saveExamModuleGeneralInformation: ExamModuleGeneralInfo;
  /** Создание и редактирование мета информации о проекте */
  saveExamModuleSettings: ExamModuleSettings;
  /** Создание и редактирование "Заданий" проекта */
  saveExamModuleTasks: ExamModuleTasks;
  saveJournalFinalStudentMark: SaveJournalFinalStudentMark;
  /** Сохраняет комментарий учителя к уроку в журнале для ученика */
  saveJournalStudentComment: JournalStudentComment;
  saveJournalStudentMark: SaveJournalStudentMarkResponse;
  /** Сохранение плана урока */
  saveLessonPlan: LessonPlan;
  /** Сохранение списка планов модуля */
  saveLessonPlanList: Array<LessonPlan>;
  /** Сохранение плана урока */
  saveLessonPlanV4: LessonPlanV4;
  /** создание и редактирование модуля */
  saveModule: StudyModule;
  /** создание и редактирование мотивационного блока */
  saveMotivationBlock: MotivationBlock;
  /** создание и редактирование секций мотивационного блока */
  saveMotivationSection: MotivationBlockSection;
  saveOrUpdatePortfolioDocument?: Maybe<PortfolioDocument>;
  /** Изменение статуса Плана на Класс По Предмету */
  setClassPlanStatus: ClassPlan;
  /** Устанавливает продолжительность в минутах Контрольной Работы для Группы по Предмету */
  setControlWorkDuration: ClassSubjectControlWork;
  /** Устанавливает дату и время запланированного начала Контрольной Работы для Группы по Предмету */
  setControlWorkPlanTime: ClassSubjectControlWork;
  /** Устанавливает флаг видимости Контрольной Работы для Группы по Предмету */
  setControlWorkVisibleFlag: ClassSubjectControlWork;
  /** Установить оценку за внешнюю работу */
  setExternalWorkMark: StudentInSubgroup;
  setGoalLandingTemplateAttributes: Scalars['Boolean']['output'];
  /** @deprecated Use saveModule instead. Will be deleted in 0.13.0 */
  setModuleLevels: StudyModule;
  /** Поставить оценку за Контрольную Работу */
  setPersonalControlWorkMark: PersonalControlWork;
  /** Изменение статуса Персонального Плана по Идентификатору (personal_subject_plans.personal_subject_plan_id) */
  setPersonalPlanStatus: PersonalPlan;
  /** Установить оценку за модуль */
  setStudentModuleMark: StudentModule;
  /** Установить оценку за убеный период */
  setStudentStageSubjectStudyPeriodMark: StudentInSubgroup;
  /** Установить годовую оценку */
  setStudentYearMark: StudentInSubgroup;
  /** Установить/снять флаг "Архив" для учебных модулей */
  setStudyModuleArchiveFlag: Array<StudyModule>;
  setTaskCriteriaConformity: Array<StudentCriteriaValue>;
  setTaskCriteriaConformityForStudentTasks: Array<SetTaskCriteriaConformityForStudentTasksResponse>;
  /**
   * Установить соответствие критерию
   * @deprecated Field no longer supported
   */
  setTaskCriteriaValue: StudentCriteriaValue;
  /**
   * Подтвердить соответствие критериям
   * @deprecated Field no longer supported
   */
  setTaskCriteriaValueConfirm: Scalars['Boolean']['output'];
  /** Расшарить план урока */
  shareLessonPlan?: Maybe<Scalars['Boolean']['output']>;
  /** Изменение статуса конкурса */
  startCheckStudentTask: StudentTask;
  stopCheckStudentTask: StudentTask;
  /** Снять с публикации плана урока */
  unpublishLessonPlan?: Maybe<Scalars['Boolean']['output']>;
  /** Отключить шару плана урока */
  unshareLessonPlan?: Maybe<Scalars['Boolean']['output']>;
  /** Создание заметок */
  updateCompleteness: Array<Maybe<Note>>;
  updateModuleGoalElements: StudyModule;
  updateModuleMeta: StudyModule;
  /** Изменение учителем статуса заявки на вступление в класс */
  updateStageGroupStudentRequest: StageGroupStudentRequest;
  /** Обновление статусов достигнутых навыков и уровней в модуле студента */
  updateStudentModuleAchievementAndComment: StudentModule;
  /** Обновление оценок по критериям */
  updateStudentTaskCriteriaAssessments: Array<EvaluatedTaskCriterion>;
};


export type TeacherMutationsAcceptStudentAnswerArgs = {
  answerId: Scalars['ID']['input'];
  criteriaEvaluations: Array<EvaluatedTaskCriterionInput>;
  governmentMarkId?: InputMaybe<Scalars['Int']['input']>;
  studentId: Scalars['ID']['input'];
};


export type TeacherMutationsAddAwardArgs = {
  awardId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type TeacherMutationsAddBadgeArgs = {
  badgeId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type TeacherMutationsAddCookiesArgs = {
  cookies: Scalars['Int']['input'];
  userId: Scalars['UUID']['input'];
};


export type TeacherMutationsAddJournalFinalStudentMarkArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  comment?: InputMaybe<Scalars['String']['input']>;
  markId?: InputMaybe<Scalars['ID']['input']>;
  stageSubjectGroupId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
  studyPeriodId?: InputMaybe<Scalars['ID']['input']>;
};


export type TeacherMutationsAddJournalFinalStudentMarkV4Args = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  comment?: InputMaybe<Scalars['String']['input']>;
  markId?: InputMaybe<Scalars['ID']['input']>;
  stageSubjectGroupId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
  studyPeriodId?: InputMaybe<Scalars['ID']['input']>;
};


export type TeacherMutationsAddJournalStudentMarkArgs = {
  comment?: InputMaybe<Scalars['String']['input']>;
  lessonLearningActivityId: Scalars['ID']['input'];
  markId?: InputMaybe<Scalars['ID']['input']>;
  needMark?: InputMaybe<Scalars['Boolean']['input']>;
  studentId: Scalars['ID']['input'];
  studyPeriodId?: InputMaybe<Scalars['ID']['input']>;
};


export type TeacherMutationsAddLessonLearningActivityArgs = {
  learningActivityId: Scalars['ID']['input'];
  lessonId: Scalars['ID']['input'];
};


export type TeacherMutationsAddLessonPlanToArchiveArgs = {
  lessonPlanId: Scalars['ID']['input'];
};


export type TeacherMutationsAddNoteToLessonPlanArgs = {
  newLessonNote: LessonNoteToLessonPlanInput;
};


export type TeacherMutationsAddOnlineLessonForAllFutureLessonsArgs = {
  onlineLessonLink: Scalars['String']['input'];
  stageSubjectGroupId: Scalars['ID']['input'];
  videoconferenceType: VideoconferenceType;
};


export type TeacherMutationsAddOnlineLessonToLessonPlanArgs = {
  newOnlineLesson: OnlineLessonToLessonPlanInput;
};


export type TeacherMutationsAddOrUpdateNotesArgs = {
  noteInputModels: Array<NoteInput>;
};


export type TeacherMutationsAddTopicToLessonPlanArgs = {
  newLessonTopic: LessonTopicToLessonPlanInput;
};


export type TeacherMutationsAddVariantToControlWorkArgs = {
  classSubjectControlWorkId: Scalars['ID']['input'];
  taskIds: Array<Scalars['ID']['input']>;
};


export type TeacherMutationsAssignControlWorkToStudentsInSubgroupArgs = {
  classSubjectControlWorkId: Scalars['ID']['input'];
  variantsToStudents: Array<AssignVariantToStudentRequest>;
};


export type TeacherMutationsAssignTaskSetToStudentArgs = {
  request: AssignTaskSetToStudentRequest;
};


export type TeacherMutationsAttachExternalWorkFileArgs = {
  externalWorkId: Scalars['ID']['input'];
  fileInput: FileInput;
};


export type TeacherMutationsAttachTaskMessageFileArgs = {
  file?: InputMaybe<FileInput>;
  messageId: Scalars['ID']['input'];
};


export type TeacherMutationsChangeClassPlanWithCheckingArgs = {
  frames: Array<ClassPlanFrameInput>;
  isNeedToCheckAffecting: Scalars['Boolean']['input'];
  planId: Scalars['ID']['input'];
};


export type TeacherMutationsChangeControlWorkStatusArgs = {
  classSubjectControlWorkId: Scalars['ID']['input'];
  newStatus: ControlWorkStatus;
};


export type TeacherMutationsChangeExternalWorkNameArgs = {
  externalWorkId: Scalars['ID']['input'];
  externalWorkName: Scalars['String']['input'];
};


export type TeacherMutationsChangeLessonLearningActivityArgs = {
  learningActivityId: Scalars['ID']['input'];
  lessonLearningActivityId: Scalars['ID']['input'];
  skipCheck?: InputMaybe<Scalars['Boolean']['input']>;
};


export type TeacherMutationsChangeLessonNoteToLessonPlanArgs = {
  noteId: Scalars['ID']['input'];
  text: Scalars['String']['input'];
};


export type TeacherMutationsChangeLessonTopicToLessonPlanArgs = {
  topic: Scalars['String']['input'];
  topicId: Scalars['ID']['input'];
};


export type TeacherMutationsChangeOnlineLessonToLessonPlanLinkArgs = {
  onlineLessonId: Scalars['ID']['input'];
  onlineLessonLink: Scalars['String']['input'];
  videoconferenceType: VideoconferenceType;
};


export type TeacherMutationsChangePersonalPlanWithCheckingArgs = {
  endDate?: InputMaybe<Scalars['String']['input']>;
  frames: Array<PersonalPlanFrameInput>;
  isNeedToCheckAffecting: Scalars['Boolean']['input'];
  orderNumber?: InputMaybe<Scalars['Int']['input']>;
  planId: Scalars['ID']['input'];
  startDate?: InputMaybe<Scalars['String']['input']>;
  trajectory?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherMutationsChangePersonalPlanWithCheckingForBtcArgs = {
  endDate?: InputMaybe<Scalars['String']['input']>;
  frames: Array<PersonalPlanFrameInput>;
  isNeedToCheckAffecting: Scalars['Boolean']['input'];
  orderNumber?: InputMaybe<Scalars['Int']['input']>;
  planId: Scalars['ID']['input'];
  startDate?: InputMaybe<Scalars['String']['input']>;
  trajectory: Scalars['String']['input'];
};


export type TeacherMutationsChangeStudentGenericTaskStatusArgs = {
  criteriaEvaluations: Array<EvaluatedTaskCriterionInput>;
  governmentMarkId?: InputMaybe<Scalars['Int']['input']>;
  studentTaskId: Scalars['ID']['input'];
  taskStatus: TaskStatusEnum;
};


export type TeacherMutationsChangeStudentGenericTaskStatusesArgs = {
  request: ChangeStudentTaskStatusesRequest;
};


export type TeacherMutationsChangeStudentModuleGoalLevelForAchieveArgs = {
  request: ChangeStudentModuleGoalLevelForAchieveRequest;
};


export type TeacherMutationsChangeStudentModuleLaboriousnessAndDatesArgs = {
  request?: InputMaybe<ChangeStudentModuleLaboriousnessAndDatesRequest>;
};


export type TeacherMutationsChangeSubgroupArgs = {
  name: Scalars['String']['input'];
  studentIds: Array<Scalars['UUID']['input']>;
  subgroupId: Scalars['ID']['input'];
};


export type TeacherMutationsChangeTaskProgressStatusArgs = {
  criteriaEvaluations: Array<EvaluatedTaskCriterionInput>;
  governmentMarkId?: InputMaybe<Scalars['ID']['input']>;
  studentId: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
  taskStatus: TaskStatusEnum;
};


export type TeacherMutationsChangeTaskSetArgs = {
  playlistType: PlaylistType;
  slots: Array<TaskSetSlotInput>;
  taskSetId: Scalars['ID']['input'];
};


export type TeacherMutationsChangeTaskSetNameArgs = {
  newName: Scalars['String']['input'];
  taskSetId: Scalars['ID']['input'];
  taskSetType: PlaylistType;
};


export type TeacherMutationsChangeTaskSetSlotArgs = {
  request: ChangeTaskSetSlotRequest;
};


export type TeacherMutationsChangeTaskSetSlotsArgs = {
  request: ChangeTaskSetSlotsRequest;
};


export type TeacherMutationsChangeTaskSetSlotsV2Args = {
  request: ChangeTaskSetSlotsRequest;
};


export type TeacherMutationsCopyBasePlaylistArgs = {
  basePlaylistId: Scalars['ID']['input'];
  classSubjectIds: Array<Scalars['ID']['input']>;
  excludePersonalPlansFromChangingClassPlan?: InputMaybe<Scalars['Boolean']['input']>;
  studentInSubgroupIds: Array<Scalars['ID']['input']>;
};


export type TeacherMutationsCopyClassPlanArgs = {
  classPlanId: Scalars['ID']['input'];
  classSubjectIds: Array<Scalars['ID']['input']>;
  status: PlanStatusEnum;
  studentInSubgroupIds: Array<Scalars['ID']['input']>;
};


export type TeacherMutationsCopyControlWorkArgs = {
  classSubjectControlWorkId: Scalars['ID']['input'];
};


export type TeacherMutationsCopyModuleArgs = {
  moduleId: Scalars['ID']['input'];
};


export type TeacherMutationsCopyPersonalPlanArgs = {
  classSubjectIds: Array<Scalars['ID']['input']>;
  personalPlanId: Scalars['ID']['input'];
  studentInSubgroupIds: Array<Scalars['ID']['input']>;
};


export type TeacherMutationsCopyTeacherTaskSetArgs = {
  classSubjectIds: Array<Scalars['ID']['input']>;
  excludePersonalPlansFromChangingClassPlan?: InputMaybe<Scalars['Boolean']['input']>;
  studentInSubgroupIds: Array<Scalars['ID']['input']>;
  teacherTaskSetId: Scalars['ID']['input'];
};


export type TeacherMutationsCopyTeacherTaskSetV2Args = {
  classSubjectIds: Array<Scalars['ID']['input']>;
  excludePersonalPlansFromChangingClassPlan?: InputMaybe<Scalars['Boolean']['input']>;
  studentInSubgroupIds: Array<Scalars['ID']['input']>;
  teacherTaskSetId: Scalars['ID']['input'];
};


export type TeacherMutationsCreateClassPlanArgs = {
  classSubjectId: Scalars['ID']['input'];
  frames: Array<ClassPlanFrameInput>;
  status?: InputMaybe<PlanStatusEnum>;
};


export type TeacherMutationsCreateControlWorkForModuleArgs = {
  moduleId: Scalars['ID']['input'];
};


export type TeacherMutationsCreateEmptyTaskSetArgs = {
  taskSet: TaskSetInput;
};


export type TeacherMutationsCreateEmptyTaskSetV2Args = {
  taskSet: TaskSetInput;
};


export type TeacherMutationsCreateExternalWorkArgs = {
  externalWorkInput: ExternalWorkInput;
};


export type TeacherMutationsCreateExternalWorkForClassSubjectArgs = {
  classSubjectId: Scalars['ID']['input'];
  name: Scalars['String']['input'];
  studyPeriodId: Scalars['ID']['input'];
};


export type TeacherMutationsCreateLessonPlanRecommendationArgs = {
  lessonPlanRecommendation: LessonPlanRecommendationInput;
  moduleId: Scalars['ID']['input'];
};


export type TeacherMutationsCreatePersonalPlanWithCheckingArgs = {
  endDate?: InputMaybe<Scalars['String']['input']>;
  frames: Array<PersonalPlanFrameInput>;
  isNeedToCheckAffecting: Scalars['Boolean']['input'];
  orderNumber?: InputMaybe<Scalars['Int']['input']>;
  startDate?: InputMaybe<Scalars['String']['input']>;
  status: PlanStatusEnum;
  studentInSubgroupId: Scalars['ID']['input'];
  trajectory?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherMutationsCreatePersonalPlanWithCheckingWithoutClassPlanArgs = {
  endDate?: InputMaybe<Scalars['String']['input']>;
  frames: Array<PersonalPlanFrameInput>;
  isNeedToCheckAffecting: Scalars['Boolean']['input'];
  orderNumber?: InputMaybe<Scalars['Int']['input']>;
  startDate?: InputMaybe<Scalars['String']['input']>;
  status: PlanStatusEnum;
  studentInSubgroupId: Scalars['ID']['input'];
  trajectory?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherMutationsCreateSubgroupArgs = {
  classSubjectId: Scalars['ID']['input'];
  name: Scalars['String']['input'];
  studentIds: Array<Scalars['UUID']['input']>;
};


export type TeacherMutationsCreateTaskMessageArgs = {
  files: Array<FileInput>;
  readOnly?: InputMaybe<Scalars['Boolean']['input']>;
  studentId: Scalars['UUID']['input'];
  taskId: Scalars['ID']['input'];
  text: Scalars['String']['input'];
};


export type TeacherMutationsCreateTaskMessageReadFactsArgs = {
  messageIds: Array<Scalars['ID']['input']>;
};


export type TeacherMutationsCreateTaskSetSlotArgs = {
  request: CreateTaskSetSlotRequest;
};


export type TeacherMutationsCreateTeacherTaskSetFromAnotherTaskSetArgs = {
  taskSetId: Scalars['ID']['input'];
  taskSetType: PlaylistType;
};


export type TeacherMutationsCreateTeacherTaskSetFromAnotherTaskSetV2Args = {
  taskSetId: Scalars['ID']['input'];
  taskSetType: PlaylistType;
};


export type TeacherMutationsCreateWebinarRuWebinarArgs = {
  lessonId?: InputMaybe<Scalars['ID']['input']>;
  lessonPlanId: Scalars['ID']['input'];
  roomTitle: Scalars['String']['input'];
  timeZone?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherMutationsDeattachTaskMessageFileArgs = {
  messageFileId: Scalars['ID']['input'];
};


export type TeacherMutationsDeleteLessonNoteArgs = {
  lessonNoteId: Scalars['ID']['input'];
};


export type TeacherMutationsDeleteLessonPlanArgs = {
  lessonPlanId: Scalars['ID']['input'];
};


export type TeacherMutationsDeleteLessonPlanByIdArgs = {
  lessonPlanId: Scalars['ID']['input'];
};


export type TeacherMutationsDeleteMotivationBlockByModuleIdArgs = {
  goalID: Scalars['ID']['input'];
};


export type TeacherMutationsDeleteNotesByIdsArgs = {
  noteIds: Array<Scalars['ID']['input']>;
};


export type TeacherMutationsDeleteOnlineLessonForAllFutureLessonsArgs = {
  stageSubjectGroupId: Scalars['ID']['input'];
};


export type TeacherMutationsDeletePortfolioDocumentsArgs = {
  portfolioDocumentIds: Array<InputMaybe<Scalars['UUID']['input']>>;
};


export type TeacherMutationsEditTaskMessageArgs = {
  files: Array<FileInput>;
  messageId: Scalars['ID']['input'];
  text: Scalars['String']['input'];
};


export type TeacherMutationsGetLessonPlanFromArchiveArgs = {
  lessonPlanId: Scalars['ID']['input'];
};


export type TeacherMutationsMarkClassPlanVersionAsViewedArgs = {
  classPlanVersionId: Scalars['ID']['input'];
};


export type TeacherMutationsMarkNotificationsAsReadArgs = {
  studentId: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
};


export type TeacherMutationsMarkPersonalPlanVersionAsViewedArgs = {
  personalPlanVersionId: Scalars['ID']['input'];
};


export type TeacherMutationsMarkTaskMessageAsRemovedArgs = {
  messageId: Scalars['ID']['input'];
};


export type TeacherMutationsPersonalizeStudentModuleAndChangeTeacherTaskSetsArgs = {
  request: PersonalizeStudentModuleAndChangeTeacherTaskSetsRequest;
};


export type TeacherMutationsPersonalizeStudentModuleAndChangeTeacherTaskSetsV2Args = {
  request: PersonalizeStudentModuleAndChangeTeacherTaskSetsRequest;
};


export type TeacherMutationsPublishLessonPlanArgs = {
  lessonPlanInput: LessonPlanV4Input;
};


export type TeacherMutationsReadNotificationArgs = {
  notificationId: Scalars['ID']['input'];
};


export type TeacherMutationsRejectStudentAnswerArgs = {
  answerId: Scalars['ID']['input'];
  criteriaEvaluations: Array<EvaluatedTaskCriterionInput>;
  finalTry: Scalars['Boolean']['input'];
  governmentMarkId?: InputMaybe<Scalars['Int']['input']>;
  studentId: Scalars['ID']['input'];
};


export type TeacherMutationsRemoveControlWorkArgs = {
  classSubjectControlWorkId: Scalars['ID']['input'];
};


export type TeacherMutationsRemoveControlWorkVariantArgs = {
  classSubjectControlWorkVariantId: Scalars['ID']['input'];
  isNeedToCheckAffecting: Scalars['Boolean']['input'];
};


export type TeacherMutationsRemoveExternalWorkArgs = {
  externalWorkId: Scalars['ID']['input'];
};


export type TeacherMutationsRemoveExternalWorkFileArgs = {
  fileId: Scalars['ID']['input'];
};


export type TeacherMutationsRemoveLessonLearningActivityArgs = {
  lessonLearningActivityId: Scalars['ID']['input'];
  skipCheck?: InputMaybe<Scalars['Boolean']['input']>;
};


export type TeacherMutationsRemoveModulesFromPlanArgs = {
  isNeedToCheckAffecting: Scalars['Boolean']['input'];
  moduleIdsToRemove: Array<Scalars['Int']['input']>;
  planId: Scalars['ID']['input'];
};


export type TeacherMutationsRemovePersonalPlanWithCheckingArgs = {
  isNeedToCheckAffecting: Scalars['Boolean']['input'];
  planId: Scalars['ID']['input'];
};


export type TeacherMutationsRemoveSubgroupArgs = {
  subgroupId: Scalars['ID']['input'];
};


export type TeacherMutationsRemoveTaskSetArgs = {
  taskSetId: Scalars['ID']['input'];
  taskSetType: PlaylistType;
};


export type TeacherMutationsRemoveTaskSetWithCheckingArgs = {
  request: RemoveTaskSetRequest;
};


export type TeacherMutationsRemoveTaskSetWithCheckingV2Args = {
  request: RemoveTaskSetRequest;
};


export type TeacherMutationsResetControlWorkAssignmentsArgs = {
  classSubjectControlWorkId: Scalars['ID']['input'];
};


export type TeacherMutationsSaveExamModuleGeneralInformationArgs = {
  generalInformation: ExamModuleGeneralInfoInput;
};


export type TeacherMutationsSaveExamModuleSettingsArgs = {
  moduleSettings: ExamModuleSettingsInput;
};


export type TeacherMutationsSaveExamModuleTasksArgs = {
  tasks: ExamModuleTasksInput;
};


export type TeacherMutationsSaveJournalFinalStudentMarkArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  comment?: InputMaybe<Scalars['String']['input']>;
  markId?: InputMaybe<Scalars['ID']['input']>;
  stageSubjectGroupId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
  studyPeriodId?: InputMaybe<Scalars['ID']['input']>;
};


export type TeacherMutationsSaveJournalStudentCommentArgs = {
  comment: Scalars['String']['input'];
  lessonId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type TeacherMutationsSaveJournalStudentMarkArgs = {
  comment?: InputMaybe<Scalars['String']['input']>;
  lessonLearningActivityId: Scalars['ID']['input'];
  markId?: InputMaybe<Scalars['ID']['input']>;
  needMark?: InputMaybe<Scalars['Boolean']['input']>;
  studentId: Scalars['ID']['input'];
  studyPeriodId?: InputMaybe<Scalars['ID']['input']>;
};


export type TeacherMutationsSaveLessonPlanArgs = {
  lessonPlanInput: LessonPlanInput;
};


export type TeacherMutationsSaveLessonPlanListArgs = {
  lessonPlanInput: Array<LessonPlanInput>;
};


export type TeacherMutationsSaveLessonPlanV4Args = {
  lessonPlanInput: LessonPlanV4Input;
};


export type TeacherMutationsSaveModuleArgs = {
  levels?: InputMaybe<Array<StudyModuleLevelInput>>;
  module?: InputMaybe<StudyModuleMetaInput>;
  moduleId?: InputMaybe<Scalars['ID']['input']>;
};


export type TeacherMutationsSaveMotivationBlockArgs = {
  motivationBlock: MotivationBlockInput;
};


export type TeacherMutationsSaveMotivationSectionArgs = {
  motivationSection: MotivationBlockSectionInput;
};


export type TeacherMutationsSaveOrUpdatePortfolioDocumentArgs = {
  categoryCode: Scalars['String']['input'];
  documentDate: Scalars['Date']['input'];
  documentName: Scalars['String']['input'];
  fields: Array<PortfolioDocumentFieldsInput>;
  files?: InputMaybe<Array<PortfolioDocumentFileInput>>;
  portfolioDocumentId?: InputMaybe<Scalars['UUID']['input']>;
  typeCode: Scalars['String']['input'];
};


export type TeacherMutationsSetClassPlanStatusArgs = {
  planId: Scalars['ID']['input'];
  status: PlanStatusEnum;
};


export type TeacherMutationsSetControlWorkDurationArgs = {
  classSubjectControlWorkId: Scalars['ID']['input'];
  duration: Scalars['Int']['input'];
};


export type TeacherMutationsSetControlWorkPlanTimeArgs = {
  classSubjectControlWorkId: Scalars['ID']['input'];
  planTime: Scalars['DateTime']['input'];
};


export type TeacherMutationsSetControlWorkVisibleFlagArgs = {
  classSubjectControlWorkId: Scalars['ID']['input'];
  visible: Scalars['Boolean']['input'];
};


export type TeacherMutationsSetExternalWorkMarkArgs = {
  externalWorkId: Scalars['ID']['input'];
  markId?: InputMaybe<Scalars['ID']['input']>;
  percentageMark?: InputMaybe<Scalars['Float']['input']>;
};


export type TeacherMutationsSetGoalLandingTemplateAttributesArgs = {
  attributes: StudyModuleLandingTemplateAttributesInput;
  moduleId: Scalars['ID']['input'];
};


export type TeacherMutationsSetModuleLevelsArgs = {
  levels: Array<StudyModuleLevelInput>;
  moduleId: Scalars['ID']['input'];
};


export type TeacherMutationsSetPersonalControlWorkMarkArgs = {
  markId: Scalars['ID']['input'];
  personalControlWorkId: Scalars['ID']['input'];
};


export type TeacherMutationsSetPersonalPlanStatusArgs = {
  planId: Scalars['ID']['input'];
  status: PlanStatusEnum;
};


export type TeacherMutationsSetStudentModuleMarkArgs = {
  markId?: InputMaybe<Scalars['ID']['input']>;
  moduleId: Scalars['ID']['input'];
  studentId: Scalars['ID']['input'];
};


export type TeacherMutationsSetStudentStageSubjectStudyPeriodMarkArgs = {
  markId?: InputMaybe<Scalars['ID']['input']>;
  stageSubjectId: Scalars['ID']['input'];
  studentId: Scalars['ID']['input'];
  studyPeriodId: Scalars['ID']['input'];
};


export type TeacherMutationsSetStudentYearMarkArgs = {
  classSubjectId: Scalars['ID']['input'];
  markId?: InputMaybe<Scalars['ID']['input']>;
  studentId: Scalars['ID']['input'];
};


export type TeacherMutationsSetStudyModuleArchiveFlagArgs = {
  archive: Scalars['Boolean']['input'];
  cascade?: InputMaybe<Scalars['Boolean']['input']>;
  studyModuleIds: Array<Scalars['ID']['input']>;
};


export type TeacherMutationsSetTaskCriteriaConformityArgs = {
  studentCriteriaValueWrappers?: InputMaybe<Array<StudentCriteriaValueInput>>;
};


export type TeacherMutationsSetTaskCriteriaConformityForStudentTasksArgs = {
  studentCriteriaValueWrappers: Array<StudentCriteriaValueInput>;
};


export type TeacherMutationsSetTaskCriteriaValueArgs = {
  criteriaId: Scalars['ID']['input'];
  criteriaValue: CriteriaValue;
  studentId: Scalars['ID']['input'];
};


export type TeacherMutationsSetTaskCriteriaValueConfirmArgs = {
  studentId: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
};


export type TeacherMutationsShareLessonPlanArgs = {
  lessonPlaId: Scalars['ID']['input'];
};


export type TeacherMutationsStartCheckStudentTaskArgs = {
  studentTaskId: Scalars['ID']['input'];
};


export type TeacherMutationsStopCheckStudentTaskArgs = {
  studentTaskId: Scalars['ID']['input'];
};


export type TeacherMutationsUnpublishLessonPlanArgs = {
  lessonPlanId: Scalars['ID']['input'];
};


export type TeacherMutationsUnshareLessonPlanArgs = {
  lessonPlanId: Scalars['ID']['input'];
};


export type TeacherMutationsUpdateCompletenessArgs = {
  isCompleted: Scalars['Boolean']['input'];
  noteId: Scalars['ID']['input'];
};


export type TeacherMutationsUpdateModuleGoalElementsArgs = {
  changedGoalElements: Array<StudyModuleGoalElementInput>;
  deletedGoalElementIds: Array<Scalars['ID']['input']>;
  moduleId: Scalars['ID']['input'];
};


export type TeacherMutationsUpdateModuleMetaArgs = {
  module: StudyModuleMetaInput;
  moduleId: Scalars['ID']['input'];
};


export type TeacherMutationsUpdateStageGroupStudentRequestArgs = {
  requestId: Scalars['ID']['input'];
  status: StageGroupStudentRequestStatus;
};


export type TeacherMutationsUpdateStudentModuleAchievementAndCommentArgs = {
  achievedGoalLevelIds: Array<Scalars['ID']['input']>;
  achievedSkillIds: Array<Scalars['ID']['input']>;
  comment?: InputMaybe<Scalars['String']['input']>;
  maxAchievedLevel?: InputMaybe<Scalars['Float']['input']>;
  moduleId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type TeacherMutationsUpdateStudentTaskCriteriaAssessmentsArgs = {
  criteriaEvaluations: Array<EvaluatedTaskCriterionInput>;
  studentTaskId: Scalars['ID']['input'];
};

/** Обзор обучения учителей 'Персонализированное образование' */
export type TeacherPersonalTraining = {
  __typename?: 'TeacherPersonalTraining';
  items: Array<TeacherPersonalTrainingItem>;
  scanDateTime?: Maybe<Scalars['DateTime']['output']>;
};

/**
 * Обзор обучения учителей 'Персонализированное образование' детальный
 * userRole: 0-PG_Configurator, 1-Configurator, 2-Teacher
 */
export type TeacherPersonalTrainingDetailed = {
  __typename?: 'TeacherPersonalTrainingDetailed';
  items: Array<TeacherPersonalTrainingDetailedItem>;
  scanDateTime?: Maybe<Scalars['DateTime']['output']>;
  userRole: Scalars['Int']['output'];
};

export type TeacherPersonalTrainingDetailedItem = {
  __typename?: 'TeacherPersonalTrainingDetailedItem';
  completedCultureOfPersonalEducation?: Maybe<Scalars['Boolean']['output']>;
  completedCultureOfPersonalEducationLevel3?: Maybe<Scalars['Boolean']['output']>;
  completedCultureOfPersonalEducationLevel4?: Maybe<Scalars['Boolean']['output']>;
  completedGoalsAndGrading: Scalars['Boolean']['output'];
  completedGoalsAndGradingLevel3: Scalars['Boolean']['output'];
  completedGoalsAndGradingLevel4: Scalars['Boolean']['output'];
  completedPersonalEducation: Scalars['Boolean']['output'];
  completedPersonalEducationLevel3: Scalars['Boolean']['output'];
  completedPersonalEducationLevel4: Scalars['Boolean']['output'];
  completedPersonalPotential?: Maybe<Scalars['Boolean']['output']>;
  completedPersonalPotentialLevel3?: Maybe<Scalars['Boolean']['output']>;
  completedPersonalPotentialLevel4?: Maybe<Scalars['Boolean']['output']>;
  completedTrainingModule: Scalars['Boolean']['output'];
  completedTrainingModuleLevel3: Scalars['Boolean']['output'];
  completedTrainingModuleLevel4: Scalars['Boolean']['output'];
  email?: Maybe<Scalars['String']['output']>;
  fio?: Maybe<Scalars['String']['output']>;
  identifier: Scalars['String']['output'];
  login?: Maybe<Scalars['String']['output']>;
  phoneNumber?: Maybe<Scalars['String']['output']>;
  region: Scalars['String']['output'];
  schoolName: Scalars['String']['output'];
};

export type TeacherPersonalTrainingItem = {
  __typename?: 'TeacherPersonalTrainingItem';
  activeConfiguratorsCount: Scalars['Int']['output'];
  activeTeachersCount: Scalars['Int']['output'];
  completedModule2TrainingModule: Scalars['Int']['output'];
  completedModule3GoalsAndGrading: Scalars['Int']['output'];
  completedModule4CultureOfPersonalEducation?: Maybe<Scalars['Int']['output']>;
  completedModule5PersonalPotential?: Maybe<Scalars['Int']['output']>;
  completedPersonalEducation: Scalars['Int']['output'];
  configuratorsCount: Scalars['Int']['output'];
  identifier: Scalars['String']['output'];
  region: Scalars['String']['output'];
  schoolName: Scalars['String']['output'];
  studentsInPG: Scalars['Int']['output'];
  teachersCount: Scalars['Int']['output'];
};

/** Информация об учителе для публичных профилей */
export type TeacherPublicData = {
  __typename?: 'TeacherPublicData';
  avatarUrl?: Maybe<Scalars['String']['output']>;
  firstName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  lastName: Scalars['String']['output'];
  middleName?: Maybe<Scalars['String']['output']>;
  subject?: Maybe<Subject>;
  subjects?: Maybe<Array<Maybe<Subject>>>;
};

/** Публичный профиль учителя */
export type TeacherPublicProfile = {
  __typename?: 'TeacherPublicProfile';
  aboutMePersonalInfo?: Maybe<Scalars['String']['output']>;
  avatarUrl?: Maybe<Scalars['String']['output']>;
  birthdayDate?: Maybe<Scalars['Date']['output']>;
  classroomIds: Array<Scalars['ID']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  firstName: Scalars['String']['output'];
  /** классы, в которых он классный руководитель */
  formMasterStageGroups: Array<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  lastName: Scalars['String']['output'];
  login: Scalars['String']['output'];
  middleName?: Maybe<Scalars['String']['output']>;
  mobilePhone?: Maybe<Scalars['String']['output']>;
  showBirthYear?: Maybe<Scalars['Boolean']['output']>;
  showContacts?: Maybe<Scalars['Boolean']['output']>;
  stageGroupName: Scalars['String']['output'];
  stageGroupNameList: Array<Scalars['String']['output']>;
  subjects: Array<SubjectData>;
};

export type TeacherQueries = {
  __typename?: 'TeacherQueries';
  /** Проверяет, создавал ли эту контрольную учитель */
  checkClassSubjectPermissionByControlWorkId: Scalars['Boolean']['output'];
  /** Определение прав учителя относительно группы по предмету */
  checkClassSubjectPermissions: ClassSubjectPermission;
  /** Определение прав учителя относительно группы по предмету */
  checkClassSubjectPermissionsForSubjectIDs: Array<ClassSubjectIdToPermission>;
  /** Проверяет, может ли учительпросмотреть контрольную на экранах Группы по Предмету */
  checkClassSubjectViewPermissionByControlWorkId: Scalars['Boolean']['output'];
  /** Возвращает признак, имеет ли право текущий пользователь редактировать модуль */
  checkGoalAllowEdit: Scalars['Boolean']['output'];
  /** Определение прав учителя относительно группы по предмету для электронного журнала */
  checkJournalLessonsPermissions: ElectronicJournalPermission;
  /** Проверяет наличие студентов, которым учитель преподает в активных группах по предмету */
  checkMyStudentsPresent: Scalars['Boolean']['output'];
  /** Возвращает признак, имеет ли право текущий пользователь редактировать задание */
  checkTaskAllowEdit: Scalars['Boolean']['output'];
  /** Возвращает классы, для которых учитель является ведущим по заданным классам */
  checkTeacherLeadRoleByClassSubjectIDs: Array<Scalars['ID']['output']>;
  /**
   * Запрос количества школ, которым доступен модуль
   * @deprecated Will be deleted in 0.14
   */
  countGoalAvailableSchools: Scalars['Int']['output'];
  /**
   * Запрос количества пользователей, которым доступен модуль
   * @deprecated Will be deleted in 0.14
   */
  countGoalAvailableUsers: Scalars['Int']['output'];
  /** количество пед.техник по параметрам */
  countPedagogicalTechniques: Scalars['Int']['output'];
  /**
   * Запрос количества школ, которым доступно задание
   * @deprecated Will be deleted in 0.14
   */
  countTaskAvailableSchools: Scalars['Int']['output'];
  /**
   * Запрос количества пользователей, которым доступно задание
   * @deprecated Will be deleted in 0.14
   */
  countTaskAvailableUsers: Scalars['Int']['output'];
  /**
   * Электронный журнал. Выгрузка в Excel.
   * @deprecated Под удаление. EDU-48885
   */
  downloadJournalToExcel: ReportExcelFile;
  /** Предметы. Выгрузка в Excel. */
  downloadModulesProgressBySubjectAndStageExcel: ReportExcelFile;
  /** Отчет "Успеваемость по эл.журналу" выгрузка в Excel */
  downloadStudentJournalPerformanceExcel: ReportExcelFile;
  /** Статистика. Успеваемость учеников расширенная по аттестационным периодам. Выгрузка в Excel. */
  downloadStudentsAcademicPerformanceByAttestationPeriodExpandedExcel: ReportExcelFile;
  /** Отчет "Успеваемость" по Аттестационным периодам расширенный V2. Выгрузка в Excel */
  downloadStudentsAcademicPerformanceByAttestationPeriodExpandedExcelV2: ReportExcelFile;
  /** Статистика. Успеваемость учеников. Выгрузка в Excel. */
  downloadStudentsAcademicPerformanceExcel: ReportExcelFile;
  /** Статистика. Успеваемость учеников расширенная. Выгрузка в Excel. */
  downloadStudentsAcademicPerformanceExpandedExcel: ReportExcelFile;
  /** Отчет "Успеваемость" расширенный V2. Выгрузка в Excel */
  downloadStudentsAcademicPerformanceExpandedExcelV2: ReportExcelFile;
  /** Отчет "Итоговые оценки. Детальный" с датами Выгрузка в Excel */
  downloadStudentsMarksResultDetailedExcel: ReportExcelFile;
  /** Статистика. Мониторинг. Выгрузка в Excel. */
  downloadStudentsMonitoringExcel: ReportExcelFile;
  /** Итоговые оценки. Выгрузка в Excel */
  downloadStudyPeriodMarksExcel: ReportExcelFile;
  /** Задания на проверке. Выгрузка в Excel. */
  downloadTasksOnCheckExcel: ReportExcelFile;
  /** Эскпорт прогресса учащихся в файл */
  exportStudentProgress: StudentPersonalProgressReport;
  /** Эскпорт прогресса учащихся по траекториям в файл для проекта Bootcamp */
  exportStudentProgressByTrajectoryForBTC: StudentPersonalProgressReport;
  /** Эскпорт прогресса учащихся по траекториям в файл для проекта Bootcamp V2 */
  exportStudentProgressByTrajectoryForBTCV2: ReportExcelFile;
  /** Эскпорт прогресса учащихся в файл для проекта Bootcamp */
  exportStudentProgressForBTC: StudentPersonalProgressReport;
  /** Эскпорт прогресса учащихся в файл для проекта Bootcamp V2 */
  exportStudentProgressForBTCV2: ReportExcelFile;
  /** Эскпорт прогресса учащихся в формате Excel для проекта Bootcamp (версия 3, использующая report-service, объединен в один запрос) */
  exportStudentProgressForBTCV3: ReportExcelFile;
  /** выдает список академических лет школы. Если не передать schoolId, выдаст по текущей */
  getAcademicYears: Array<AcademicYear>;
  /** Возвращает агрегированные данные для диаграммы Радар (Паутинка) */
  getAggregatedStudentRadarChartData: AggregatedStudentRadarChart;
  getAllExistedTasksQuantity: Scalars['Int']['output'];
  /** Получение списка заданий групированного по элементам цели для планирования расписания к уроку */
  getAllPlausibleModuleTasksFromSets?: Maybe<Array<GoalLevelWithElements>>;
  /**
   * Возвращает список регионов России
   * @deprecated Запрос для получения всех регионов в UserQueries
   */
  getAllRegions: Array<Region>;
  getAllowedTaskTypesByLevel: Array<TaskTypeEnum>;
  /**
   * Получение всех доступных плейлистов в рамках модуля + плейлист назначенный на студента
   * (в случае если учитель ведет предмет у данной группы, но не является создателем плейлиста)
   */
  getAvailableModuleTaskSets: Array<TaskSet>;
  getAvailableModuleTaskSetsV2: Array<TaskSet>;
  /** Все доступные пользователю области видимости для установки при создании модуля */
  getAvailableScopeTypesForCreateGoal: AvailableScopes;
  /** Все доступные пользователю области видимости для установки при создании задания */
  getAvailableScopeTypesForCreateTask: AvailableScopes;
  /** Доступные награды для выдачи */
  getAwards: Array<Award>;
  /** количество доступных наград для выдачи */
  getAwardsCount: Scalars['Int']['output'];
  /** выбирает только с BadgeAssignmentType == TEACHER_STUDENT */
  getBadgesByKindId: Array<Badge>;
  getBookAvatarsByIds: Array<BookAvatar>;
  /** Возвращает Книги по идентифкаторам УМК. В случае если массив пустой возвращает весь справочник Книг */
  getBooksByUMKIds: Array<Book>;
  /**
   * Возвращает Книги по идентифкаторам УМК и типу книги.
   * В случае пустого массива идентификаторов УМК возвращает весь справочник Книг определенного типа.
   */
  getBooksByUMKIdsAndBookType: Array<Book>;
  /** Возвращает последнее непрочитанное уведомление об изменении расписания. Или null если таковых нет */
  getChangeScheduleNotification?: Maybe<Notification>;
  /** Получить родителей учеников в классе учителя. */
  getClassParent: Array<Maybe<ParentPublicProfile>>;
  getClassPlansByFilters: GetClassSubjectsByFiltersResponse;
  /** Агрегированная информация вкладки оценки экрана мои классы */
  getClassSubjectAssessments: ClassSubject;
  /** Возвращает всю персональную информацию по Контрольной Работе на Группу по Предмету */
  getClassSubjectControlWorkInfo: ClassSubjectControlWorkInfo;
  /** Агрегированная информация вкладки контрорльная работа экрана мои классы */
  getClassSubjectControlWorks: ClassSubject;
  /** Возвращает иден */
  getClassSubjectGroupsForTeacher: Array<StageGroupInfo>;
  /** Возвращает идентификатор Группы по идентификатору ученика и идентификатору задания (tasks) или null если его нет */
  getClassSubjectIdByStudentIdAndTaskId?: Maybe<Scalars['ID']['output']>;
  /**
   * Возвращает информацию для отображения мониторинга Группы по Предмету
   * по идентификатору Группы по Предмету (stage_subject_groups.stage_subject_group_id)
   * ВНИМАНИЕ!!! Возвращаемый набор данных захардкожен на бэкенде,
   * при расгирении возвращаемого набора данных необходима доработка на бэке.
   * @deprecated Запрос будет удален в версии 0.15.0 . Необходимо использовать один из запросов getClassSubjectStudents, getClassSubjectPerformance, getClassSubjectAssessments, getClassSubjectControlWorks в зависимости от вкладки
   */
  getClassSubjectMonitoring: ClassSubject;
  /** Получение информации о текущей успеваемости группы класса по предмету */
  getClassSubjectPerformance: GetClassSubjectPerformanceResponse;
  /** статистика по прохождению заданий по каждому модулю из плана на класс (только для учеников, занимающихся по общему плану) */
  getClassSubjectPerformanceByModules: Array<StudentTaskStatusGroup>;
  /**
   * Получить Планы на Группы по Предмету Учителя, в которых он вел в академическом году,
   * по идентификатору академического года (academic_years.academic_year_id)
   */
  getClassSubjectPlansByAcademicYearId: Array<ClassSubject>;
  /** Агрегированная информация вкладки мои ученики экрана мои классы */
  getClassSubjectStudents: ClassSubject;
  /** Агрегированная информация вкладки мои ученики экрана мои классы с разбивкой по страницам */
  getClassSubjectStudentsMonitoring: ClassSubjectStudentsBySubgroupsPage;
  /** Возвращает все текущие Группы по Предмету Учителя */
  getClassSubjects: Array<ClassSubject>;
  /** Возвращает все Группы по Предмету Учителя (stage_subject_groups) по идентификатору академического года (academic_years.academic_year_id) */
  getClassSubjectsByAcademicYearId: Array<ClassSubject>;
  getClassSubjectsByClassName: Array<ClassSubject>;
  /**
   * Возвращает Классы по Предмету Учителя по фильтрам
   * Включает только активные Группы; классное руководство не включается
   * Отсортированы по имени предмета, затем по параллели, затем по имени группы
   */
  getClassSubjectsByFilters: GetClassSubjectsByFiltersResponse;
  /** Возвращает Классы по Предмету Учителя по массиву идентификаторов (stage_subject_groups.stage_subject_group_id) */
  getClassSubjectsByIds: Array<ClassSubject>;
  /**
   * Возвращает Классы по Предмету Учителя по массиву идентификаторов (stage_subject_groups.stage_subject_group_id)
   * Предсборка StudyModules, только для страницы Плана в V3
   */
  getClassSubjectsByIdsWithLevels: Array<ClassSubject>;
  /** Возвращает Группы по Предмету Учителя с лимитами Групп в срезе каждого предмета */
  getClassSubjectsBySubject: Array<ClassSubject>;
  /**
   * Возвращает текущие Группы по Предмету Учителя (stage_subject_groups)
   * по идентификатору Предмета (subjects.subject_id) и идентифкатору параллели (stages.stage_id)
   */
  getClassSubjectsBySubjectIdAndStageId: Array<ClassSubject>;
  /** @deprecated Под удаление. Использовать getClassSubjectsByTeacherTrainingWithEnumType */
  getClassSubjectsByTeacherTraining: Array<ClassSubject>;
  /** @deprecated Под удаление. Использовать getClassSubjectsByFilters */
  getClassSubjectsByTeacherTrainingWithEnumType: Array<ClassSubject>;
  /**
   * Возвращает развернутую информацию о предмете класса, его модулях и количестве заданий в их плейлистах
   * (в методе getClassSubjectsByIds считается общее количество заданий, не по плейлисту)
   */
  getClassSubjectsExtendedInfo: Array<ClassSubject>;
  /** Возвращает все Группы по Предмету, в которых учатся ученики из Класса по идентификатору Класса */
  getClassSubjectsForFormMasterByStageGroupId: Array<ClassSubject>;
  /**
   * по идентификатору Предмета (subjects.subject_id) и идентифкатору параллели (stages.stage_id)
   * только те группы, в которых учитель преподает
   */
  getClassSubjectsTaughtByTeacherBySubjectIdAndStageId: Array<ClassSubject>;
  /**
   * Аналог вызова getClassSubjectsByFilters.
   * Добавлено заполнение типов currentPeriodPerformance и currentModulePerformance.
   */
  getClassSubjectsWithPerformanceByFilters: GetClassSubjectsByFiltersResponse;
  /** Возвращает Контрольные Работы на Группу по Предмету Учителя по идентификаторам */
  getControlWorksByIds: Array<ClassSubjectControlWork>;
  /** Возвращает все Контрольные Работы Учителя по Учебному Модулю */
  getControlWorksByModuleId: Array<ClassSubjectControlWork>;
  /** Возвращает количество непрочитанных текущим пользователем комментариев по заданию. Комментарии пользователя не учитываются */
  getCountUnreadMessages: Scalars['Int']['output'];
  /** Получение списка доступных мета-критериев оценивания */
  getCriteriaMeta: Array<Criterion>;
  /** Получение списка предустановленых связок критериев */
  getCriteriaPresetsAll: Array<CriterionPreset>;
  /** Получение списка предустановленых связок критериев и шкал для текущей школы */
  getCriteriaPresetsForCurrentSchool: Array<CriterionPreset>;
  /** Получение списка шкал для критериев оценивания */
  getCriteriaScales: Array<CriterionScale>;
  /** Возвращает Группы по Предмету Учителя текущего года с захардкоженным набором полей */
  getCurrentClassSubjectsGrid: Array<ClassSubject>;
  getCurrentSchoolBusinessAdmins: Array<User>;
  /** Возвращает Учебные периоды конкретной параллели в этом году в конкретной Школе */
  getCurrentStudyPeriodsByStage: Array<StudyPeriod>;
  /** Получение событий в заданном модуле */
  getEventsByGoalId: Array<Event>;
  /** Получение событий в заданных модулях */
  getEventsByGoalIds: Array<Event>;
  /** Получение учебного модуля по его идентификатору */
  getExamModuleById: ExamModule;
  /** получение типов проектов для планов */
  getExecutionTypes: Array<ModuleExecutionTypeModel>;
  /** Получение истории изменения опыта */
  getExperienceHistoryDate: UserExperienceHistoryDate;
  /**
   * Возвращает список внешних систем для проверки заданий с типом "Проверка во внешней системе"
   * @deprecated Не используется
   */
  getExternalCheckingSystems: Array<ExternalCheckingSystem>;
  /** Получение данных о количестве P2P проверок и средней оценке пользователя как ревьюера */
  getFeedbackStatisticsAverageScore: FeedbackStatisticsAverageScore;
  /** Возвращает информацию для фильтра планов уроков */
  getFilterLessonPlans: Array<LessonPlanV4>;
  /** Запрос школ, которым доступен модуль */
  getGoalAvailableSchools: Array<Scalars['UUID']['output']>;
  /** Запрос пользователей, которым доступен модуль */
  getGoalAvailableUsers: Array<User>;
  getGoalConsistencyInfo: GoalConsistency;
  /** Запрос текущего и доступных скоупов модуля для изменения текущим пользователем */
  getGoalCurrentAndAvailableScopeTypes: CurrentAndAvailableScopeTypes;
  /** модули по периоду и группе по предметам */
  getGoalsByDatePeriodAndStageSubjectGroup: Array<Goal>;
  /** Возвращает кол-во модулей назначенных на класс */
  getGoalsNumberByStageGroupId: Scalars['Int']['output'];
  /** Возвращает систему оценивания, установленную для школьной параллели и переданного учебного года */
  getGovernmentMarkTypeBySchoolAndStage: GovernmentMarkType;
  /** Получение мета информация о домашней работе для страницы редактирования подборки материалов к ней */
  getHomeworkMetaBySelectionId: HomeworkMeta;
  getJournalCells: GetJournalCellsResponse;
  /** Получить набор итоговых оценок(за учебный период и год) по группе по предмету и учебному году */
  getJournalFinalStudentMarks: Array<JournalFinalStudentMark>;
  /** Возвращает уведомления для электронного журнала */
  getJournalNotifications: GetJournalNotificationsResponseModel;
  /** Simplified in EDU-69256 */
  getLandingTemplates: Array<LandingTemplate>;
  /**
   * Получение списка учебных активностей для эл.журнала по ИД школы и ИД предмета
   * Если по предмету в школе не задано активностей, возвращаются все доступные в данной школе активности
   */
  getLearningActivitiesBySchoolAndSubject: Array<LearningActivity>;
  /** Возвращает формы контроля, настроенные для школьного предмета и уровня образования */
  getLearningActivitiesBySubjectAndStage: Array<LearningActivity>;
  /** Возвращает план урока по идентификатору */
  getLessonPlanById: LessonPlanV4;
  /**
   * Возвращает план урока по идентификатору.
   * Не бросает исключения, как getLessonPlanById, а возвращает описание ошибки и статус
   */
  getLessonPlanByIdV2: LessonPlanV4Response;
  /** Получение плана к уроку по идентификатору таймслота урока */
  getLessonPlanByLessonId?: Maybe<LessonPlan>;
  /** Возвращает план на ближайший урок для учителя */
  getLessonPlanForNextLesson?: Maybe<LessonPlanV4>;
  /** Получение мета информация о плане к уроку для страницы редактирования подборки материалов к нему */
  getLessonPlanMetaBySelectionId: LessonPlanMeta;
  getLessonPlanRecommendationByModuleId?: Maybe<LessonPlanRecommendation>;
  /** Возвращает планы уроков */
  getLessonPlans: Array<LessonPlanV4>;
  /** Получение планов к уроку в заданном модуле */
  getLessonPlansByGoalIdAndClassSubjectId: Array<LessonPlan>;
  /** Получение планов к уроку в заданных модулях */
  getLessonPlansByGoalIdsAndClassSubjectId: Array<LessonPlan>;
  /** Получение планов к уроку по идентификаторам */
  getLessonPlansByIds: Array<LessonPlan>;
  /** Возвращает кол-во планов уроков */
  getLessonPlansCount: Scalars['Int']['output'];
  getLessonsForWeek: Array<Lesson>;
  /** Запрос уроков и учебных активностей заданных для них */
  getLessonsWithLearningActivities: Array<LessonsWithLearningActivities>;
  /** Возвращает идентификаторы уроков для которых есть опубликованный план */
  getLessonsWithPublishedLessonPlan: Array<Scalars['ID']['output']>;
  /** @deprecated Field no longer supported */
  getLicenses: Array<License>;
  /** Награды, которые можно назначить за выполнения модуля */
  getModuleAchieveAwards: Array<Award>;
  /** Получение всех плейлистов в рамках модуля(Базовые плейлисты + плейлисты Учителя) */
  getModuleTaskSets: Array<TaskSet>;
  /** Запрос списка модулей */
  getModules: GetModulesResponse;
  getModulesByBookId: Array<StudyModule>;
  getModulesByIds: Array<StudyModule>;
  getModulesByIdsV2: Array<StudyModule>;
  /** @deprecated Use getModules instead. Will be deleted in 23.0.0 */
  getModulesCount: Scalars['Int']['output'];
  getModulesForPlan: GetModulesResponse;
  /** Предметы */
  getModulesProgressBySubjectAndStageReport: Array<ModulesProgressBySubjectAndStage>;
  getMotivationBlockByGoalId?: Maybe<MotivationBlock>;
  getMotivationBlockSections: Array<MotivationBlockSection>;
  /**
   * Возвращает список регионов, в которых пользователь назначен как проверяющий учитель
   * (фроль Учитель для внешних школ) с сортировкой
   */
  getMyRegionsByTeacherTraining: GetMyRegionsByTeacherTrainingResponse;
  /**
   * Возвращает список школ, в которых пользователь назначен проверяющим учителем
   * (фроль Учитель для внешних школ) с сортировкой
   * @deprecated Под удаление. Использовать getMySchoolsByTeacherTrainingWithEnumType
   */
  getMySchoolsByTeacherTraining: GetMySchoolsByTeacherTrainingResponse;
  getMySchoolsByTeacherTrainingWithEnumType: GetMySchoolsByTeacherTrainingResponse;
  /**
   * Возвращает список студентов, которым учитель преподает в активных группах по предмету
   * Отсортирован сначала по фамилии, потом по имени
   */
  getMyStudents: Array<Student>;
  /** Возвращает список ВСЕХ предметов, которые имеет право преподавать Учитель */
  getMySubjects: Array<Subject>;
  /** Возвращает список ТОЛЬКО ТЕХ предметов, которые преподает Учитель в активных группах по предмету */
  getMySubjectsWithActiveGroups: Array<Subject>;
  /** Возвращает отображаемые на Дашборде задания на проверку в Bootcamp */
  getNeedCheckTasksForDashboardBootcamp: GetStudentTasksResponse;
  getNeedCheckTeacherStudentTasks: GetStudentTasksGroupedResponse;
  /**
   * Возвращает "соседние" Группы по Предмету Учителя (stage_subject_groups) по идентификатору группы
   * соседние по предмету(subjects.subject_id), идентификатору параллели (stages.stage_id) и году (academic_years)
   */
  getNestedClassSubjectsByStageSubjectGroupId: Array<ClassSubject>;
  /** Получение заметок за переданный период */
  getNotesBetweenDate: Array<Note>;
  /** Получение заметок за переданный день */
  getNotesByDate: Array<Note>;
  getNotifications: Array<Notification>;
  getNotificationsByTypes: Array<Notification>;
  getNotificationsCount: Scalars['Int']['output'];
  /** Получение педтехник с сортировкой, полнотекстовым поиском и пагинацией */
  getPedagogicalTechniques: Array<PedagogicalTechnique>;
  getPersonalTrajectory: PersonalTrajectory;
  /** Получить данные документа/документов портфолио */
  getPortfolioDocuments?: Maybe<Array<Maybe<PortfolioDocument>>>;
  /** Получение цитаты недели */
  getQuote: Quote;
  /** Получение рекомендуемого кол-ва дней на  учебный модуь в соотношении (Идентификатор цели, кол-во дне на  учебный модуь) */
  getRecommendedDurationForModules: Array<GoalDurationMap>;
  getSchedule: Schedule;
  /** Расписание группы по предмету за период */
  getScheduleByStageSubjectGroup: Schedule;
  /** Возвращает конфигурацию оценивания для переданных параметров */
  getSchoolMarkTypeGroupConfigurationsBySchoolAndStage: SchoolMarkTypeGroupConfiguration;
  /** набор оценок, принятых в школе */
  getSchoolMarks: Array<SchoolMark>;
  /** Обзор */
  getSchoolMonitoring: Array<SchoolMonitoring>;
  /** Возвращает список оценок для школьной параллели и переданного учебного года */
  getSchoolStageMarks: Array<SchoolMark>;
  /** Получить учителей в рамках одной школы */
  getSchoolTeachers: Array<TeacherPublicProfile>;
  /** Возвращает список навыков */
  getSoftSkillTypes: Array<SoftSkillType>;
  /** Возвращает список навыков */
  getSoftSkillTypesV2: Array<SoftSkillType>;
  /** Возвращает список заявок для вступления в класс */
  getStageGroupStudentRequests: Array<StageGroupStudentRequest>;
  /** список классов (для завуча все классы, для учителя его классы, возможны фильтры по параллели и учебному году, excludeConsulting исключает группы в которых учитель является консультирующим) */
  getStageGroupsBySchoolAndTeacher: Array<StageGroupInfo>;
  /**
   * S21. Публичный профиль студента. Получение всех волн (аналог stage_group_name) и форм обучения (аналог stage_name) по StudentId
   * @deprecated use school21 query
   */
  getStageGroupsS21PublicProfile?: Maybe<Array<Maybe<StageGroupS21>>>;
  getStageSubjectGroupStudentsByYear: GetStageSubjectGroupStudentsByYearResponse;
  /** список групп по предмету по классу и предмету (для учителя только его предметы, для классного руководителя его предмет и предметы его класса) */
  getStageSubjectGroupsByStageGroupAndSubject: Array<StageSubjectGroup>;
  getStages: Array<Stage>;
  /** список параллелей для учителя */
  getStagesForTeacher: Array<Stage>;
  /** список параллелей для учителя (без учета параллелей по которым он не ведет группы, а является только классным руководителем) */
  getStagesForTeacherWithoutFormMaster: Array<Stage>;
  /** Возвращает статистику посещаемости уроков учеником */
  getStudentAttendance: StudentAttendanceStatistic;
  /** Возвращает статистику посещаемости уроков учеником */
  getStudentAttendanceStatisticsByPeriod: StudentAttendanceStatistic;
  /** Возвращает расписание на день учителя, для класса, где он классный руководитель на указанную дату. */
  getStudentDiaryForTeacher?: Maybe<TeacherDiary>;
  /** Получение реальной оценки трудоемкости задания */
  getStudentEffortEstimation?: Maybe<StudentEffortEstimation>;
  /** Получить фидбек ученика по опредлённому заданию или null если его нет */
  getStudentFeedback?: Maybe<Feedback>;
  /**
   * Возвращает Студента В Подгруппе с детализацией в рамках конкретного Класса по Предмету
   * по Идентификатору (stage_subject_subgroup_students.stage_subject_subgroup_student_id)
   */
  getStudentInSubgroupWithPersonalizedPlan: StudentInSubgroup;
  /** Отчет "Успеваемость по эл.журналу" */
  getStudentJournalPerformance: Array<StudentJournalPerformance>;
  /**
   * Возвращает персонализированный Учебный Модуль Студента
   * по идентификатору Учебного Модуля (goals.goal_id)
   * и по идентификатору Студента (students.student_id)
   */
  getStudentModule: StudentModule;
  /**
   * Возвращает полную информацию по Учебному Модулю в контексте Студента
   * по идентификатору Учебного Модуля (goals.goal_id)
   * и по идентификатору Студента (students.student_id)
   */
  getStudentModuleInformation: StudentModuleInfo;
  /**
   * Возвращает полную информацию по Учебному Модулю в контексте Студента
   * по идентификатору Учебного Модуля (goals.goal_id)
   * и по идентификатору Студента (students.student_id)
   * по идентификатору группы по предмету(stage_subject_group.stage_subject_group_id), если модуль добавлен в группу другого предмета
   * со всеми Плэйлистами, доступными Студенту
   */
  getStudentModuleInformationWithAvailablePlaylists: StudentModuleInfo;
  getStudentModuleV2: StudentModule;
  /** Получить доступные модули, которые запланированы у учеников подходящих под фильтр */
  getStudentModulesForProgressReport: Array<StudyModule>;
  /** Получить доступные модули, которые запланированы у учеников подходящих под фильтр, оптимизировано */
  getStudentModulesForProgressReportForBTC: Array<StudyModule>;
  /** Возвращает количество Заданий по Статусам */
  getStudentModulesTaskStatusQuantityWithEnumType: Array<StudentModulesTaskStatusWithQuantity>;
  /** Получение цели по предмету ученика */
  getStudentObjectivesByStatuses: Array<PersonalObjective>;
  /** Запрос всех модулей с системами заданий по учебным планам учеников группы по предмету. */
  getStudentPlanGoalsWithTaskSetsForClassSubject: Array<StudentPlanGoalWithTaskSet>;
  getStudentProfile: Student;
  /** Получить прогресс учащихся для проекта Bootcamp (версия 3, использующая report-service, объединен в один запрос) */
  getStudentProgressForBM: Array<StudentProgressForBtcModel>;
  /** Получить кол-во учеников по фильтру */
  getStudentProgressForBMCount: Scalars['Int']['output'];
  /** Получение всех проектов по userId и stageGroupId */
  getStudentProjectsByStageGroup: Array<Maybe<StudentItem>>;
  /** Возвращает данные для диаграммы Радар (Паутинка) */
  getStudentRadarChartData: Array<StudentRadarChart>;
  /** Возвращает агрегированные данные по навыкам для диаграммы Радар (Паутинка) */
  getStudentSkillRadarChartData: AggregatedSkillStudentRadarChart;
  /**
   * Получение детальной информации о состоянии прогресса ученика по предмету (с понедельным планом или детальной информацией по цели)
   * Выводится детальная информация о цели по отстающему предмету в случае ее наличия или понедельный план с данными по заданиям
   * Копия запроса parent.getChildSubjectProgressStateWithDetails, только вместо studentUserId принимается studentId
   */
  getStudentSubjectProgressStateWithDetails: StudentSubjectProgressState;
  getStudentTaskAmountForDashboard: Array<TaskCardsStatusesWithQuantity>;
  /** получение списка отправленных ответов ученика */
  getStudentTaskAnswers: Array<StudentAnswer>;
  /** Возвращает полную персональную информацию по Заданию в контексте Студента */
  getStudentTaskInfo?: Maybe<StudentTaskInfo>;
  /**
   * Возвращает количество Заданий по Статусам
   * @deprecated Под удаление. Использовать getStudentTaskStatusQuantityWithEnumType
   */
  getStudentTaskStatusQuantity: Array<TaskStatusWithQuantity>;
  getStudentTaskStatusQuantityCompetition: Array<TaskStatusWithQuantity>;
  getStudentTaskStatusQuantityWithEnumType: Array<TaskStatusWithQuantity>;
  /**
   * Возвращает Задания в контексте студента по фильтрам
   * @deprecated Под удаление. Использовать getStudentTasksWithEnumType
   */
  getStudentTasks: GetStudentTasksGroupedResponse;
  /** Получение списка заданий и статусов заданий по идентификатору урока */
  getStudentTasksByLesson?: Maybe<ElectonicJournalStudentTasks>;
  /** Получение списка заданий и статусов заданий по идентификатору плана на урок */
  getStudentTasksByLessonPlan?: Maybe<ElectonicJournalStudentTasks>;
  /**
   * Возвращает количество заданий в контексте студента по фильтрам
   * Копия getStudentTasks, но без сортировки и пагинации
   * @deprecated Под удаление. Использовать getStudentTasksCountWithEnumType
   */
  getStudentTasksCount: Scalars['Int']['output'];
  /**
   * Возвращает количество заданий в контексте студента по фильтрам
   * Копия getStudentTasks, но без сортировки и пагинации
   */
  getStudentTasksCountWithEnumType: Scalars['Int']['output'];
  /**
   * Замена методу getStudentTasksWithEnumType для Дашборд. Убраны лишние фильтрации и лишние вызовы разных методов.
   * Все необходимые аргументы достаются на бэке. Так же был совет, не использовать этот метод на других экранах,
   * так как он был написан для страницы проверки заданий
   */
  getStudentTasksForDashboard: Array<StudentTask>;
  /** Возвращает Задания в контексте студента по фильтрам для конкурсов */
  getStudentTasksForExternalCompetitions: GetStudentTasksGroupedResponse;
  getStudentTasksWithEnumType: GetStudentTasksGroupedResponse;
  getStudentTasksWithQuestions?: Maybe<StudentTasksWithPerformance>;
  /**
   * Возвращает Задания в контексте учителя по фильтрам с подменой статусов заданий
   * к примеру статус заданий "на проверке" при типе проверки "самопроверка" или "проверка другим студентом" и не назначена на данного учителя
   * будет заменен на "Назначено"
   */
  getStudentTasksWithStatusReplacement: GetStudentTasksGroupedResponse;
  /**
   * Статистика. Успеваемость учеников
   * @deprecated Использовать getStudentsAcademicPerformanceExpandedV2
   */
  getStudentsAcademicPerformance: Array<StudentAcademicPerformance>;
  /** Отчет "Успеваемость" по Аттестационным периодам */
  getStudentsAcademicPerformanceByAttestationPeriod: Array<StudentAcademicPerformance>;
  /** Отчет "Успеваемость" по Аттестационным периодам расширенный */
  getStudentsAcademicPerformanceByAttestationPeriodExpanded: Array<StudentAcademicPerformanceExpandedV2>;
  /** Отчет "Успеваемость" по Аттестационным периодам расширенный V2 */
  getStudentsAcademicPerformanceByAttestationPeriodExpandedV2: Array<StudentAcademicPerformanceExpandedV2>;
  getStudentsAcademicPerformanceExpanded: Array<StudentAcademicPerformanceExpanded>;
  getStudentsAcademicPerformanceExpandedV2: Array<StudentAcademicPerformanceExpandedV2>;
  /** Отчет "Успеваемость" расширенный V3 */
  getStudentsAcademicPerformanceExpandedV3?: Maybe<Array<StudentAcademicPerformanceExpandedV2>>;
  /** Получить учеников по фильтру */
  getStudentsForProgress: Array<StudentForProgress>;
  /** Получить кол-во учеников по фильтру */
  getStudentsForProgressCount: Scalars['Int']['output'];
  /** Получить кол-во учеников по фильтру */
  getStudentsForProgressCountForBTC: Scalars['Int']['output'];
  /** Получить кол-во учеников по фильтру */
  getStudentsForProgressCountForBTCV2: Scalars['Int']['output'];
  /**
   * Возвращает Студентов В Подгруппе с информацией об успеваемости в рамках конкретного Класса по Предмету
   * по Идентификатору (stage_subject_subgroup_students.stage_subject_subgroup_student_id)
   */
  getStudentsInSubgroupByIds: Array<StudentInSubgroup>;
  /**
   * Получение списка всех активных подгрупп по предмету для конкретного ученика в какой-либо из этих подгрупп (stage_subject_subgroup_students.id)
   * То есть при отправке Лев Абрамов.физика мы получим [Лев Абрамов.математика, Лев Абрамов.история, Лев Абрамов.физика, ...]
   * Отсортированы по названию предмета
   */
  getStudentsInSubgroupByStudentInSubgroupId: StudentsInSubgroupPage;
  /**
   * Возвращает Студента В Подгруппе с информацией об успеваемости в рамках конкретного Класса по Предмету
   * по Идентификатору (stage_subject_subgroup_students.stage_subject_subgroup_student_id)
   * ВНИМАНИЕ!!! Возвращаемый набор данных захардкожен на бэкенде,
   * при расгирении возвращаемого набора данных необходима доработка на бэке.
   */
  getStudentsInSubgroupGrid: StudentInSubgroup;
  /** @deprecated Под удаление. EDU-48885 */
  getStudentsMarksResultDetailed: StudentFinalMarkModel;
  /** Отчет "Итоговые оценки. Детальный" с датами */
  getStudentsMarksResultDetailedByDates: StudentFinalMarkModel;
  getStudentsMarksSubjectsDetailed: StudentFinalMarkSubjectsModel;
  /** Отчет "Итоговые оценки. Детальный" по ученику и всем предметам с датами */
  getStudentsMarksSubjectsDetailedByDates: StudentFinalMarkSubjectsModel;
  /** Получить прогресс учащихся */
  getStudentsProgress: Array<StudentPersonalProgress>;
  /** Получить прогресс учащихся по траекториям для проекта Bootcamp */
  getStudentsProgressByTrajectoryForBTC: Array<StudentPersonalProgressByTrajectory>;
  /** Получить прогресс учащихся по траекториям для проекта Bootcamp (версия 2, использующая report-service) */
  getStudentsProgressByTrajectoryForBTCV2: Array<StudentPersonalProgressByTrajectory>;
  /** Получить прогресс учащихся для проекта Bootcamp */
  getStudentsProgressForBTC: Array<StudentPersonalProgress>;
  /** Получить прогресс учащихся для проекта Bootcamp (версия 2, использующая report-service) */
  getStudentsProgressForBTCV2: Array<StudentPersonalProgress>;
  /** Возвращает агрегированные данные по навыкам для диаграммы Радар (Паутинка) */
  getStudentsSkillRadarChartData: Array<AggregatedSkillStudentRadarChart>;
  /** Получить информацию об учениках группы по предмету и их группе успеваемости */
  getStudentsWithPerformance: Array<StudentWithPerformance>;
  /** Возвращает все элементы целей и относящиеся к ним задания. */
  getStudyModuleGoalElementsForTaskSet: Array<StudyModuleGoalElement>;
  /**
   * Возвращает Рекомендации к названию Учебного Модуля (Темы) по идентификаторам Книг.
   * В случае если массив пустой возвращает весь справочник рекомендаций к названию Учебного Модуля (Темы)
   * @deprecated Book now contains coverUrl, use any other query instead.
   */
  getStudyModuleNameRecommendationsByBookIds: Array<StudyModuleNameRecommendation>;
  /** Получение рекомендаций к названию модуля */
  getStudyModuleNameRecommendationsBySearchString: Array<StudyModuleNameRecommendation>;
  getStudyModulesList: Array<StudyModule>;
  /** Итоговые оценки */
  getStudyPeriodMarks: Array<StudyPeriodMark>;
  /** учебные периоды */
  getStudyPeriodsByStudyPeriodSet: Array<StudyPeriod>;
  getSubgroupsByIds: Array<Subgroup>;
  /** Оценки по предметам */
  getSubjectMarks: Array<SubjectMarks>;
  /** список предметов по организации */
  getSubjects: Array<Subject>;
  /** список предметов для класса (для учителя только его предметы, для классного руководителя его предмет и предметы его класса) */
  getSubjectsByStageGroupAntSchoolAndTeacher: Array<Subject>;
  /** Возвращает список отправленных ответов ученика по заданию */
  getTaskAnswers: Array<StudentAnswer>;
  /** Запрос школ, которым доступно задание */
  getTaskAvailableSchools: Array<Scalars['UUID']['output']>;
  /** Запрос пользователей, которым доступно задание */
  getTaskAvailableUsers: Array<User>;
  getTaskConsistencyInfo: TaskInModuleConsistency;
  /** Получение всех возможных критериев */
  getTaskCriteria: Array<Criteria>;
  /**
   * Расчет процента соответствия
   * @deprecated Под удаление.
   */
  getTaskCriteriaPercent: CriteriaRecommendedValue;
  /**
   * Расчет процента соответствия
   * @deprecated Под удаление.
   */
  getTaskCriteriaPercentByStudentId: StudentCriteriaPercent;
  /** Получить соответствия критериям */
  getTaskCriteriaValues: Array<StudentCriteriaValue>;
  /** Запрос текущего и доступных скоупов заданич для изменения текущим пользователем */
  getTaskCurrentAndAvailableScopeTypes: CurrentAndAvailableScopeTypes;
  /** Возвращает комментарии, которые оставляли пользователи под выполняемым учеником заданием. */
  getTaskMessages: Array<TaskMessage>;
  getTaskMeta: Task;
  /** Получение набора заданий(системы заданий) в модулях по идентификаторам */
  getTaskSetByGoalIds: Array<TaskSet>;
  getTaskSetPerformance?: Maybe<TaskSetPerformance>;
  /** Информация о слотах в модуле */
  getTaskSetSLotsByFilter: Array<TaskSetSlot>;
  /** Возвращает слот плейлиста по идентификатору и типу плейлиста */
  getTaskSetSlotById: TaskSetSlot;
  /** Возвращает все доступные Планы Учителя по Параллели */
  getTasks: Array<Task>;
  getTasksByIds?: Maybe<Array<Maybe<StudentTask>>>;
  getTasksConsistencyInfo: Array<TaskInModuleConsistency>;
  /** Задания на проверке */
  getTasksOnCheck: Array<TasksOnCheck>;
  /** Задания на проверке с детализацией */
  getTasksOnCheckDetailed: Array<TaskOnCheckDetailed>;
  getTasksWithCount: TasksWithCount;
  /** Возвращает расписание на день для учителя на указанную дату */
  getTeacherDiary?: Maybe<TeacherDiary>;
  /** Возвращает детальный вид расписания */
  getTeacherSchedule: Schedule;
  /** Учителя */
  getTeacherSchoolMetrics: Array<TeacherSchoolMetrics>;
  /** Учителя. Выгрузка в Excel. */
  getTeacherSchoolMetricsExcel: ReportExcelFile;
  getTeacherTimetableByPeriod: TeacherDiary;
  /** запрос набора таймслотов для школы учителя */
  getTimeSlotSets: Array<TimeSlotSet>;
  /** запрос набора таймслотов для класса. Возвращаются таймслоты и наборы таймслотов привязанные к расписанию класса */
  getTimeSlotSetsByStageGroup: Array<TimeSlotSet>;
  /**
   * Возвращает Задания, которые Учитель должен проверить
   * ВНИМАНИЕ!!! Возвращаемый набор данных захардкожен на бэкенде,
   * при расгирении возвращаемого набора данных необходима доработка на бэке.
   */
  getTodos: Array<Todo>;
  /** Получение списка траекторий */
  getTrajectories?: Maybe<Array<Scalars['String']['output']>>;
  /** Поиск УМК по фильтру */
  getUMKs: Array<Umk>;
  /**
   * Возвращает УМК либо по идентифкаторам параллелей и по идентифкаторам предметов, либо по тому и по тому.
   * В случае если оба массива пустые возвращает весь справочник УМК.
   * @deprecated Use getUMKs(filter: UmkFilterInput!)
   */
  getUMKsBySubjectIdsAndStageIds: Array<Umk>;
  /** Опыт любого ученика, пока что доступно только буткемп-мастеру */
  getUserExperience: UserExperience;
  /**
   * Получение списка пользователей по ролям
   * Фильтры: роли - только BUSINESS_ADM (EDU-24486)
   * Копия функционала системного администратора, но без фильтра по школе - внутри используется только школа учителя
   */
  getUsers: Array<User>;
  /** Создание ссылки на online урок */
  getVCUrl?: Maybe<VcLink>;
};


export type TeacherQueriesCheckClassSubjectPermissionByControlWorkIdArgs = {
  classSubjectControlWorkId: Scalars['ID']['input'];
};


export type TeacherQueriesCheckClassSubjectPermissionsArgs = {
  classSubjectId: Scalars['ID']['input'];
};


export type TeacherQueriesCheckClassSubjectPermissionsForSubjectIDsArgs = {
  classSubjectIds: Array<Scalars['ID']['input']>;
};


export type TeacherQueriesCheckClassSubjectViewPermissionByControlWorkIdArgs = {
  classSubjectControlWorkId: Scalars['ID']['input'];
};


export type TeacherQueriesCheckGoalAllowEditArgs = {
  goalId: Scalars['ID']['input'];
};


export type TeacherQueriesCheckJournalLessonsPermissionsArgs = {
  classSubjectId: Scalars['ID']['input'];
};


export type TeacherQueriesCheckTaskAllowEditArgs = {
  taskId: Scalars['ID']['input'];
};


export type TeacherQueriesCheckTeacherLeadRoleByClassSubjectIDsArgs = {
  classSubjectIds: Array<Scalars['ID']['input']>;
};


export type TeacherQueriesCountGoalAvailableSchoolsArgs = {
  goalId: Scalars['ID']['input'];
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesCountGoalAvailableUsersArgs = {
  goalId: Scalars['ID']['input'];
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesCountPedagogicalTechniquesArgs = {
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesCountTaskAvailableSchoolsArgs = {
  taskId: Scalars['ID']['input'];
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesCountTaskAvailableUsersArgs = {
  taskId: Scalars['ID']['input'];
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesDownloadJournalToExcelArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  reportDateTime: Scalars['String']['input'];
  reportType: JournalReportTypeEnum;
  showLessonPlan?: InputMaybe<Scalars['Boolean']['input']>;
  showThematicPlan?: InputMaybe<Scalars['Boolean']['input']>;
  stageSubjectGroupId: Scalars['ID']['input'];
  studyPeriodId?: InputMaybe<Scalars['ID']['input']>;
};


export type TeacherQueriesDownloadModulesProgressBySubjectAndStageExcelArgs = {
  currentRole: Scalars['String']['input'];
  endDate: Scalars['DateTime']['input'];
  reportDateTime: Scalars['String']['input'];
  startDate: Scalars['DateTime']['input'];
};


export type TeacherQueriesDownloadStudentJournalPerformanceExcelArgs = {
  studentJournalPerformanceExcelInput: StudentJournalPerformanceExcelInput;
};


export type TeacherQueriesDownloadStudentsAcademicPerformanceByAttestationPeriodExpandedExcelArgs = {
  closeModuleDate: Scalars['Date']['input'];
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  reportDateTime: Scalars['String']['input'];
  stageId: Scalars['Int']['input'];
  stageSubjectGroupId?: InputMaybe<Scalars['Int']['input']>;
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type TeacherQueriesDownloadStudentsAcademicPerformanceByAttestationPeriodExpandedExcelV2Args = {
  closeModuleDate: Scalars['Date']['input'];
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  reportDateTime: Scalars['String']['input'];
  stageId: Scalars['Int']['input'];
  stageSubjectGroupId?: InputMaybe<Scalars['Int']['input']>;
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type TeacherQueriesDownloadStudentsAcademicPerformanceExcelArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  reportDateTime: Scalars['String']['input'];
  stageId: Scalars['Int']['input'];
  stageSubjectGroupId?: InputMaybe<Scalars['Int']['input']>;
  startDate: Scalars['DateTime']['input'];
};


export type TeacherQueriesDownloadStudentsAcademicPerformanceExpandedExcelArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  reportDateTime: Scalars['String']['input'];
  stageId: Scalars['Int']['input'];
  stageSubjectGroupId?: InputMaybe<Scalars['Int']['input']>;
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type TeacherQueriesDownloadStudentsAcademicPerformanceExpandedExcelV2Args = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  reportDateTime: Scalars['String']['input'];
  stageId: Scalars['Int']['input'];
  stageSubjectGroupId?: InputMaybe<Scalars['Int']['input']>;
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type TeacherQueriesDownloadStudentsMarksResultDetailedExcelArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  currentRole?: InputMaybe<Scalars['String']['input']>;
  periodEndDate: Scalars['Date']['input'];
  periodStartDate: Scalars['Date']['input'];
  reportDateTime: Scalars['String']['input'];
  stageGroupId: Scalars['Int']['input'];
  stageId: Scalars['Int']['input'];
  subjectId: Scalars['Int']['input'];
};


export type TeacherQueriesDownloadStudentsMonitoringExcelArgs = {
  classSubjectId: Scalars['ID']['input'];
  currentRole?: InputMaybe<Scalars['String']['input']>;
  moduleIds: Array<Scalars['ID']['input']>;
  reportDateTime: Scalars['String']['input'];
  studentIds: Array<Scalars['UUID']['input']>;
  taskCheckTypes: Array<InputMaybe<TaskCheckEnum>>;
  taskForms: Array<InputMaybe<TaskAssignmentEnum>>;
  taskIds: Array<Scalars['ID']['input']>;
  taskStatuses: Array<TaskStatusEnum>;
  taskTypes: Array<InputMaybe<TaskTypeEnum>>;
};


export type TeacherQueriesDownloadStudyPeriodMarksExcelArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  currentRole?: InputMaybe<Scalars['String']['input']>;
  reportDateTime: Scalars['String']['input'];
  stageGroupId?: InputMaybe<Scalars['Int']['input']>;
  stageId: Scalars['Int']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type TeacherQueriesDownloadTasksOnCheckExcelArgs = {
  currentRole: Scalars['String']['input'];
  endDate: Scalars['DateTime']['input'];
  reportDateTime: Scalars['String']['input'];
  stageGroupId?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageSubjectGroupId?: InputMaybe<Scalars['Int']['input']>;
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  tasksDate: Scalars['DateTime']['input'];
};


export type TeacherQueriesExportStudentProgressArgs = {
  exportRequest: StudentPersonalProgressExportInput;
};


export type TeacherQueriesExportStudentProgressByTrajectoryForBtcArgs = {
  exportRequest: StudentPersonalProgressExportInput;
};


export type TeacherQueriesExportStudentProgressByTrajectoryForBtcv2Args = {
  exportRequest: StudentPersonalProgressExportBtcInput;
};


export type TeacherQueriesExportStudentProgressForBtcArgs = {
  exportRequest: StudentPersonalProgressExportInput;
};


export type TeacherQueriesExportStudentProgressForBtcv2Args = {
  exportRequest: StudentPersonalProgressExportBtcInput;
};


export type TeacherQueriesExportStudentProgressForBtcv3Args = {
  exportRequest: StudentProgressFilterBtcInputModelV2;
};


export type TeacherQueriesGetAcademicYearsArgs = {
  schoolId?: InputMaybe<Scalars['ID']['input']>;
};


export type TeacherQueriesGetAggregatedStudentRadarChartDataArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  studentId: Scalars['ID']['input'];
  studyPeriodId?: InputMaybe<Scalars['ID']['input']>;
};


export type TeacherQueriesGetAllExistedTasksQuantityArgs = {
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  filterAccess?: InputMaybe<Scalars['Boolean']['input']>;
  filterGoalLevelValues?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filterLaboriousnessFrom?: InputMaybe<Scalars['Int']['input']>;
  filterLaboriousnessTo?: InputMaybe<Scalars['Int']['input']>;
  filterLicense?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterNoParent?: InputMaybe<Scalars['Boolean']['input']>;
  filterScopes?: InputMaybe<Array<InputMaybe<ScopeEnum>>>;
  filterSoftSkillTypes?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterStages?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterSubjects?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterTaskTypes?: InputMaybe<Array<TaskTypeEnum>>;
  isInModule?: InputMaybe<Scalars['Boolean']['input']>;
  myCreatedTasks?: InputMaybe<Scalars['Boolean']['input']>;
  myStagesAndModules?: InputMaybe<Scalars['Boolean']['input']>;
  tags?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesGetAllPlausibleModuleTasksFromSetsArgs = {
  goalId: Scalars['ID']['input'];
  stageSubjectGroupId: Scalars['ID']['input'];
};


export type TeacherQueriesGetAllowedTaskTypesByLevelArgs = {
  level: Scalars['Float']['input'];
};


export type TeacherQueriesGetAvailableModuleTaskSetsArgs = {
  moduleId: Scalars['ID']['input'];
  studentInSubgroupId: Scalars['ID']['input'];
};


export type TeacherQueriesGetAvailableModuleTaskSetsV2Args = {
  moduleId: Scalars['ID']['input'];
  studentInSubgroupId: Scalars['ID']['input'];
};


export type TeacherQueriesGetAwardsArgs = {
  assignmentTypeId?: InputMaybe<Scalars['Int']['input']>;
  awardName?: InputMaybe<Scalars['String']['input']>;
  badgeKindTypeId?: InputMaybe<Scalars['Int']['input']>;
  page?: InputMaybe<PagingInput>;
  schoolId?: InputMaybe<Scalars['ID']['input']>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
};


export type TeacherQueriesGetAwardsCountArgs = {
  assignmentTypeId?: InputMaybe<Scalars['Int']['input']>;
  awardName?: InputMaybe<Scalars['String']['input']>;
  badgeKindTypeId?: InputMaybe<Scalars['Int']['input']>;
  schoolId?: InputMaybe<Scalars['ID']['input']>;
};


export type TeacherQueriesGetBadgesByKindIdArgs = {
  kindId: Scalars['Int']['input'];
};


export type TeacherQueriesGetBookAvatarsByIdsArgs = {
  bookIds: Array<Scalars['ID']['input']>;
};


export type TeacherQueriesGetBooksByUmkIdsArgs = {
  umkIds: Array<Scalars['ID']['input']>;
};


export type TeacherQueriesGetBooksByUmkIdsAndBookTypeArgs = {
  bookType: BookTypeEnum;
  umkIds: Array<Scalars['ID']['input']>;
};


export type TeacherQueriesGetClassPlansByFiltersArgs = {
  academicYearIds: Array<Scalars['ID']['input']>;
  planStatuses?: InputMaybe<Array<PlanStatusEnum>>;
  searchName?: InputMaybe<Scalars['String']['input']>;
  stageIds: Array<Scalars['ID']['input']>;
  subjectId: Scalars['ID']['input'];
};


export type TeacherQueriesGetClassSubjectAssessmentsArgs = {
  classSubjectId: Scalars['ID']['input'];
};


export type TeacherQueriesGetClassSubjectControlWorkInfoArgs = {
  classSubjectControlWorkId: Scalars['ID']['input'];
};


export type TeacherQueriesGetClassSubjectControlWorksArgs = {
  classSubjectId: Scalars['ID']['input'];
};


export type TeacherQueriesGetClassSubjectGroupsForTeacherArgs = {
  academicYearId: Scalars['ID']['input'];
  teacherId: Scalars['ID']['input'];
};


export type TeacherQueriesGetClassSubjectIdByStudentIdAndTaskIdArgs = {
  studentId: Scalars['UUID']['input'];
  taskId: Scalars['ID']['input'];
};


export type TeacherQueriesGetClassSubjectMonitoringArgs = {
  classSubjectId: Scalars['ID']['input'];
};


export type TeacherQueriesGetClassSubjectPerformanceArgs = {
  classSubjectId: Scalars['ID']['input'];
  moduleIds: Array<Scalars['ID']['input']>;
  paging: PagingInput;
  studentIds: Array<Scalars['ID']['input']>;
  taskCheckTypes: Array<TaskCheckEnum>;
  taskForms: Array<TaskAssignmentEnum>;
  taskIds: Array<Scalars['ID']['input']>;
  taskStatuses: Array<TaskStatusEnum>;
  taskTypes: Array<TaskTypeEnum>;
};


export type TeacherQueriesGetClassSubjectPerformanceByModulesArgs = {
  stageSubjectGroupId: Scalars['ID']['input'];
};


export type TeacherQueriesGetClassSubjectPlansByAcademicYearIdArgs = {
  academicYearId: Scalars['ID']['input'];
};


export type TeacherQueriesGetClassSubjectStudentsArgs = {
  classSubjectId: Scalars['ID']['input'];
};


export type TeacherQueriesGetClassSubjectStudentsMonitoringArgs = {
  classSubjectId: Scalars['ID']['input'];
  loadBySubgroups: Scalars['Boolean']['input'];
  page: PagingInput;
  sorting?: InputMaybe<SortingField>;
};


export type TeacherQueriesGetClassSubjectsByAcademicYearIdArgs = {
  academicYearId: Scalars['ID']['input'];
};


export type TeacherQueriesGetClassSubjectsByClassNameArgs = {
  className?: InputMaybe<Scalars['String']['input']>;
  limit: Scalars['Int']['input'];
  offset: Scalars['Int']['input'];
};


export type TeacherQueriesGetClassSubjectsByFiltersArgs = {
  classSubjectTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  excludeConsulting?: InputMaybe<Scalars['Boolean']['input']>;
  filterAcademyYears: Array<Scalars['ID']['input']>;
  filterStages: Array<Scalars['ID']['input']>;
  filterSubjects: Array<Scalars['ID']['input']>;
  includeFormMasterGroup?: InputMaybe<Scalars['Boolean']['input']>;
  learningTypes?: InputMaybe<Array<LearningTypeEnum>>;
  page?: InputMaybe<PagingInput>;
  regionIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
  schoolINameTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  schoolIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  stageSubjectGroupIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type TeacherQueriesGetClassSubjectsByIdsArgs = {
  classSubjectIds: Array<Scalars['ID']['input']>;
};


export type TeacherQueriesGetClassSubjectsByIdsWithLevelsArgs = {
  classSubjectIds: Array<Scalars['ID']['input']>;
};


export type TeacherQueriesGetClassSubjectsBySubjectArgs = {
  limit: Scalars['Int']['input'];
  offset: Scalars['Int']['input'];
  subjectId?: InputMaybe<Scalars['ID']['input']>;
};


export type TeacherQueriesGetClassSubjectsBySubjectIdAndStageIdArgs = {
  stageId: Scalars['ID']['input'];
  subjectId: Scalars['ID']['input'];
};


export type TeacherQueriesGetClassSubjectsByTeacherTrainingArgs = {
  classSubjectTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  filterAcademyYears: Array<Scalars['ID']['input']>;
  learningType: LearningTypeEnum;
  paging?: InputMaybe<PagingInput>;
  regionIds: Array<Scalars['UUID']['input']>;
  schoolINameTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  schoolIds: Array<Scalars['ID']['input']>;
  stageSubjectGroupIds: Array<Scalars['ID']['input']>;
  subjectIds: Array<Scalars['ID']['input']>;
};


export type TeacherQueriesGetClassSubjectsByTeacherTrainingWithEnumTypeArgs = {
  classSubjectTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  filterAcademyYears: Array<Scalars['ID']['input']>;
  learningTypes: Array<LearningTypeEnum>;
  paging?: InputMaybe<PagingInput>;
  regionIds: Array<Scalars['UUID']['input']>;
  schoolINameTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  schoolIds: Array<Scalars['ID']['input']>;
  stageSubjectGroupIds: Array<Scalars['ID']['input']>;
  subjectIds: Array<Scalars['ID']['input']>;
};


export type TeacherQueriesGetClassSubjectsExtendedInfoArgs = {
  classSubjectIds: Array<Scalars['ID']['input']>;
};


export type TeacherQueriesGetClassSubjectsForFormMasterByStageGroupIdArgs = {
  stageGroupId: Scalars['ID']['input'];
};


export type TeacherQueriesGetClassSubjectsTaughtByTeacherBySubjectIdAndStageIdArgs = {
  stageId: Scalars['ID']['input'];
  subjectId: Scalars['ID']['input'];
};


export type TeacherQueriesGetClassSubjectsWithPerformanceByFiltersArgs = {
  classSubjectTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  excludeConsulting?: InputMaybe<Scalars['Boolean']['input']>;
  filterAcademyYears: Array<Scalars['ID']['input']>;
  filterStages: Array<Scalars['ID']['input']>;
  filterSubjects: Array<Scalars['ID']['input']>;
  includeFormMasterGroup?: InputMaybe<Scalars['Boolean']['input']>;
  learningTypes?: InputMaybe<Array<LearningTypeEnum>>;
  page?: InputMaybe<PagingInput>;
  regionIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
  schoolINameTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  schoolIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  stageSubjectGroupIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type TeacherQueriesGetControlWorksByIdsArgs = {
  classSubjectControlWorkIds: Array<Scalars['ID']['input']>;
};


export type TeacherQueriesGetControlWorksByModuleIdArgs = {
  moduleId: Scalars['ID']['input'];
};


export type TeacherQueriesGetCountUnreadMessagesArgs = {
  studentId: Scalars['UUID']['input'];
  taskId: Scalars['ID']['input'];
};


export type TeacherQueriesGetCurrentSchoolBusinessAdminsArgs = {
  onlyWithEmails?: InputMaybe<Scalars['Boolean']['input']>;
  paging?: InputMaybe<PagingInput>;
};


export type TeacherQueriesGetCurrentStudyPeriodsByStageArgs = {
  stageId: Scalars['ID']['input'];
};


export type TeacherQueriesGetEventsByGoalIdArgs = {
  goalId: Scalars['ID']['input'];
  stageSubjectGroupId: Scalars['ID']['input'];
};


export type TeacherQueriesGetEventsByGoalIdsArgs = {
  goalIds: Array<Scalars['ID']['input']>;
  stageSubjectGroupId: Scalars['ID']['input'];
};


export type TeacherQueriesGetExamModuleByIdArgs = {
  goalId: Scalars['ID']['input'];
};


export type TeacherQueriesGetExperienceHistoryDateArgs = {
  schoolId?: InputMaybe<Scalars['ID']['input']>;
  userId: Scalars['UUID']['input'];
};


export type TeacherQueriesGetFeedbackStatisticsAverageScoreArgs = {
  studentId: Scalars['UUID']['input'];
};


export type TeacherQueriesGetFilterLessonPlansArgs = {
  isArchived?: InputMaybe<Scalars['Boolean']['input']>;
  searchString?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesGetGoalAvailableSchoolsArgs = {
  goalId: Scalars['ID']['input'];
  paging?: InputMaybe<PagingInput>;
};


export type TeacherQueriesGetGoalAvailableUsersArgs = {
  goalId: Scalars['ID']['input'];
  paging?: InputMaybe<PagingInput>;
};


export type TeacherQueriesGetGoalConsistencyInfoArgs = {
  goalId: Scalars['ID']['input'];
};


export type TeacherQueriesGetGoalCurrentAndAvailableScopeTypesArgs = {
  goalId: Scalars['ID']['input'];
};


export type TeacherQueriesGetGoalsByDatePeriodAndStageSubjectGroupArgs = {
  endDate?: InputMaybe<Scalars['DateTime']['input']>;
  stageSubjectGroupId: Scalars['ID']['input'];
  startDate?: InputMaybe<Scalars['DateTime']['input']>;
};


export type TeacherQueriesGetGoalsNumberByStageGroupIdArgs = {
  stageGroupId: Scalars['ID']['input'];
};


export type TeacherQueriesGetGovernmentMarkTypeBySchoolAndStageArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  schoolId: Scalars['UUID']['input'];
  stageId: Scalars['ID']['input'];
};


export type TeacherQueriesGetHomeworkMetaBySelectionIdArgs = {
  selectionId: Scalars['UUID']['input'];
};


export type TeacherQueriesGetJournalCellsArgs = {
  classSubjectId: Scalars['ID']['input'];
  studentName?: InputMaybe<Scalars['String']['input']>;
  studyPeriodId: Scalars['ID']['input'];
};


export type TeacherQueriesGetJournalFinalStudentMarksArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  stageSubjectGroupId: Scalars['ID']['input'];
};


export type TeacherQueriesGetJournalNotificationsArgs = {
  stageSubjectGroupId: Scalars['ID']['input'];
};


export type TeacherQueriesGetLearningActivitiesBySchoolAndSubjectArgs = {
  schoolId: Scalars['UUID']['input'];
  subjectId: Scalars['ID']['input'];
};


export type TeacherQueriesGetLearningActivitiesBySubjectAndStageArgs = {
  stageId: Scalars['ID']['input'];
  subjectId: Scalars['ID']['input'];
};


export type TeacherQueriesGetLessonPlanByIdArgs = {
  lessonPlanId: Scalars['ID']['input'];
};


export type TeacherQueriesGetLessonPlanByIdV2Args = {
  lessonPlanId: Scalars['ID']['input'];
};


export type TeacherQueriesGetLessonPlanByLessonIdArgs = {
  lessonId: Scalars['ID']['input'];
};


export type TeacherQueriesGetLessonPlanMetaBySelectionIdArgs = {
  selectionId: Scalars['UUID']['input'];
};


export type TeacherQueriesGetLessonPlanRecommendationByModuleIdArgs = {
  moduleId: Scalars['ID']['input'];
};


export type TeacherQueriesGetLessonPlansArgs = {
  isArchived?: InputMaybe<Scalars['Boolean']['input']>;
  pagingInput: PagingInput;
  searchString?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesGetLessonPlansByGoalIdAndClassSubjectIdArgs = {
  classSubjectId: Scalars['ID']['input'];
  goalId: Scalars['ID']['input'];
};


export type TeacherQueriesGetLessonPlansByGoalIdsAndClassSubjectIdArgs = {
  classSubjectId: Scalars['ID']['input'];
  goalIds: Array<Scalars['ID']['input']>;
};


export type TeacherQueriesGetLessonPlansByIdsArgs = {
  lessonPlanIds: Array<Scalars['ID']['input']>;
};


export type TeacherQueriesGetLessonPlansCountArgs = {
  isArchived?: InputMaybe<Scalars['Boolean']['input']>;
  searchString?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesGetLessonsForWeekArgs = {
  classSubjectId: Scalars['ID']['input'];
  weekStart: Scalars['DateTime']['input'];
};


export type TeacherQueriesGetLessonsWithLearningActivitiesArgs = {
  classSubjectId: Scalars['ID']['input'];
  studyPeriodId: Scalars['ID']['input'];
};


export type TeacherQueriesGetLessonsWithPublishedLessonPlanArgs = {
  lessonIds: Array<Scalars['ID']['input']>;
};


export type TeacherQueriesGetModuleTaskSetsArgs = {
  moduleId: Scalars['ID']['input'];
};


export type TeacherQueriesGetModulesArgs = {
  authorFIOTextSearch?: InputMaybe<Scalars['String']['input']>;
  filterAccess?: InputMaybe<Scalars['Boolean']['input']>;
  filterArchived?: InputMaybe<Scalars['Boolean']['input']>;
  filterCreateTimeFrom?: InputMaybe<Scalars['String']['input']>;
  filterCreateTimeTo?: InputMaybe<Scalars['String']['input']>;
  filterExceptGoals?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterExecutionType?: InputMaybe<Scalars['Int']['input']>;
  filterForCurrentUser?: InputMaybe<Scalars['Boolean']['input']>;
  filterImported?: InputMaybe<Scalars['Boolean']['input']>;
  filterIsCreatedByCurrentUser?: InputMaybe<Scalars['Boolean']['input']>;
  filterLaboriousnessFrom?: InputMaybe<Scalars['Int']['input']>;
  filterLaboriousnessTo?: InputMaybe<Scalars['Int']['input']>;
  filterReady?: InputMaybe<Scalars['Boolean']['input']>;
  filterSchoolIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterScope?: InputMaybe<ScopeEnum>;
  filterScopes?: InputMaybe<Array<InputMaybe<ScopeEnum>>>;
  filterSoftSkills: Array<Scalars['ID']['input']>;
  filterStages?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterSubjects?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  moduleTaskAvailability: ModuleTaskAvailabilityEnum;
  nameOnlyTextSearch?: InputMaybe<Scalars['Boolean']['input']>;
  paging?: InputMaybe<PagingInput>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  tags?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesGetModulesByBookIdArgs = {
  bookId: Scalars['ID']['input'];
};


export type TeacherQueriesGetModulesByIdsArgs = {
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type TeacherQueriesGetModulesByIdsV2Args = {
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type TeacherQueriesGetModulesCountArgs = {
  authorFIOTextSearch?: InputMaybe<Scalars['String']['input']>;
  filterAccess?: InputMaybe<Scalars['Boolean']['input']>;
  filterArchived?: InputMaybe<Scalars['Boolean']['input']>;
  filterCreateTimeFrom?: InputMaybe<Scalars['String']['input']>;
  filterCreateTimeTo?: InputMaybe<Scalars['String']['input']>;
  filterExecutionType?: InputMaybe<Scalars['Int']['input']>;
  filterForCurrentUser?: InputMaybe<Scalars['Boolean']['input']>;
  filterImported?: InputMaybe<Scalars['Boolean']['input']>;
  filterIsCreatedByCurrentUser?: InputMaybe<Scalars['Boolean']['input']>;
  filterLaboriousnessFrom?: InputMaybe<Scalars['Int']['input']>;
  filterLaboriousnessTo?: InputMaybe<Scalars['Int']['input']>;
  filterReady?: InputMaybe<Scalars['Boolean']['input']>;
  filterSchoolIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterScope?: InputMaybe<ScopeEnum>;
  filterScopes?: InputMaybe<Array<InputMaybe<ScopeEnum>>>;
  filterStages?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterSubjects?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  tags?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesGetModulesForPlanArgs = {
  fLaboriousnessFrom?: InputMaybe<Scalars['Int']['input']>;
  fLaboriousnessTo?: InputMaybe<Scalars['Int']['input']>;
  fSoftSkillIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterIsCreatedByCurrentUser?: InputMaybe<Scalars['Boolean']['input']>;
  filterScopes?: InputMaybe<Array<InputMaybe<ScopeEnum>>>;
  filterStages?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterSubjects?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesGetModulesProgressBySubjectAndStageReportArgs = {
  currentRole: Scalars['String']['input'];
  endDate: Scalars['DateTime']['input'];
  stageSubjectGroupId?: InputMaybe<Scalars['Int']['input']>;
  startDate: Scalars['DateTime']['input'];
};


export type TeacherQueriesGetMotivationBlockByGoalIdArgs = {
  id: Scalars['ID']['input'];
};


export type TeacherQueriesGetMotivationBlockSectionsArgs = {
  id: Scalars['ID']['input'];
};


export type TeacherQueriesGetMyRegionsByTeacherTrainingArgs = {
  schoolIds: Array<Scalars['UUID']['input']>;
  studentIds: Array<Scalars['UUID']['input']>;
};


export type TeacherQueriesGetMySchoolsByTeacherTrainingArgs = {
  filterAcademyYears: Array<Scalars['ID']['input']>;
  learningType: LearningTypeEnum;
  regionIds: Array<Scalars['UUID']['input']>;
  studentIds: Array<Scalars['UUID']['input']>;
};


export type TeacherQueriesGetMySchoolsByTeacherTrainingWithEnumTypeArgs = {
  filterAcademyYears: Array<Scalars['ID']['input']>;
  learningTypes: Array<LearningTypeEnum>;
  regionIds: Array<Scalars['UUID']['input']>;
  studentIds: Array<Scalars['UUID']['input']>;
};


export type TeacherQueriesGetMyStudentsArgs = {
  moduleIds: Array<Scalars['ID']['input']>;
  needFormTeacherStudent?: InputMaybe<Scalars['Boolean']['input']>;
  regionIds: Array<Scalars['UUID']['input']>;
  schoolIds: Array<Scalars['UUID']['input']>;
  stageSubjectGroupIds: Array<Scalars['ID']['input']>;
  studentFioTextSearch?: InputMaybe<Scalars['String']['input']>;
  taskIds: Array<Scalars['ID']['input']>;
};


export type TeacherQueriesGetMySubjectsArgs = {
  filterAcademyYears?: InputMaybe<Array<Scalars['ID']['input']>>;
  learningTypes?: InputMaybe<Array<LearningTypeEnum>>;
};


export type TeacherQueriesGetMySubjectsWithActiveGroupsArgs = {
  filterAcademyYears?: InputMaybe<Array<Scalars['ID']['input']>>;
  learningTypes?: InputMaybe<Array<LearningTypeEnum>>;
};


export type TeacherQueriesGetNeedCheckTasksForDashboardBootcampArgs = {
  ascending: Scalars['Boolean']['input'];
  defaultPeriod?: InputMaybe<Scalars['Boolean']['input']>;
  more3daysInStatus: Scalars['Boolean']['input'];
  paging: PagingInput;
};


export type TeacherQueriesGetNeedCheckTeacherStudentTasksArgs = {
  filteringDateFrom?: InputMaybe<Scalars['Date']['input']>;
  filteringDateTo?: InputMaybe<Scalars['Date']['input']>;
  groupKey?: InputMaybe<StudentTaskGroupTypeEnum>;
  learningTypes: Array<LearningTypeEnum>;
  paging?: InputMaybe<PagingInput>;
};


export type TeacherQueriesGetNestedClassSubjectsByStageSubjectGroupIdArgs = {
  stageSubjectGroupId: Scalars['ID']['input'];
};


export type TeacherQueriesGetNotesBetweenDateArgs = {
  fromDate: Scalars['DateTime']['input'];
  toDate: Scalars['DateTime']['input'];
};


export type TeacherQueriesGetNotesByDateArgs = {
  atDate: Scalars['Date']['input'];
};


export type TeacherQueriesGetNotificationsArgs = {
  paging?: InputMaybe<PagingInput>;
  wasReadIncluded?: InputMaybe<Scalars['Boolean']['input']>;
};


export type TeacherQueriesGetNotificationsByTypesArgs = {
  includeOnlyCurrentYearNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  paging?: InputMaybe<PagingInput>;
  typeIds: Array<Scalars['ID']['input']>;
  wasReadIncluded?: InputMaybe<Scalars['Boolean']['input']>;
};


export type TeacherQueriesGetNotificationsCountArgs = {
  wasReadIncluded?: InputMaybe<Scalars['Boolean']['input']>;
};


export type TeacherQueriesGetPedagogicalTechniquesArgs = {
  paging?: InputMaybe<PagingInput>;
  sortingFields?: InputMaybe<Array<SortingField>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesGetPersonalTrajectoryArgs = {
  goalId?: InputMaybe<Scalars['ID']['input']>;
  studentId: Scalars['ID']['input'];
  taskId?: InputMaybe<Scalars['ID']['input']>;
};


export type TeacherQueriesGetPortfolioDocumentsArgs = {
  documentAmount?: InputMaybe<Scalars['String']['input']>;
  documentCategory?: InputMaybe<Scalars['String']['input']>;
  documentType?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesGetRecommendedDurationForModulesArgs = {
  classSubjectId: Scalars['ID']['input'];
  goalIds: Array<Scalars['ID']['input']>;
};


export type TeacherQueriesGetScheduleArgs = {
  from: Scalars['DateTime']['input'];
  to: Scalars['DateTime']['input'];
};


export type TeacherQueriesGetScheduleByStageSubjectGroupArgs = {
  from: Scalars['DateTime']['input'];
  stageSubjectGroupId: Scalars['ID']['input'];
  to: Scalars['DateTime']['input'];
};


export type TeacherQueriesGetSchoolMarkTypeGroupConfigurationsBySchoolAndStageArgs = {
  academicYearId: Scalars['ID']['input'];
  schoolId: Scalars['UUID']['input'];
  stageId: Scalars['Int']['input'];
};


export type TeacherQueriesGetSchoolMonitoringArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  schoolMonitoringInput?: InputMaybe<SchoolMonitoringInput>;
};


export type TeacherQueriesGetSchoolStageMarksArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  schoolId: Scalars['UUID']['input'];
  stageId: Scalars['ID']['input'];
};


export type TeacherQueriesGetSchoolTeachersArgs = {
  page?: InputMaybe<PagingInput>;
  schoolId?: InputMaybe<Scalars['ID']['input']>;
  stageGroupNameFormMaster?: InputMaybe<Scalars['String']['input']>;
  stageGroupNameTeacher?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


export type TeacherQueriesGetSoftSkillTypesArgs = {
  isArchive?: InputMaybe<Scalars['Boolean']['input']>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
};


export type TeacherQueriesGetSoftSkillTypesV2Args = {
  isArchive?: InputMaybe<Scalars['Boolean']['input']>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  taskId?: InputMaybe<Scalars['ID']['input']>;
};


export type TeacherQueriesGetStageGroupStudentRequestsArgs = {
  stageGroupId?: InputMaybe<Scalars['ID']['input']>;
  status?: InputMaybe<StageGroupStudentRequestStatus>;
};


export type TeacherQueriesGetStageGroupsBySchoolAndTeacherArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  excludeConsulting?: InputMaybe<Scalars['Boolean']['input']>;
  stageId?: InputMaybe<Scalars['ID']['input']>;
};


export type TeacherQueriesGetStageGroupsS21PublicProfileArgs = {
  studentId: Scalars['UUID']['input'];
};


export type TeacherQueriesGetStageSubjectGroupStudentsByYearArgs = {
  stageSubjectGroupId: Scalars['ID']['input'];
};


export type TeacherQueriesGetStageSubjectGroupsByStageGroupAndSubjectArgs = {
  stageGroupId: Scalars['ID']['input'];
  subjectId: Scalars['ID']['input'];
};


export type TeacherQueriesGetStagesArgs = {
  isSchool21?: InputMaybe<Scalars['Boolean']['input']>;
};


export type TeacherQueriesGetStagesForTeacherArgs = {
  filterAcademyYears?: InputMaybe<Array<Scalars['ID']['input']>>;
  learningTypes?: InputMaybe<Array<LearningTypeEnum>>;
};


export type TeacherQueriesGetStagesForTeacherWithoutFormMasterArgs = {
  filterAcademyYears?: InputMaybe<Array<Scalars['ID']['input']>>;
  learningTypes?: InputMaybe<Array<LearningTypeEnum>>;
};


export type TeacherQueriesGetStudentAttendanceArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  studentId: Scalars['ID']['input'];
  studyPeriodIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  subjectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type TeacherQueriesGetStudentAttendanceStatisticsByPeriodArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  studentId: Scalars['ID']['input'];
  studyPeriodId?: InputMaybe<Scalars['ID']['input']>;
};


export type TeacherQueriesGetStudentDiaryForTeacherArgs = {
  date: Scalars['Date']['input'];
  stageGroupId: Scalars['ID']['input'];
};


export type TeacherQueriesGetStudentEffortEstimationArgs = {
  studentTaskId: Scalars['ID']['input'];
  studentUserId: Scalars['UUID']['input'];
};


export type TeacherQueriesGetStudentFeedbackArgs = {
  studentId: Scalars['UUID']['input'];
  taskId: Scalars['ID']['input'];
};


export type TeacherQueriesGetStudentInSubgroupWithPersonalizedPlanArgs = {
  studentInSubgroupId: Scalars['ID']['input'];
};


export type TeacherQueriesGetStudentJournalPerformanceArgs = {
  stageId: Scalars['Int']['input'];
  studyPeriodId: Scalars['Int']['input'];
};


export type TeacherQueriesGetStudentModuleArgs = {
  moduleId: Scalars['ID']['input'];
  studentId?: InputMaybe<Scalars['UUID']['input']>;
};


export type TeacherQueriesGetStudentModuleInformationArgs = {
  moduleId: Scalars['ID']['input'];
  studentId?: InputMaybe<Scalars['UUID']['input']>;
};


export type TeacherQueriesGetStudentModuleInformationWithAvailablePlaylistsArgs = {
  moduleId: Scalars['ID']['input'];
  stageSubjectGroupId?: InputMaybe<Scalars['ID']['input']>;
  studentId: Scalars['UUID']['input'];
};


export type TeacherQueriesGetStudentModuleV2Args = {
  moduleId: Scalars['ID']['input'];
  studentId?: InputMaybe<Scalars['UUID']['input']>;
};


export type TeacherQueriesGetStudentModulesForProgressReportArgs = {
  filter: StudentProgressSearchModulesInput;
};


export type TeacherQueriesGetStudentModulesForProgressReportForBtcArgs = {
  filter: StudentProgressSearchModulesInput;
};


export type TeacherQueriesGetStudentModulesTaskStatusQuantityWithEnumTypeArgs = {
  moduleIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  statuses?: InputMaybe<Array<TaskStatusEnum>>;
  studentInSubgroupIds: Array<Scalars['ID']['input']>;
  taskCheckTypes?: InputMaybe<Array<TaskCheckEnum>>;
  taskIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type TeacherQueriesGetStudentObjectivesByStatusesArgs = {
  statuses: Array<PersonalObjectiveStatusEnum>;
  studentId: Scalars['UUID']['input'];
};


export type TeacherQueriesGetStudentPlanGoalsWithTaskSetsForClassSubjectArgs = {
  stageSubjectGroupId: Scalars['ID']['input'];
};


export type TeacherQueriesGetStudentProfileArgs = {
  studentId: Scalars['ID']['input'];
};


export type TeacherQueriesGetStudentProgressForBmArgs = {
  filter: StudentProgressFilterBtcInputModelV2;
};


export type TeacherQueriesGetStudentProgressForBmCountArgs = {
  filter: StudentProgressFilterBtcInputModelV2;
};


export type TeacherQueriesGetStudentProjectsByStageGroupArgs = {
  stageGroupId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};


export type TeacherQueriesGetStudentRadarChartDataArgs = {
  atDate?: InputMaybe<Scalars['Date']['input']>;
  studentId: Scalars['ID']['input'];
};


export type TeacherQueriesGetStudentSkillRadarChartDataArgs = {
  softSkillId?: InputMaybe<Scalars['ID']['input']>;
  studentId: Scalars['ID']['input'];
};


export type TeacherQueriesGetStudentSubjectProgressStateWithDetailsArgs = {
  studentId: Scalars['ID']['input'];
  subjectId: Scalars['ID']['input'];
};


export type TeacherQueriesGetStudentTaskAnswersArgs = {
  studentId: Scalars['UUID']['input'];
  taskId: Scalars['ID']['input'];
};


export type TeacherQueriesGetStudentTaskInfoArgs = {
  studentId: Scalars['UUID']['input'];
  taskId: Scalars['ID']['input'];
};


export type TeacherQueriesGetStudentTaskStatusQuantityArgs = {
  goalLevelValues: Array<Scalars['Float']['input']>;
  lastNeedCheckStatusDateTimeFrom?: InputMaybe<Scalars['DateTime']['input']>;
  lastNeedCheckStatusDateTimeTo?: InputMaybe<Scalars['DateTime']['input']>;
  learningType?: InputMaybe<LearningTypeEnum>;
  modifiedFrom?: InputMaybe<Scalars['DateTime']['input']>;
  modifiedTo?: InputMaybe<Scalars['DateTime']['input']>;
  moduleIds: Array<Scalars['ID']['input']>;
  stageSubjectGroupIds: Array<Scalars['ID']['input']>;
  statusDateModifiedFrom?: InputMaybe<Scalars['Date']['input']>;
  statusDateModifiedTo?: InputMaybe<Scalars['Date']['input']>;
  statuses: Array<TaskStatusEnum>;
  studentIds: Array<Scalars['UUID']['input']>;
  subjectIds: Array<Scalars['ID']['input']>;
  taskCheckTypes: Array<TaskCheckEnum>;
  taskIds: Array<Scalars['ID']['input']>;
  taskTypes: Array<TaskTypeEnum>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesGetStudentTaskStatusQuantityCompetitionArgs = {
  externalCompetitionIds: Array<Scalars['ID']['input']>;
  moduleIds: Array<Scalars['ID']['input']>;
  statusDateModifiedFrom?: InputMaybe<Scalars['Date']['input']>;
  statusDateModifiedTo?: InputMaybe<Scalars['Date']['input']>;
  statuses: Array<TaskStatusEnum>;
  taskCheckTypes: Array<TaskCheckEnum>;
  taskIds: Array<Scalars['ID']['input']>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesGetStudentTaskStatusQuantityWithEnumTypeArgs = {
  goalLevelValues: Array<Scalars['Float']['input']>;
  includeFormMaster?: InputMaybe<Scalars['Boolean']['input']>;
  lastNeedCheckStatusDateTimeFrom?: InputMaybe<Scalars['DateTime']['input']>;
  lastNeedCheckStatusDateTimeTo?: InputMaybe<Scalars['DateTime']['input']>;
  learningTypes: Array<LearningTypeEnum>;
  modifiedFrom?: InputMaybe<Scalars['DateTime']['input']>;
  modifiedTo?: InputMaybe<Scalars['DateTime']['input']>;
  moduleIds: Array<Scalars['ID']['input']>;
  replaceStudentTaskStatusesForTeacher?: InputMaybe<Scalars['Boolean']['input']>;
  stageSubjectGroupIds: Array<Scalars['ID']['input']>;
  statusDateModifiedFrom?: InputMaybe<Scalars['Date']['input']>;
  statusDateModifiedTo?: InputMaybe<Scalars['Date']['input']>;
  statuses: Array<TaskStatusEnum>;
  studentIds: Array<Scalars['UUID']['input']>;
  subjectIds: Array<Scalars['ID']['input']>;
  taskCheckTypes: Array<TaskCheckEnum>;
  taskIds: Array<Scalars['ID']['input']>;
  taskTypes: Array<TaskTypeEnum>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesGetStudentTasksArgs = {
  goalLevelValues: Array<Scalars['Float']['input']>;
  groupKeys: Array<StudentTaskGroupTypeEnum>;
  lastNeedCheckStatusDateTimeFrom?: InputMaybe<Scalars['DateTime']['input']>;
  lastNeedCheckStatusDateTimeTo?: InputMaybe<Scalars['DateTime']['input']>;
  learningType?: InputMaybe<LearningTypeEnum>;
  modifiedFrom?: InputMaybe<Scalars['DateTime']['input']>;
  modifiedTo?: InputMaybe<Scalars['DateTime']['input']>;
  moduleIds: Array<Scalars['ID']['input']>;
  moduleTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  paging: PagingInput;
  regionIds: Array<Scalars['UUID']['input']>;
  schoolIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
  sorting: Array<SortingField>;
  stageSubjectGroupIds: Array<Scalars['ID']['input']>;
  stageSubjectGroupTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  statusDateModifiedFrom?: InputMaybe<Scalars['Date']['input']>;
  statusDateModifiedTo?: InputMaybe<Scalars['Date']['input']>;
  statuses: Array<TaskStatusEnum>;
  studentFioTextSearch?: InputMaybe<Scalars['String']['input']>;
  studentIds: Array<Scalars['UUID']['input']>;
  subjectIds: Array<Scalars['ID']['input']>;
  subjectTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  taskCheckTypes: Array<TaskCheckEnum>;
  taskIds: Array<Scalars['ID']['input']>;
  taskTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  taskTypes: Array<TaskTypeEnum>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesGetStudentTasksByLessonArgs = {
  lessonId: Scalars['ID']['input'];
};


export type TeacherQueriesGetStudentTasksByLessonPlanArgs = {
  lessonPlanId: Scalars['ID']['input'];
};


export type TeacherQueriesGetStudentTasksCountArgs = {
  goalLevelValues: Array<Scalars['Float']['input']>;
  lastNeedCheckStatusDateTimeFrom?: InputMaybe<Scalars['DateTime']['input']>;
  lastNeedCheckStatusDateTimeTo?: InputMaybe<Scalars['DateTime']['input']>;
  modifiedFrom?: InputMaybe<Scalars['DateTime']['input']>;
  modifiedTo?: InputMaybe<Scalars['DateTime']['input']>;
  moduleIds: Array<Scalars['ID']['input']>;
  moduleTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  schoolIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
  searchType?: InputMaybe<Array<TaskSearchTypeEnum>>;
  stageSubjectGroupIds: Array<Scalars['ID']['input']>;
  stageSubjectGroupTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  statusDateModifiedFrom?: InputMaybe<Scalars['Date']['input']>;
  statusDateModifiedTo?: InputMaybe<Scalars['Date']['input']>;
  statuses: Array<TaskStatusEnum>;
  studentFioTextSearch?: InputMaybe<Scalars['String']['input']>;
  studentIds: Array<Scalars['UUID']['input']>;
  subjectIds: Array<Scalars['ID']['input']>;
  subjectTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  taskCheckTypes: Array<TaskCheckEnum>;
  taskIds: Array<Scalars['ID']['input']>;
  taskTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  taskTypes: Array<TaskTypeEnum>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesGetStudentTasksCountWithEnumTypeArgs = {
  goalLevelValues: Array<Scalars['Float']['input']>;
  includeFormMaster?: InputMaybe<Scalars['Boolean']['input']>;
  lastNeedCheckStatusDateTimeFrom?: InputMaybe<Scalars['DateTime']['input']>;
  lastNeedCheckStatusDateTimeTo?: InputMaybe<Scalars['DateTime']['input']>;
  learningTypes: Array<LearningTypeEnum>;
  modifiedFrom?: InputMaybe<Scalars['DateTime']['input']>;
  modifiedTo?: InputMaybe<Scalars['DateTime']['input']>;
  moduleIds: Array<Scalars['ID']['input']>;
  moduleTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  schoolIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
  searchType?: InputMaybe<Array<TaskSearchTypeEnum>>;
  stageSubjectGroupIds: Array<Scalars['ID']['input']>;
  stageSubjectGroupTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  statusDateModifiedFrom?: InputMaybe<Scalars['Date']['input']>;
  statusDateModifiedTo?: InputMaybe<Scalars['Date']['input']>;
  statuses: Array<TaskStatusEnum>;
  studentFioTextSearch?: InputMaybe<Scalars['String']['input']>;
  studentIds: Array<Scalars['UUID']['input']>;
  subjectIds: Array<Scalars['ID']['input']>;
  subjectTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  taskCheckTypes: Array<TaskCheckEnum>;
  taskIds: Array<Scalars['ID']['input']>;
  taskTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  taskTypes: Array<TaskTypeEnum>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesGetStudentTasksForExternalCompetitionsArgs = {
  competitionTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  externalCompetitionIds: Array<Scalars['ID']['input']>;
  groupKeys: Array<StudentTaskGroupTypeEnum>;
  moduleIds: Array<Scalars['ID']['input']>;
  moduleTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  paging: PagingInput;
  sorting: Array<SortingField>;
  statusDateModifiedFrom?: InputMaybe<Scalars['Date']['input']>;
  statusDateModifiedTo?: InputMaybe<Scalars['Date']['input']>;
  statuses: Array<TaskStatusEnum>;
  studentIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  taskCheckTypes: Array<TaskCheckEnum>;
  taskIds: Array<Scalars['ID']['input']>;
  taskTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesGetStudentTasksWithEnumTypeArgs = {
  goalLevelValues: Array<Scalars['Float']['input']>;
  groupKeys: Array<StudentTaskGroupTypeEnum>;
  includeFormMaster?: InputMaybe<Scalars['Boolean']['input']>;
  includeOnlyCurrentYear?: InputMaybe<Scalars['Boolean']['input']>;
  lastNeedCheckStatusDateTimeFrom?: InputMaybe<Scalars['DateTime']['input']>;
  lastNeedCheckStatusDateTimeTo?: InputMaybe<Scalars['DateTime']['input']>;
  learningTypes: Array<LearningTypeEnum>;
  modifiedFrom?: InputMaybe<Scalars['DateTime']['input']>;
  modifiedTo?: InputMaybe<Scalars['DateTime']['input']>;
  moduleIds: Array<Scalars['ID']['input']>;
  moduleTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  paging: PagingInput;
  regionIds: Array<Scalars['UUID']['input']>;
  schoolIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
  searchType?: InputMaybe<Array<TaskSearchTypeEnum>>;
  sorting: Array<SortingField>;
  stageSubjectGroupIds: Array<Scalars['ID']['input']>;
  stageSubjectGroupTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  statusDateModifiedFrom?: InputMaybe<Scalars['Date']['input']>;
  statusDateModifiedTo?: InputMaybe<Scalars['Date']['input']>;
  statuses: Array<TaskStatusEnum>;
  studentFioTextSearch?: InputMaybe<Scalars['String']['input']>;
  studentIds: Array<Scalars['UUID']['input']>;
  subjectIds: Array<Scalars['ID']['input']>;
  subjectTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  taskCheckTypes: Array<TaskCheckEnum>;
  taskIds: Array<Scalars['ID']['input']>;
  taskTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  taskTypes: Array<TaskTypeEnum>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesGetStudentTasksWithQuestionsArgs = {
  classSubjectId: Scalars['ID']['input'];
  hasQuestion?: InputMaybe<Scalars['Boolean']['input']>;
  paging: PagingInput;
  playlistType: PlaylistType;
  sorting?: InputMaybe<Array<SortingField>>;
  statuses?: InputMaybe<Array<TaskStatusEnum>>;
  studentIds: Array<Scalars['UUID']['input']>;
  taskIds: Array<Scalars['ID']['input']>;
  taskSetId: Scalars['ID']['input'];
};


export type TeacherQueriesGetStudentTasksWithStatusReplacementArgs = {
  groupKeys: Array<StudentTaskGroupTypeEnum>;
  hideNotStartedOutOfTrajectoryTasks?: InputMaybe<Scalars['Boolean']['input']>;
  lastNeedCheckStatusDateTimeFrom?: InputMaybe<Scalars['DateTime']['input']>;
  lastNeedCheckStatusDateTimeTo?: InputMaybe<Scalars['DateTime']['input']>;
  learningTypes: Array<LearningTypeEnum>;
  moduleIds: Array<Scalars['ID']['input']>;
  paging: PagingInput;
  schoolIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
  sorting: Array<SortingField>;
  statuses: Array<TaskStatusEnum>;
  studentIds: Array<Scalars['UUID']['input']>;
  taskCheckTypes: Array<TaskCheckEnum>;
  taskIds: Array<Scalars['ID']['input']>;
};


export type TeacherQueriesGetStudentsAcademicPerformanceArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  stageId: Scalars['Int']['input'];
  stageSubjectGroupId?: InputMaybe<Scalars['Int']['input']>;
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type TeacherQueriesGetStudentsAcademicPerformanceByAttestationPeriodArgs = {
  closeModuleDate: Scalars['Date']['input'];
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  stageId: Scalars['Int']['input'];
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type TeacherQueriesGetStudentsAcademicPerformanceByAttestationPeriodExpandedArgs = {
  closeModuleDate: Scalars['Date']['input'];
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  stageId: Scalars['Int']['input'];
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type TeacherQueriesGetStudentsAcademicPerformanceByAttestationPeriodExpandedV2Args = {
  closeModuleDate: Scalars['Date']['input'];
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  stageId: Scalars['Int']['input'];
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type TeacherQueriesGetStudentsAcademicPerformanceExpandedArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  stageId: Scalars['Int']['input'];
  stageSubjectGroupId?: InputMaybe<Scalars['Int']['input']>;
  startDate: Scalars['DateTime']['input'];
};


export type TeacherQueriesGetStudentsAcademicPerformanceExpandedV2Args = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  stageId: Scalars['Int']['input'];
  stageSubjectGroupId?: InputMaybe<Scalars['Int']['input']>;
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type TeacherQueriesGetStudentsAcademicPerformanceExpandedV3Args = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  endDate: Scalars['DateTime']['input'];
  stageId: Scalars['Int']['input'];
  stageSubjectGroupId?: InputMaybe<Scalars['Int']['input']>;
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type TeacherQueriesGetStudentsForProgressArgs = {
  filter: StudentSearchFilterInput;
};


export type TeacherQueriesGetStudentsForProgressCountArgs = {
  filter: StudentSearchCountFilterInput;
};


export type TeacherQueriesGetStudentsForProgressCountForBtcArgs = {
  filter: StudentSearchCountFilterInput;
  mode?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesGetStudentsForProgressCountForBtcv2Args = {
  filter: StudentSearchCountFilterBtcInput;
  mode?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesGetStudentsInSubgroupByIdsArgs = {
  studentsInSubgroupIds: Array<Scalars['ID']['input']>;
};


export type TeacherQueriesGetStudentsInSubgroupByStudentInSubgroupIdArgs = {
  paging?: InputMaybe<PagingInput>;
  studentInSubgroupId: Scalars['ID']['input'];
};


export type TeacherQueriesGetStudentsInSubgroupGridArgs = {
  studentsInSubgroupId: Scalars['ID']['input'];
};


export type TeacherQueriesGetStudentsMarksResultDetailedArgs = {
  stageGroupId: Scalars['Int']['input'];
  stageId: Scalars['Int']['input'];
  studyPeriodId: Scalars['Int']['input'];
  subjectId: Scalars['Int']['input'];
};


export type TeacherQueriesGetStudentsMarksResultDetailedByDatesArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  currentRole?: InputMaybe<Scalars['String']['input']>;
  periodEndDate: Scalars['Date']['input'];
  periodStartDate: Scalars['Date']['input'];
  stageGroupId: Scalars['Int']['input'];
  stageId: Scalars['Int']['input'];
  subjectId: Scalars['Int']['input'];
};


export type TeacherQueriesGetStudentsMarksSubjectsDetailedArgs = {
  stageId: Scalars['Int']['input'];
  studentId: Scalars['UUID']['input'];
  studyPeriodId: Scalars['Int']['input'];
};


export type TeacherQueriesGetStudentsMarksSubjectsDetailedByDatesArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  periodEndDate: Scalars['Date']['input'];
  periodStartDate: Scalars['Date']['input'];
  stageId: Scalars['Int']['input'];
  studentId: Scalars['UUID']['input'];
};


export type TeacherQueriesGetStudentsProgressArgs = {
  filter: StudentProgressFilterInput;
};


export type TeacherQueriesGetStudentsProgressByTrajectoryForBtcArgs = {
  filter: StudentProgressFilterInput;
};


export type TeacherQueriesGetStudentsProgressByTrajectoryForBtcv2Args = {
  filter: StudentProgressFilterBtcInput;
};


export type TeacherQueriesGetStudentsProgressForBtcArgs = {
  filter: StudentProgressFilterInput;
};


export type TeacherQueriesGetStudentsProgressForBtcv2Args = {
  filter: StudentProgressFilterBtcInput;
};


export type TeacherQueriesGetStudentsSkillRadarChartDataArgs = {
  stageGroupIds: Array<Scalars['ID']['input']>;
};


export type TeacherQueriesGetStudentsWithPerformanceArgs = {
  classSubjectGroupId: Scalars['ID']['input'];
  studyPeriodId: Scalars['ID']['input'];
};


export type TeacherQueriesGetStudyModuleGoalElementsForTaskSetArgs = {
  playlistType: PlaylistType;
  taskSetId: Scalars['ID']['input'];
};


export type TeacherQueriesGetStudyModuleNameRecommendationsByBookIdsArgs = {
  bookIds: Array<Scalars['ID']['input']>;
};


export type TeacherQueriesGetStudyModuleNameRecommendationsBySearchStringArgs = {
  searchString: Scalars['String']['input'];
};


export type TeacherQueriesGetStudyPeriodMarksArgs = {
  academicYearId?: InputMaybe<Scalars['ID']['input']>;
  currentRole?: InputMaybe<Scalars['String']['input']>;
  stageGroupId?: InputMaybe<Scalars['Int']['input']>;
  stageId: Scalars['Int']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
};


export type TeacherQueriesGetStudyPeriodsByStudyPeriodSetArgs = {
  studyPeriodSetId: Scalars['ID']['input'];
};


export type TeacherQueriesGetSubgroupsByIdsArgs = {
  subgroupIds: Array<Scalars['ID']['input']>;
};


export type TeacherQueriesGetSubjectsByStageGroupAntSchoolAndTeacherArgs = {
  stageGroupId: Scalars['ID']['input'];
};


export type TeacherQueriesGetTaskAnswersArgs = {
  studentId: Scalars['UUID']['input'];
  taskId: Scalars['ID']['input'];
};


export type TeacherQueriesGetTaskAvailableSchoolsArgs = {
  paging?: InputMaybe<PagingInput>;
  taskId: Scalars['ID']['input'];
};


export type TeacherQueriesGetTaskAvailableUsersArgs = {
  paging?: InputMaybe<PagingInput>;
  taskId: Scalars['ID']['input'];
};


export type TeacherQueriesGetTaskConsistencyInfoArgs = {
  taskId: Scalars['ID']['input'];
};


export type TeacherQueriesGetTaskCriteriaArgs = {
  taskId: Scalars['ID']['input'];
};


export type TeacherQueriesGetTaskCriteriaPercentArgs = {
  studentId: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
};


export type TeacherQueriesGetTaskCriteriaPercentByStudentIdArgs = {
  studentId: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
};


export type TeacherQueriesGetTaskCriteriaValuesArgs = {
  isConfirmed?: InputMaybe<Scalars['Boolean']['input']>;
  studentId: Scalars['ID']['input'];
  taskId: Scalars['ID']['input'];
};


export type TeacherQueriesGetTaskCurrentAndAvailableScopeTypesArgs = {
  taskId: Scalars['ID']['input'];
};


export type TeacherQueriesGetTaskMessagesArgs = {
  studentId: Scalars['UUID']['input'];
  taskId: Scalars['ID']['input'];
};


export type TeacherQueriesGetTaskMetaArgs = {
  language?: InputMaybe<Scalars['String']['input']>;
  taskId: Scalars['ID']['input'];
};


export type TeacherQueriesGetTaskSetByGoalIdsArgs = {
  goalIds: Array<Scalars['ID']['input']>;
};


export type TeacherQueriesGetTaskSetPerformanceArgs = {
  classSubjectId: Scalars['ID']['input'];
  goalElementIds: Array<Scalars['ID']['input']>;
  hasQuestions?: InputMaybe<Scalars['Boolean']['input']>;
  playlistType: PlaylistType;
  studentIds: Array<Scalars['UUID']['input']>;
  taskForms: Array<TaskAssignmentEnum>;
  taskIds: Array<Scalars['ID']['input']>;
  taskSetId: Scalars['ID']['input'];
  taskStatuses: Array<TaskStatusEnum>;
  taskTypes: Array<TaskTypeEnum>;
};


export type TeacherQueriesGetTaskSetSLotsByFilterArgs = {
  isCheckSlot?: InputMaybe<Scalars['Boolean']['input']>;
  moduleIds: Array<Scalars['ID']['input']>;
  moduleLevelValues: Array<Scalars['String']['input']>;
  slotType?: InputMaybe<PlaylistSlotTypeEnum>;
  taskSetIds: Array<Scalars['ID']['input']>;
};


export type TeacherQueriesGetTaskSetSlotByIdArgs = {
  slotId: Scalars['ID']['input'];
  taskSetType: PlaylistType;
};


export type TeacherQueriesGetTasksArgs = {
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  filterAccess?: InputMaybe<Scalars['Boolean']['input']>;
  filterGoalLevelValues: Array<Scalars['String']['input']>;
  filterLaboriousnessFrom?: InputMaybe<Scalars['Int']['input']>;
  filterLaboriousnessTo?: InputMaybe<Scalars['Int']['input']>;
  filterLicense?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterNoParent?: InputMaybe<Scalars['Boolean']['input']>;
  filterScopes: Array<ScopeEnum>;
  filterSoftSkillTypes: Array<Scalars['ID']['input']>;
  filterStages: Array<Scalars['ID']['input']>;
  filterSubjects: Array<Scalars['ID']['input']>;
  filterTaskTypes: Array<TaskTypeEnum>;
  isInModule?: InputMaybe<Scalars['Boolean']['input']>;
  myCreatedTasks?: InputMaybe<Scalars['Boolean']['input']>;
  myStagesAndModules?: InputMaybe<Scalars['Boolean']['input']>;
  organizationType?: InputMaybe<OrganizationType>;
  paging?: InputMaybe<PagingInput>;
  sortingFields: Array<SortingField>;
  tags: Array<Scalars['String']['input']>;
  taskAssignmentTypes?: InputMaybe<Array<InputMaybe<TaskAssignmentEnum>>>;
  taskCheckTypes: Array<TaskCheckEnum>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesGetTasksByIdsArgs = {
  ids: Array<Scalars['ID']['input']>;
  studentId?: InputMaybe<Scalars['ID']['input']>;
};


export type TeacherQueriesGetTasksConsistencyInfoArgs = {
  taskIds: Array<Scalars['ID']['input']>;
};


export type TeacherQueriesGetTasksOnCheckArgs = {
  currentRole: Scalars['String']['input'];
  endDate: Scalars['DateTime']['input'];
  stageGroupId?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageSubjectGroupId?: InputMaybe<Scalars['Int']['input']>;
  startDate: Scalars['DateTime']['input'];
  subjectId?: InputMaybe<Scalars['Int']['input']>;
  tasksDate: Scalars['DateTime']['input'];
};


export type TeacherQueriesGetTasksOnCheckDetailedArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  tasksOnCheckInput: TasksOnCheckInput;
};


export type TeacherQueriesGetTasksWithCountArgs = {
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  filterAccess?: InputMaybe<Scalars['Boolean']['input']>;
  filterGoalLevelValues: Array<Scalars['String']['input']>;
  filterLaboriousnessFrom?: InputMaybe<Scalars['Int']['input']>;
  filterLaboriousnessTo?: InputMaybe<Scalars['Int']['input']>;
  filterLicense?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  filterNoParent?: InputMaybe<Scalars['Boolean']['input']>;
  filterScopes: Array<ScopeEnum>;
  filterSoftSkillTypes: Array<Scalars['ID']['input']>;
  filterStages: Array<Scalars['ID']['input']>;
  filterSubjects: Array<Scalars['ID']['input']>;
  filterTaskTypes: Array<TaskTypeEnum>;
  isInModule?: InputMaybe<Scalars['Boolean']['input']>;
  myCreatedTasks?: InputMaybe<Scalars['Boolean']['input']>;
  myStagesAndModules?: InputMaybe<Scalars['Boolean']['input']>;
  organizationType?: InputMaybe<OrganizationType>;
  paging?: InputMaybe<PagingInput>;
  solutionTypes?: InputMaybe<Array<InputMaybe<TaskSolutionTypeEnum>>>;
  sortingFields: Array<SortingField>;
  tags: Array<Scalars['String']['input']>;
  taskAssignmentTypes?: InputMaybe<Array<InputMaybe<TaskAssignmentEnum>>>;
  taskCheckTypes: Array<TaskCheckEnum>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesGetTeacherDiaryArgs = {
  date: Scalars['Date']['input'];
};


export type TeacherQueriesGetTeacherScheduleArgs = {
  from: Scalars['DateTime']['input'];
  to: Scalars['DateTime']['input'];
};


export type TeacherQueriesGetTeacherSchoolMetricsArgs = {
  currentRole: Scalars['String']['input'];
  teacherSchoolMetricsInput?: InputMaybe<SchoolMonitoringInput>;
};


export type TeacherQueriesGetTeacherSchoolMetricsExcelArgs = {
  currentRole?: InputMaybe<Scalars['String']['input']>;
  reportDateTime: Scalars['String']['input'];
  teacherSchoolMetricsInput: SchoolMonitoringInput;
};


export type TeacherQueriesGetTeacherTimetableByPeriodArgs = {
  fromDateTime: Scalars['DateTime']['input'];
  toDateTime: Scalars['DateTime']['input'];
};


export type TeacherQueriesGetTimeSlotSetsByStageGroupArgs = {
  stageGroupId: Scalars['ID']['input'];
};


export type TeacherQueriesGetTodosArgs = {
  limit: Scalars['Int']['input'];
  offset: Scalars['Int']['input'];
};


export type TeacherQueriesGetUmKsArgs = {
  filter: UmkFilterInput;
};


export type TeacherQueriesGetUmKsBySubjectIdsAndStageIdsArgs = {
  stageIds: Array<Scalars['ID']['input']>;
  subjectIds: Array<Scalars['ID']['input']>;
};


export type TeacherQueriesGetUserExperienceArgs = {
  userId: Scalars['ID']['input'];
};


export type TeacherQueriesGetUsersArgs = {
  filterConfiguredUsers?: InputMaybe<Scalars['Boolean']['input']>;
  filterRoleStatus?: InputMaybe<RoleStatus>;
  filterRoles: Array<Scalars['String']['input']>;
  filterStageGroups: Array<Scalars['ID']['input']>;
  filterSubjects: Array<Scalars['ID']['input']>;
  filterUserStatus?: InputMaybe<UserStatus>;
  graduationDateTimeEnd?: InputMaybe<Scalars['DateTime']['input']>;
  graduationDateTimeStart?: InputMaybe<Scalars['DateTime']['input']>;
  paging?: InputMaybe<PagingInput>;
  sortingFields: Array<SortingField>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type TeacherQueriesGetVcUrlArgs = {
  roomTitle?: InputMaybe<Scalars['String']['input']>;
};

export type TeacherRole = {
  __typename?: 'TeacherRole';
  /**
   * предпочитаемые кабинеты учителя
   * @deprecated Кабинеты не являются частью роли
   */
  classrooms: Array<ClassRoom>;
  /** дата деактивации роли */
  dateEnd?: Maybe<Scalars['DateTime']['output']>;
  /** дата активации роли */
  dateStart?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  /** является ли роль дефолтной при входе пользователя в приложение */
  isDefault: Scalars['Boolean']['output'];
  orgUnitId?: Maybe<Scalars['ID']['output']>;
  productId?: Maybe<Scalars['ID']['output']>;
  /** название роли */
  role: Roles;
  school: SafeSchool;
  schoolId: Scalars['ID']['output'];
  status: RoleStatus;
  /**
   * группы, которые ведет преподаватель. Запрос тяжелый, в цикле не вызывать
   * @deprecated Too heavy. Trip to DB for every group parameter. Instead use query:userProfile:getTeacherPublicProfile:subjects:stageGroups
   */
  subjectGroups?: Maybe<Array<ClassSubject>>;
  /** предметы, которые преподает учитель */
  subjects: Array<Subject>;
};

export type TeacherRoleInput = {
  classroomIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  id?: InputMaybe<Scalars['ID']['input']>;
  schoolId: Scalars['ID']['input'];
  status?: InputMaybe<RoleStatus>;
  /** предметы, которые преподает учитель */
  subjects?: InputMaybe<Array<Scalars['ID']['input']>>;
  subjectsToRemove?: InputMaybe<Array<Scalars['ID']['input']>>;
  temporaryRoleInput?: InputMaybe<TemporaryRoleInput>;
};

export type TeacherSchoolMetrics = {
  __typename?: 'TeacherSchoolMetrics';
  hasNoMetrics: Scalars['Boolean']['output'];
  mainMetrics?: Maybe<Array<TeacherMonitoring>>;
  subjectMetrics?: Maybe<Array<TeacherSchoolSubjectMetrics>>;
  teacherFullName: Scalars['String']['output'];
  teacherId: Scalars['UUID']['output'];
};

/** Фильтр данных отчета 'Обзор работы учителей' выгрузка в Excel */
export type TeacherSchoolMetricsExcelInput = {
  filterDescriptions: Array<FilterDescription>;
  metricOrder?: InputMaybe<Scalars['Int']['input']>;
  schoolMonitoringFilter: TeacherSchoolMetricsInput;
  showNonNullable: Scalars['Boolean']['input'];
  showNullable: Scalars['Boolean']['input'];
};

/** элемент фильтра для отчета 'Обзор работы учителей' */
export type TeacherSchoolMetricsFilter = {
  __typename?: 'TeacherSchoolMetricsFilter';
  stageGroupId: Scalars['ID']['output'];
  stageGroupName: Scalars['String']['output'];
  stageId: Scalars['ID']['output'];
  stageName: Scalars['String']['output'];
  studyStepId?: Maybe<Scalars['Int']['output']>;
  subjectId: Scalars['ID']['output'];
  subjectName: Scalars['String']['output'];
  teacherId: Scalars['UUID']['output'];
  teacherName: Scalars['String']['output'];
};

/** Фильтр данных отчета 'Обзор работы учителей' */
export type TeacherSchoolMetricsInput = {
  endDate: Scalars['Date']['input'];
  stageGroupIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  stageIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  startDate: Scalars['Date']['input'];
  subjectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  teacherIds?: InputMaybe<Array<Scalars['UUID']['input']>>;
};

export type TeacherSchoolSubjectMetrics = {
  __typename?: 'TeacherSchoolSubjectMetrics';
  metrics?: Maybe<Array<TeacherMonitoring>>;
  subjectName: Scalars['String']['output'];
};

/** Входящий запрос для получения списка учителей по фильтру */
export type TeacherSearchInput = {
  /** Параметры пагинации */
  paging: PagingInput;
  /** Строка поиска для фильтрации по фамилии учителя */
  searchString?: InputMaybe<Scalars['String']['input']>;
  /** Список id предметов, по которым будем грузить учителей, если пустой список - то ищем по всем предметам */
  subjectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/**
 * Учительский контекст, в котором содержится информация, на кого назначен этот модуль в тех группах,
 * в которых учитель ведет
 */
export type TeacherStudyModuleAssignContext = {
  __typename?: 'TeacherStudyModuleAssignContext';
  /** Группы по предмету ТЕКУЩЕГО УЧЕБНОГО ГОДА, в классовых планах которых присутсвует этот модуль */
  currentClassSubjects: Array<ClassSubject>;
  id: Scalars['ID']['output'];
};

/**
 * Учительский контекст, в котором содержится информация, на кого назначена эта система заданий
 * в тех группах, в которых учитель ведет.
 */
export type TeacherTaskSetAssignContext = {
  __typename?: 'TeacherTaskSetAssignContext';
  /** Группы по предмету ТЕКУЩЕГО УЧЕБНОГО ГОДА, в классовых планах которых модулю назначена эта система заданий */
  currentClassSubjects: Array<ClassSubject>;
  id: Scalars['ID']['output'];
};

/** Обзор обучения учителей */
export type TeacherTraining = {
  __typename?: 'TeacherTraining';
  items: Array<TeacherTrainingItem>;
  scanDateTime?: Maybe<Scalars['DateTime']['output']>;
};

/** Обзор обучения учителей 3ья волна */
export type TeacherTraining3rdWave = {
  __typename?: 'TeacherTraining3rdWave';
  items: Array<TeacherTraining3rdWaveItem>;
  scanDateTime?: Maybe<Scalars['DateTime']['output']>;
  userRole: Scalars['Int']['output'];
};

/** Обзор обучения учителей 3ья волна детальный */
export type TeacherTraining3rdWaveDetailed = {
  __typename?: 'TeacherTraining3rdWaveDetailed';
  items: Array<TeacherTraining3rdWaveDetailedItem>;
  scanDateTime?: Maybe<Scalars['DateTime']['output']>;
  userRole: Scalars['Int']['output'];
};

export type TeacherTraining3rdWaveDetailedItem = {
  __typename?: 'TeacherTraining3rdWaveDetailedItem';
  email?: Maybe<Scalars['String']['output']>;
  fio?: Maybe<Scalars['String']['output']>;
  identifier: Scalars['String']['output'];
  login?: Maybe<Scalars['String']['output']>;
  modules: Array<TeacherTraining3rdWaveDetailedModule>;
  phoneNumber?: Maybe<Scalars['String']['output']>;
  region: Scalars['String']['output'];
  schoolName: Scalars['String']['output'];
  stageSubjectGroupEnrollmentDate: Scalars['Date']['output'];
};

export type TeacherTraining3rdWaveDetailedModule = {
  __typename?: 'TeacherTraining3rdWaveDetailedModule';
  moduleCompleted: Scalars['Boolean']['output'];
  moduleId: Scalars['Int']['output'];
  moduleLevel3Completed: Scalars['Boolean']['output'];
  moduleLevel4Completed: Scalars['Boolean']['output'];
  moduleName: Scalars['String']['output'];
  moduleOrder: Scalars['Int']['output'];
};

export type TeacherTraining3rdWaveItem = {
  __typename?: 'TeacherTraining3rdWaveItem';
  activeConfiguratorsCount: Scalars['Int']['output'];
  activeTeachersCount: Scalars['Int']['output'];
  configuratorsCount: Scalars['Int']['output'];
  identifier: Scalars['String']['output'];
  modules: Array<TeacherTraining3rdWaveModule>;
  region: Scalars['String']['output'];
  schoolName: Scalars['String']['output'];
  teachersCount: Scalars['Int']['output'];
};

export type TeacherTraining3rdWaveModule = {
  __typename?: 'TeacherTraining3rdWaveModule';
  moduleId: Scalars['Int']['output'];
  moduleName: Scalars['String']['output'];
  moduleOrder: Scalars['Int']['output'];
  studentsCompletedModule: Scalars['Int']['output'];
};

/**
 * Обзор обучения учителей детальный
 * userRole: 0-PG_Configurator, 1-Configurator, 2-Teacher
 */
export type TeacherTrainingDetailed = {
  __typename?: 'TeacherTrainingDetailed';
  items: Array<TeacherTrainingDetailedItem>;
  scanDateTime?: Maybe<Scalars['DateTime']['output']>;
  userRole: Scalars['Int']['output'];
};

export type TeacherTrainingDetailedItem = {
  __typename?: 'TeacherTrainingDetailedItem';
  completedCultureOfPMO: Scalars['Boolean']['output'];
  completedCultureOfPMOLevel3?: Maybe<Scalars['Boolean']['output']>;
  completedCultureOfPMOLevel4?: Maybe<Scalars['Boolean']['output']>;
  completedGoalsResults: Scalars['Boolean']['output'];
  completedGoalsResultsLevel3?: Maybe<Scalars['Boolean']['output']>;
  completedGoalsResultsLevel4?: Maybe<Scalars['Boolean']['output']>;
  completedIntroductionToPMO: Scalars['Boolean']['output'];
  completedIntroductionToPMOLevel3?: Maybe<Scalars['Boolean']['output']>;
  completedIntroductionToPMOLevel4?: Maybe<Scalars['Boolean']['output']>;
  completedPersonalPotential: Scalars['Boolean']['output'];
  completedPersonalPotentialLevel3?: Maybe<Scalars['Boolean']['output']>;
  completedPersonalPotentialLevel4?: Maybe<Scalars['Boolean']['output']>;
  completedTrainingModule: Scalars['Boolean']['output'];
  completedTrainingModuleLevel3?: Maybe<Scalars['Boolean']['output']>;
  completedTrainingModuleLevel4?: Maybe<Scalars['Boolean']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  fio?: Maybe<Scalars['String']['output']>;
  identifier: Scalars['String']['output'];
  login?: Maybe<Scalars['String']['output']>;
  phoneNumber?: Maybe<Scalars['String']['output']>;
  region: Scalars['String']['output'];
  schoolName: Scalars['String']['output'];
};

export type TeacherTrainingItem = {
  __typename?: 'TeacherTrainingItem';
  activeConfiguratorsCount: Scalars['Int']['output'];
  activeTeachersCount: Scalars['Int']['output'];
  completedCultureOfPMO: Scalars['Int']['output'];
  completedGoalsResults: Scalars['Int']['output'];
  completedIntroductionToPMO: Scalars['Int']['output'];
  completedPersonalPotential: Scalars['Int']['output'];
  completedTrainingModule: Scalars['Int']['output'];
  configuratorsCount: Scalars['Int']['output'];
  identifier: Scalars['String']['output'];
  region: Scalars['String']['output'];
  schoolName: Scalars['String']['output'];
  studentsInPG: Scalars['Int']['output'];
  teachersCount: Scalars['Int']['output'];
};

/** Общая информация по учителю с ФИО */
export type TeacherUserInfo = {
  __typename?: 'TeacherUserInfo';
  teacherId: Scalars['UUID']['output'];
  user: UserInfo;
};

export type TeachersWorkload = {
  __typename?: 'TeachersWorkload';
  subjectId: Scalars['Int']['output'];
  subjectName: Scalars['String']['output'];
  teachersCount: Scalars['Int']['output'];
  workload: Workload;
};

export type TeachersWorkloadBySubject = {
  __typename?: 'TeachersWorkloadBySubject';
  teacherId: Scalars['UUID']['output'];
  workload: Workload;
};

export type TeachersWorkloadBySubjectForPrincipal = {
  __typename?: 'TeachersWorkloadBySubjectForPrincipal';
  fullName?: Maybe<Scalars['String']['output']>;
  teacherId: Scalars['UUID']['output'];
  workload: Workload;
};

export type Team = {
  __typename?: 'Team';
  code: Scalars['String']['output'];
  currentTeamMemberCount: Scalars['Int']['output'];
  id: Scalars['UUID']['output'];
  maxTeamMemberCount: Scalars['Int']['output'];
  minTeamMemberCount: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  status: TeamStatusEnum;
};

/** Вид формирования команды для группового задания */
export enum TeamCreateOptionEnum {
  /** Алгоритмический */
  Algorithmic = 'ALGORITHMIC',
  /** Ручной */
  Manual = 'MANUAL',
  /** Случайный */
  Random = 'RANDOM'
}

export type TeamExitReason = {
  __typename?: 'TeamExitReason';
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  type: TeamExitReasonType;
};

/** Тип причины выхода участника из команды/проекта */
export enum TeamExitReasonType {
  CaptainLeaveProject = 'CAPTAIN_LEAVE_PROJECT',
  DeleteProject = 'DELETE_PROJECT',
  LeaveProject = 'LEAVE_PROJECT',
  LeaveProjectSchool_21 = 'LEAVE_PROJECT_SCHOOL_21',
  RemovedByCaptain = 'REMOVED_BY_CAPTAIN'
}

export type TeamHistory = {
  __typename?: 'TeamHistory';
  createdTs: Scalars['DateTime']['output'];
  exitReason?: Maybe<TeamExitReason>;
  exitReasonDescription?: Maybe<Scalars['String']['output']>;
  id: Scalars['UUID']['output'];
  team: Team;
  teamRole: TeamRole;
  user?: Maybe<User>;
};

/** Временные настройки периодов для студента (с учетом настроек тимлида) */
export type TeamLeadGoalPeriodSettings = {
  __typename?: 'TeamLeadGoalPeriodSettings';
  /** Дата/время начала курса */
  beginDate: Scalars['DateTime']['output'];
  /** Дата/время начала проверки */
  checkDate: Scalars['DateTime']['output'];
  /** Дата/время дедлайна */
  deadlineDate: Scalars['DateTime']['output'];
  /** Признак того, что настройки периодов студента и тимлида идентичны */
  isTeamLeadPeriodsEqual?: Maybe<Scalars['Boolean']['output']>;
  /** Дата/время начала регистрации */
  signUpDate: Scalars['DateTime']['output'];
};

export type TeamMember = {
  __typename?: 'TeamMember';
  role: TeamRole;
  teamId: Scalars['UUID']['output'];
  user?: Maybe<User>;
};

export type TeamMemberWithVacancy = {
  __typename?: 'TeamMemberWithVacancy';
  resume?: Maybe<ResumeModel>;
  teamMember: TeamMember;
  vacancy?: Maybe<Scalars['String']['output']>;
};

export type TeamMutations = {
  __typename?: 'TeamMutations';
  /** Выход капитана из команды */
  removeCaptainFromTeam: TeamWithMembers;
  /** Удаление члена команды капитаном */
  removeMemberFromTeamByCaptain: TeamWithMembers;
  /** Выход пользователя из команды */
  removeMemberFromTeamByThemselves: TeamWithMembers;
};


export type TeamMutationsRemoveCaptainFromTeamArgs = {
  exitReasonDescription?: InputMaybe<Scalars['String']['input']>;
  exitReasonId?: InputMaybe<Scalars['Int']['input']>;
  teamId: Scalars['UUID']['input'];
};


export type TeamMutationsRemoveMemberFromTeamByCaptainArgs = {
  deletedUserId: Scalars['UUID']['input'];
  exitReasonDescription?: InputMaybe<Scalars['String']['input']>;
  exitReasonId?: InputMaybe<Scalars['Int']['input']>;
  teamId: Scalars['UUID']['input'];
};


export type TeamMutationsRemoveMemberFromTeamByThemselvesArgs = {
  exitReasonDescription?: InputMaybe<Scalars['String']['input']>;
  exitReasonId?: InputMaybe<Scalars['Int']['input']>;
  teamId: Scalars['UUID']['input'];
};

export type TeamQueries = {
  __typename?: 'TeamQueries';
  /** Получение всех значений справочника причин отклонения/отзыва заявки на проект */
  getAllDeclineReasons: Array<Maybe<DeclineReason>>;
  /** Получение всех причин выхода из команды */
  getAllTeamExitReasons: Array<TeamExitReason>;
  /** Получение всей истории изменений в командах */
  getAllTeamHistory: Array<TeamHistory>;
  /** Количество доступных приглашений */
  getAvailableRequestToProjectCount: RequestToProjectCount;
  /** Получение количества созданных приглашений в команды для текущего пользователя */
  getCreatedJoinTeamRequestCount: Scalars['Int']['output'];
  /** Получение причины отклонения/отзыва заявки на проект по ид */
  getDeclineReasonById?: Maybe<DeclineReason>;
  getRequestForUserByProjectId?: Maybe<JoinTeamRequestAdd>;
  /** Получение всей истории изменений в командах c данными пользователей */
  getTeamHistoryByExitReason: Array<TeamHistory>;
  /** Получение всех членов команд, имеющих определённую роль */
  getTeamMembersByRole: Array<TeamMember>;
  /** Получение членов команды с данными о пользователе */
  getTeamMembersByTeam: Array<TeamMember>;
  getTeamMembersWithVacancyByRole: Array<TeamMemberWithVacancy>;
  /**
   * Получение членов команды с данными о пользователе
   * @deprecated unused method
   */
  getTeamMembersWithVacancyByTeam: Array<TeamMemberWithVacancy>;
};


export type TeamQueriesGetDeclineReasonByIdArgs = {
  declineReasonId: Scalars['UUID']['input'];
};


export type TeamQueriesGetRequestForUserByProjectIdArgs = {
  projectId: Scalars['UUID']['input'];
};


export type TeamQueriesGetTeamHistoryByExitReasonArgs = {
  teamExitReasonId: Scalars['Int']['input'];
};


export type TeamQueriesGetTeamMembersByRoleArgs = {
  teamRoleId: Scalars['Int']['input'];
};


export type TeamQueriesGetTeamMembersByTeamArgs = {
  teamId: Scalars['UUID']['input'];
};


export type TeamQueriesGetTeamMembersWithVacancyByRoleArgs = {
  teamRoleId: Scalars['Int']['input'];
};


export type TeamQueriesGetTeamMembersWithVacancyByTeamArgs = {
  teamId: Scalars['UUID']['input'];
};

/** Роль участника в команде */
export enum TeamRole {
  Captain = 'CAPTAIN',
  Mentor = 'MENTOR',
  Participant = 'PARTICIPANT'
}

/** Настройки команды в групповом задании s21 */
export type TeamSettingTask = {
  __typename?: 'TeamSettingTask';
  /** Количество часов, отведенных на проведение голосования для расформирования команды ее участниками */
  durationAutoDisbandment?: Maybe<Scalars['Int']['output']>;
  /** Параметр, определяющий возможность участникам команды провести голосование для ее расформирования */
  enableSurrenderTeam?: Maybe<Scalars['Boolean']['output']>;
  /** Идентификатор */
  id: Scalars['ID']['output'];
  /** Тип локации команды */
  location: LocationEnum;
  /** Позволяет задать макс кол-во участников */
  maxAmountMember: Scalars['Int']['output'];
  /** Позволяет задать мин кол-во участников */
  minAmountMember: Scalars['Int']['output'];
  /** Вариант формирования команды */
  teamCreateOption: TeamCreateOptionEnum;
};

/** Настройки команды в групповом задании в школе 21 */
export type TeamSettingTaskInput = {
  /** Количество часов, отведенных на проведение голосования для расформирования команды ее участниками */
  durationAutoDisbandment?: InputMaybe<Scalars['Int']['input']>;
  /** Параметр, определяющий возможность участникам команды провести голосование для ее расформирования */
  enableSurrenderTeam?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  /** Тип локации команды */
  location: LocationEnum;
  /** Макс кол-во участников */
  maxAmountMember: Scalars['Int']['input'];
  /** Мин кол-во участников */
  minAmountMember: Scalars['Int']['input'];
  /** Вариант формирования команды */
  teamCreateOption: TeamCreateOptionEnum;
};

export type TeamSettings = {
  __typename?: 'TeamSettings';
  /** Количество часов, отведенных на проведение голосования для расформирования команды ее участниками */
  durationAutoDisbandment?: Maybe<Scalars['Int']['output']>;
  /** Параметр, определяющий возможность участникам команды провести голосование для ее расформирования */
  enableSurrenderTeam?: Maybe<Scalars['Boolean']['output']>;
  location: LocationEnum;
  maxAmountMember: Scalars['Int']['output'];
  minAmountMember: Scalars['Int']['output'];
  teamCreateOption: TeamCreateOptionEnum;
};

/** Группа настроек комманды из конструктора для проекта в текущем и вышестоящем плане с результатом их сравнения */
export type TeamSettingsGroupWithEquivalentFlag = {
  __typename?: 'TeamSettingsGroupWithEquivalentFlag';
  campusNamesList?: Maybe<Array<Scalars['String']['output']>>;
  equivalentTeamSettings: Scalars['Boolean']['output'];
  multiCampusIsEnabled?: Maybe<Scalars['Boolean']['output']>;
  superiorTeamSettings?: Maybe<TeamSettings>;
  teamSettings?: Maybe<TeamSettings>;
};

export type TeamSettingsInput = {
  /** Количество часов, отведенных на проведение голосования для расформирования команды ее участниками */
  durationAutoDisbandment?: InputMaybe<Scalars['Int']['input']>;
  /** Параметр, определяющий возможность участникам команды провести голосование для ее расформирования */
  enableSurrenderTeam?: InputMaybe<Scalars['Boolean']['input']>;
  location: LocationEnum;
  maxAmountMember: Scalars['Int']['input'];
  minAmountMember: Scalars['Int']['input'];
  teamCreateOption: TeamCreateOptionEnum;
};

/** Информация о размере команды */
export type TeamSizeInfo = {
  __typename?: 'TeamSizeInfo';
  /** Идентификатор команды */
  teamId?: Maybe<Scalars['UUID']['output']>;
  /** Название команды */
  teamName?: Maybe<Scalars['String']['output']>;
  /** Размер команды */
  teamSize?: Maybe<Scalars['Int']['output']>;
};

/** Статус команды */
export enum TeamStatusEnum {
  /** Команда расформирована */
  Closed = 'CLOSED',
  /** Команда сформирована */
  Formed = 'FORMED',
  /** Команда открыта для формирования */
  Open = 'OPEN'
}

export type TeamWithMembers = {
  __typename?: 'TeamWithMembers';
  captains: Array<User>;
  members: Array<TeamMember>;
  team: Team;
};

export type Technology = {
  __typename?: 'Technology';
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['UUID']['output'];
  name: Scalars['String']['output'];
};

/** Асинхронная задача на назначение шаблонов траекторий на студентов */
export type TemplateAssignmentTask = {
  __typename?: 'TemplateAssignmentTask';
  /** Способ назначения шаблона */
  assignmentMode: Scalars['String']['output'];
  /** Дата и время создания */
  creationDateTime: Scalars['DateTime']['output'];
  /** Сообщение об ошибке */
  errorMessage?: Maybe<Scalars['String']['output']>;
  /** Статус асинхронной задачи */
  status: AsyncTaskStatus;
  /** ФИО студента */
  studentFullName: Scalars['String']['output'];
  /** Идентификатор асинхронной задачи */
  taskId: Scalars['UUID']['output'];
  /** Список траекторий (через запятую) */
  trajectories: Scalars['String']['output'];
};

/** Фильтр для списка асинхронных задач на назначение шаблонов траекторий на студентов */
export type TemplateAssignmentTaskFilter = {
  /** Данные для пагинации */
  page: PagingInput;
  /** Список идентификаторов классов */
  stageGroupIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** Статус асинхронной задачи */
  status?: InputMaybe<AsyncTaskStatus>;
  /** ФИО студента для поиска */
  studentNameSearchQuery?: InputMaybe<Scalars['String']['input']>;
};

/** Статусы для фильтров для страницы списка асинхронных задач по назначению шаблонов траектории на студентов */
export type TemplateAssignmentTaskFilterData = {
  __typename?: 'TemplateAssignmentTaskFilterData';
  /** Список статусов асинхронных задач */
  taskStatuses?: Maybe<Array<Maybe<AsyncTaskStatus>>>;
};

/** Типы шаблонов для получения файлов из gitlab репозитория */
export enum TemplateType {
  /** Шаблон докер файлов */
  DockerFiles = 'DOCKER_FILES',
  /** Шаблон cy файлов */
  GitlabCyYmls = 'GITLAB_CY_YMLS',
  /** Шаблон gitignore файлов */
  GitIgnores = 'GIT_IGNORES',
  /** Шаблон файлов-лицензий */
  Licenses = 'LICENSES'
}

export type TemporaryRoleInput = {
  dateEnd?: InputMaybe<Scalars['String']['input']>;
  dateStart?: InputMaybe<Scalars['String']['input']>;
};

export type TenantConfiguration = {
  __typename?: 'TenantConfiguration';
  /** Тенанты (школы), из которых происходит чтение словарей данных */
  tenantToReadFrom: Array<Scalars['UUID']['output']>;
  /** Тенанты (школы), в которые происходит запись словарей данных */
  tenantToWriteTo: Array<Scalars['UUID']['output']>;
};

export type TenantConfigurationInput = {
  /** Тенанты (школы), из которых происходит чтение словарей данных */
  tenantToReadFrom: Array<Scalars['UUID']['input']>;
  /** Тенанты (школы), в которые происходит запись словарей данных */
  tenantToWriteTo: Array<Scalars['UUID']['input']>;
};

export type TerbanksModel = {
  __typename?: 'TerbanksModel';
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  regions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

export type TestAnswerBody = {
  __typename?: 'TestAnswerBody';
  /** Варианты ответа */
  choices: Array<TestAnswerBodyChoice>;
};

export type TestAnswerBodyChoice = {
  __typename?: 'TestAnswerBodyChoice';
  /** Иденитификатор ответа */
  choiceId: Scalars['ID']['output'];
  /** Правильный ответ */
  correct?: Maybe<Scalars['Boolean']['output']>;
};

export type TestAnswerBodyChoiceInput = {
  /** Идентификатор варианта ответа */
  choiceId: Scalars['ID']['input'];
};

export type TestAnswerBodyInput = {
  /** Варианты ответов */
  choices: Array<TestAnswerBodyChoiceInput>;
};

/** Тематический план */
export type ThematicPlan = {
  __typename?: 'ThematicPlan';
  /** Уровень видимости */
  accessLevelId: Scalars['ID']['output'];
  /** Дата создания плана */
  createdTs?: Maybe<Scalars['DateTime']['output']>;
  /** Автор плана */
  createdUser?: Maybe<PlanningUserInfo>;
  /** Идентификатор общеобразовательного учреждения */
  orgUnitId: Scalars['UUID']['output'];
  /** Идентификатор параллели плана */
  stageId: Scalars['ID']['output'];
  /** Идентификатор предмета плана */
  subjectId: Scalars['ID']['output'];
  /** Количество часов на план */
  thematicPlanHours?: Maybe<Scalars['Int']['output']>;
  /** Идентификатор тематического плана */
  thematicPlanId: Scalars['ID']['output'];
  /** Наименование плана */
  thematicPlanName: Scalars['String']['output'];
  /** Темы в тематическом плане */
  topics?: Maybe<Array<Maybe<ThematicPlanTopic>>>;
  /** Дата обновления плана */
  updatedTs?: Maybe<Scalars['DateTime']['output']>;
  /** Редактор плана */
  updatedUser?: Maybe<PlanningUserInfo>;
};

/** Уровень видимости тематического плана. */
export type ThematicPlanAccessLevel = {
  __typename?: 'ThematicPlanAccessLevel';
  /** Идентификатор уровня видимости */
  id: Scalars['ID']['output'];
  /** Название уровня видимости */
  name: Scalars['String']['output'];
};

/** Модель для создания тематического плана */
export type ThematicPlanCreationInput = {
  /** Уровень видимости */
  accessLevelId: Scalars['ID']['input'];
  /** Название тематического плана */
  name: Scalars['String']['input'];
  /** Идентификатор образовательного учреждения */
  orgUnitId: Scalars['UUID']['input'];
  /** Количество часов на изучение плана */
  plannedHours: Scalars['Int']['input'];
  /** Количество тем */
  plannedTopicsAmount: Scalars['Int']['input'];
  /** Идентификатор параллели */
  stageId: Scalars['ID']['input'];
  /** Идентификатор предмета */
  subjectId: Scalars['ID']['input'];
};

/** Фильтр для выборки тематических планов */
export type ThematicPlanFilter = {
  /** список нужных уровней видимости */
  accessLevelIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** список параллелей */
  stageIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  /** список предметов */
  subjectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
};

/** Модель тематического плана для мутаций */
export type ThematicPlanInput = {
  /** Уровень видимости */
  accessLevelId: Scalars['ID']['input'];
  /** Идентификатор общеобразовательного учреждения */
  orgUnitId: Scalars['UUID']['input'];
  /** Идентификатор параллели плана */
  stageId: Scalars['ID']['input'];
  /** Идентификатор предмета плана */
  subjectId: Scalars['ID']['input'];
  /** Количество часов на план */
  thematicPlanHours: Scalars['Int']['input'];
  /** Идентификатор тематического плана */
  thematicPlanId: Scalars['ID']['input'];
  /** Наименование плана */
  thematicPlanName: Scalars['String']['input'];
  /** Список тем в плане */
  topics?: InputMaybe<Array<InputMaybe<ThematicPlanTopicInput>>>;
};

/** Тема тематического плана */
export type ThematicPlanTopic = {
  __typename?: 'ThematicPlanTopic';
  /** Уроки по теме */
  lessons?: Maybe<Array<Maybe<ThematicPlanTopicLesson>>>;
  /** Идентификатор темы */
  thematicPlanTopicId: Scalars['ID']['output'];
  /** Количество часов на тему */
  topicHours: Scalars['Int']['output'];
  /** Наименование темы */
  topicName: Scalars['String']['output'];
  /** Номер темы */
  topicNumber: Scalars['Int']['output'];
};

/** Модель тема тематического плана для мутаций */
export type ThematicPlanTopicInput = {
  /** Уроки по теме */
  lessons?: InputMaybe<Array<InputMaybe<ThematicPlanTopicLessonInput>>>;
  /** Идентификатор темы */
  thematicPlanTopicId: Scalars['ID']['input'];
  /** Количество часов на тему */
  topicHours: Scalars['Int']['input'];
  /** Название темы */
  topicName: Scalars['String']['input'];
  /** Номер темы */
  topicNumber: Scalars['Int']['input'];
};

/** Уроки темы тематического плана */
export type ThematicPlanTopicLesson = {
  __typename?: 'ThematicPlanTopicLesson';
  /** Признак наличия контрольной работы */
  controlWork: Scalars['Boolean']['output'];
  /** Наименование урока, */
  lessonName: Scalars['String']['output'];
  /** Номер урока */
  lessonNumber: Scalars['Int']['output'];
  /** Идентификатор урока в теме */
  thematicPlanTopicLessonId: Scalars['ID']['output'];
};

/** Модель урока тематического плана для мутации */
export type ThematicPlanTopicLessonInput = {
  /** Признак контрольной работы */
  controlWork: Scalars['Boolean']['input'];
  /** Название урока */
  lessonName: Scalars['String']['input'];
  /** Номер урока по порядку изучения в теме */
  lessonNumber: Scalars['Int']['input'];
  /** Идентификатор урока */
  thematicPlanTopicLessonId: Scalars['ID']['input'];
};

/** Статус градусника (прогресс ученика по предмету относительно класса) */
export enum ThermometerPmoStatusEnum {
  /** Отображается, если прогресс ученика выше прогресса класса */
  Blue = 'BLUE',
  /** Отображается, если прогресс класса равен 0 */
  Gray = 'GRAY',
  /** Отображается, если прогресс ученика равен прогрессу класса */
  Green = 'GREEN',
  /** Отображается, если прогресс ученика ниже прогресса класса */
  Red = 'RED'
}

export type TimeSlot = {
  __typename?: 'TimeSlot';
  endTime: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  isActive: Scalars['Boolean']['output'];
  lessonNumber: Scalars['Int']['output'];
  startTime: Scalars['Time']['output'];
};

export type TimeSlotInput = {
  endTime: Scalars['String']['input'];
  id?: InputMaybe<Scalars['ID']['input']>;
  isActive: Scalars['Boolean']['input'];
  lessonNumber: Scalars['Int']['input'];
  /**
   * Заполняется при редактировании слота.
   * Сдвиг времени таймслота (начала урока) в минутах с учетом знака (отрицательное значение при уменьшении 8:00 -> 7:00 shiftMinutes = -60)
   * будет удалено после влития EDU-48922
   */
  shiftMinutes?: InputMaybe<Scalars['Int']['input']>;
  startTime: Scalars['String']['input'];
};

export type TimeSlotSet = {
  __typename?: 'TimeSlotSet';
  id: Scalars['ID']['output'];
  isActive: Scalars['Boolean']['output'];
  lessonLengthType: LessonLengthType;
  name: Scalars['String']['output'];
  stageGroupIds: Array<Scalars['ID']['output']>;
  timeSlots: Array<TimeSlot>;
};

export type TimeSlotSetInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  isActive: Scalars['Boolean']['input'];
  lessonLengthTypeId: Scalars['ID']['input'];
  name: Scalars['String']['input'];
  stageGroupIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  timeSlots: Array<TimeSlotInput>;
};

/** Типы временных слотов */
export enum TimeSlotTypeEnum {
  /** Слоты на которые я записан */
  BookedTime = 'BOOKED_TIME',
  /** Событие * */
  Event = 'EVENT',
  /** Слоты, доступные для записи */
  FreeTime = 'FREE_TIME'
}

export enum TimeStatus {
  Any = 'ANY',
  Completed = 'COMPLETED',
  Ongoing = 'ONGOING',
  Upcoming = 'UPCOMING'
}

/** Тип элемента таймлайна */
export enum TimelineElementEnum {
  /** авто-проверка */
  Autotest = 'AUTOTEST',
  /** код ревью 1 */
  CodeReviewRound_1 = 'CODE_REVIEW_ROUND_1',
  /** код ревью 2 */
  CodeReviewRound_2 = 'CODE_REVIEW_ROUND_2',
  /** Стажировка */
  Internship = 'INTERNSHIP',
  /** оценка ментора */
  MentorFeedback = 'MENTOR_FEEDBACK',
  /** p2p */
  PeerReview = 'PEER_REVIEW'
}

/** Статус элемента таймлайна проекта */
export enum TimelineItemStatus {
  /** Этап требует внимания студента */
  Attention = 'ATTENTION',
  /** Этап доступен */
  Current = 'CURRENT',
  /** Этап не доступен */
  Disabled = 'DISABLED',
  /** Этап провален */
  Fail = 'FAIL',
  /** Этап пройден */
  Success = 'SUCCESS'
}

/** Тип элемента таймлайна проекта */
export enum TimelineItemType {
  /** Этап проверки */
  Evaluation = 'EVALUATION',
  /** Этап выполнения */
  InProgress = 'IN_PROGRESS',
  /** Этап регистрации */
  Registration = 'REGISTRATION'
}

/** Расписание для школы по дням */
export type Timetable = {
  __typename?: 'Timetable';
  isEmpty: Scalars['Boolean']['output'];
  timetableDays: Array<TimetableDay>;
};

/** Расписание по номеру урока за определенный день */
export type TimetableByLessonNumber = {
  __typename?: 'TimetableByLessonNumber';
  lessonNumber: Scalars['Int']['output'];
  stageGroupTimetables: Array<StageGroupTimetable>;
};

/** Расписание по школе за определенный день по всем классам */
export type TimetableDay = {
  __typename?: 'TimetableDay';
  date: Scalars['Date']['output'];
  timetableByLessonNumbers: Array<TimetableByLessonNumber>;
};

/** Драфт расписания на неделю */
export type TimetableDraft = {
  __typename?: 'TimetableDraft';
  /** Признак, есть ли драфты уроков */
  isEmpty: Scalars['Boolean']['output'];
  /** Драфт расписания по дням недели */
  timetableDraftDays: Array<TimetableDraftDay>;
  /** Краткая информация о выполнении задачи на генерацию расписания */
  timetableDraftSummary: TimetableDraftSummary;
};

/** Драфт расписания по номеру урока за определенный день */
export type TimetableDraftByLessonNumber = {
  __typename?: 'TimetableDraftByLessonNumber';
  /** Номер урока */
  lessonNumber: Scalars['Int']['output'];
  /** Драфты уроков групп по классам */
  stageGroupTimetableDrafts: Array<StageGroupTimetableDraft>;
};

/** Изменение драфта расписания */
export type TimetableDraftChangeInput = {
  /** Идентификатор кабинета */
  classroomId?: InputMaybe<Scalars['ID']['input']>;
  /** Порядковый номер дня недели */
  dayOrderNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Идентификатор драфта урока */
  lessonDraftId: Scalars['ID']['input'];
  /** Идентификатор интервала времени, в который проводится урок */
  lessonTimeslotId?: InputMaybe<Scalars['ID']['input']>;
};

/** Драфт расписания по школе за определенный порядковый день по всем классам */
export type TimetableDraftDay = {
  __typename?: 'TimetableDraftDay';
  /** Порядковый номер дня недели */
  dayOrderNumber: Scalars['Int']['output'];
  /** # Драфт расписания по номеру урока за определенный день */
  timetableDraftByLessonNumbers: Array<TimetableDraftByLessonNumber>;
};

/** Краткая информация о выполнении задач на генерацию расписания */
export type TimetableDraftSummary = {
  __typename?: 'TimetableDraftSummary';
  /** Академический год */
  academicYearId: Scalars['ID']['output'];
  /** Время создания */
  createTime: Scalars['DateTime']['output'];
  /** Просматривали ли этот черновик */
  hasBeenViewed: Scalars['Boolean']['output'];
  /** Признак можно ли ставить письменные уроки после физ-ры */
  isNoWritingWorkSubjectsAfterPhysicalExercise: Scalars['Boolean']['output'];
  /** Время обновления */
  modifyTime: Scalars['DateTime']['output'];
  /** Название для генерируемого расписания */
  name: Scalars['String']['output'];
  /** Количество учебных дней в неделе */
  schoolDaysCountPerWeek: Scalars['Int']['output'];
  /** Идентификатор школы */
  schoolId: Scalars['ID']['output'];
  /** Объяснение счета */
  scoreExplanation?: Maybe<ScoreExplanation>;
  /** Классы, для которых генерируется расписание */
  stageGroups: Array<StageGroupCommonInfo>;
  /** Статус задачи на генерацию расписания */
  status: TimetableGeneratorStatus;
  /** Идентификатор (edu_power_shard.auto_timetables.auto_timetable_id) */
  timetableDraftId: Scalars['ID']['output'];
};

/** Драфт расписания на неделю */
export type TimetableDraftV2 = {
  __typename?: 'TimetableDraftV2';
  /** Драфт расписания по классам */
  assignedLessonDraftsByDays: Array<LessonDraftsByStageGroup>;
  /** Краткая информация о выполнении задачи на генерацию расписания */
  timetableDraftSummary: TimetableDraftSummary;
  /** Нераспределенные уроки ("подвал") */
  unassignedLessonDraftsByTeachers: Array<LessonDraftsByTeacher>;
};

/** Статусы выполнения задач по генерации расписания */
export enum TimetableGeneratorStatus {
  /** Выполнено с ошибкой (во время генерации расписания возникла ошибка) */
  Error = 'ERROR',
  /** В работе (отправлена асинхронная задача на генерацию расписания) */
  InProgress = 'IN_PROGRESS',
  /** Выполнено успешно */
  Success = 'SUCCESS'
}

/** Расписание, в котором уроки сгруппированы по временным промежуткам */
export type TimetableGroupedByPeriods = {
  __typename?: 'TimetableGroupedByPeriods';
  lessonsByPeriods: Array<LessonsByPeriod>;
};

/** Задание от Ученика, требующее проверки Учителем */
export type Todo = {
  __typename?: 'Todo';
  /** время отправки учеником запроса на проверку задания */
  checkRequestTime: Scalars['DateTime']['output'];
  /** Название Класса, в котором учится Ученик, отправивший запрос на проверку */
  className: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** Пользователь от которого поступил запрос на проверку */
  student: User;
  studentId: Scalars['ID']['output'];
  /** Задание которое необходимо проверить */
  task: Task;
};

/** Ранги текущего студента и ТОП-5 участников коалиции в турнире */
export type Top5AndMeCoalitionTournamentMembers = {
  __typename?: 'Top5AndMeCoalitionTournamentMembers';
  /** Ранг текущего студента */
  me?: Maybe<CoalitionMemberPowerRank>;
  /** Ранги ТОП-5 участников коалиции в турнире */
  top5: Array<CoalitionMemberPowerRank>;
};

export type TournamentAwardSetting = {
  __typename?: 'TournamentAwardSetting';
  award?: Maybe<Award>;
  awardId?: Maybe<Scalars['ID']['output']>;
  coalitionPlace: Scalars['Int']['output'];
  coins?: Maybe<Scalars['Int']['output']>;
  memberAwards?: Maybe<Array<TournamentAwardSetting>>;
  memberPlace?: Maybe<Scalars['Int']['output']>;
  tournamentAwardSettingId: Scalars['ID']['output'];
  tournamentId: Scalars['ID']['output'];
};

export type TournamentAwardSettingInput = {
  awardId?: InputMaybe<Scalars['Int']['input']>;
  coalitionPlace: Scalars['Int']['input'];
  coins?: InputMaybe<Scalars['Int']['input']>;
  memberAwards?: InputMaybe<Array<TournamentAwardSettingInput>>;
  memberPlace?: InputMaybe<Scalars['Int']['input']>;
};

export type Trajectory = {
  __typename?: 'Trajectory';
  created?: Maybe<Scalars['DateTime']['output']>;
  lastModified?: Maybe<Scalars['DateTime']['output']>;
  name: Scalars['String']['output'];
  slug: Scalars['String']['output'];
  trajectoryId?: Maybe<Scalars['ID']['output']>;
};

/** Способ применения шаблона траектории Bootcamp на сотрудников */
export enum TrajectoryAssignmentMode {
  /** Назначение с объединением с текущими траекториями */
  Merge = 'MERGE',
  /** Назначение с перекрытием пересекающихся модулей */
  Replacement = 'REPLACEMENT'
}

export type TrajectoryMutations = {
  __typename?: 'TrajectoryMutations';
  /** Назначить шаблон траектории на студента */
  assignTrajectoryTemplateToStudent?: Maybe<Scalars['Boolean']['output']>;
  /** Изменить плановые даты начала и окончания траектории студента отталкиваясь от новой плановой даты окончания */
  changePlanDatesTrajectoryStudent?: Maybe<Scalars['Boolean']['output']>;
  createTrajectory: Trajectory;
  /** Сохранение маппинга между шаблонами траекторий и внешними идентификаторами профессий/ролей/подразделений */
  savePulseJobCodeMapper?: Maybe<PulseJobCodeMapper>;
  /** Сохранение шаблона траектории Bootcamp */
  saveTrajectoryTemplate: TrajectoryTemplate;
  updateTrajectory: Trajectory;
  /** Изменение шаблона траектории Bootcamp */
  updateTrajectoryTemplate: TrajectoryTemplate;
  /** Обновление статуса шаблона траектории Bootcamp по идентификатору шаблона */
  updateTrajectoryTemplateStatus: TrajectoryTemplate;
};


export type TrajectoryMutationsAssignTrajectoryTemplateToStudentArgs = {
  studentTrajectoryTemplateAssignmentInputModel: StudentTrajectoryTemplateAssignmentInputModel;
};


export type TrajectoryMutationsChangePlanDatesTrajectoryStudentArgs = {
  newPlanEndDate: Scalars['Date']['input'];
  studentId: Scalars['UUID']['input'];
  trajectory: Scalars['String']['input'];
};


export type TrajectoryMutationsCreateTrajectoryArgs = {
  name: Scalars['String']['input'];
  slug: Scalars['String']['input'];
};


export type TrajectoryMutationsSavePulseJobCodeMapperArgs = {
  pulseJobCodeMapperInputModel: PulseJobCodeMapperInputModel;
};


export type TrajectoryMutationsSaveTrajectoryTemplateArgs = {
  trajectoryTemplate: TrajectoryTemplateInputModel;
};


export type TrajectoryMutationsUpdateTrajectoryArgs = {
  id: Scalars['ID']['input'];
  name: Scalars['String']['input'];
};


export type TrajectoryMutationsUpdateTrajectoryTemplateArgs = {
  trajectoryTemplate: TrajectoryTemplateInputModel;
};


export type TrajectoryMutationsUpdateTrajectoryTemplateStatusArgs = {
  status: TrajectoryTemplateStatus;
  trajectoryTemplateId: Scalars['ID']['input'];
};

export type TrajectoryQueries = {
  __typename?: 'TrajectoryQueries';
  /** Подсчет количества связей между шаблонами траекторий и внешними идентификаторами профессий/ролей/подразделений по фильтру */
  countPulseJobCodeMapperByFilter: Scalars['ID']['output'];
  /** Получить по фильтру список задач на назначение шаблонов траекторий на студентов */
  filterTemplateAssignmentTasks?: Maybe<Array<Maybe<TemplateAssignmentTask>>>;
  /** Получение списка профессий/ролей/подразделений, полученных из АС Пульс по типу справочника */
  findPulseJobCodeByJobCodeType: Array<Maybe<PulseJobCode>>;
  /** Получение маппинга между шаблонами траекторий и внешними идентификаторами профессий/ролей/подразделений по фильтру */
  findPulseJobCodeMapperByFilter: Array<Maybe<PulseJobCodeMapper>>;
  /** Получение списка всех шаблонов траекторий Bootcamp */
  findTrajectoryTemplates: Array<Maybe<TrajectoryTemplate>>;
  /** Получить все доступные шаблоны траекторий Bootcamp по id класса */
  getAccessibleTrajectoryTemplatesByStageGroupId?: Maybe<Array<TrajectoryTemplate>>;
  /** Получение списка всех траекторий Bootcamp */
  getAllTrajectories: Array<Trajectory>;
  /**
   * Получение списка шаблонов траекторий, у которых есть класс
   * @deprecated Использовать getAllTrajectoryTemplatesWithStageGroupV2
   */
  getAllTrajectoryTemplatesWithStageGroup: Array<Maybe<TrajectoryTemplate>>;
  /** Получение списка шаблонов траекторий, у которых есть класс */
  getAllTrajectoryTemplatesWithStageGroupV2: Array<Maybe<TrajectoryTemplate>>;
  /** Получение списка идентификаторов студентов с информацией по назначенным траекториям в виде строки разделенной запятой */
  getAssignedTrajectories: Array<Maybe<StudentTrajectorySlug>>;
  /** Получить максимальную плановую дату окончания траектории студента */
  getMaxPlanEndDateByStudentIdAndTrajectory?: Maybe<Scalars['Date']['output']>;
  getRecommendedTrajectoryTemplate?: Maybe<TrajectoryTemplate>;
  /** Получение рекомендованого шаблона траектории на основании данных из АС Пульс */
  getRecommendedTrajectoryTemplateV2?: Maybe<TrajectoryTemplate>;
  /** Получить данные для фильтров для страницы списка задач по назначению шаблонов траектории на студентов */
  getTemplateAssignmentTaskFilterData?: Maybe<TemplateAssignmentTaskFilterData>;
  getTrajectoriesByIds: Array<Trajectory>;
  /** Получение траекторий по идентификаторам классов */
  getTrajectoriesByStageGroupIds: Array<Trajectory>;
  getTrajectoryById: Trajectory;
  /** Получение шаблона траектории Bootcamp по его идентификатору */
  getTrajectoryTemplateById: TrajectoryTemplate;
  /** Получение статусов шаблонов траекторий Bootcamp */
  getTrajectoryTemplateStatuses: Array<Maybe<TrajectoryTemplateStatus>>;
  /**
   * Получение типов шаблонов траекторий Bootcamp
   * @deprecated Использовать getTrajectoryTemplateTypesV2
   */
  getTrajectoryTemplateTypes: Array<Maybe<TrajectoryTemplateType>>;
  /**
   * Получение типов шаблонов траекторий Bootcamp
   * @deprecated Использовать getRecommendedTrajectoryTemplateV2
   */
  getTrajectoryTemplateTypesV2: Array<TrajectoryTemplateTypeModel>;
};


export type TrajectoryQueriesCountPulseJobCodeMapperByFilterArgs = {
  filter: TrajectoryTemplateJobCodeMapperFilter;
};


export type TrajectoryQueriesFilterTemplateAssignmentTasksArgs = {
  templateAssignmentTaskFilter: TemplateAssignmentTaskFilter;
};


export type TrajectoryQueriesFindPulseJobCodeByJobCodeTypeArgs = {
  pulseJobCodeType: Array<PulseJobCodeType>;
};


export type TrajectoryQueriesFindPulseJobCodeMapperByFilterArgs = {
  filter: TrajectoryTemplateJobCodeMapperFilter;
  page: PagingInput;
};


export type TrajectoryQueriesFindTrajectoryTemplatesArgs = {
  creatorUserIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  goalIds?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
  statuses?: InputMaybe<Array<InputMaybe<TrajectoryTemplateStatus>>>;
  templateName?: InputMaybe<Scalars['String']['input']>;
};


export type TrajectoryQueriesGetAccessibleTrajectoryTemplatesByStageGroupIdArgs = {
  stageGroupId: Scalars['ID']['input'];
};


export type TrajectoryQueriesGetAllTrajectoryTemplatesWithStageGroupArgs = {
  trajectoryTemplateType?: InputMaybe<TrajectoryTemplateType>;
};


export type TrajectoryQueriesGetAllTrajectoryTemplatesWithStageGroupV2Args = {
  trajectoryTemplateType: Scalars['String']['input'];
};


export type TrajectoryQueriesGetAssignedTrajectoriesArgs = {
  studentIds: Array<Scalars['ID']['input']>;
};


export type TrajectoryQueriesGetMaxPlanEndDateByStudentIdAndTrajectoryArgs = {
  studentId: Scalars['UUID']['input'];
  trajectory: Scalars['String']['input'];
};


export type TrajectoryQueriesGetRecommendedTrajectoryTemplateArgs = {
  studentId: Scalars['ID']['input'];
  trajectoryTemplateType: TrajectoryTemplateType;
  userId: Scalars['ID']['input'];
};


export type TrajectoryQueriesGetRecommendedTrajectoryTemplateV2Args = {
  studentId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};


export type TrajectoryQueriesGetTrajectoriesByIdsArgs = {
  ids: Array<Scalars['ID']['input']>;
};


export type TrajectoryQueriesGetTrajectoriesByStageGroupIdsArgs = {
  stageGroupIds: Array<Scalars['ID']['input']>;
};


export type TrajectoryQueriesGetTrajectoryByIdArgs = {
  id: Scalars['ID']['input'];
};


export type TrajectoryQueriesGetTrajectoryTemplateByIdArgs = {
  trajectoryTemplateId: Scalars['ID']['input'];
};

/** Шаблон траектории Bootcamp */
export type TrajectoryTemplate = {
  __typename?: 'TrajectoryTemplate';
  /** Свидетельство о прохождение траектории */
  certificate?: Maybe<CertificateOfParticipation>;
  /** Дата и время создания траектории */
  createTs: Scalars['DateTime']['output'];
  /** Электронная почта */
  creatorEmail?: Maybe<Scalars['String']['output']>;
  /** ФИО */
  creatorFullName?: Maybe<Scalars['String']['output']>;
  /** Идентификатор пользователя создавшего шаблон */
  creatorUserId: Scalars['UUID']['output'];
  /** Описание шаблона */
  description?: Maybe<Scalars['String']['output']>;
  /** Идентификатор пользователя, который последний изменил шаблон */
  lastModifierUserId?: Maybe<Scalars['UUID']['output']>;
  /** Дата и время последнего изменения шаблона */
  lastModifyTs?: Maybe<Scalars['DateTime']['output']>;
  /** Максимальная длительность в днях */
  maxDuration?: Maybe<Scalars['ID']['output']>;
  /** Идентификатор класса */
  stageGroupId?: Maybe<Scalars['ID']['output']>;
  /** Статус шаблона траектории */
  status: TrajectoryTemplateStatus;
  /** Метка траектории из справочника траекторий (таблица trajectories) */
  trajectorySlug?: Maybe<Scalars['String']['output']>;
  /** Список предметов шаблона траектории */
  trajectoryTemplateGoals?: Maybe<Array<Maybe<TrajectoryTemplateGoal>>>;
  /** Идентификатор (trajectory_templates.trajectory_template_id) */
  trajectoryTemplateId: Scalars['ID']['output'];
  /** Название шаблона траектории */
  trajectoryTemplateName: Scalars['String']['output'];
  /**
   * Тип шаблона траектории
   * @deprecated Переход на хранение типов шаблонов траекторий в БД, а не в коде
   */
  trajectoryTemplateType?: Maybe<TrajectoryTemplateType>;
  /** Тип шаблона траектории */
  trajectoryTemplateTypeV2?: Maybe<Scalars['String']['output']>;
};

/** Модуль по предмету входящему в шаблон траектории Bootcamp */
export type TrajectoryTemplateGoal = {
  __typename?: 'TrajectoryTemplateGoal';
  /** Идентификатор модуля */
  goalId: Scalars['ID']['output'];
  /** Целевой уровень учебного модуля */
  goalLevel: Scalars['Float']['output'];
  /** Название модуля */
  goalName?: Maybe<Scalars['String']['output']>;
  /** Сквозной порядок следования учебного модуля по всей траектории шаблона */
  goalOrderNumber: Scalars['Int']['output'];
  /** Признак обязательности */
  isMandatory: Scalars['Boolean']['output'];
  /** Трудоемкость цели в часах */
  laboriousness: Scalars['Int']['output'];
  /** Идентификатор предмета */
  subjectId: Scalars['ID']['output'];
  /** Название предмета */
  subjectName?: Maybe<Scalars['String']['output']>;
  /** Порядковый номер предмета в шаблоне траектории */
  subjectOrderNumber?: Maybe<Scalars['Int']['output']>;
  /** Идентификатор модуля по предмету в шаблоне траектории (trajectory_template_goals.trajectory_template_goal_id) */
  trajectoryTemplateGoalId: Scalars['ID']['output'];
  /** Идентификатор шаблона траектории (ссылка на trajectory_templates.trajectory_template_id) */
  trajectoryTemplateId: Scalars['ID']['output'];
};

/** Модуль по предмету входящему в шаблон траектории Bootcamp */
export type TrajectoryTemplateGoalInputModel = {
  /** Идентификатор модуля */
  goalId: Scalars['ID']['input'];
  /** Целевой уровень учебного модуля */
  goalLevel: Scalars['Float']['input'];
  /** Признак обязательности */
  isMandatory: Scalars['Boolean']['input'];
  /** Трудоемкость цели в часах */
  laboriousness: Scalars['Int']['input'];
  /** Сквозной порядок следования учебного модуля по всей траектории шаблона */
  orderNumber: Scalars['Int']['input'];
  /** Идентификатор модуля по предмету в шаблоне траектории (trajectory_template_goals.trajectory_template_goal_id) */
  trajectoryTemplateGoalId?: InputMaybe<Scalars['ID']['input']>;
  /** Идентификатор шаблона траектории (ссылка на trajectory_templates.trajectory_template_id) */
  trajectoryTemplateId?: InputMaybe<Scalars['ID']['input']>;
};

/** Шаблон траектории Bootcamp */
export type TrajectoryTemplateInputModel = {
  /** Сертификаты выдаваемые при прохождение траектории */
  certificate?: InputMaybe<CertificateInputModel>;
  /** Дата и время создания шаблона траектории */
  createTs?: InputMaybe<Scalars['DateTime']['input']>;
  /** Идентификатор пользователя создавшего шаблон */
  creatorUserId?: InputMaybe<Scalars['UUID']['input']>;
  /** Описание шаблона */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Идентификатор пользователя, который последний изменил шаблон */
  lastModifierUserId?: InputMaybe<Scalars['UUID']['input']>;
  /** Дата и время последнего изменения шаблона */
  lastModifyTs?: InputMaybe<Scalars['DateTime']['input']>;
  /** Максимальная длительность в днях */
  maxDuration?: InputMaybe<Scalars['ID']['input']>;
  /** Идентификатор класса */
  stageGroupId?: InputMaybe<Scalars['ID']['input']>;
  /** Статус шаблона траектории */
  status: TrajectoryTemplateStatus;
  /** Метка траектории из справочника траекторий (таблица trajectories) */
  trajectorySlug: Scalars['String']['input'];
  /** Список предметов шаблона траектории */
  trajectoryTemplateGoals?: InputMaybe<Array<InputMaybe<TrajectoryTemplateGoalInputModel>>>;
  /** Идентификатор (trajectory_templates.trajectory_template_id) */
  trajectoryTemplateId?: InputMaybe<Scalars['ID']['input']>;
  /** Название шаблона траектории */
  trajectoryTemplateName: Scalars['String']['input'];
  /** Тип шаблона траектории */
  trajectoryTemplateType?: InputMaybe<TrajectoryTemplateType>;
  /** Тип шаблона траектории */
  trajectoryTemplateTypeV2?: InputMaybe<Scalars['String']['input']>;
};

/** Фильтр для поиска шаблонов траекторий с учетом связей с профессиями/ролями/подразделениями из АС Пульс */
export type TrajectoryTemplateJobCodeMapperFilter = {
  /** Список идентификаторов профессий */
  professionIds: Array<InputMaybe<Scalars['String']['input']>>;
  /** Список идентификаторов ролей */
  sbergileIds: Array<InputMaybe<Scalars['String']['input']>>;
  /** Список идентификаторов шаблонов */
  trajectoryTemplateIds: Array<InputMaybe<Scalars['ID']['input']>>;
  /** Список статусов шаблонов траекторий */
  trajectoryTemplateStatuses: Array<TrajectoryTemplateStatus>;
  /** Список идентификаторов подразделений */
  unitIds: Array<InputMaybe<Scalars['String']['input']>>;
};

/** Статус шаблона траектории Bootcamp */
export enum TrajectoryTemplateStatus {
  /** Шаблон неактивен и его теперь нельзя использовать */
  Deleted = 'DELETED',
  /** Шаблон до конца не заполнен */
  Draft = 'DRAFT',
  /** Шаблон полностью заполнен и может использоваться */
  Published = 'PUBLISHED'
}

/** Тип шаблона траектории Bootcamp */
export enum TrajectoryTemplateType {
  /** Тип "Адаптация" */
  Adaptation = 'ADAPTATION',
  /** Тип "Внешний" */
  External = 'EXTERNAL',
  /** Тип "Стажировка" */
  Internship = 'INTERNSHIP',
  /** Тип "Квалификация" */
  Qualification = 'QUALIFICATION'
}

/** Тип шаблона траектории Bootcamp */
export type TrajectoryTemplateTypeModel = {
  __typename?: 'TrajectoryTemplateTypeModel';
  /** Человекочитаемое наименование типа шаблона траектории */
  title?: Maybe<Scalars['String']['output']>;
  /** Идентификатор типа шаблона траектории */
  trajectoryTypeId?: Maybe<Scalars['ID']['output']>;
  /** Наименование типа шаблона траектории */
  trajectoryTypeName?: Maybe<Scalars['String']['output']>;
};

/** Параметры перевода класса/классов из одного учебного года в другой. Переводится один класс в другой (1 -> 1 - класс в класс). Или несколько классов переводится другой класс (М -> 1) */
export type TransferInput = {
  /** id классного руководителя для нового класса */
  formMasterId?: InputMaybe<Scalars['ID']['input']>;
  /** id классов, которые нужно перенести */
  stageGroupIds: Array<Scalars['ID']['input']>;
  /** имя нового класса */
  targetName: Scalars['String']['input'];
};

/** Результат перевода студентов */
export type TransferResult = {
  __typename?: 'TransferResult';
  /** Студенты, в ходе перевода которых возникли ошибки */
  studentsWithErrors?: Maybe<Array<Student>>;
  /** Успешно переведенные студенты */
  successfullyTransferredStudents?: Maybe<Array<Student>>;
};

export type TypedUserGroup = {
  __typename?: 'TypedUserGroup';
  /** Идентификатор сущности */
  entityId: Scalars['String']['output'];
  /** Типы групп пользователей */
  groupType: UserGroupTypeEnum;
  /** Идентификатор группы */
  userGroupId: Scalars['UUID']['output'];
};

/** Учебно-методический комплекс */
export type Umk = {
  __typename?: 'UMK';
  id: Scalars['ID']['output'];
  /** Название УМК */
  name: Scalars['String']['output'];
  /** Идентификатор предмета */
  subjectId: Scalars['ID']['output'];
};

/** Фильтр поиска УМК по заданным параметрам */
export type UmkFilterInput = {
  /** строка поиска по книгам, входящим в УМК (название / автор) */
  booksSearchText?: InputMaybe<Scalars['String']['input']>;
  /** фильтр по параллелям */
  stageIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** фильтр по предметам */
  subjectIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type UniversityActiveStudentsCount = {
  __typename?: 'UniversityActiveStudentsCount';
  activeStudentsCount: Scalars['Int']['output'];
  registeredStudentsCount: Scalars['Int']['output'];
};

export type UniversityDomainInputModel = {
  /** Имя домена университета */
  domain: Scalars['String']['input'];
  /** Идентификатор домена университета */
  universityDomainId?: InputMaybe<Scalars['ID']['input']>;
  /** Идентификатор университета, к которому относится домен */
  universityId?: InputMaybe<Scalars['ID']['input']>;
};

/** Домен университет, к которому относится пользователь Bootcamp */
export type UniversityDomainModel = {
  __typename?: 'UniversityDomainModel';
  /** Имя домена университета */
  domain: Scalars['String']['output'];
  /** Идентификатор домена университета */
  universityDomainId: Scalars['ID']['output'];
  /** Идентификатор университета, к которому относится домен */
  universityId: Scalars['ID']['output'];
};

/** Фильтр по получению вузовской почты учеников Bootcamp */
export type UniversityEmailFilterInputModel = {
  /** Дата начала поиска */
  dateFrom?: InputMaybe<Scalars['DateTime']['input']>;
  /** Дата окончания поиска */
  dateTo?: InputMaybe<Scalars['DateTime']['input']>;
  /** Сортировка по почте */
  isAscSortByEmail?: InputMaybe<Scalars['Boolean']['input']>;
  /** Флаг, определяющий, заполнено ли поле комментария записью о вузе, который не был найден в списке существующих вузов */
  isCommentPresent?: InputMaybe<Scalars['Boolean']['input']>;
  /** Флаг по запросу записей, где была заполнена почта */
  isEmailPresent?: InputMaybe<Scalars['Boolean']['input']>;
  /** Флаг показа страницы верификации вузовской почты пользователю */
  isVisible?: InputMaybe<Scalars['Boolean']['input']>;
  /** Флаг определения использования фильтра по статусу формы */
  isVisibleDefined?: InputMaybe<Scalars['Boolean']['input']>;
  /** Пагинация */
  paging?: InputMaybe<PagingInput>;
  /** Строка поиска по внутренней почте пользователя */
  textSearch?: InputMaybe<Scalars['String']['input']>;
  /** Идентификаторы вузов, по которым запрашивается поиск */
  universityIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type UniversityInfoFilterModel = {
  domains?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  paging?: InputMaybe<PagingInput>;
  universityIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type UniversityInfoInputModel = {
  /** Список доменов университета */
  domains: Array<InputMaybe<UniversityDomainInputModel>>;
  /** Идентификатор университета */
  universityId?: InputMaybe<Scalars['ID']['input']>;
  /** Имя университета */
  universityName: Scalars['String']['input'];
};

export type UniversityInfoModel = {
  __typename?: 'UniversityInfoModel';
  domains: Array<Maybe<UniversityDomainModel>>;
  universityId: Scalars['ID']['output'];
  universityName: Scalars['String']['output'];
};

/** Университет, к которому относится пользователь Bootcamp */
export type UniversityModel = {
  __typename?: 'UniversityModel';
  /** Идентификатор университета */
  universityId: Scalars['ID']['output'];
  /** Название университета */
  universityName: Scalars['String']['output'];
};

export type UniversityModulesReportFilter = {
  beginDate: Scalars['Date']['input'];
  endDate: Scalars['Date']['input'];
  noNameRegion: Scalars['Boolean']['input'];
  regions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  stageGroupIds: Array<InputMaybe<Scalars['Int']['input']>>;
};

export type UniversityNumberOfStudentsOnStage = {
  __typename?: 'UniversityNumberOfStudentsOnStage';
  finalistsStudents: Scalars['Int']['output'];
  nullStageStudents: Scalars['Int']['output'];
  secondStageStudents: Scalars['Int']['output'];
};

export type UniversityStageGroupModel = {
  __typename?: 'UniversityStageGroupModel';
  academicYearId: Scalars['Int']['output'];
  academicYearName: Scalars['String']['output'];
  stageGroupId: Scalars['Int']['output'];
  stageGroupName?: Maybe<Scalars['String']['output']>;
};

export enum UnpublishedChangesType {
  /** Планы */
  Plans = 'PLANS',
  /** Неопубликованные школы */
  Schools = 'SCHOOLS',
  /** Проверяющие */
  Verifiers = 'VERIFIERS'
}

export type UpdatePenaltyInput = {
  /** Комментарий */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** Продолжительность отработки штрафа */
  duration?: InputMaybe<Scalars['Int']['input']>;
  /** Идентификатор редактируемого штрафа */
  penaltyId: Scalars['ID']['input'];
  /** Идентификатор слота отработки штрафа */
  penaltySlotId?: InputMaybe<Scalars['ID']['input']>;
  /** Идентификатор причины штрафа */
  reasonId?: InputMaybe<Scalars['Int']['input']>;
};

export type UpdatedJournalFinalStudentMark = {
  __typename?: 'UpdatedJournalFinalStudentMark';
  journalFinalStudentMark?: Maybe<JournalFinalStudentMark>;
  yearJournalFinalStudentMark: JournalFinalStudentMark;
};

export type User = {
  __typename?: 'User';
  /** Краткое наименование кампуса, где сейчас числится пользователь */
  activeSchoolShortName?: Maybe<Scalars['String']['output']>;
  avatarUrl: Scalars['String']['output'];
  /** Формированное ФИО. Пример, Ульянов Д. */
  birthDate?: Maybe<Scalars['Date']['output']>;
  businessAdminRoles?: Maybe<Array<BusinessAdminRole>>;
  /** deprecated(reason: "Появились продуктовые БА и школа теперь не обязательна. Использовать businessAdminRolesV2") */
  businessAdminRolesV2?: Maybe<Array<BusinessAdminRoleV2>>;
  /** Идентификатор студента в рамках той школы, в которой происходит запрос */
  currentSchoolStudentId?: Maybe<Scalars['UUID']['output']>;
  /** Идентификатор учителя в рамках той школы, в которой происходит запрос */
  currentSchoolTeacherId?: Maybe<Scalars['UUID']['output']>;
  /** диалект для установки локали */
  dialect?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  emailConfirmed?: Maybe<Scalars['Boolean']['output']>;
  externalSession: Scalars['Boolean']['output'];
  firstName: Scalars['String']['output'];
  /** Профили доступа */
  froleSets: Array<FunctionalRoleSet>;
  functionalRoles: Array<FunctionalRole>;
  /** Индивидуальная группа пользователя в сервисе групп */
  groupId?: Maybe<Scalars['UUID']['output']>;
  id: Scalars['ID']['output'];
  /** Дата время последнего логина в систему */
  lastLoginTs?: Maybe<Scalars['DateTime']['output']>;
  lastName: Scalars['String']['output'];
  /**
   * Установленая локаль пользователя
   * @deprecated Have to be used LocaleContextHolder only in context
   */
  locale?: Maybe<Scalars['String']['output']>;
  login?: Maybe<Scalars['String']['output']>;
  middleName?: Maybe<Scalars['String']['output']>;
  mobileNumberEditInfo: MobilePhoneEditInfo;
  mobilePhone?: Maybe<Scalars['String']['output']>;
  parentRoles?: Maybe<Array<ParentRole>>;
  shortFio: Scalars['String']['output'];
  status: UserStatus;
  studentRoles?: Maybe<Array<StudentRole>>;
  systemAdminRole?: Maybe<SystemAdminRole>;
  teacherRoles?: Maybe<Array<TeacherRole>>;
  /** Дата создания учетной записи */
  userCreationDate: Scalars['DateTime']['output'];
  /** Опыт пользователя */
  userExperience?: Maybe<UserExperience>;
  userFiles?: Maybe<Array<Maybe<UserFile>>>;
  /** Привязка профилей доступа пользователя к орг.единицам */
  userFroleSets: Array<UserFroleSet>;
  userPermissions: Array<UserPermission>;
  userSchoolPermissions: Array<UserSchoolPermission>;
};

/** Общая информация аккаунта пользователя */
export type UserAccount = {
  __typename?: 'UserAccount';
  avatarUrl: Scalars['String']['output'];
  birthDate?: Maybe<Scalars['Date']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  emailConfirmed: Scalars['Boolean']['output'];
  firstName: Scalars['String']['output'];
  /** Дата время последнего логина в систему */
  lastLoginTs?: Maybe<Scalars['DateTime']['output']>;
  lastName: Scalars['String']['output'];
  login: Scalars['String']['output'];
  middleName?: Maybe<Scalars['String']['output']>;
  mobilePhone?: Maybe<Scalars['String']['output']>;
  /** дата создания учетной записи пользователя */
  userCreationDate: Scalars['DateTime']['output'];
  /** идентификатор пользователя */
  userId: Scalars['ID']['output'];
  /** текущий статус учетной записи (аккаунта) пользователя */
  userStatus: UserStatus;
};

/** Аватары юзера(ученика) */
export type UserAvatar = {
  __typename?: 'UserAvatar';
  /** Выданный аватар */
  avatar: Avatar;
  id: Scalars['ID']['output'];
  /** Когда выдан аватар */
  rewardDate: Scalars['DateTime']['output'];
};

/** История получения стикеров */
export type UserAvatarHistory = {
  __typename?: 'UserAvatarHistory';
  /** Выданный стикер */
  avatar: Avatar;
  /** Не null, Если стикер выдан за достижения уровня */
  experienceLevel?: Maybe<ExperienceLevel>;
  id: Scalars['ID']['output'];
  /** Когда выдан стикер */
  rewardDate: Scalars['DateTime']['output'];
  /** Не null, Если стикер выдан за выполнения таски */
  task?: Maybe<Task>;
};

/** Награда, выданная пользователю */
export type UserAward = {
  __typename?: 'UserAward';
  /** Награда */
  award: Award;
  /** award_id */
  id: Scalars['ID']['output'];
  /** {true} если у ученика нет этой награды - нужно для бейджей на вкладке "Мои бейджи" */
  isFake: Scalars['Boolean']['output'];
  /** дата получения награды учеником */
  lastAwardDate?: Maybe<Scalars['DateTime']['output']>;
  /** Грейд награды */
  points: Scalars['Int']['output'];
  /** user_id */
  userId: Scalars['ID']['output'];
};

/** История получения наград */
export type UserAwardHistory = {
  __typename?: 'UserAwardHistory';
  /** Выданная награда */
  award: Award;
  /** Очков награды стал */
  awardPoints: Scalars['Int']['output'];
  /** Комментарий выдавшего награду */
  comment?: Maybe<Scalars['String']['output']>;
  /** Пользователь, выдавший награду */
  fromUser?: Maybe<User>;
  id: Scalars['ID']['output'];
  /**
   * Модуль, за закрытие которого получена награда.
   * Null в случае если награда выдана не за закрытие модуля
   */
  module?: Maybe<StudyModule>;
  /** Очков получено */
  pointsReceived: Scalars['Int']['output'];
  /** Когда выдана награда */
  rewardDate: Scalars['DateTime']['output'];
  /** За переход на какую параллель выдалась награда */
  stage?: Maybe<Stage>;
  /** Пользователь, получивший награду */
  user: User;
};

/** Бэйдж юзера(ученика) */
export type UserBadgeAward = {
  __typename?: 'UserBadgeAward';
  /**
   * Награда
   * [{ level: 1 }]
   */
  award: Award;
  /** Бейдж */
  badge: Badge;
  /** История получения награды [{ level: 1, date: 01.01.2012 }] */
  histories: Array<UserAwardHistory>;
  id: Scalars['ID']['output'];
  /** {true} если у ученика нет этого бейджа */
  isFake: Scalars['Boolean']['output'];
  /** дата получения бейджа учеником */
  lastAwardDate?: Maybe<Scalars['DateTime']['output']>;
  /** Грейд бейджа */
  points: Scalars['Int']['output'];
  /** юзер */
  userId: Scalars['UUID']['output'];
};

/** История получения бейджей */
export type UserBadgeAwardHistory = {
  __typename?: 'UserBadgeAwardHistory';
  /** Выданный бейдж */
  badge: Badge;
  /** Грейд бейджа стал */
  badgePoints: Scalars['Int']['output'];
  /** Комментарий выдавшего награду */
  comment?: Maybe<Scalars['String']['output']>;
  /** Пользователь, выдавший награду */
  fromUserId?: Maybe<Scalars['ID']['output']>;
  id: Scalars['ID']['output'];
  /**
   * Модуль, за закрытие которого получен бейдж.
   * Null в случае если бейдж назначен учеником или учителем, а не системой
   */
  module?: Maybe<StudyModule>;
  /** Грейдов получено */
  pointsReceived: Scalars['Int']['output'];
  /** Когда выдан бейдж */
  rewardDate: Scalars['DateTime']['output'];
  /** Пользователь, получивший награду */
  userId: Scalars['ID']['output'];
};

/** Сущность стикер-фона для истории, с коллекцией стикер-фонов для истории, если студент не собрал все части, url будет null */
export type UserBgSticker = {
  __typename?: 'UserBgSticker';
  /** описание стикера */
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** название стикера */
  name: Scalars['String']['output'];
  /** части стикер-фона с датами их получения студентом */
  parts?: Maybe<Array<Maybe<UserBgStickerPart>>>;
  /** ссылка на целый стикер, null, если не собраны все части */
  url?: Maybe<Scalars['String']['output']>;
};

/** сущность части стикер-фона для отображения истории получения стикер-фонов без ссылки на основную часть, но с датой получения */
export type UserBgStickerPart = {
  __typename?: 'UserBgStickerPart';
  /** Описание части */
  description: Scalars['String']['output'];
  /** Id части стикер-фона */
  id: Scalars['ID']['output'];
  /** Уровень за который выдается этот стикер-фон */
  level: ExperienceLevel;
  /** Название части стикер-фона */
  name: Scalars['String']['output'];
  /** дата, когда часть была выдана */
  rewardDate?: Maybe<Scalars['DateTime']['output']>;
  /** Ссылка на стикер-аватар */
  url?: Maybe<Scalars['String']['output']>;
};

/** Информация о запросе по созданию/изменению заявки по сотруднику */
export type UserChangeRequest = {
  __typename?: 'UserChangeRequest';
  /** Логин автора заявки */
  authorLogin: Scalars['String']['output'];
  /** Тип заявки (создание/изменение) */
  changeRequestStatusType: ChangeRequestStatusType;
  /** Тип заявки (создание/изменение) */
  changeRequestType: ChangeRequestType;
  /** Дата создания заявки */
  createTime: Scalars['DateTime']['output'];
  /** Идентификатор заявки */
  id: Scalars['ID']['output'];
  /** Изменения, которые сделаны в рамках заявки */
  modifiedUserDataResult: ModifiedUserDataResult;
  /** Идентификатор изменямого сотрудника */
  userId?: Maybe<Scalars['UUID']['output']>;
  /** Логин изменяемого сотрудника */
  userLogin: Scalars['String']['output'];
};

/** Запрос на создание/изменение заявки по сотруднику */
export type UserChangeRequestInput = {
  /** Тип заявки (создание/изменение) */
  changeRequestType: ChangeRequestType;
  /** Параметры сотрудника, которые изменяются через заявку */
  modifiedUserData: ModifiedUserDataInput;
  /** Логин изменяемого сотрудника */
  userLogin: Scalars['String']['input'];
};

export type UserChangeRequestMutations = {
  __typename?: 'UserChangeRequestMutations';
  /** Отмена заявки на создание/изменение сотрудника */
  cancelUserChangeRequest: Scalars['Boolean']['output'];
  /** Подтверждение заявки на создание/изменение сотрудника */
  confirmUserChangeRequest?: Maybe<UserChangeRequest>;
  /** Создание заявки на создание/изменение сотрудника */
  createUserChangeRequest: UserChangeRequest;
  /** Редактирование заявки на создание/изменение сотрудника */
  editUserChangeRequest: UserChangeRequest;
  /** Отклонение заявки на создание/изменение сотрудника */
  rejectUserChangeRequest?: Maybe<UserChangeRequest>;
};


export type UserChangeRequestMutationsCancelUserChangeRequestArgs = {
  userChangeRequestId: Scalars['ID']['input'];
};


export type UserChangeRequestMutationsConfirmUserChangeRequestArgs = {
  userChangeRequestId: Scalars['ID']['input'];
};


export type UserChangeRequestMutationsCreateUserChangeRequestArgs = {
  userChangeRequest: UserChangeRequestInput;
};


export type UserChangeRequestMutationsEditUserChangeRequestArgs = {
  modifiedUserData: ModifiedUserDataInput;
  userChangeRequestId: Scalars['ID']['input'];
};


export type UserChangeRequestMutationsRejectUserChangeRequestArgs = {
  reason?: InputMaybe<Scalars['String']['input']>;
  userChangeRequestId: Scalars['ID']['input'];
};

export type UserChangeRequestQueries = {
  __typename?: 'UserChangeRequestQueries';
  /** Получение заявки на создание/изменение пользователя по ее ид */
  getUserChangeRequest?: Maybe<UserChangeRequest>;
  /** Получение списка заявок на создание/изменение пользователей по параметрам */
  getUserChangeRequests: Array<Maybe<UserChangeRequest>>;
  /** Получение количества заявок на создание/изменение пользователей по параметрам */
  getUserChangeRequestsCount: Scalars['Int']['output'];
  /** Получение флага заявки находящейся в работе по указанному пользователю */
  getUserHasChangeRequest: Scalars['Boolean']['output'];
};


export type UserChangeRequestQueriesGetUserChangeRequestArgs = {
  userChangeRequestId: Scalars['ID']['input'];
};


export type UserChangeRequestQueriesGetUserChangeRequestsArgs = {
  filterByStatus?: InputMaybe<ChangeRequestStatusType>;
  filterMyRequests?: InputMaybe<Scalars['Boolean']['input']>;
  paging?: InputMaybe<PagingInput>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type UserChangeRequestQueriesGetUserChangeRequestsCountArgs = {
  filterByStatus?: InputMaybe<ChangeRequestStatusType>;
  filterMyRequests?: InputMaybe<Scalars['Boolean']['input']>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type UserChangeRequestQueriesGetUserHasChangeRequestArgs = {
  userLogin: Scalars['String']['input'];
};

/** Инфа по пользователю и его монетам */
export type UserCoins = {
  __typename?: 'UserCoins';
  /** аватар пользователя(относительный путь) */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** текущее кол-во монет */
  currentAmount: Scalars['Int']['output'];
  /** размер последнего начисления\списания */
  lastTransactionAmount?: Maybe<Scalars['Int']['output']>;
  /** дата и время последнего начисления\списания */
  lastTransactionDate?: Maybe<Scalars['DateTime']['output']>;
  /** логин пользователя */
  login: Scalars['String']['output'];
  /** идентификатор пользователя */
  userId: Scalars['UUID']['output'];
};

/** Один элемент начисления\списания монет */
export type UserCoinsHistoryItemModel = {
  __typename?: 'UserCoinsHistoryItemModel';
  /** Размер начисления\списания */
  amount: Scalars['Int']['output'];
  /** Кол-во монет после начисления\списания(поле всегда содержит значение) */
  amountAfter: Scalars['Int']['output'];
  /** Если начисление было от бейджа, то здесь будет его аватарка, иначе null */
  badgeAvatar?: Maybe<Scalars['String']['output']>;
  /** Если начисление было от бейджа, то здесь будет его имя, иначе null */
  badgeName?: Maybe<Scalars['String']['output']>;
  /** Коммент из БД(тут может быть что угодно в разном формате, даже null) */
  comment?: Maybe<Scalars['String']['output']>;
  /** Дата начисления\списания */
  date: Scalars['DateTime']['output'];
  /** Если это была покупка в магазине, то здесь будет номер заказа, иначе null */
  externalTransactionId?: Maybe<Scalars['Int']['output']>;
  /** Если это была ручная транзакция, то тут будет логин инициатора, иначе null */
  giverLogin?: Maybe<Scalars['String']['output']>;
  /** Уникальный номер записи в БД */
  id: Scalars['Int']['output'];
  /** Тип записи в истории(ачивка, покупка...) */
  itemType: UserCoinsHistoryItemType;
  /** Название турнира, если коины получены за турнир, иначе null */
  tournamentName?: Maybe<Scalars['String']['output']>;
};

/** Тип операции с монетами */
export enum UserCoinsHistoryItemType {
  /** Монеты получены вместе с наградой */
  BountyByAward = 'BOUNTY_BY_AWARD',
  /** Монеты выданы админом в ручном режиме */
  HandReward = 'HAND_REWARD',
  /** Монеты потрачены в магазине */
  ShopInStore = 'SHOP_IN_STORE',
  /** монеты получены прямым начислением за турнир */
  TournamentReward = 'TOURNAMENT_REWARD'
}

/** Инфа по пользователю и история изменения его монет */
export type UserCoinsHistoryModel = {
  __typename?: 'UserCoinsHistoryModel';
  /** Аватар пользователя по которому запрошена история */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Список с начислениями\списаниями */
  histories: Array<Maybe<UserCoinsHistoryItemModel>>;
  /** Логин пользователя по которому запрошена история */
  login: Scalars['String']['output'];
  /** Айди пользователя по которому запрошена история */
  userId: Scalars['UUID']['output'];
};

export type UserCredentialsInfo = {
  __typename?: 'UserCredentialsInfo';
  /** идентификатор пользователя */
  id: Scalars['ID']['output'];
  /** установлен пароль */
  passwordConfigured: Scalars['Boolean']['output'];
  /** требуется смена пароля, при входе */
  passwordUpdateRequired: Scalars['Boolean']['output'];
  /** список requiredActions, если список отображать не нужно тогда он будет пустой. */
  requiredOnLoginActionList?: Maybe<Array<Scalars['String']['output']>>;
  /** нужно ли отображать список requiredActions */
  requiredOnLoginActionVisible: Scalars['Boolean']['output'];
  /** Требуется ли обязательно включать второй фактор. */
  secondFactorAuthRequired: Scalars['Boolean']['output'];
  /** настроена sms аутентификация */
  smsAuthEnabled: Scalars['Boolean']['output'];
  /** требуется настройка TOTP, при входе */
  totpConfigurationRequired: Scalars['Boolean']['output'];
  /** настроен TOTP (например в Google Authenticator) */
  totpConfigured: Scalars['Boolean']['output'];
};

/** Комментарий пользователя к заявке на расформирование его команды */
export type UserDisbandRequestComment = {
  __typename?: 'UserDisbandRequestComment';
  /** Комментарий пользователя */
  comment?: Maybe<Scalars['String']['output']>;
  /** Логин пользователя */
  login?: Maybe<Scalars['String']['output']>;
  /** Дата/время создания комментария пользователя */
  userDisbandRequestDate?: Maybe<Scalars['DateTime']['output']>;
};

/** Статус заявки пользователя на расформирование его команды */
export enum UserDisbandRequestStatus {
  /** Заявка пользователя на расформирование команды принята */
  Submit = 'SUBMIT',
  /** Команда уже расформирована, заявка отклонена */
  TeamDisbanded = 'TEAM_DISBANDED'
}

/** Драфт пользователя, приглашенного на платформу (недопользователь) */
export type UserDraft = {
  __typename?: 'UserDraft';
  /** Определяет истек ли срок действия */
  active?: Maybe<Scalars['Boolean']['output']>;
  birthdayDate?: Maybe<Scalars['Date']['output']>;
  /** Дата создания драфта */
  createTs: Scalars['DateTime']['output'];
  /** Идентификатор пользователя, созданного из этого драфта */
  createdUserId?: Maybe<Scalars['UUID']['output']>;
  /** Идентификатор приглашающего пользователя */
  creatorUserId: Scalars['UUID']['output'];
  email?: Maybe<Scalars['String']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  middleName?: Maybe<Scalars['String']['output']>;
  mobilePhone?: Maybe<Scalars['String']['output']>;
  /** Логин, который будет предложен приглашенному пользователю */
  preferredLogin: Scalars['String']['output'];
  stageGroupId?: Maybe<Scalars['Int']['output']>;
  /** Идентификатор драфта пользователя */
  userDraftId: Scalars['UUID']['output'];
  /** Описание ролевой модели будущего пользователя */
  userDraftProfiles: Array<UserDraftProfile>;
};

export type UserDraftInvite = {
  /** Учебный год */
  academicYearString?: InputMaybe<Scalars['String']['input']>;
  /** Дата рождения */
  birthdayDate?: InputMaybe<Scalars['Date']['input']>;
  /** Е-мэйл */
  email: Scalars['String']['input'];
  /** Имя */
  firstName: Scalars['String']['input'];
  /** Фамилия */
  lastName: Scalars['String']['input'];
  /** Отчество */
  middleName?: InputMaybe<Scalars['String']['input']>;
  /** Номер телефона */
  mobilePhone: Scalars['String']['input'];
  /** Предпочтительный логин пользователя */
  preferredLogin?: InputMaybe<Scalars['String']['input']>;
  /** ID школы */
  schoolId: Scalars['UUID']['input'];
  /** Идентификатор группы (класса) */
  stageGroupId?: InputMaybe<Scalars['ID']['input']>;
  /** Наименование группы (класса) */
  stageGroupName?: InputMaybe<Scalars['String']['input']>;
  /** User Draft ID */
  userDraftId?: InputMaybe<Scalars['UUID']['input']>;
  /** Название роли */
  userDraftProfiles?: InputMaybe<Array<UserDraftProfileInput>>;
};

/** Результат постраничного запроса списка черновиков */
export type UserDraftList = {
  __typename?: 'UserDraftList';
  /** общее количество записей в БД, удовлетворяющих запросу */
  count: Scalars['Int']['output'];
  /** информация об черновиках */
  userDrafts: Array<UserDraft>;
};

export type UserDraftOperationsResult = {
  __typename?: 'UserDraftOperationsResult';
  /** Сообщение ошибки, если завершилось не успешно */
  errorMessage?: Maybe<Scalars['String']['output']>;
  /** field email or phone */
  field?: Maybe<Scalars['String']['output']>;
  /** Текущий статус */
  success: Scalars['Boolean']['output'];
  /** userDraftId */
  userDraftId?: Maybe<Scalars['UUID']['output']>;
};

/** Ролевая модель драфта пользователя */
export type UserDraftProfile = {
  __typename?: 'UserDraftProfile';
  /** Наименование Роли из ru\sbt\sber_learning\security\commons\BusinessRoleType */
  businessRoleType: Scalars['String']['output'];
  /** Идентификатор ОУ, в которой пользователь получит роль */
  orgUnitId: Scalars['UUID']['output'];
  /** Сущность, нужная для расширения стандартного набора фролей роли */
  profileType?: Maybe<ProfileType>;
};

export type UserDraftProfileInput = {
  /** UUID Роли из ru\sbt\sber_learning\security\commons\BusinessRoleType */
  businessRoleTypeId: Scalars['UUID']['input'];
  /** Идентификатор ОУ, в которой пользователь получит роль */
  orgUnitId: Scalars['UUID']['input'];
  /** Сущность, нужная для расширения стандартного набора фролей роли */
  profileType?: InputMaybe<ProfileType>;
};

/** Экипировка полученная пользователем */
export type UserEquipmentAward = {
  __typename?: 'UserEquipmentAward';
  /** Награда */
  award: Award;
  /** ID награды */
  awardId: Scalars['ID']['output'];
  /** Шмотка */
  equipment: Equipment;
  /** award_id */
  id: Scalars['ID']['output'];
  /** Надета или нет */
  isDressed: Scalars['Boolean']['output'];
  /** Получена шмотка или нет */
  isFake: Scalars['Boolean']['output'];
  /** Дата получения */
  lastAwardDate?: Maybe<Scalars['DateTime']['output']>;
  /** Кол-во экипировки */
  points: Scalars['Int']['output'];
  /** Хар-ки шмоток пользователя(с учетом их кол-ва) */
  totalAbilitiesPower: Array<AbilityPower>;
};

/** Уровни и опыт пользователя */
export type UserExperience = {
  __typename?: 'UserExperience';
  /** Очки, используемые для проверки code review в S21. {default = 5} */
  codeReviewPoints: Scalars['Int']['output'];
  /** Кол-во монет */
  coinsCount: Scalars['Int']['output'];
  /** Кол-во печенек */
  cookiesCount: Scalars['Int']['output'];
  /** id пользователя */
  id: Scalars['ID']['output'];
  /** S21. Консистентный ли баланс у пользователя */
  isReviewPointsConsistent?: Maybe<Scalars['Boolean']['output']>;
  /** текущий уровень */
  level: ExperienceLevel;
  /** уведомлен ли пользователь что ему присвоен уровень */
  showed: Scalars['Boolean']['output'];
  /** id тенанта продуктового уровня */
  tenantId: Scalars['ID']['output'];
  /** Суммарное значение каждой характеристики пользователя */
  totalAbilitiesPower: Array<AbilityPower>;
  /** текущее количество накопленного опыта */
  value: Scalars['Int']['output'];
  /** количество опыта на выбранную дату */
  valueOnDate?: Maybe<UserExperienceHistory>;
  /** текущее количество опыта, которое можно потратить на стикеры */
  valueToSpent: Scalars['Int']['output'];
};

export type UserExperienceHistory = {
  __typename?: 'UserExperienceHistory';
  /** дата */
  awardDate: Scalars['DateTime']['output'];
  /** id уровня */
  expLevelId: Scalars['ID']['output'];
  /** id условия за которое выдан опыт */
  expTaskType?: Maybe<Scalars['Int']['output']>;
  /** сколько опыта стало */
  expValue: Scalars['Int']['output'];
  /** сколько опыта получено */
  experienceReceived: Scalars['Int']['output'];
  /** тип задаения за которое получен опыт */
  experienceTaskType?: Maybe<ExperienceTaskType>;
  /** userId */
  id: Scalars['ID']['output'];
  /** уровень на дату */
  level: ExperienceLevel;
  /** задание за которое начислен опыт */
  task?: Maybe<Task>;
  /** id задания */
  taskId?: Maybe<Scalars['ID']['output']>;
};

/** Полученный опыт, сгрупированный по дням */
export type UserExperienceHistoryDate = {
  __typename?: 'UserExperienceHistoryDate';
  /** история изменения опыта */
  history?: Maybe<Array<Maybe<ExperienceHistoryDate>>>;
  /** id пользователя */
  userId: Scalars['UUID']['output'];
};

/** Уровни и опыт пользователя в сокращенном виде */
export type UserExperienceShort = {
  __typename?: 'UserExperienceShort';
  /** id пользователя */
  id: Scalars['ID']['output'];
  /** текущий уровень */
  level: ExperienceLevel;
  /** текущее количество накопленного опыта */
  value: Scalars['Int']['output'];
};

export type UserFile = {
  __typename?: 'UserFile';
  fileExtension?: Maybe<Scalars['String']['output']>;
  fileName?: Maybe<Scalars['String']['output']>;
  filePath?: Maybe<Scalars['String']['output']>;
  fileSize?: Maybe<Scalars['Int']['output']>;
  id: Scalars['ID']['output'];
  userId: Scalars['ID']['output'];
};

export type UserFileInput = {
  fileExtension?: InputMaybe<Scalars['String']['input']>;
  fileName?: InputMaybe<Scalars['String']['input']>;
  filePath?: InputMaybe<Scalars['String']['input']>;
  fileSize?: InputMaybe<Scalars['Int']['input']>;
};

/** Параметры поиска\фильтрации пользователей в админке(старой и новой) */
export type UserFilterInput = {
  /** Коалиция пользователей */
  coalitionId?: InputMaybe<Scalars['ID']['input']>;
  /** Уровень опыта */
  experienceLevelId?: InputMaybe<Scalars['ID']['input']>;
  /** Строка поиска логина */
  login?: InputMaybe<Scalars['String']['input']>;
  /** Класс */
  stageGroupId?: InputMaybe<Scalars['ID']['input']>;
  /** Параллель */
  stageId?: InputMaybe<Scalars['ID']['input']>;
};

export type UserFroleSet = {
  __typename?: 'UserFroleSet';
  functionalRoleSet: FunctionalRoleSet;
  orgUnit?: Maybe<OrganizationUnit>;
  product?: Maybe<OrganizationUnit>;
};

export type UserFroleSetInput = {
  functionalRoleSetId: Scalars['UUID']['input'];
  orgUnitId: Scalars['UUID']['input'];
};

/** Инфа по пользователю и его награждениям */
export type UserGivingsHistoryModel = {
  __typename?: 'UserGivingsHistoryModel';
  /** аватар пользователя(относительный путь) */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** Общее кол-во наград */
  badgeCount: Scalars['Int']['output'];
  /** Общее кол-во очков в текущем турнире */
  coalitionPoints: Scalars['Int']['output'];
  /** Баланс монет на данный момент */
  coinsCount: Scalars['Int']['output'];
  /** История награждений(может быть пагинирована) */
  givings?: Maybe<Array<Giving>>;
  /** Общее кол-во награждений за все время */
  givingsTotalCount: Scalars['Int']['output'];
  /** логин пользователя */
  login: Scalars['String']['output'];
  /** идентификатор пользователя */
  userId: Scalars['UUID']['output'];
};

export type UserGroup = {
  __typename?: 'UserGroup';
  /** Идентификатор группы */
  groupId: Scalars['ID']['output'];
  /** Имя группы */
  name: Scalars['String']['output'];
  /** Индетификатор школы */
  schoolId?: Maybe<Scalars['UUID']['output']>;
  /** Пользователи */
  users?: Maybe<Array<User>>;
};

/** Типы групп пользователей */
export enum UserGroupTypeEnum {
  Custom = 'CUSTOM',
  GlobalUserGroup = 'GLOBAL_USER_GROUP',
  Individual = 'INDIVIDUAL',
  Routing = 'ROUTING',
  School = 'SCHOOL',
  SchoolFunctionalRole = 'SCHOOL_FUNCTIONAL_ROLE',
  StageGroup = 'STAGE_GROUP',
  StageSubjectGroup = 'STAGE_SUBJECT_GROUP',
  SystemAdmins = 'SYSTEM_ADMINS',
  Team = 'TEAM'
}

export type UserInfo = {
  __typename?: 'UserInfo';
  firstName: Scalars['String']['output'];
  lastName: Scalars['String']['output'];
  middleName?: Maybe<Scalars['String']['output']>;
  userId: Scalars['ID']['output'];
};

export type UserInput = {
  avatarUrl?: InputMaybe<Scalars['String']['input']>;
  birthDate?: InputMaybe<Scalars['String']['input']>;
  businessAdminRoles?: InputMaybe<Array<BusinessAdminRoleInput>>;
  deletedFilesIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  deletedFunctionalRoles: Array<FunctionalRoleInput>;
  email?: InputMaybe<Scalars['String']['input']>;
  firstName: Scalars['String']['input'];
  id?: InputMaybe<Scalars['ID']['input']>;
  isTrustEmail?: InputMaybe<Scalars['Boolean']['input']>;
  lastName: Scalars['String']['input'];
  login?: InputMaybe<Scalars['String']['input']>;
  middleName?: InputMaybe<Scalars['String']['input']>;
  mobilePhone?: InputMaybe<Scalars['String']['input']>;
  newAndUpdatedFunctionalRoles: Array<FunctionalRoleInput>;
  parentRoles?: InputMaybe<Array<ParentRoleInput>>;
  status?: InputMaybe<UserStatus>;
  studentRoles?: InputMaybe<Array<StudentRoleInput>>;
  systemAdminRole?: InputMaybe<SystemAdminRoleInput>;
  teacherRoles?: InputMaybe<Array<TeacherRoleInput>>;
  userFiles?: InputMaybe<Array<InputMaybe<UserFileInput>>>;
  userFroleSets?: InputMaybe<Array<UserFroleSetInput>>;
};

/** Инфа по пользователю и его последнем награждении */
export type UserLastGiving = {
  __typename?: 'UserLastGiving';
  /** аватар пользователя(относительный путь) */
  avatarUrl?: Maybe<Scalars['String']['output']>;
  /** последнее награждение(нуль если еще ничем не награждали) */
  lastGiving?: Maybe<Giving>;
  /** логин пользователя */
  login: Scalars['String']['output'];
  /** идентификатор пользователя */
  userId: Scalars['UUID']['output'];
};

export type UserLastGivingsResponse = {
  __typename?: 'UserLastGivingsResponse';
  /** Все последние награждения по фильтру (с пагинацией) */
  allLastGivings: Array<UserLastGiving>;
  /** Логины тез кому нель выдать очки коалиции(не в коалиции или без турнира, все по фильтру, без учета пагинации) */
  nonAwardedLogins: Array<Scalars['String']['output']>;
  /** Кол-во тех кому можно выдать очки коалиции(все по фильтру, без учета пагинации) */
  studentsForCoalitionPointsCount: Scalars['Int']['output'];
};

export type UserLoginSettings = {
  __typename?: 'UserLoginSettings';
  deviceId?: Maybe<Scalars['String']['output']>;
  rememberMeOtherCount: Scalars['Int']['output'];
  rememberMeOtherState: RememberMeState;
  rememberMeState: RememberMeState;
};

export type UserLoginSettingsInput = {
  rememberMe: Scalars['Boolean']['input'];
};

/** Награда, которая выдается за закрытие модуля в контексте пользователя */
export type UserModuleAward = {
  __typename?: 'UserModuleAward';
  /** Награда */
  award: Award;
  /** ID модуля, за закрытие которого выдается награда */
  goalId: Scalars['ID']['output'];
  /** module_award_id */
  id: Scalars['ID']['output'];
  /** Получена ли они пользователем */
  isGot: Scalars['Boolean']['output'];
  /** При каком условие выдается */
  moduleAwardType: ModuleAwardTypeEnum;
  /** Сколько наград выдается */
  power: Scalars['Int']['output'];
};

export type UserMutations = {
  __typename?: 'UserMutations';
  /**
   * Блокировка/разблокировка пользователей (в ШЦП, KC, GitLab).
   * Возвращает относительный путь на файл с результатом блокировки
   */
  changeUsersActiveStatus: Scalars['String']['output'];
  /** Удаление всех других быстрых входов за исключением текущего */
  clearOtherUserQuickLogins: UserLoginSettings;
  /** создание жалобы */
  createComplaint: Scalars['Boolean']['output'];
  /** создание жалобы в Bootcamp */
  createComplaintBTC: Scalars['Boolean']['output'];
  /** Оставить сообщение об ошибке в тексте */
  createMisprintReport: Scalars['Boolean']['output'];
  /** создание системной ошибки */
  createSystemError: Scalars['Boolean']['output'];
  /** Удалить отзыв о задании (Лайк/Дизлайк) */
  deleteFeedback: Scalars['Boolean']['output'];
  /** Удалить отзыв на задании (Лайк/Дизлайк) используется командой Bootcamp */
  deleteFeedbackBTC: Scalars['Boolean']['output'];
  /** Делает запрос на редактирование телефона, возвращает сколько времени будет действовать код */
  editMobile: Scalars['Int']['output'];
  /** установка признака прохождения онбординга определенного типа */
  finishOnboarding?: Maybe<Scalars['Boolean']['output']>;
  /** сброс признака прохождения онбординга определенного типа */
  resetOnboarding?: Maybe<Scalars['Boolean']['output']>;
  /** Оставить отзыв задании (Лайк/Дизлайк) */
  saveFeedback: Scalars['Boolean']['output'];
  /** Оставить отзыв на задании (Лайк/Дизлайк) используется командой Bootcamp */
  saveFeedbackBTC: Scalars['Boolean']['output'];
  /** простановка идентификатора текущего шага онбординга и окончен ли он. Вернет ид онбординга */
  setCurrentOnboardingStep: Scalars['ID']['output'];
  /** устанавливает текущему пользователю переданный пароль. Так же передается старый пароль для верификации */
  setPassword?: Maybe<User>;
  /** устанавливает временные пароли переданным пользователям. Выдает файл pdf в формате base64 */
  setTemporaryPasswords: Scalars['String']['output'];
  /** устанавливает временные пароли переданным пользователям. Выдает список связок логинов паролей */
  setTemporaryPasswordsAndReturnPairs: Array<Maybe<LogoPass>>;
  /** Установка локали пользователя */
  setUserLocale: Scalars['String']['output'];
  /**
   * Установка дефолтного контекста роли для входа пользователя
   * @deprecated Field no longer supported
   */
  setUserRoleDefaultContext: Scalars['Boolean']['output'];
  setUserRoleDefaultContext_v2: Scalars['Boolean']['output'];
  /** Изменение пользовательских настроек отображения темы пользователя */
  switchUserTheme: Scalars['Boolean']['output'];
  /** Изменение статуса и комментария исполнителя у жалоб */
  updateComplaint: Scalars['Boolean']['output'];
  /** Изменение статуса и комментария исполнителя у жалоб в Bootcamp */
  updateComplaintBTC: Scalars['Boolean']['output'];
  /** Массовое изменение статуса у жалоб в Bootcamp */
  updateComplaintsStatusBTC: Scalars['Boolean']['output'];
  /** Редактирование ФИО */
  updateFullName: User;
  /** Изменение статуса и комментария исполнителя у опечаток */
  updateMisprint: Scalars['Boolean']['output'];
  /** Массовое изменение статуса у опечаток в Bootcamp */
  updateMisprintsStatusBTC: Scalars['Boolean']['output'];
  /** редактирование профиля */
  updateProfile: User;
  /** изменение email, для учителя при первом входе. */
  updateProfileEmail: User;
  /** Изменение статуса и комментария исполнителя у ошибок */
  updateSystemError: Scalars['Boolean']['output'];
  /** Редактирование настроек логина */
  updateUserLoginSettings: UserLoginSettings;
  /** Отправить письмо для подтверждения текущей почты */
  verifyEmail: Scalars['Boolean']['output'];
  /** Ввод кода отправленного владельцу телефона */
  verifyMobile: EditMobileNumberVerifyResult;
};


export type UserMutationsChangeUsersActiveStatusArgs = {
  userIds: Array<Scalars['UUID']['input']>;
  userStatus: UserStatus;
};


export type UserMutationsCreateComplaintArgs = {
  complaint: ComplaintInput;
};


export type UserMutationsCreateComplaintBtcArgs = {
  complaint: ComplaintInput;
};


export type UserMutationsCreateMisprintReportArgs = {
  misprintReport: MisprintReportInput;
};


export type UserMutationsCreateSystemErrorArgs = {
  systemError: SystemErrorInput;
};


export type UserMutationsDeleteFeedbackArgs = {
  taskId: Scalars['ID']['input'];
};


export type UserMutationsDeleteFeedbackBtcArgs = {
  taskId: Scalars['ID']['input'];
};


export type UserMutationsEditMobileArgs = {
  newMobileNumber: Scalars['String']['input'];
};


export type UserMutationsFinishOnboardingArgs = {
  onboardingType: OnboardingType;
};


export type UserMutationsResetOnboardingArgs = {
  onboardingType: OnboardingType;
};


export type UserMutationsSaveFeedbackArgs = {
  feedback: FeedbackInput;
};


export type UserMutationsSaveFeedbackBtcArgs = {
  feedback: FeedbackInput;
};


export type UserMutationsSetCurrentOnboardingStepArgs = {
  currentStepId: Scalars['ID']['input'];
  isFinished?: InputMaybe<Scalars['Boolean']['input']>;
  onboardingId?: InputMaybe<Scalars['ID']['input']>;
  scriptId: Scalars['ID']['input'];
};


export type UserMutationsSetPasswordArgs = {
  newPassword: Scalars['String']['input'];
  oldPassword: Scalars['String']['input'];
};


export type UserMutationsSetTemporaryPasswordsArgs = {
  userIds: Array<Scalars['ID']['input']>;
  userLocalDateTime: Scalars['DateTime']['input'];
};


export type UserMutationsSetTemporaryPasswordsAndReturnPairsArgs = {
  userIds: Array<Scalars['ID']['input']>;
};


export type UserMutationsSetUserLocaleArgs = {
  locale: Scalars['String']['input'];
};


export type UserMutationsSetUserRoleDefaultContextArgs = {
  role: Roles;
  schoolId?: InputMaybe<Scalars['ID']['input']>;
};


export type UserMutationsSetUserRoleDefaultContext_V2Args = {
  orgUnitId?: InputMaybe<Scalars['ID']['input']>;
  role: Roles;
};


export type UserMutationsSwitchUserThemeArgs = {
  isDarkThemeEnabled: Scalars['Boolean']['input'];
  userId: Scalars['UUID']['input'];
};


export type UserMutationsUpdateComplaintArgs = {
  complaintId: Scalars['ID']['input'];
  executorComment?: InputMaybe<Scalars['String']['input']>;
  status: ComplaintAndSystemErrorStatus;
};


export type UserMutationsUpdateComplaintBtcArgs = {
  complaintId: Scalars['ID']['input'];
  executorComment?: InputMaybe<Scalars['String']['input']>;
  status: ComplaintAndSystemErrorStatus;
};


export type UserMutationsUpdateComplaintsStatusBtcArgs = {
  complaintIds: Array<Scalars['ID']['input']>;
  status: ComplaintAndSystemErrorStatus;
};


export type UserMutationsUpdateFullNameArgs = {
  firstName: Scalars['String']['input'];
  lastName: Scalars['String']['input'];
  middleName?: InputMaybe<Scalars['String']['input']>;
};


export type UserMutationsUpdateMisprintArgs = {
  executorComment?: InputMaybe<Scalars['String']['input']>;
  misprintId: Scalars['ID']['input'];
  status: ComplaintAndSystemErrorStatus;
};


export type UserMutationsUpdateMisprintsStatusBtcArgs = {
  misprintIds: Array<Scalars['ID']['input']>;
  status: ComplaintAndSystemErrorStatus;
};


export type UserMutationsUpdateProfileArgs = {
  avatarUrl?: InputMaybe<Scalars['String']['input']>;
  birthDate?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  mobilePhone?: InputMaybe<Scalars['String']['input']>;
};


export type UserMutationsUpdateProfileEmailArgs = {
  email?: InputMaybe<Scalars['String']['input']>;
};


export type UserMutationsUpdateSystemErrorArgs = {
  executorComment?: InputMaybe<Scalars['String']['input']>;
  status: ComplaintAndSystemErrorStatus;
  systemErrorId: Scalars['ID']['input'];
};


export type UserMutationsUpdateUserLoginSettingsArgs = {
  settings: UserLoginSettingsInput;
};


export type UserMutationsVerifyEmailArgs = {
  returnTo: Scalars['String']['input'];
  returnToWithPath?: InputMaybe<Scalars['String']['input']>;
};


export type UserMutationsVerifyMobileArgs = {
  code: Scalars['String']['input'];
  newMobileNumber: Scalars['String']['input'];
};

export type UserNameView = {
  __typename?: 'UserNameView';
  avatarUrl?: Maybe<Scalars['String']['output']>;
  fullName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
};

export type UserPermission = {
  __typename?: 'UserPermission';
  orgUnitId?: Maybe<Scalars['UUID']['output']>;
  permissions: Array<Scalars['String']['output']>;
};

/** Все бейджи ученика за достижения */
export type UserPortfolioBadges = {
  __typename?: 'UserPortfolioBadges';
  /** Бейджы */
  portfolioBadges: Array<Maybe<PortfolioBadge>>;
  /** Идентификатор пользователя (ученика) */
  userId: Scalars['UUID']['output'];
};

export type UserPositionOrganization = {
  __typename?: 'UserPositionOrganization';
  /** Признак активности */
  active: Scalars['Boolean']['output'];
  /** Дата начала обучения/работы */
  beginDate?: Maybe<Scalars['DateTime']['output']>;
  /** Описание для классов и групп */
  description?: Maybe<Scalars['String']['output']>;
  /** Дата окончания обучения/работы */
  endDate?: Maybe<Scalars['DateTime']['output']>;
  /** Дата выпуска учащегося */
  graduateDate?: Maybe<Scalars['DateTime']['output']>;
  /** Первичный идентификатор */
  id: Scalars['UUID']['output'];
  /** Идентификатор образовательного учреждения */
  orgUnit: OrgUnit;
  /**
   * Идентификатор образовательного учреждения
   * @deprecated Use orgUnit
   */
  orgUnitId: Scalars['UUID']['output'];
  /** Наименование образовательного учреждения */
  otherOrgUnitName?: Maybe<Scalars['String']['output']>;
  /** Идентификатор должности */
  position: Position;
  /**
   * Идентификатор должности
   * @deprecated Use position
   */
  positionId: Scalars['UUID']['output'];
  /** Идентификатор пользователя */
  userId: Scalars['UUID']['output'];
};

export type UserPositionOrganizationInput = {
  /** Признак активности */
  active: Scalars['Boolean']['input'];
  /** Дата начала обучения/работы */
  beginDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Описание для классов и групп */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Дата окончания обучения/работы */
  endDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Дата выпуска учащегося */
  graduateDate?: InputMaybe<Scalars['DateTime']['input']>;
  /** Первичный идентификатор */
  id?: InputMaybe<Scalars['UUID']['input']>;
  /** Идентификатор образовательного учреждения */
  orgUnitId: Scalars['UUID']['input'];
  /** Наименование образовательного учреждения */
  otherOrgUnitName?: InputMaybe<Scalars['String']['input']>;
  /** Идентификатор должности */
  positionId: Scalars['UUID']['input'];
  /** Первичный идентификатор региона образовательного учреждения */
  regionId?: InputMaybe<Scalars['UUID']['input']>;
  /** Наименование класса */
  stageGroup?: InputMaybe<Scalars['String']['input']>;
  /** Идентификатор пользователя */
  userId: Scalars['UUID']['input'];
};

export type UserProfile = {
  __typename?: 'UserProfile';
  /** Аватар(Скин) пользователя */
  avatar: Avatar;
  /** Моя экипировка + характеристики персонажа исходя из надетых вещей */
  equipments: Array<UserEquipmentAward>;
  /** Обо мне */
  meta: UserProfileMeta;
  /** Группы гибких навыков */
  softSkills: Array<UserSoftSkillPercentage>;
};

export type UserProfileMeta = {
  __typename?: 'UserProfileMeta';
  /** "Обо мне" */
  aboutMePersonalInfo?: Maybe<Scalars['String']['output']>;
  /** Любимые исполнители */
  favoriteArtists: Scalars['String']['output'];
  /** Любимые книги */
  favoriteBooks: Scalars['String']['output'];
  /** Любимые фильмы */
  favoriteFilms: Scalars['String']['output'];
  /** Любимые виды спорта */
  favoriteSportKinds: Array<Scalars['String']['output']>;
  /** Любимые предметы */
  favoriteSubjects: Array<FavoriteSubject>;
  /** Любимые форматы заданий */
  favoriteTaskFormats: Array<Scalars['String']['output']>;
  /** Любимые формы работы */
  favoriteWorkForms: Array<Scalars['String']['output']>;
  /** Пол */
  gender: Scalars['String']['output'];
  /** "Увлечения" */
  interests?: Maybe<Array<Scalars['String']['output']>>;
  /** Хобби и увлечения */
  interestsHobbies: Scalars['String']['output'];
  /** Показывать год рождения */
  showBirthYear?: Maybe<Scalars['Boolean']['output']>;
  /** Показывать контактную информацию */
  showContacts?: Maybe<Scalars['Boolean']['output']>;
  /** Показывать прогресс-бар */
  showProgressBar?: Maybe<Scalars['Boolean']['output']>;
  /** Кем хочешь стать */
  wantToBecome: Scalars['String']['output'];
};

export type UserProfileMetaInput = {
  /** "Обо мне" */
  aboutMePersonalInfo?: InputMaybe<Scalars['String']['input']>;
  /** Любимые исполнители */
  favoriteArtists: Scalars['String']['input'];
  /** Любимые книги */
  favoriteBooks: Scalars['String']['input'];
  /** Любимые фильмы */
  favoriteFilms: Scalars['String']['input'];
  /** Любимые виды спорта */
  favoriteSportKinds: Array<Scalars['String']['input']>;
  /** Любимые предметы */
  favoriteSubjectIds: Array<Scalars['Int']['input']>;
  /** Любимые форматы заданий */
  favoriteTaskFormats: Array<Scalars['String']['input']>;
  /** Любимые формы работы */
  favoriteWorkForms: Array<Scalars['String']['input']>;
  /** Пол */
  gender?: InputMaybe<Scalars['String']['input']>;
  /** "Увлечения" */
  interests?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Хобби и увлечения */
  interestsHobbies: Scalars['String']['input'];
  /** Показывать год рождения */
  showBirthYear?: InputMaybe<Scalars['Boolean']['input']>;
  /** Показывать контактную информацию */
  showContacts?: InputMaybe<Scalars['Boolean']['input']>;
  /** Показывать прогресс-бар */
  showProgressBar?: InputMaybe<Scalars['Boolean']['input']>;
  /** Кем хочешь стать */
  wantToBecome: Scalars['String']['input'];
};

export type UserProfileMutations = {
  __typename?: 'UserProfileMutations';
  /** Обновление URL фона профиля пользователя */
  saveCover: Scalars['Boolean']['output'];
  /** Обновление URL фотографии пользователя (доступно ученику, учителю, родителю) */
  savePhoto: Scalars['Boolean']['output'];
  savePhotoAndAvatar: Scalars['Boolean']['output'];
  saveProfileMeta: Scalars['Boolean']['output'];
  setAvatar: Scalars['Boolean']['output'];
  /** Отображение/сокрытие прогресс-бара пользователя */
  setProgressBarShowed: Scalars['Boolean']['output'];
};


export type UserProfileMutationsSaveCoverArgs = {
  coverUrl?: InputMaybe<Scalars['String']['input']>;
};


export type UserProfileMutationsSavePhotoArgs = {
  photoUrl?: InputMaybe<Scalars['String']['input']>;
};


export type UserProfileMutationsSavePhotoAndAvatarArgs = {
  avatarId: Scalars['ID']['input'];
  photoUrl?: InputMaybe<Scalars['String']['input']>;
};


export type UserProfileMutationsSaveProfileMetaArgs = {
  userProfileMetaInput: UserProfileMetaInput;
};


export type UserProfileMutationsSetAvatarArgs = {
  avatarId: Scalars['ID']['input'];
};


export type UserProfileMutationsSetProgressBarShowedArgs = {
  isShowed: Scalars['Boolean']['input'];
};

export type UserProfileQueries = {
  __typename?: 'UserProfileQueries';
  getAdminBusinessPublicProfile: AdminBusinessPublicProfile;
  getAllFavoriteSubjects: Array<FavoriteSubject>;
  /** Получение публичного профиля пользователя по userID */
  getBasePublicProfile: BasePublicProfile;
  /** Получить справочник стандартных фонов профиля */
  getCoverUrls?: Maybe<Array<ProfileCover>>;
  getParentPublicProfile: ParentPublicProfile;
  /** Получить справочник категорий документов портфолио */
  getPortfolioReactions: Array<PortfolioReaction>;
  getProfileCoversUser?: Maybe<ProfileCoverUser>;
  getSoftSkillTypeProgress: Array<UserSoftSkillTypeProgress>;
  getStudentPublicProfile: StudentPublicProfile;
  getTeacherPublicProfile: TeacherPublicProfile;
};


export type UserProfileQueriesGetAdminBusinessPublicProfileArgs = {
  adminBusinessId: Scalars['UUID']['input'];
};


export type UserProfileQueriesGetBasePublicProfileArgs = {
  userId: Scalars['UUID']['input'];
};


export type UserProfileQueriesGetParentPublicProfileArgs = {
  parentId: Scalars['UUID']['input'];
};


export type UserProfileQueriesGetProfileCoversUserArgs = {
  userId?: InputMaybe<Scalars['UUID']['input']>;
};


export type UserProfileQueriesGetSoftSkillTypeProgressArgs = {
  softSkillTypeId: Scalars['ID']['input'];
};


export type UserProfileQueriesGetStudentPublicProfileArgs = {
  studentId: Scalars['UUID']['input'];
};


export type UserProfileQueriesGetTeacherPublicProfileArgs = {
  teacherId: Scalars['UUID']['input'];
};

export type UserQueries = {
  __typename?: 'UserQueries';
  /** проверяет, превысил ли пользователь лимит на жалобы на задание или матариал каталога */
  canAddComplaint: Scalars['Boolean']['output'];
  /** Запрос количества жалоб */
  countComplaints: Scalars['Int']['output'];
  /** Запрос количества жалоб в Bootcamp */
  countComplaintsBTC: Scalars['Int']['output'];
  /** Запрос количества рейтингов */
  countFeedbacks: Scalars['Int']['output'];
  /** Подсчет результатов удовлетворяющих фильтру */
  countFeedbacksBTC: Scalars['Int']['output'];
  /** Запрос количества рейтингов текущего пользователя */
  countMyFeedbacks: Scalars['Int']['output'];
  /** Получение количества записей по упрощенной версии отчета БМ для Внешнего учителя */
  countStudentsReducedProgressForBTC: Scalars['Int']['output'];
  /** Запрос количества системных ошибок */
  countSystemError: Scalars['Int']['output'];
  /** Отчет по жалобам пользователей в Bootcamp */
  exportComplaintsBTC: ReportExcelFile;
  exportFeedbackReport: ReportExcelFile;
  /** Отчет по опечаткам в Bootcamp */
  exportMisprintReportsBTC: ReportExcelFile;
  /** Получение excel-выгрузки упрощенной версии отчета БМ для Внешнего учителя */
  exportStudentReducedProgressBTC: ReportExcelFile;
  /**
   * Генерация логина пользователя
   * Генерация логина пользователя
   * @deprecated Field no longer supported
   */
  generateUserLogin: Scalars['String']['output'];
  /**
   * Получение списка всех аудируемых сущностей
   * @deprecated Switched to REST API
   */
  getAllAuditableEntityTypes: Array<AuditableEntityType>;
  /**
   * Получение всех конфигураций для бэкенда
   * @deprecated Have to be removed after ui for parameters with tariff. Remove after a new API version is rolled out that takes into account the Product configurations
   */
  getAllBackendConfigurations: Array<Configuration>;
  /**
   * Получение всех конфигураций для бэкенда сгрупированные по тарифам
   * @deprecated Remove after a new API version is rolled out that takes into account the Product configurations
   */
  getAllBackendConfigurationsByTariff: Array<ConfigurationByTariff>;
  /** Получение всех конфигураций для бэкенда сгрупированные по тарифам */
  getAllBackendConfigurationsByTariffV2: Array<ConfigurationByTariff>;
  /**
   * Получение всех конфигураций для бэкенда с учетом тарифов
   * @deprecated Remove after a new API version is rolled out that takes into account the Product configurations
   */
  getAllBackendConfigurationsTariffCompatible: Array<Configuration>;
  /** Получение всех конфигураций для бэкенда с учетом тарифов */
  getAllBackendConfigurationsTariffCompatibleV2: Array<Configuration>;
  /** Получение всех конфигураций для бэкенда */
  getAllBackendConfigurationsV2: Array<Configuration>;
  /** Получение всех стран */
  getAllCountries: Array<Country>;
  /** Запрос для получения всех существующих в системе регоинов */
  getAllRegions: Array<Region>;
  /** Получение списка всех учебных параллелей с учётом тенанта, в рамках которого работает пользователь */
  getAllStagesTenantAware: Array<Stage>;
  /** Возвращает список предметов согласно иерархии разрешений (полный или сокращённый для отображения в фильтрах) */
  getAllSubjectsByOrgConfiguration?: Maybe<Array<Subject>>;
  /** Получение build info основного приложения и дополнительных микросервисов */
  getApplicationBuildInfos: Array<ApplicationInfo>;
  /**
   * Получение операций по типу сущности
   * @deprecated Switched to REST API
   */
  getAuditOperationTypeByEntityType: Array<AuditOperationType>;
  /**
   * получение записей аудита
   * @deprecated Switched to REST API
   */
  getAuditRecords: AuditRecordsResponse;
  /** получить список профилей, доступных для назначения на указанную орг.единицу */
  getAvailableFroleSets: Array<FunctionalRoleSet>;
  getAvailableTimeZones: Array<AvailableTimeZone>;
  /** Возвращает набор ссылок на аватары согласно роли пользователя. Первая запись - аватар по умолчанию для роли */
  getAvatarUrls: Array<Scalars['String']['output']>;
  /** Получение списка всех городов учеников */
  getBTCStudentCities: Array<Scalars['String']['output']>;
  /** Получение списка всех Буткемп-мастеров */
  getBootcampMastersList: Array<BootcampMasterModel>;
  /** Справочник причин жалоб */
  getComplaintReasons: Array<ComplaintReason>;
  /** Справочник причин жалоб в Bootcamp */
  getComplaintReasonsBTC: Array<ComplaintReason>;
  /** Просмотр жалоб */
  getComplaints: Array<Complaint>;
  /** Просмотр жалоб в Bootcamp */
  getComplaintsBTC: Array<Complaint>;
  /** Получение фильтра */
  getComplaintsFilterBtc: Array<Task>;
  /**
   * Получение всех запрошенных конфигураций.
   * @deprecated Have to be removed after ui for parameters with tariff. Remove after a new API version is rolled out that takes into account the Product configurations
   */
  getConfigurations: Array<Configuration>;
  /**
   * Получение всех запрошенных конфигураций сгруппированые по тарифам
   * @deprecated Remove after a new API version is rolled out that takes into account the Product configurations
   */
  getConfigurationsByTariff: Array<ConfigurationByTariff>;
  /** Получение всех запрошенных конфигураций сгруппированые по тарифам */
  getConfigurationsByTariffV2: Array<ConfigurationByTariff>;
  /**
   * Получение всех запрошенных конфигураций c учетом тарифов
   * @deprecated Remove after a new API version is rolled out that takes into account the Product configurations
   */
  getConfigurationsTariffCompatible: Array<Configuration>;
  /** Получение всех запрошенных конфигураций c учетом тарифов */
  getConfigurationsTariffCompatibleV2: Array<Configuration>;
  /** Получение всех запрошенных конфигураций. */
  getConfigurationsV2: Array<Configuration>;
  /** получить данные по текущему пользователю */
  getCurrentUser: User;
  /** получить список ролей по текущему пользователю */
  getCurrentUserRoles: Array<UserRole>;
  /**
   * получить список ролей и школ с названиями по текущему пользователю (для системного админа информации о школах не будет)
   * @deprecated Use getCurrentUserRoles
   */
  getCurrentUserSchoolRoles: Array<UserSchoolRole>;
  /** Просмотр отзыва о задании */
  getFeedback?: Maybe<Feedback>;
  /** Получение отзыва для ученика БМ/Дашбоды/Рейтинги */
  getFeedbackBTC?: Maybe<Feedback>;
  /** Просмотр рейтингов БМ/Дашбоды/Рейтинги */
  getFeedbackReport: Array<FeedbackReportBtc>;
  /** Просмотр конкретного рейтинга БМ/Дашбоды/Рейтинги */
  getFeedbackReportById: FeedbackReportBtc;
  /** Получение фильтра для построения дашборда */
  getFeedbackReportFilter: Array<Task>;
  /** Запрос статистики по фидбэкам задания */
  getFeedbackStatistics: FeedbackStatistics;
  /** Запрос списка видов оценки (что понравилось больше всего) */
  getFeedbackSubjects: Array<FeedbackSubject>;
  /** Просмотр рейтингов */
  getFeedbacks: Array<Feedback>;
  /** запрос классов классного руководителя */
  getFormMasterStageGroups: Array<StageGroup>;
  /**
   * запрос классов классного руководителя
   * @deprecated Field no longer supported
   */
  getFormMasterStageGroupsWithPerformance: Array<StageGroup>;
  /** запрос классов классного руководителя v4 */
  getFormMasterStageGroupsWithPerformanceV4: Array<StageGroupAggregated>;
  /** Получить базовую минимальную информацию о модуле */
  getGoalInfo: GoalInfo;
  /** Возвращает баннеры для праздников на дату */
  getHolidayBanners: Array<Maybe<HolidayBanner>>;
  /** Возвращает набор стикеров для праздников на дату */
  getHolidayStickerPacks: Array<Maybe<HolidayStickerPackGroup>>;
  /** Возвращает приветственные страницы для праздников на дату */
  getHolidayWelcomePages: Array<Maybe<HolidayWelcomePage>>;
  /** Получение фильтра */
  getMisprintFilterBtc: Array<Task>;
  /** Справочник причин ошибок в тексте */
  getMisprintReasons: Array<MisprintReason>;
  getMisprintReports: Array<MisprintReport>;
  getMisprintReportsBTC: Array<MisprintReportBtc>;
  getMisprintReportsCount: Scalars['Int']['output'];
  getMisprintReportsCountBTC: Scalars['Int']['output'];
  /** Просмотр рейтингов текщего пользователя */
  getMyFeedbacks: Array<Feedback>;
  /** Просмотр сообщений об ошибках в тексте от текущего пользователя */
  getMyMisprintReports: Array<MisprintReport>;
  /** Получить орг. структуру по ее uuid */
  getOrganizationUnit: OrganizationUnit;
  /** Получить список орг.единиц определённого типа с фильтрацией по продуктам и строкой поиска */
  getOrganizationUnits: Array<OrganizationUnit>;
  /** Просмотр информации о школе */
  getSchool: SafeSchool;
  /** Получение упрощенной версии отчета БМ для Внешнего учителя */
  getStudentsReducedProgressForBTC: Array<StudentReducedProgressForBtcModel>;
  /** просмотр системных ошибок */
  getSystemError: Array<SystemError>;
  /** Получить базовую минимальную информацию по заданию */
  getTaskInfo: TaskInfo;
  /** получение тенанта, id которого передан в хэдере запроса "tenantId", для отображения его полей на UI */
  getTenant?: Maybe<School>;
  /** Получить список пользовательских групп по uuid и groupType */
  getTypedUserGroups: Array<TypedUserGroup>;
  /** Получить локаль */
  getUserLocale?: Maybe<Scalars['String']['output']>;
  /** Чтение настроек логина */
  getUserLoginSettings: UserLoginSettings;
  /** Получение всех статусов онбординга пользователя по заданному сценарию */
  getUserOnboardingsByScriptId: Array<Onboarding>;
  /** Получение всех статусов онбордингов пользователя по заданным сценариям */
  getUserOnboardingsByScriptIds: Array<Onboarding>;
  /** Получить список орг.единиц пользователя */
  getUserOrgUnits: Array<OrganizationUnit>;
  /** Получить заданные пользователем настройки отображения по uuid */
  getUserViewSettings: UserViewSettings;
  /** Создает токен для обращения на сервер видеоконференций */
  getVCToken: Scalars['String']['output'];
  /** Создает токен для обращения на сервер видеоконференций */
  getVCTokenV2: Scalars['String']['output'];
  /** Получения записи вебинара в Webinar.ru */
  getWebinarRuRecord: WebinarRecord;
};


export type UserQueriesCanAddComplaintArgs = {
  catalogItemId?: InputMaybe<Scalars['UUID']['input']>;
  taskId?: InputMaybe<Scalars['ID']['input']>;
};


export type UserQueriesCountComplaintsArgs = {
  dateFrom?: InputMaybe<Scalars['DateTime']['input']>;
  dateTo?: InputMaybe<Scalars['DateTime']['input']>;
  filterReasons?: InputMaybe<Array<Scalars['ID']['input']>>;
  filterStatus?: InputMaybe<ComplaintAndSystemErrorStatus>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type UserQueriesCountComplaintsBtcArgs = {
  complaintFilter: ComplaintFilterInput;
};


export type UserQueriesCountFeedbacksArgs = {
  taskId?: InputMaybe<Scalars['ID']['input']>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type UserQueriesCountFeedbacksBtcArgs = {
  filter?: InputMaybe<FeedbackFilterInputModel>;
};


export type UserQueriesCountMyFeedbacksArgs = {
  taskId?: InputMaybe<Scalars['ID']['input']>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type UserQueriesCountStudentsReducedProgressForBtcArgs = {
  filter: StudentReducedProgressFilterBtcInputModel;
};


export type UserQueriesCountSystemErrorArgs = {
  dateFrom?: InputMaybe<Scalars['DateTime']['input']>;
  dateTo?: InputMaybe<Scalars['DateTime']['input']>;
  filterStatus?: InputMaybe<ComplaintAndSystemErrorStatus>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type UserQueriesExportComplaintsBtcArgs = {
  complaintFilter: ComplaintExportFilterInput;
};


export type UserQueriesExportFeedbackReportArgs = {
  filter?: InputMaybe<FeedbackFilterInputModel>;
};


export type UserQueriesExportMisprintReportsBtcArgs = {
  misprintFilter: MisprintExportFilterInput;
};


export type UserQueriesExportStudentReducedProgressBtcArgs = {
  filter: StudentReducedProgressFilterBtcInputModel;
};


export type UserQueriesGenerateUserLoginArgs = {
  user?: InputMaybe<UserInput>;
};


export type UserQueriesGetAllBackendConfigurationsArgs = {
  entityIdList: Array<Scalars['ID']['input']>;
};


export type UserQueriesGetAllBackendConfigurationsByTariffArgs = {
  entityIdList: Array<Scalars['ID']['input']>;
};


export type UserQueriesGetAllBackendConfigurationsByTariffV2Args = {
  entityId: Scalars['String']['input'];
};


export type UserQueriesGetAllBackendConfigurationsTariffCompatibleArgs = {
  entityIdList: Array<Scalars['ID']['input']>;
};


export type UserQueriesGetAllBackendConfigurationsTariffCompatibleV2Args = {
  entityId: Scalars['String']['input'];
};


export type UserQueriesGetAllBackendConfigurationsV2Args = {
  entityId: Scalars['String']['input'];
};


export type UserQueriesGetAuditOperationTypeByEntityTypeArgs = {
  entityTypeCode?: InputMaybe<Scalars['String']['input']>;
};


export type UserQueriesGetAuditRecordsArgs = {
  action?: InputMaybe<AuditOperationAction>;
  auditOperationCodes: Array<Scalars['String']['input']>;
  dateFrom: Scalars['DateTime']['input'];
  dateTo: Scalars['DateTime']['input'];
  entityId?: InputMaybe<Scalars['ID']['input']>;
  entityTypeCode?: InputMaybe<Scalars['String']['input']>;
  paging: PagingInput;
  schoolIds: Array<Scalars['UUID']['input']>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
  userIds: Array<Scalars['UUID']['input']>;
};


export type UserQueriesGetAvailableFroleSetsArgs = {
  orgUnitId: Scalars['UUID']['input'];
};


export type UserQueriesGetComplaintReasonsArgs = {
  filterSystemComplaints?: InputMaybe<Scalars['Boolean']['input']>;
};


export type UserQueriesGetComplaintsArgs = {
  dateFrom?: InputMaybe<Scalars['DateTime']['input']>;
  dateTo?: InputMaybe<Scalars['DateTime']['input']>;
  filterReasons?: InputMaybe<Array<Scalars['ID']['input']>>;
  filterStatus?: InputMaybe<ComplaintAndSystemErrorStatus>;
  paging?: InputMaybe<PagingInput>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type UserQueriesGetComplaintsBtcArgs = {
  complaintFilter: ComplaintFilterInput;
};


export type UserQueriesGetConfigurationsArgs = {
  entityIdList: Array<Scalars['ID']['input']>;
  frontConfigurationInput: Array<FrontConfigurationInput>;
};


export type UserQueriesGetConfigurationsByTariffArgs = {
  entityIdList: Array<Scalars['ID']['input']>;
  frontConfigurationInput: Array<FrontConfigurationInput>;
};


export type UserQueriesGetConfigurationsByTariffV2Args = {
  entityId: Scalars['String']['input'];
  frontConfigurationInput: Array<FrontConfigurationInput>;
};


export type UserQueriesGetConfigurationsTariffCompatibleArgs = {
  entityIdList: Array<Scalars['ID']['input']>;
  frontConfigurationInput: Array<FrontConfigurationInput>;
};


export type UserQueriesGetConfigurationsTariffCompatibleV2Args = {
  entityId: Scalars['String']['input'];
  frontConfigurationInput: Array<FrontConfigurationInput>;
};


export type UserQueriesGetConfigurationsV2Args = {
  entityId: Scalars['String']['input'];
  frontConfigurationInput: Array<FrontConfigurationInput>;
};


export type UserQueriesGetFeedbackArgs = {
  taskId: Scalars['ID']['input'];
};


export type UserQueriesGetFeedbackBtcArgs = {
  taskId: Scalars['ID']['input'];
};


export type UserQueriesGetFeedbackReportArgs = {
  filter?: InputMaybe<FeedbackFilterInputModel>;
};


export type UserQueriesGetFeedbackReportByIdArgs = {
  feedbackId: Scalars['ID']['input'];
};


export type UserQueriesGetFeedbackStatisticsArgs = {
  taskId: Scalars['ID']['input'];
};


export type UserQueriesGetFeedbacksArgs = {
  paging?: InputMaybe<PagingInput>;
  taskId?: InputMaybe<Scalars['ID']['input']>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type UserQueriesGetFormMasterStageGroupsArgs = {
  classTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  filterStages: Array<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type UserQueriesGetFormMasterStageGroupsWithPerformanceArgs = {
  classTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  filterStages: Array<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type UserQueriesGetFormMasterStageGroupsWithPerformanceV4Args = {
  classTitleTextSearch?: InputMaybe<Scalars['String']['input']>;
  filterStages: Array<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};


export type UserQueriesGetGoalInfoArgs = {
  childUserId?: InputMaybe<Scalars['UUID']['input']>;
  goalId: Scalars['ID']['input'];
};


export type UserQueriesGetHolidayBannersArgs = {
  date: Scalars['Date']['input'];
};


export type UserQueriesGetHolidayStickerPacksArgs = {
  date: Scalars['Date']['input'];
};


export type UserQueriesGetHolidayWelcomePagesArgs = {
  date: Scalars['Date']['input'];
};


export type UserQueriesGetMisprintReportsArgs = {
  dateFrom?: InputMaybe<Scalars['DateTime']['input']>;
  dateTo?: InputMaybe<Scalars['DateTime']['input']>;
  filterReasons?: InputMaybe<Array<Scalars['ID']['input']>>;
  filterStatus?: InputMaybe<ComplaintAndSystemErrorStatus>;
  paging?: InputMaybe<PagingInput>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type UserQueriesGetMisprintReportsBtcArgs = {
  misprintFilter: MisprintFilterInput;
};


export type UserQueriesGetMisprintReportsCountArgs = {
  dateFrom?: InputMaybe<Scalars['DateTime']['input']>;
  dateTo?: InputMaybe<Scalars['DateTime']['input']>;
  filterReasons?: InputMaybe<Array<Scalars['ID']['input']>>;
  filterStatus?: InputMaybe<ComplaintAndSystemErrorStatus>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type UserQueriesGetMisprintReportsCountBtcArgs = {
  misprintFilter: MisprintFilterInput;
};


export type UserQueriesGetMyFeedbacksArgs = {
  paging?: InputMaybe<PagingInput>;
  taskId?: InputMaybe<Scalars['ID']['input']>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type UserQueriesGetOrganizationUnitArgs = {
  orgUnitId: Scalars['UUID']['input'];
};


export type UserQueriesGetOrganizationUnitsArgs = {
  filterProduct?: InputMaybe<Scalars['UUID']['input']>;
  paging?: InputMaybe<PagingInput>;
  sortingFields?: InputMaybe<Array<InputMaybe<SortingField>>>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
  type: OrganizationUnitType;
};


export type UserQueriesGetSchoolArgs = {
  schoolId: Scalars['UUID']['input'];
};


export type UserQueriesGetStudentsReducedProgressForBtcArgs = {
  filter: StudentReducedProgressFilterBtcInputModel;
};


export type UserQueriesGetSystemErrorArgs = {
  dateFrom?: InputMaybe<Scalars['DateTime']['input']>;
  dateTo?: InputMaybe<Scalars['DateTime']['input']>;
  filterStatus?: InputMaybe<ComplaintAndSystemErrorStatus>;
  paging?: InputMaybe<PagingInput>;
  textSearch?: InputMaybe<Scalars['String']['input']>;
};


export type UserQueriesGetTaskInfoArgs = {
  checkBucketId?: InputMaybe<Scalars['ID']['input']>;
  childUserId?: InputMaybe<Scalars['UUID']['input']>;
  taskId: Scalars['ID']['input'];
};


export type UserQueriesGetTypedUserGroupsArgs = {
  groupType: UserGroupTypeEnum;
  userId: Scalars['UUID']['input'];
};


export type UserQueriesGetUserOnboardingsByScriptIdArgs = {
  scriptId: Scalars['String']['input'];
};


export type UserQueriesGetUserOnboardingsByScriptIdsArgs = {
  scriptIds: Array<InputMaybe<Scalars['String']['input']>>;
};


export type UserQueriesGetUserOrgUnitsArgs = {
  userId: Scalars['UUID']['input'];
};


export type UserQueriesGetUserViewSettingsArgs = {
  userId: Scalars['UUID']['input'];
};


export type UserQueriesGetVcTokenArgs = {
  onlineLessonId: Scalars['ID']['input'];
  role: VcUserRole;
};


export type UserQueriesGetVcTokenV2Args = {
  lessonPlanId: Scalars['ID']['input'];
  role: VcUserRole;
};


export type UserQueriesGetWebinarRuRecordArgs = {
  lessonPlanId: Scalars['ID']['input'];
};

/** Место и ряд пользователя в лидерборде */
export type UserRankAndRow = {
  __typename?: 'UserRankAndRow';
  /** Текущее место */
  rank: Scalars['Int']['output'];
  /** Текущий ряд */
  row: Scalars['Int']['output'];
};

/** Ограничение пользователя в Ш21 (Штраф/Отчислен..) */
export type UserRestriction = {
  __typename?: 'UserRestriction';
  /** Время создания */
  createdTs: Scalars['DateTime']['output'];
  /** Активно ли ограничение */
  isActive: Scalars['Boolean']['output'];
  /** Идентификатор ограничения */
  restrictionId: Scalars['UUID']['output'];
  /** Тип ограничения */
  restrictionType: Scalars['String']['output'];
  /** Идентификатор школы в которой применено ограничение */
  schoolId: Scalars['UUID']['output'];
  /** Время изменения */
  updatedTs?: Maybe<Scalars['DateTime']['output']>;
  /** Идентификатор ограниченного пользователя */
  userId: Scalars['UUID']['output'];
};

export type UserRole = {
  __typename?: 'UserRole';
  /** Отображаемое название роли */
  displayableName: Scalars['String']['output'];
  /** Полное название орг.единицы */
  orgUnitFullName: Scalars['String']['output'];
  /** Ид организационной единицы */
  orgUnitId: Scalars['ID']['output'];
  /** Короткое название орг.единицы */
  orgUnitShortName: Scalars['String']['output'];
  /** Тип организационной единицы */
  orgUnitType: OrganizationUnitType;
  /** Код роли (см ru.sbt.sber_learning.security.commons.BusinessRoleType) */
  roleCode: Scalars['String']['output'];
  /** Ид пользователя */
  userId: Scalars['ID']['output'];
};

export type UserSchoolPermission = {
  __typename?: 'UserSchoolPermission';
  permissions: Array<Scalars['String']['output']>;
  schoolId?: Maybe<Scalars['UUID']['output']>;
};

export type UserSchoolRole = {
  __typename?: 'UserSchoolRole';
  /** Отображаемое название роли */
  displayableName: Scalars['String']['output'];
  /** Список данных о прохождении юзером скриптов онбординга */
  onboardings: Array<Onboarding>;
  /** Тип организации */
  organizationType?: Maybe<OrganizationType>;
  /** регион школы */
  region?: Maybe<Region>;
  /** Код роли (см ru.sbt.sber_learning.security.commons.BusinessRoleType) */
  roleCode: Scalars['String']['output'];
  /** Полное название школы, отсутствует для кейса Системного админа */
  schoolFullName?: Maybe<Scalars['String']['output']>;
  /** Ид школы, отсутствует для кейса Системного админа */
  schoolId?: Maybe<Scalars['ID']['output']>;
  /** Признак активности школы, отсутствует для кейса Системного админа */
  schoolIsActive?: Maybe<Scalars['Boolean']['output']>;
  /** Короткое название школы, отсутствует для кейса Системного админа */
  schoolShortName?: Maybe<Scalars['String']['output']>;
  /** Ид пользователя */
  userId: Scalars['ID']['output'];
};

export enum UserSecondFactorAuthSmsAction {
  /** Отключаем, требование использовать sms аутентификацию при входе. */
  Disable = 'DISABLE',
  /** Включаем, требование использовать sms аутентификацию при входе. */
  Enable = 'ENABLE',
  /** Ничего не меняем. */
  None = 'NONE'
}

export enum UserSecondFactorAuthTotpAction {
  /**
   * Выключаем TOTP:
   * - удаляем настроенный TOTP
   * - удаляем required action "Configure TOTP"
   */
  Disable = 'DISABLE',
  /**
   * Включаем TOTP:
   * - если у пользователя уже настроен TOTP или требуется конфигурации TOTP после входа, то ничего не делаем.
   * - если у пользователя не настроен TOTP, то устанавливаем required action "Configure TOTP"
   */
  Enable = 'ENABLE',
  /** Не меняет настройку TOTP у пользователя. */
  None = 'NONE',
  /**
   * Сбрасываем TOTP
   * - удаляем настроенный TOTP
   * - устанавливаем required action "Configure TOTP"
   */
  Reset = 'RESET'
}

/** Прокаченный софт скил пользователя с процентами */
export type UserSoftSkillPercentage = {
  __typename?: 'UserSoftSkillPercentage';
  /** Процент от максимального(+ 10%) прокаченного. */
  percentageOfMaximum: Scalars['Int']['output'];
  /** Процент от суммы всех прокаченных софт скиллов пользователя */
  percentageOfTotalAmount: Scalars['Int']['output'];
  /** Прокачка софт скилла */
  power: Scalars['Int']['output'];
  softSkillId: Scalars['ID']['output'];
  softSkillName: Scalars['String']['output'];
};

/** Сколько раз была улучшена группа гибкого навыка за период(неделю) */
export type UserSoftSkillTypeProgress = {
  __typename?: 'UserSoftSkillTypeProgress';
  /** ID группы гибких навыков */
  softSkillTypeId: Scalars['ID']['output'];
  /** Дата начала недели */
  startDate: Scalars['Date']['output'];
  /** Количество выполненных заданий по данной группе гибких навыков */
  taskCount: Scalars['Int']['output'];
};

export enum UserStatus {
  /** Активен */
  Active = 'ACTIVE',
  /** Заблокирован */
  Blocked = 'BLOCKED'
}

export type UserSurveyAnswerInput = {
  /** Ответ пользователя. Ожидатеся JSON в формате String */
  answer?: InputMaybe<Scalars['String']['input']>;
  /** Идентификатор запроса */
  surveyId: Scalars['UUID']['input'];
};

export type UserTestAnswer = {
  __typename?: 'UserTestAnswer';
  /** Дата ответа */
  answerDate: Scalars['DateTime']['output'];
  /** ID ответа */
  id: Scalars['ID']['output'];
  /** Тест связанный с ответом */
  testId: Scalars['ID']['output'];
  /** ID пользователя */
  userId: Scalars['ID']['output'];
};

export type UserTestAnswerContent = {
  __typename?: 'UserTestAnswerContent';
  /** Ответ связанный с контентом */
  answerId: Scalars['ID']['output'];
  /** Контент ответа в JSON формате */
  content: Scalars['String']['output'];
  /** ID контента отвта */
  id: Scalars['ID']['output'];
};

export type UserTestContent = {
  __typename?: 'UserTestContent';
  /** Тестовый контент в JSON формате */
  content: Scalars['String']['output'];
  /** ID тестового контента */
  id: Scalars['ID']['output'];
  /** Тест связанный с контентом */
  testId: Scalars['ID']['output'];
};

export type UserTestType = {
  __typename?: 'UserTestType';
  /** ID типа теста */
  id: Scalars['ID']['output'];
  /** Наименование типа теста */
  name: Scalars['String']['output'];
};

/** Результаты участия пользователя в турнире */
export type UserTournamentResult = {
  __typename?: 'UserTournamentResult';
  /** Ссылка на герб коалиции участника */
  coalitionAvatarUrl?: Maybe<Scalars['String']['output']>;
  /** Название коалиции участника */
  coalitionName: Scalars['String']['output'];
  /** Место, которое заняла коалиция пользователя */
  coalitionRank: Scalars['Int']['output'];
  /** Название коалиции, занявшей первое место */
  firstCoalitionName: Scalars['String']['output'];
  /** ID результата */
  id: Scalars['UUID']['output'];
  /** Показывался ли результат пользователю */
  isShown: Scalars['Boolean']['output'];
  /** Набранные баллы пользователя */
  power: Scalars['Int']['output'];
  /** Дата и время завершения турнира */
  timeClosed: Scalars['DateTime']['output'];
  /** Название турнира */
  tournamentName: Scalars['String']['output'];
  /** ID пользователя */
  userId: Scalars['UUID']['output'];
  /** Место, которое занял пользователь */
  userRank: Scalars['Int']['output'];
};

export type UserTournamentWidget = {
  __typename?: 'UserTournamentWidget';
  /** Коалиция пользователя */
  coalitionMember?: Maybe<CoalitionMember>;
  getMyCoalitionMembers: Array<CoalitionMember>;
  /**
   * Последний турнир пользователя
   * @deprecated Вынесено в StudentQueries из-за проблем с кэшированием
   */
  lastTournament?: Maybe<GameTournament>;
  /** Результат участия в последнем прошедшем турнире (не удаляется после удаления турнира) */
  lastTournamentResult?: Maybe<UserTournamentResult>;
};


export type UserTournamentWidgetGetMyCoalitionMembersArgs = {
  page?: InputMaybe<PagingInput>;
};

/** Содержит заданные пользователем настройки отображения */
export type UserViewSettings = {
  __typename?: 'UserViewSettings';
  /** Флаг включена ли темная тема (по умолчанию можно возвращать false) */
  isDarkThemeEnabled: Scalars['Boolean']['output'];
  /** Тип установленной праздничной темы для школы студента */
  schoolViewSettingType: S21SchoolViewSettingType;
};

export type UserWidget = {
  __typename?: 'UserWidget';
  category: Scalars['String']['output'];
  description: Scalars['String']['output'];
  group: Scalars['String']['output'];
  id: Scalars['String']['output'];
  layoutConfig: Scalars['String']['output'];
  preview: Scalars['String']['output'];
  title: Scalars['String']['output'];
  visual: Scalars['String']['output'];
};

/** layoutConfig - JSON строка типа "{"a": "a", "b": "b"...}" */
export type UserWidgetInput = {
  category: Scalars['String']['input'];
  group: Scalars['String']['input'];
  id: Scalars['String']['input'];
  layoutConfig: Scalars['String']['input'];
  visual: Scalars['String']['input'];
};

export type UserWithDeletedRole = {
  __typename?: 'UserWithDeletedRole';
  /** Наименование удаленной/деактивированной роли для отображения */
  displayableRoleName: Scalars['String']['output'];
  /** Есть ли у роли Родитель активные дети. Используется для определения возможности восстановления роли. */
  hasParentActiveChildren?: Maybe<Scalars['Boolean']['output']>;
  /**
   * Для деактивированных ролей/удаленных действует период в 30 дней, в теч. которого возможно восстановить роль.
   * Поле показывает сколько дней осталось до окончания срока восстановления.
   */
  recoveryDaysLeft: Scalars['Int']['output'];
  /** Удаленная/деактивированная роль */
  roleName: Roles;
  userAccount: UserAccount;
};

/** Количество участников класса в статусе active / inactive */
export type UsersStatusCount = {
  __typename?: 'UsersStatusCount';
  activeParticipants?: Maybe<Scalars['Int']['output']>;
  inactiveParticipants?: Maybe<Scalars['Int']['output']>;
  participants?: Maybe<Scalars['Int']['output']>;
};

/** Юзеры(ученики), для выдачи награды */
export type UsersToBadgeAward = {
  __typename?: 'UsersToBadgeAward';
  /** дата получения бейджа учеником */
  lastAwardDate?: Maybe<Scalars['DateTime']['output']>;
  /** логин пользователя */
  login: Scalars['String']['output'];
  /** Грейд бейджа */
  points?: Maybe<Scalars['Int']['output']>;
  /** идентификатор пользователя */
  userId: Scalars['UUID']['output'];
};

export type VcLink = {
  __typename?: 'VCLink';
  /** Пароль для входа в видеоконференцию */
  password: Scalars['String']['output'];
  /** Комната для проведения видеоконференции */
  room: Scalars['String']['output'];
  /** url для входа в видеоконференцию */
  url: Scalars['String']['output'];
};

export enum VcUserRole {
  Member = 'MEMBER',
  Owner = 'OWNER'
}

export type ValidatedSchool = {
  __typename?: 'ValidatedSchool';
  /** Модель школы */
  school?: Maybe<School>;
  /** Отчет по полям модели, не прошедших валидацию */
  validationErrors: Array<FieldValidationError>;
};

export enum ValueType {
  Boolean = 'BOOLEAN',
  Date = 'DATE',
  /** Допустиимое значение передается дополнительно */
  Enum = 'ENUM',
  Float = 'FLOAT',
  Integer = 'INTEGER',
  String = 'STRING'
}

/** Информация о проверяемых Ш21 */
export type VerifiableInfo = {
  __typename?: 'VerifiableInfo';
  /** Информация о команде. Null если проект индивидуальный */
  team?: Maybe<Team>;
  /** Список проверяемых студентов. Если проект индивидуальный, будет один элемент */
  verifiableStudents: Array<VerifiableStudent>;
};

/** Проверяемый студент Ш21 */
export type VerifiableStudent = {
  __typename?: 'VerifiableStudent';
  /** Аватар */
  avatarUrl: Scalars['String']['output'];
  /** Кол-во CRP */
  codeReviewPoints: Scalars['Int']['output'];
  /** Кол-во PRP */
  cookiesCount: Scalars['Int']['output'];
  /** Является ли студент тим лидом, null если проект индивидуальный */
  isTeamLead?: Maybe<Scalars['Boolean']['output']>;
  /** Уровень */
  levelCode: Scalars['Int']['output'];
  /** Логин */
  login: Scalars['String']['output'];
  /** Школа пользователя */
  school: School;
  /** Идентификатор студента */
  studentId: Scalars['ID']['output'];
  /** Идентификатор пользователя */
  userId: Scalars['ID']['output'];
};

/** Информацию о проверяемых */
export type VerifiableUsers = {
  __typename?: 'VerifiableUsers';
  teamWithMembers?: Maybe<TeamWithMembers>;
  user?: Maybe<User>;
};

/** Проверяющий программы в группе */
export type VerifierGroupUser = {
  __typename?: 'VerifierGroupUser';
  /** идентификатор проверяющего как пользователя платформы */
  userId: Scalars['UUID']['output'];
  /** именование проверющего, например ФИО */
  userName: Scalars['String']['output'];
};

export enum VideoconferenceType {
  OtherVideoconference = 'OTHER_VIDEOCONFERENCE',
  VcSberdevices = 'VC_SBERDEVICES',
  WebinarRu = 'WEBINAR_RU'
}

/** Всего в регионе */
export type VillageAndCitySchools = {
  __typename?: 'VillageAndCitySchools';
  actualDate: Scalars['Date']['output'];
  schoolsCount: Scalars['Int']['output'];
  studentsCount: Scalars['Int']['output'];
  teachersCount: Scalars['Int']['output'];
  townSchoolsPercent: Scalars['Int']['output'];
  townStudentsPercent: Scalars['Int']['output'];
  townTeachersPercent: Scalars['Int']['output'];
  villageSchoolsPercent: Scalars['Int']['output'];
  villageStudentsPercent: Scalars['Int']['output'];
  villageTeachersPercent: Scalars['Int']['output'];
};

/** Значение в ячейке журнала посещаемости */
export type VisitJournalCell = {
  __typename?: 'VisitJournalCell';
  /** комментарий */
  comment?: Maybe<Scalars['String']['output']>;
  /** Дата и время создания ячейки журнала */
  createTime?: Maybe<Scalars['DateTime']['output']>;
  /** Дата и время модификации ячейки журнала */
  lastModifyTime?: Maybe<Scalars['DateTime']['output']>;
  /** Идентификатор пользователя, изменившего ячейку журнала */
  lastModifyUserId?: Maybe<Scalars['ID']['output']>;
  /** Дата занятия */
  lessonId: Scalars['ID']['output'];
  /** Идентификатор учителя */
  teacherId?: Maybe<Scalars['ID']['output']>;
  /** Значение в ячейке журнала */
  value: VisitJournalCellValueEnum;
  /** Идентификатор ячейки журнала посещаемости */
  visitJournalCellId: Scalars['ID']['output'];
};

/** Типы значений в ячейках журнала посещаемости */
export enum VisitJournalCellValueEnum {
  /** Отсутствовал */
  Absent = 'ABSENT',
  /** Отсутствовал по уважительной причине */
  AbsentReasonable = 'ABSENT_REASONABLE',
  /** Нет данных в журнале */
  NotPresent = 'NOT_PRESENT',
  /** Не установлено */
  NotSet = 'NOT_SET',
  /** Посетил */
  Visited = 'VISITED',
  /** Был болен */
  WasIll = 'WAS_ILL',
  /** Опоздал */
  WasLate = 'WAS_LATE'
}

/** Представление урока для журнала */
export type VisitJournalLesson = {
  __typename?: 'VisitJournalLesson';
  /** Дата урока */
  date: Scalars['Date']['output'];
  /** Идентификатор урока */
  lessonId: Scalars['ID']['output'];
  /** Время начала урока */
  startTime?: Maybe<Scalars['Time']['output']>;
};

/** Управление журналом посещения */
export type VisitJournalMutations = {
  __typename?: 'VisitJournalMutations';
  /** Создать правило тиражирования журнала посещаемости */
  addVisitJournalRule: Scalars['Boolean']['output'];
  /** Редактирование ячейки в журнале посещения */
  editVisitJournalCells: Scalars['Boolean']['output'];
  /**
   * Удаление правила тиражирования посещаемости
   * true - произошло даление и false - сущность по ИД не найдена
   */
  removeVisitJournalRule: Scalars['Boolean']['output'];
};


/** Управление журналом посещения */
export type VisitJournalMutationsAddVisitJournalRuleArgs = {
  comment?: InputMaybe<Scalars['String']['input']>;
  daysOfWeek?: InputMaybe<Array<Scalars['Int']['input']>>;
  endDate: Scalars['Date']['input'];
  skipCheck?: InputMaybe<Scalars['Boolean']['input']>;
  startDate: Scalars['Date']['input'];
  studentId: Scalars['UUID']['input'];
  timeSlotIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  value: VisitJournalCellValueEnum;
};


/** Управление журналом посещения */
export type VisitJournalMutationsEditVisitJournalCellsArgs = {
  cells: Array<EditVisitJournalCellInput>;
};


/** Управление журналом посещения */
export type VisitJournalMutationsRemoveVisitJournalRuleArgs = {
  visitJournalRuleId: Scalars['ID']['input'];
};

/** Запросы данных о посещениях из журнала */
export type VisitJournalQueries = {
  __typename?: 'VisitJournalQueries';
  /** Поиск ячеек журнала посещений */
  getVisitJournalCellsByFilter: StageSubjectGroupVisitJournal;
  getVisitJournalRules?: Maybe<Array<Maybe<GetVisitJournalRulesResponse>>>;
};


/** Запросы данных о посещениях из журнала */
export type VisitJournalQueriesGetVisitJournalCellsByFilterArgs = {
  filter: VisitJournalSearchFilter;
};


/** Запросы данных о посещениях из журнала */
export type VisitJournalQueriesGetVisitJournalRulesArgs = {
  endDate?: InputMaybe<Scalars['DateTime']['input']>;
  stageGroupId: Scalars['ID']['input'];
  startDate?: InputMaybe<Scalars['DateTime']['input']>;
  subjectId?: InputMaybe<Scalars['ID']['input']>;
  visitJournalCellValues?: InputMaybe<Array<VisitJournalCellValueEnum>>;
};

/** Строка в журнале посещаемости */
export type VisitJournalRow = {
  __typename?: 'VisitJournalRow';
  /** Ячейки в строке */
  cells: Array<VisitJournalCell>;
  /** Ученик */
  student: Student;
};

export type VisitJournalRule = {
  __typename?: 'VisitJournalRule';
  /** комментарий устанавливающийся в журнал посещаемости при срабатывании правила */
  comment?: Maybe<Scalars['String']['output']>;
  /** дата до которой правило действует */
  endDate: Scalars['DateTime']['output'];
  /** дата с которой правило действует */
  startDate: Scalars['DateTime']['output'];
  /** Идентификаор ученика */
  studentId: Scalars['ID']['output'];
  /** предметы затрагиваемые правилом */
  subjects?: Maybe<Array<Scalars['ID']['output']>>;
  /** Идетификаторы таймслотов (уроков/звонков) */
  timeslotIds?: Maybe<Array<Scalars['ID']['output']>>;
  /** значение правила */
  visitJournalCellValue: VisitJournalCellValueEnum;
  /** Идентификатор правила */
  visitJournalRuleId: Scalars['ID']['output'];
  /** Дни недели в которые действует правило */
  weekDays?: Maybe<Array<Scalars['ID']['output']>>;
};

/** Фильтр для поиска данных в журнале посещаемости. */
export type VisitJournalSearchFilter = {
  /** Дата окончания занятий (включительно) */
  endDate: Scalars['Date']['input'];
  /** Идентификатор группы по предмету */
  stageSubjectGroupId: Scalars['ID']['input'];
  /** Дата начала занятий (включительно) */
  startDate: Scalars['Date']['input'];
  /** Идентификаторы учеников */
  studentIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** Информация по урокам */
export type VisitLessonInfo = {
  __typename?: 'VisitLessonInfo';
  /** Время конца урока */
  lessonEnd: Scalars['Time']['output'];
  /** Идентификатор урока */
  lessonId: Scalars['ID']['output'];
  /** Время начала урока */
  lessonStart: Scalars['Time']['output'];
  /** Название предмета */
  subjectName: Scalars['String']['output'];
  /** ФИО учителя */
  teacherName: Scalars['String']['output'];
};

export type VisitLessonPeriod = {
  __typename?: 'VisitLessonPeriod';
  /** Дата начала периода */
  dateFrom: Scalars['Date']['output'];
  /** Дата конца периода */
  dateTo: Scalars['Date']['output'];
};

/** Данные статистики посещаемости */
export type VisitLessonStatData = {
  __typename?: 'VisitLessonStatData';
  /** Кол-во записей (для пагинации) */
  count: Scalars['Int']['output'];
  /** Список студентов */
  studentsStat: Array<VisitLessonStudentStat>;
};

/** Модель ошибки */
export type VisitLessonStatError = {
  __typename?: 'VisitLessonStatError';
  /** Код ошибки */
  errorCode: VisitLessonStatErrorCode;
};

/** Коды ошибок */
export enum VisitLessonStatErrorCode {
  /** Аттестационный период не найден */
  AttestationPeriodNotFound = 'ATTESTATION_PERIOD_NOT_FOUND',
  /** Некорректный период */
  WrongPeriod = 'WRONG_PERIOD'
}

export type VisitLessonStatQueries = {
  __typename?: 'VisitLessonStatQueries';
  /** Запрос списка академических годов школы */
  getAcademicYears: Array<AcademicYear>;
  /** Запрос информации по урокам */
  getLessonsInfo: Array<VisitLessonInfo>;
  /** Запрос дат аттестационного периода */
  getPeriod: AttestationPeriodDatesResponse;
  /** Запрос списка групп (классов) */
  getStageGroups: Array<StageGroup>;
  /** Запрос предметов параллели */
  getSubjects: Array<StageSubject>;
  /** Запрос статистики посещения уроков */
  getVisitLessonStat: VisitLessonStatResponse;
};


export type VisitLessonStatQueriesGetLessonsInfoArgs = {
  lessonIds: Array<Scalars['ID']['input']>;
};


export type VisitLessonStatQueriesGetPeriodArgs = {
  stageGroupId: Scalars['ID']['input'];
  stageSubjectId?: InputMaybe<Scalars['ID']['input']>;
};


export type VisitLessonStatQueriesGetStageGroupsArgs = {
  academicYearId: Scalars['ID']['input'];
};


export type VisitLessonStatQueriesGetSubjectsArgs = {
  stageGroupId: Scalars['ID']['input'];
};


export type VisitLessonStatQueriesGetVisitLessonStatArgs = {
  visitLessonStatRequest: VisitLessonStatRequest;
};

/** Параметры запроса статистики */
export type VisitLessonStatRequest = {
  /** Дата начала периода выгрузки */
  dateFrom: Scalars['Date']['input'];
  /** Дата конца периода выгрузки */
  dateTo: Scalars['Date']['input'];
  /** Параметры пагинации */
  paging: PagingInput;
  /** Параметры сортировки */
  sorting: Array<VisitLessonStatSorting>;
  /** Идентификатор группы (класса) */
  stageGroupId: Scalars['ID']['input'];
  /** Идентификатор предмета параллели */
  stageSubjectId?: InputMaybe<Scalars['ID']['input']>;
  /** ФИО студента */
  studentName?: InputMaybe<Scalars['String']['input']>;
};

/** Статистика посещений */
export type VisitLessonStatResponse = {
  __typename?: 'VisitLessonStatResponse';
  /** Данные */
  data?: Maybe<VisitLessonStatData>;
  /** Ошибки */
  error?: Maybe<VisitLessonStatError>;
  /** Успешность операции */
  isSuccess: Scalars['Boolean']['output'];
};

/** Параметры сортировки */
export type VisitLessonStatSorting = {
  /** Направление сортировки */
  asc: Scalars['Boolean']['input'];
  /** Поле сортировки */
  field: VisitLessonStatSortingField;
  /** Порядок сортировки */
  order: Scalars['Int']['input'];
};

/** Поле сортировки */
export enum VisitLessonStatSortingField {
  /** Процент пропуска уроков */
  LessonMissedPercentage = 'LESSON_MISSED_PERCENTAGE',
  /** ФИ студента */
  StudentName = 'STUDENT_NAME'
}

/** Данные статистики посещаемости по студенту */
export type VisitLessonStudentStat = {
  __typename?: 'VisitLessonStudentStat';
  /** Суммарная статистика посещаемости */
  overallVisitStat: OverallVisitStat;
  /** Студент */
  student: StudentWithUser;
  /** Посещаемость по дням */
  visitsByDate: Array<VisitStatByDate>;
};

/** Информация о пропущенных уроках на дату */
export type VisitStatByDate = {
  __typename?: 'VisitStatByDate';
  /** Дата */
  date: Scalars['Date']['output'];
  /** Признак того, что студент был в составе класса */
  isStudentExistedInGroup: Scalars['Boolean']['output'];
  /** Идентификаторы пропущенных уроков */
  missedLessonIds: Array<Scalars['ID']['output']>;
  /** Пропущено уроков */
  missedLessons: Scalars['Int']['output'];
};

export type WebinarRecord = {
  __typename?: 'WebinarRecord';
  convertionStatus?: Maybe<Scalars['Int']['output']>;
  recordLink?: Maybe<Scalars['String']['output']>;
};

/** Понедельный план в рамках учебного периода по предмету */
export type WeekSubjectPlan = {
  __typename?: 'WeekSubjectPlan';
  /** Конечная дата недели в рамках учебного периода */
  endDate: Scalars['DateTime']['output'];
  /** Есть ли мотивационный блок у модуля с Id = nearestGoalId */
  isMotivationBlockPresent?: Maybe<Scalars['Boolean']['output']>;
  /** Id ближайшего модуля для текущей даты в рамках текущей недели */
  nearestGoalId?: Maybe<Scalars['ID']['output']>;
  /** Начальная дата недели в рамках учебного периода */
  startDate: Scalars['DateTime']['output'];
  /**
   * Задания, относящиеся к данной неделе (если есть траектории) или пустой список если нет траектории
   * null - если на данную неделю не запланирован никакой модуль
   */
  tasks?: Maybe<Array<SubjectTask>>;
};

export type WelcomePackFilterInputModel = {
  /** Поиск по городам */
  cities?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Филь по дате начало */
  dateFrom?: InputMaybe<Scalars['DateTime']['input']>;
  /** Филь по дате конец */
  dateTo?: InputMaybe<Scalars['DateTime']['input']>;
  /** Фильтр по факту окончания Bootcamp */
  isCompleteTrajectory?: InputMaybe<Scalars['Boolean']['input']>;
  /** Поиск среди всех учеников */
  isFullSearch?: InputMaybe<Scalars['Boolean']['input']>;
  /** Фильтр по факту выдачи */
  isIssued?: InputMaybe<Scalars['Boolean']['input']>;
  /** Сортирорвка по дате */
  isSortByDate?: InputMaybe<Scalars['Boolean']['input']>;
  /** Сортировка по ФИО */
  isSortByName?: InputMaybe<Scalars['Boolean']['input']>;
  /** Поиск по Botcamp мастерам */
  masters?: InputMaybe<Array<Scalars['UUID']['input']>>;
  /** Поиск по организациям */
  organisationsNames?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Пагинация */
  paging?: InputMaybe<PagingInput>;
  /** Поиск по вхождению */
  textSearch?: InputMaybe<Scalars['String']['input']>;
};

export type WelcomePackFilterParamsModel = {
  __typename?: 'WelcomePackFilterParamsModel';
  /** Города учеников из отчета о welcome pack */
  allCities: Array<Maybe<CityModel>>;
  /** БМ мастера из отчета о welcome pack */
  masters: Array<Maybe<SimpleUserInfoModel>>;
};

export type WelcomePackModel = {
  __typename?: 'WelcomePackModel';
  /** Комментарий к сбросу */
  commentForReset?: Maybe<Scalars['String']['output']>;
  /** Факт выдачи Welcome Pack */
  isIssued: Scalars['Boolean']['output'];
  /** Факт сброса выдачи welcome pack */
  isReset: Scalars['Boolean']['output'];
  /** Дата выдачи Welcome Pack */
  issuedTs?: Maybe<Scalars['DateTime']['output']>;
  /** Полное ФИО буткемп мастера который выдал welcome pack */
  issuedUserFullName?: Maybe<Scalars['String']['output']>;
  /** Организация ученика */
  organisationName?: Maybe<Scalars['String']['output']>;
  /** Табельный номер ученика */
  personnelNumber?: Maybe<Scalars['ID']['output']>;
  /** ID ученика */
  studentId: Scalars['UUID']['output'];
  /** ID записи */
  welcomePackId: Scalars['ID']['output'];
};

export type WelcomePackReportModel = {
  __typename?: 'WelcomePackReportModel';
  /** Полное ФИО Botcamp мастера */
  BmFullName?: Maybe<Scalars['String']['output']>;
  /** Город ученика */
  city?: Maybe<Scalars['String']['output']>;
  /** Коментарий к сбросу факта выдачи */
  commentForReset?: Maybe<Scalars['String']['output']>;
  /** Факт выдачи Welcome Pack */
  isIssued: Scalars['Boolean']['output'];
  /** Факт сброса выдачи welcome pack */
  isReset: Scalars['Boolean']['output'];
  /** Дата выдачи Welcome Pack */
  issuedTs?: Maybe<Scalars['DateTime']['output']>;
  /** Полное ФИО буткемп мастера который выдал welcome pack */
  issuedUserFullName?: Maybe<Scalars['String']['output']>;
  /** Организация ученика */
  organisationName?: Maybe<Scalars['String']['output']>;
  /** Табельный номер ученика */
  personnelNumber?: Maybe<Scalars['ID']['output']>;
  /** Полное ФИО ученика */
  studentFullName: Scalars['String']['output'];
  /** ID ученика */
  studentId: Scalars['UUID']['output'];
  /** Прогресс ученика по траектории */
  studentProgress: Scalars['Int']['output'];
  /** Плановая дата окончания траектории */
  trajectoryEndDate?: Maybe<Scalars['DateTime']['output']>;
  /** Название траектории ученика */
  trajectoryName?: Maybe<Scalars['String']['output']>;
  /** ID записи */
  welcomePackId: Scalars['ID']['output'];
};

export type Widget = {
  __typename?: 'Widget';
  /** тело виджета */
  body: WidgetBody;
  /** Бизнесс тип (используется только если WidgetGroupTypeEnum=Business) */
  businessType?: Maybe<BusinessTypeEnum>;
  /** Информация для виджета бизнес-типа (WidgetGroupTypeEnum=BUSINESS) */
  businessWidgetInfo?: Maybe<BusinessWidgetInfo>;
  /** Мета-информация о вариативности виджета */
  variationMeta?: Maybe<WidgetVariationMeta>;
  /** Тип группы виджетов */
  widgetGroupType: WidgetGroupTypeEnum;
  /** Идентификатор виджета */
  widgetId: Scalars['ID']['output'];
  /** Порядковый номер виджета на странице */
  widgetNumber: Scalars['Int']['output'];
  /** Css-стили виджета */
  widgetStyle?: Maybe<Scalars['String']['output']>;
  /** Тип виджета */
  widgetType: WidgetTypeEnum;
};

export type WidgetAnswerBody = {
  __typename?: 'WidgetAnswerBody';
  /** Возврат ответа на виджет код */
  codeAnswerBody?: Maybe<CodeAnswerBody>;
  /** Возврат ответа заполнения пропусков */
  fillingGapAnswerBody?: Maybe<FillingGapAnswerBody>;
  /** Возврат ответа на развернутый ответ */
  fullAnswerBody?: Maybe<FullAnswerBody>;
  /** Возврат ответа соединения линиями */
  lineConnectorAnswerBody?: Maybe<LineConnectorAnswerBody>;
  /** Отправляемый ответ на виджет "Таблица (выбор одного)" */
  matrixAnswerBody?: Maybe<MatrixAnswerBody>;
  /** Отправляемый ответ на виджет "Таблица (множественный выбор)" */
  matrixDropdownAnswerBody?: Maybe<MatrixDropdownAnswerBody>;
  /** Отправляемый ответ на виджет "Множественный выбор текста" */
  multipleTextAnswerBody?: Maybe<MultipleTextAnswerBody>;
  /** Возврат ответа на scorm-задание */
  scormAnswerBody?: Maybe<ScormAnswerBody>;
  /** Возврат ответа на простой ответ */
  simpleAnswerBody?: Maybe<SimpleAnswerBody>;
  /** Возврат ответа сортировки */
  sortableAnswerBody?: Maybe<SortableAnswerBody>;
  /** Возврат ответа на тест */
  testAnswerBody?: Maybe<TestAnswerBody>;
};

export type WidgetAnswerInput = {
  /** Ответ на виджет */
  answer?: InputMaybe<Scalars['String']['input']>;
  /** Файлы, прикрепленные к ответу на виджет */
  files?: InputMaybe<Array<FileInput>>;
  /** Идентификатор виджета */
  widgetId: Scalars['UUID']['input'];
  /** Тип виджета */
  widgetType: ContentWidgetTypeEnum;
};

export type WidgetAudio = {
  __typename?: 'WidgetAudio';
  /** Название загруженного файла или ссылка */
  audioName: Scalars['String']['output'];
  /** Ссылка на аудио */
  audioUrl: Scalars['String']['output'];
  /** Обложка трека */
  cover?: Maybe<WidgetAudioCover>;
  /** Описание аудио */
  description: Scalars['String']['output'];
  /** порядок файла при проигрывании (на будущее) */
  order?: Maybe<Scalars['Int']['output']>;
  /** Заголовок аудио */
  title: Scalars['String']['output'];
  /** UUID файла */
  trackId?: Maybe<Scalars['ID']['output']>;
};

export type WidgetAudioCover = {
  __typename?: 'WidgetAudioCover';
  /** Ссылка на обложку */
  imgUrl: Scalars['String']['output'];
  /** Заголовок/краткое описание к обложке */
  title?: Maybe<Scalars['String']['output']>;
};

export type WidgetAudioCoverInput = {
  /** Ссылка на обложку */
  imgUrl: Scalars['String']['input'];
  /** Заголовок/краткое описание к обложке */
  title?: InputMaybe<Scalars['String']['input']>;
};

export type WidgetAudioInput = {
  /** Название загруженного файла или ссылка */
  audioName: Scalars['String']['input'];
  /** Ссылка на аудио */
  audioUrl: Scalars['String']['input'];
  /** Обложка для трека */
  cover?: InputMaybe<WidgetAudioCoverInput>;
  /** Описание аудио */
  description: Scalars['String']['input'];
  /** порядок файла при проигрывании (на будущее) */
  order?: InputMaybe<Scalars['Int']['input']>;
  /** Заголовок аудио */
  title: Scalars['String']['input'];
  /** UUID файла */
  trackId?: InputMaybe<Scalars['ID']['input']>;
};

export type WidgetAudioList = {
  __typename?: 'WidgetAudioList';
  /** Обложка плей-листа */
  cover?: Maybe<WidgetAudioCover>;
  /** Записи плейлиста */
  tracks: Array<WidgetAudio>;
};

export type WidgetAudioListInput = {
  /** Обложка плей-листа */
  cover?: InputMaybe<WidgetAudioCoverInput>;
  /** Записи плейлиста */
  tracks: Array<WidgetAudioInput>;
};

/** GraphQL не дает использовать union внутри input, поэтому делаем композицию всех типов тела виджетов */
export type WidgetBody = {
  __typename?: 'WidgetBody';
  /** Аудио */
  audio?: Maybe<WidgetAudio>;
  /** Плейлист */
  audioList?: Maybe<WidgetAudioList>;
  /** Фрагмент кода */
  code?: Maybe<WidgetCode>;
  /** Кастомный информационный виджет */
  custom?: Maybe<WidgetCustom>;
  /** Виджет документ */
  documentList?: Maybe<WidgetDocList>;
  /** Виджет внешнее задание */
  externalTaskLink?: Maybe<WidgetExternalTaskLink>;
  /** Заполнение пропусков */
  fillingGap?: Maybe<WidgetFillingGap>;
  /** Развернутый ответ */
  fullAnswer?: Maybe<WidgetFullAnswer>;
  /** Галерея изображения */
  gallery?: Maybe<WidgetGallery>;
  /** Html-документ для проигрывания внутри страницы */
  iframe?: Maybe<WidgetIframe>;
  /** Соединение линиями */
  lineConnector?: Maybe<WidgetLineConnector>;
  /** Фрагмент размеченного текста */
  markdown?: Maybe<WidgetMarkdown>;
  /** Таблица (выбор одного) */
  matrix?: Maybe<WidgetMatrix>;
  /** Таблица (множественный выбор) */
  matrixDropdown?: Maybe<WidgetMatrixDropdown>;
  /** Виджет мини-тест (мини-тест из мотоблока) */
  miniTest?: Maybe<WidgetMiniTest>;
  /** Множественный текст */
  multipleText?: Maybe<WidgetMultipleText>;
  /**
   * Sbercode
   * @deprecated Интеграция не используется, удалена на стороне sbercode
   */
  sbercodeLink?: Maybe<WidgetSbercodeLink>;
  /** Интерактивный виджет с заданием в SCORM-пакете */
  scorm?: Maybe<WidgetScorm>;
  /** Простой ответ */
  simpleAnswer?: Maybe<WidgetSimpleAnswer>;
  /** Сортировка */
  sortable?: Maybe<WidgetSortable>;
  /** Тест */
  test?: Maybe<WidgetTest>;
  /** Текст */
  text?: Maybe<WidgetText>;
  /** Видео */
  video?: Maybe<WidgetVideo>;
};

/** GraphQL не дает использовать union внутри input, поэтому делаем композицию всех типов тела виджетов */
export type WidgetBodyCompositionInput = {
  /** Аудио */
  audio?: InputMaybe<WidgetAudioInput>;
  /** Плейлист */
  audioList?: InputMaybe<WidgetAudioListInput>;
  /** Фрагмент кода */
  code?: InputMaybe<WidgetCodeInput>;
  /** Кастомный информационный виджет */
  custom?: InputMaybe<WidgetCustomInput>;
  /** Информационный виджет о загружаемых документах */
  documentList?: InputMaybe<WidgetDocListInput>;
  /** Виджет внешнее задание */
  externalTaskLink?: InputMaybe<WidgetExternalTaskLinkInput>;
  /** Заполнение пропусков */
  fillingGap?: InputMaybe<WidgetFillingGapInput>;
  /** Развернутый ответ */
  fullAnswer?: InputMaybe<WidgetFullAnswerInput>;
  /** Галерея изображения */
  gallery?: InputMaybe<WidgetGalleryInput>;
  /** Html-документ для проигрывания внутри страницы */
  iframe?: InputMaybe<WidgetIframeInput>;
  /** Соединение линиями */
  lineConnector?: InputMaybe<WidgetLineConnectorInput>;
  /** Фрагмент размеченного текста */
  markdown?: InputMaybe<WidgetMarkdownInput>;
  /** Таблица (выбор одного) */
  matrix?: InputMaybe<WidgetMatrixInput>;
  /** Таблица (множественный выбор) */
  matrixDropdown?: InputMaybe<WidgetMatrixDropdownInput>;
  /** Виджет мини-тест (мини-тест из мотоблока) */
  miniTest?: InputMaybe<WidgetMiniTestInput>;
  /** Множественный текст */
  multipleText?: InputMaybe<WidgetMultipleTextInput>;
  /** Sbercode */
  sbercodeInputModel?: InputMaybe<WidgetSbercodeInput>;
  /** Интерактивный виджет с заданием в SCORM-пакете */
  scorm?: InputMaybe<WidgetScormInput>;
  /** Простой ответ */
  simpleAnswer?: InputMaybe<WidgetSimpleAnswerInput>;
  /** Сортировка */
  sortable?: InputMaybe<WidgetSortableInput>;
  /** Тест */
  test?: InputMaybe<WidgetTestInput>;
  /** Текст */
  text?: InputMaybe<WidgetTextInput>;
  /** Видео */
  video?: InputMaybe<WidgetVideoInput>;
};

export type WidgetCode = {
  __typename?: 'WidgetCode';
  /** Содержимое блока "код" */
  code: Scalars['String']['output'];
  /** Описание */
  description: Scalars['String']['output'];
  /** url картинка */
  imgUrl?: Maybe<Scalars['String']['output']>;
  /** Язык программирования */
  language: CodeWidgetLanguageEnum;
  /** Цветовая тема редактора */
  theme?: Maybe<Scalars['String']['output']>;
  /** Заголовок */
  title: Scalars['String']['output'];
};

export type WidgetCodeInput = {
  /** Содержимое блока "код" */
  code: Scalars['String']['input'];
  /** Описание */
  description: Scalars['String']['input'];
  /** url картинки */
  imgUrl?: InputMaybe<Scalars['String']['input']>;
  /** Язык программирования */
  language: CodeWidgetLanguageEnum;
  /** Цветовая тема редактора */
  theme?: InputMaybe<Scalars['String']['input']>;
  /** Заголовок */
  title: Scalars['String']['input'];
};

export type WidgetCustom = {
  __typename?: 'WidgetCustom';
  /** Строка с json-структурой, внутри которой хранится информация о виджете */
  json?: Maybe<Scalars['String']['output']>;
};

export type WidgetCustomInput = {
  /** Строка с json-структурой, внутри которой хранится информация о виджете */
  json?: InputMaybe<Scalars['String']['input']>;
};

export type WidgetDoc = {
  __typename?: 'WidgetDoc';
  /** Описание документа */
  description?: Maybe<Scalars['String']['output']>;
  /** Ссылка на документ */
  docLink?: Maybe<Scalars['String']['output']>;
  /** Заголовок документа */
  title?: Maybe<Scalars['String']['output']>;
  /** Признак того, что видео загружен с локального диска */
  uploadedFromLocalDevice?: Maybe<Scalars['Boolean']['output']>;
};

export type WidgetDocInput = {
  /** Описание документа */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Ссылка на документ */
  docLink?: InputMaybe<Scalars['String']['input']>;
  /** Заголовок документа */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Признак того, что документ загружен с локального диска */
  uploadedFromLocalDevice?: InputMaybe<Scalars['Boolean']['input']>;
};

export type WidgetDocList = {
  __typename?: 'WidgetDocList';
  /** Описание загруженных документов */
  description?: Maybe<Scalars['String']['output']>;
  /** Массив документов, загруженных в задание */
  uploadedDocuments?: Maybe<Array<WidgetDoc>>;
};

export type WidgetDocListInput = {
  /** Описание загруженных документов */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Массив документов, загруженных в задание */
  uploadedDocuments?: InputMaybe<Array<WidgetDocInput>>;
};

export type WidgetExternalTaskLink = {
  __typename?: 'WidgetExternalTaskLink';
  /** код внешней системы, предоставляющей задание (например, sbercode) */
  externalSystemCode: Scalars['String']['output'];
  /** uri задачи на внешнем ресурсе (без домена) */
  taskUri: Scalars['String']['output'];
};

export type WidgetExternalTaskLinkInput = {
  /** код внешней системы, предоставляющей задание (например, sbercode) */
  externalSystemCode: Scalars['String']['input'];
  /** uri задачи на внешнем ресурсе (без домена) */
  taskUri: Scalars['String']['input'];
};

export type WidgetFillingGap = {
  __typename?: 'WidgetFillingGap';
  /** Карточки для раскладывания в пропуски */
  cards?: Maybe<Array<WidgetFillingGapCard>>;
  /** Настройка учета регистра букв */
  caseSensitive: Scalars['Boolean']['output'];
  /** контент */
  content: Scalars['String']['output'];
  /** правильные ответы */
  correctAnswers: Array<WidgetFillingGapAnswerPair>;
  /** Пояснение к вопросу */
  description: Scalars['String']['output'];
  /** Картинка к пояснению */
  imgUrl: Scalars['String']['output'];
  /** Вопрос */
  title: Scalars['String']['output'];
};

export type WidgetFillingGapAnswerPair = {
  __typename?: 'WidgetFillingGapAnswerPair';
  /** Массив вариантов выбора заполнения для режимов DropDown, Drag-and-Drop */
  dropDownChoices?: Maybe<Array<WidgetFillingGapAnswerPairChoice>>;
  /** Уникальный идентификатор пропуска */
  gapId: Scalars['ID']['output'];
  /** Массив вариантов выбора заполнения для режима Input */
  inputChoices?: Maybe<Array<Scalars['String']['output']>>;
  /** Режим заполнения пропуска */
  mode?: Maybe<GapMode>;
  /** Значение для пропуска */
  value: Scalars['String']['output'];
};

export type WidgetFillingGapAnswerPairChoice = {
  __typename?: 'WidgetFillingGapAnswerPairChoice';
  /** Правильно/неправильно */
  correct: Scalars['Boolean']['output'];
  /** Идентификатор варианта выбора заполнения пропуска */
  gapChoiceId: Scalars['ID']['output'];
  /** Значение варианта */
  text?: Maybe<Scalars['String']['output']>;
};

export type WidgetFillingGapAnswerPairChoiceInput = {
  /** Правильно/неправильно */
  correct: Scalars['Boolean']['input'];
  /** Идентификатор варианта выбора заполнения пропуска */
  gapChoiceId: Scalars['ID']['input'];
  /** Значение варианта */
  text?: InputMaybe<Scalars['String']['input']>;
};

export type WidgetFillingGapAnswerPairInput = {
  /** Массив вариантов выбора заполнения для режимов DropDown, Drag-and-Drop */
  dropDownChoices?: InputMaybe<Array<WidgetFillingGapAnswerPairChoiceInput>>;
  /** Уникальный идентификатор пропуска */
  gapId: Scalars['ID']['input'];
  /** Массив вариантов выбора заполнения для режима Input */
  inputChoices?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Режим заполнения пропуска */
  mode?: InputMaybe<GapMode>;
  /** Значение для пропуска */
  value: Scalars['String']['input'];
};

export type WidgetFillingGapCard = {
  __typename?: 'WidgetFillingGapCard';
  /** UUID карточки */
  cardId?: Maybe<Scalars['ID']['output']>;
  /** Содержимое карточки */
  content?: Maybe<Scalars['String']['output']>;
  /** ID пропуска, в котором находится карточка */
  gapId?: Maybe<Scalars['ID']['output']>;
  /** UUID карточек с идентичным контентом в других пропусках */
  siblingCardIds?: Maybe<Array<Scalars['ID']['output']>>;
};

export type WidgetFillingGapCardInput = {
  /** UUID карточки */
  cardId?: InputMaybe<Scalars['ID']['input']>;
  /** Содержимое карточки */
  content?: InputMaybe<Scalars['String']['input']>;
  /** ID пропуска, в котором находится карточка */
  gapId?: InputMaybe<Scalars['ID']['input']>;
  /** UUID карточек с идентичным контентом в других пропусках */
  siblingCardIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type WidgetFillingGapInput = {
  /** Карточки для раскладывания в пропуски */
  cards?: InputMaybe<Array<WidgetFillingGapCardInput>>;
  /** Настройка учета регистра букв */
  caseSensitive: Scalars['Boolean']['input'];
  /** контент */
  content: Scalars['String']['input'];
  /** пропуски */
  correctAnswers: Array<WidgetFillingGapAnswerPairInput>;
  /** Пояснение к вопросу */
  description: Scalars['String']['input'];
  /** Картинка к пояснению */
  imgUrl: Scalars['String']['input'];
  /** Вопрос */
  title: Scalars['String']['input'];
};

export type WidgetFullAnswer = {
  __typename?: 'WidgetFullAnswer';
  /** Пояснение к вопросу */
  description: Scalars['String']['output'];
  /** Ссылка на изображение к пояснению */
  imgUrl: Scalars['String']['output'];
  /** Вопрос */
  title: Scalars['String']['output'];
};

export type WidgetFullAnswerInput = {
  /** Пояснение к вопросу */
  description: Scalars['String']['input'];
  /** Ссылка на изображение к пояснению */
  imgUrl: Scalars['String']['input'];
  /** Вопрос */
  title: Scalars['String']['input'];
};

export type WidgetGallery = {
  __typename?: 'WidgetGallery';
  /** Изображения галереи */
  images: Array<WidgetGalleryImage>;
  /** Режим отображения галереи (для поддержки  режимов мотоблока) */
  mode?: Maybe<Scalars['String']['output']>;
};

export type WidgetGalleryImage = {
  __typename?: 'WidgetGalleryImage';
  /** Описание изображения */
  description: Scalars['String']['output'];
  /** UUID изображения */
  imageId: Scalars['ID']['output'];
  /** Параметр, задающий режим отображение изображения в режиме превью */
  imgScale?: Maybe<Scalars['String']['output']>;
  /** Ссылка на файл картинки */
  imgUrl: Scalars['String']['output'];
  /** Источник изображения */
  linkSrc?: Maybe<Scalars['String']['output']>;
  /** Порядок изображения в галерее */
  order: Scalars['Int']['output'];
  /** Заголовок изображения */
  title: Scalars['String']['output'];
};

export type WidgetGalleryImageInput = {
  /** Описание изображения */
  description: Scalars['String']['input'];
  /** UUID изображения */
  imageId: Scalars['ID']['input'];
  /** Параметр, задающий режим отображение изображения в режиме превью */
  imgScale?: InputMaybe<Scalars['String']['input']>;
  /** Ссылка на файл картинки */
  imgUrl: Scalars['String']['input'];
  /** Источник изображения */
  linkSrc?: InputMaybe<Scalars['String']['input']>;
  /** Порядок изображения в галерее */
  order: Scalars['Int']['input'];
  /** Заголовок изображения */
  title: Scalars['String']['input'];
};

export type WidgetGalleryInput = {
  /** Изображения галереи */
  images: Array<WidgetGalleryImageInput>;
  /** Режим отображения галереи (для поддержки  режимов мотоблока) */
  mode?: InputMaybe<Scalars['String']['input']>;
};

/** Тип группы виджетов виджета */
export enum WidgetGroupTypeEnum {
  /** Бизнесс-тип с предобработкой на backend */
  Business = 'BUSINESS',
  /** Информационный(для информации, без ответа) */
  Info = 'INFO',
  /** Интерактивный(есть возможность ввести ответ и может быть предусмотрен правильный ответ) */
  Interactive = 'INTERACTIVE',
  /** Ссылочный тип */
  Link = 'LINK',
  /** Смешанный(есть возможность ввести ответ, но правильного ответа не предусмотрено) */
  Mixed = 'MIXED'
}

export type WidgetIframe = {
  __typename?: 'WidgetIframe';
  /** Ссылка на сайт или код <iframe/> */
  content: Scalars['String']['output'];
  /** Описание */
  description: Scalars['String']['output'];
  /** Высота */
  height: Scalars['String']['output'];
  /** Ссылка на ресурс iframe */
  src: Scalars['String']['output'];
  /** Заголовок */
  title: Scalars['String']['output'];
  /** Ширина */
  width: Scalars['String']['output'];
};

export type WidgetIframeInput = {
  /** Ссылка на сайт или код <iframe/> */
  content: Scalars['String']['input'];
  /** Описание */
  description: Scalars['String']['input'];
  /** Высота */
  height: Scalars['String']['input'];
  /** Ссылка на ресурс iframe */
  src: Scalars['String']['input'];
  /** Заголовок */
  title: Scalars['String']['input'];
  /** Ширина */
  width: Scalars['String']['input'];
};

export type WidgetInput = {
  /** тело виджета */
  body?: InputMaybe<WidgetBodyCompositionInput>;
  /** Бизнесс тип (используется только если WidgetGroupTypeEnum=Business) */
  businessType?: InputMaybe<BusinessTypeEnum>;
  /** Мета-информация о вариативности виджета */
  variationMeta?: InputMaybe<WidgetVariationMetaInput>;
  /** Тип группы виджетов */
  widgetGroupType: WidgetGroupTypeEnum;
  /** Идентификатор виджета */
  widgetId: Scalars['ID']['input'];
  /** Порядковый номер виджета на странице */
  widgetNumber: Scalars['Int']['input'];
  /** Css-стили виджета */
  widgetStyle?: InputMaybe<Scalars['String']['input']>;
  /** Тип виджета */
  widgetType: WidgetTypeEnum;
};

export type WidgetLineConnector = {
  __typename?: 'WidgetLineConnector';
  /** Пояснение к вопросу */
  description: Scalars['String']['output'];
  /** Картинка к пояснению */
  imgUrl: Scalars['String']['output'];
  /** левые карты */
  leftCards: Array<WidgetLineConnectorCard>;
  /** правые карты */
  rightCards: Array<WidgetLineConnectorCard>;
  /** Вопрос */
  title: Scalars['String']['output'];
};

export type WidgetLineConnectorCard = {
  __typename?: 'WidgetLineConnectorCard';
  /** Идентификатор карточки */
  cardId: Scalars['ID']['output'];
  /** Содержимое карточки */
  content: Scalars['String']['output'];
  /** Ссылка на картинку */
  imgUrl: Scalars['String']['output'];
  /** Идентификатор пары */
  pairId: Scalars['ID']['output'];
};

export type WidgetLineConnectorCardInput = {
  /** Идентификатор карточки */
  cardId: Scalars['ID']['input'];
  /** Содержимое карточки */
  content: Scalars['String']['input'];
  /** Ссылка на картинку */
  imgUrl: Scalars['String']['input'];
  /** Идентификатор пары */
  pairId: Scalars['ID']['input'];
};

export type WidgetLineConnectorInput = {
  /** Пояснение к вопросу */
  description: Scalars['String']['input'];
  /** Картинка к пояснению */
  imgUrl: Scalars['String']['input'];
  /** левые карты */
  leftCards: Array<WidgetLineConnectorCardInput>;
  /** правые карты */
  rightCards: Array<WidgetLineConnectorCardInput>;
  /** Вопрос */
  title: Scalars['String']['input'];
};

export type WidgetMarkdown = {
  __typename?: 'WidgetMarkdown';
  /** Содержимое в разметке html */
  content: Scalars['String']['output'];
};

export type WidgetMarkdownInput = {
  /** Содержимое в разметке html */
  content: Scalars['String']['input'];
};

export type WidgetMatrix = {
  __typename?: 'WidgetMatrix';
  content: Scalars['String']['output'];
};

export type WidgetMatrixDropdown = {
  __typename?: 'WidgetMatrixDropdown';
  content: Scalars['String']['output'];
};

export type WidgetMatrixDropdownInput = {
  /** Контент таблицы с множественным выбором */
  content: Scalars['String']['input'];
};

export type WidgetMatrixInput = {
  /** Контент таблицы с одним выбором */
  content: Scalars['String']['input'];
};

export type WidgetMiniTest = {
  __typename?: 'WidgetMiniTest';
  /** Варианты ответов */
  choices?: Maybe<Array<WidgetMiniTestChoice>>;
  /** Вопрос */
  description?: Maybe<Scalars['String']['output']>;
  /** Ссылка на изображение к пояснению */
  imgUrl?: Maybe<Scalars['String']['output']>;
  /** Описание правильного ответа */
  rightAnswerDescription?: Maybe<Scalars['String']['output']>;
};

export type WidgetMiniTestChoice = {
  __typename?: 'WidgetMiniTestChoice';
  /** Идентификатор варианта ответа */
  choiceId?: Maybe<Scalars['ID']['output']>;
  /** правильный/неправильный */
  correct?: Maybe<Scalars['Boolean']['output']>;
  /** Подпись к картинке */
  text?: Maybe<Scalars['String']['output']>;
};

export type WidgetMiniTestChoiceInput = {
  /** Идентификатор варианта ответа */
  choiceId?: InputMaybe<Scalars['ID']['input']>;
  /** правильный/неправильный */
  correct?: InputMaybe<Scalars['Boolean']['input']>;
  /** Подпись к картинке */
  text?: InputMaybe<Scalars['String']['input']>;
};

export type WidgetMiniTestInput = {
  /** Варианты ответов */
  choices?: InputMaybe<Array<WidgetMiniTestChoiceInput>>;
  /** Вопрос */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Ссылка на изображение к пояснению */
  imgUrl?: InputMaybe<Scalars['String']['input']>;
  /** Описание правильного ответа */
  rightAnswerDescription?: InputMaybe<Scalars['String']['input']>;
};

export type WidgetMultipleText = {
  __typename?: 'WidgetMultipleText';
  content: Scalars['String']['output'];
};

export type WidgetMultipleTextInput = {
  /** Контент для множественного текста */
  content: Scalars['String']['input'];
};

/** @deprecated(reason: "Интеграция не используется, удалена на стороне sbercode") */
export type WidgetSbercodeInput = {
  /** url отдельной задачи в Sbercode */
  sbercodeTaskUrl: Scalars['String']['input'];
};

/** @deprecated(reason: "Интеграция не используется, удалена на стороне sbercode") */
export type WidgetSbercodeLink = {
  __typename?: 'WidgetSbercodeLink';
  /** url отдельной задачи в Sbercode */
  sbercodeTaskUrl: Scalars['String']['output'];
};

export type WidgetScorm = {
  __typename?: 'WidgetScorm';
  /** ID внешнего задания в postgres */
  externalTaskId?: Maybe<Scalars['Int']['output']>;
  /** Путь к загруженному в виджет zip-файлу */
  filePath?: Maybe<Scalars['String']['output']>;
  /** URL SCORM-контента */
  scormUrl?: Maybe<Scalars['String']['output']>;
};

export type WidgetScormInput = {
  /** ID внешнего задания в postgres */
  externalTaskId?: InputMaybe<Scalars['Int']['input']>;
  /** Путь к загруженному в виджет zip-файлу */
  filePath?: InputMaybe<Scalars['String']['input']>;
  /** URL SCORM-контента */
  scormUrl?: InputMaybe<Scalars['String']['input']>;
};

export type WidgetSimpleAnswer = {
  __typename?: 'WidgetSimpleAnswer';
  /** Настройка учета регистра букв в ответе */
  caseSensitive: Scalars['Boolean']['output'];
  /** Правильные ответы */
  correctAnswers: Array<Scalars['String']['output']>;
  /** Значение поля по умолчанию */
  defaultValue?: Maybe<Scalars['String']['output']>;
  /** Пояснение к вопросу */
  description: Scalars['String']['output'];
  /** Ссылка на изображение к пояснению */
  imgUrl: Scalars['String']['output'];
  /** Текст в поле */
  placeholder?: Maybe<Scalars['String']['output']>;
  /** Вопрос */
  title: Scalars['String']['output'];
};

export type WidgetSimpleAnswerInput = {
  /** Настройка учета регистра букв в ответе */
  caseSensitive: Scalars['Boolean']['input'];
  /** Правильные ответы */
  correctAnswers: Array<Scalars['String']['input']>;
  /** Значение поля по умолчанию */
  defaultValue?: InputMaybe<Scalars['String']['input']>;
  /** Пояснение к вопросу */
  description: Scalars['String']['input'];
  /** Ссылка на изображение к пояснению */
  imgUrl: Scalars['String']['input'];
  /** Текст в поле */
  placeholder?: InputMaybe<Scalars['String']['input']>;
  /** Вопрос */
  title: Scalars['String']['input'];
};

export type WidgetSortable = {
  __typename?: 'WidgetSortable';
  /** Карточки для раскладывания в группы */
  cards: Array<WidgetSortableCard>;
  /** Пояснение к вопросу */
  description: Scalars['String']['output'];
  /** Набор групп карточек */
  groups: Array<WidgetSortableCardGroup>;
  /** Картинка к пояснению */
  imgUrl: Scalars['String']['output'];
  /** Учитывать ли порядок карточек в группах */
  orderSensitive: Scalars['Boolean']['output'];
  /** Вопрос */
  title: Scalars['String']['output'];
};

export type WidgetSortableCard = {
  __typename?: 'WidgetSortableCard';
  /** UUID карточки */
  cardId: Scalars['ID']['output'];
  /** Содержимое карточки */
  content: Scalars['String']['output'];
  /** UUID группы, в случае если null значит, что карточка без группы */
  groupId?: Maybe<Scalars['ID']['output']>;
  /** Порядок внутри группы, в случае если null значит, что карточка без группы */
  groupOrder?: Maybe<Scalars['Int']['output']>;
  /** Ссылка на картинку карточки */
  imgUrl: Scalars['String']['output'];
  /** UUID карточек с идентичным контентом в других группах */
  siblingCardIds: Array<Scalars['ID']['output']>;
};

export type WidgetSortableCardGroup = {
  __typename?: 'WidgetSortableCardGroup';
  /** UUID группы */
  groupId: Scalars['ID']['output'];
  /** Название группы */
  title: Scalars['String']['output'];
};

export type WidgetSortableCardGroupInput = {
  /** UUID группы */
  groupId: Scalars['ID']['input'];
  /** Название группы */
  title: Scalars['String']['input'];
};

export type WidgetSortableCardInput = {
  /** UUID карточки */
  cardId: Scalars['ID']['input'];
  /** Содержимое карточки */
  content: Scalars['String']['input'];
  /** UUID группы, в случае если null значит, что карточка без группы */
  groupId?: InputMaybe<Scalars['ID']['input']>;
  /** Порядок внутри группы, в случае если null значит, что карточка без группы */
  groupOrder?: InputMaybe<Scalars['Int']['input']>;
  /** Ссылка на картинку карточки */
  imgUrl: Scalars['String']['input'];
  /** UUID карточек с идентичным контентом в других группах */
  siblingCardIds: Array<Scalars['ID']['input']>;
};

export type WidgetSortableInput = {
  /** Карточки для раскладывания в группы */
  cards: Array<WidgetSortableCardInput>;
  /** Пояснение к вопросу */
  description: Scalars['String']['input'];
  /** Набор групп карточек */
  groups: Array<WidgetSortableCardGroupInput>;
  /** Картинка к пояснению */
  imgUrl: Scalars['String']['input'];
  /** Учитывать ли порядок карточек в группах */
  orderSensitive: Scalars['Boolean']['input'];
  /** Вопрос */
  title: Scalars['String']['input'];
};

export type WidgetTest = {
  __typename?: 'WidgetTest';
  /** Варианты ответов */
  choices: Array<WidgetTestChoice>;
  /** Значение по умолчанию */
  defaultValue?: Maybe<Scalars['String']['output']>;
  /** Пояснение к вопросу */
  description: Scalars['String']['output'];
  /** Ссылка на изображение к пояснению */
  imgUrl: Scalars['String']['output'];
  /** Настройка режима мультивыбора */
  manyChoices: Scalars['Boolean']['output'];
  /** Режим отображение виджета (для поддержки мини-теста мотоблока) */
  mode?: Maybe<Scalars['String']['output']>;
  /** Описание правильного ответа */
  rightAnswerDescription?: Maybe<Scalars['String']['output']>;
  /** Вопрос */
  title: Scalars['String']['output'];
};

export type WidgetTestChoice = {
  __typename?: 'WidgetTestChoice';
  /** Идентификатор варианта ответа */
  choiceId?: Maybe<Scalars['ID']['output']>;
  /** правильный/неправильный */
  correct: Scalars['Boolean']['output'];
  /** Ссылка на картинку */
  imgUrl: Scalars['String']['output'];
  /** Оригинальный индекс для локаторов e2e (ответы могут перемешиваться) */
  originalIndex: Scalars['Int']['output'];
  /** Подпись к картинке */
  text: Scalars['String']['output'];
  /** Значение варианта ответа */
  value: Scalars['String']['output'];
};

export type WidgetTestChoiceInput = {
  /** Идентификатор варианта ответа */
  choiceId?: InputMaybe<Scalars['ID']['input']>;
  /** правильный/неправильный */
  correct: Scalars['Boolean']['input'];
  /** Ссылка на картинку */
  imgUrl: Scalars['String']['input'];
  /** Оригинальный индекс для локаторов e2e (ответы могут перемешиваться) */
  originalIndex: Scalars['Int']['input'];
  /** Подпись к картинке */
  text: Scalars['String']['input'];
  /** Значение варианта ответа */
  value: Scalars['String']['input'];
};

export type WidgetTestInput = {
  /** Варианты ответов */
  choices: Array<WidgetTestChoiceInput>;
  /** Значение по умолчанию */
  defaultValue?: InputMaybe<Scalars['String']['input']>;
  /** Пояснение к вопросу */
  description: Scalars['String']['input'];
  /** Ссылка на изображение к пояснению */
  imgUrl: Scalars['String']['input'];
  /** Настройка режима мультивыбора */
  manyChoices: Scalars['Boolean']['input'];
  /** Режим отображение виджета (для поддержки мини-теста мотоблока) */
  mode?: InputMaybe<Scalars['String']['input']>;
  /** Описание правильного ответа */
  rightAnswerDescription?: InputMaybe<Scalars['String']['input']>;
  /** Вопрос */
  title: Scalars['String']['input'];
};

export type WidgetText = {
  __typename?: 'WidgetText';
  /** Учебный текст с поддержкой разметки в html */
  content: Scalars['String']['output'];
};

export type WidgetTextInput = {
  /** Учебный текст с поддержкой разметки в html */
  content: Scalars['String']['input'];
};

/** Тип тела виджета */
export enum WidgetTypeEnum {
  /** Аудио */
  Audio = 'AUDIO',
  /** Плейлист аудиоплеера */
  Audiolist = 'AUDIOLIST',
  /** Фрагмент кода */
  Code = 'CODE',
  /** Кастомный информационный виджет */
  Custom = 'CUSTOM',
  /** Информационный виджет о загружаемых документах */
  DocumentList = 'DOCUMENT_LIST',
  /** Виджет ссылка на внешнее задание */
  ExternalTaskLink = 'EXTERNAL_TASK_LINK',
  /** Заполнение пропусков */
  FillingGap = 'FILLING_GAP',
  /** Развернутый ответ */
  FullAnswer = 'FULL_ANSWER',
  /** Галлерея изображения */
  Gallery = 'GALLERY',
  /** html-документ для проигрывания внутри страницы */
  Iframe = 'IFRAME',
  /** Соединение линиями */
  LineConnector = 'LINE_CONNECTOR',
  /** Фрагмент размеченного текста */
  Markdown = 'MARKDOWN',
  /** Виджет-матрица */
  Matrix = 'MATRIX',
  /** Виджет дропдауна для матрицы */
  MatrixDropdown = 'MATRIX_DROPDOWN',
  /** Виджет мини-тест (мини-тест из мотоблока) */
  MiniTest = 'MINI_TEST',
  /** Множественный текст */
  MultipleText = 'MULTIPLE_TEXT',
  /** Sbercode */
  SbercodeWidgetLink = 'SBERCODE_WIDGET_LINK',
  /** SCORM */
  Scorm = 'SCORM',
  /** Простой ответ */
  SimpleAnswer = 'SIMPLE_ANSWER',
  /** Сортировка */
  Sortable = 'SORTABLE',
  /** Тест */
  Test = 'TEST',
  /** Текст */
  Text = 'TEXT',
  /** Видео */
  Video = 'VIDEO'
}

export type WidgetVariant = {
  __typename?: 'WidgetVariant';
  /** Тело варианта. Актуально только в случае, если variationMode = BY_WIDGET_BODY */
  body?: Maybe<WidgetBody>;
  /** Кастомный код варианта для отображения на UI */
  code?: Maybe<Scalars['String']['output']>;
  /** Уникальный идентификатор варианта. ГЕНЕРИТСЯ НА ФРОНТЕ */
  variantId: Scalars['ID']['output'];
  /** Идентификатор виджета */
  widgetId: Scalars['ID']['output'];
};

export type WidgetVariantInput = {
  /** Тело варианта. Актуально только в случае, если variationMode = BY_WIDGET_BODY */
  body?: InputMaybe<WidgetBodyCompositionInput>;
  /** Кастомный код варианта для отображения на UI */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Уникальный идентификатор варианта. ГЕНЕРИТСЯ НА ФРОНТЕ */
  variantId: Scalars['ID']['input'];
  /** Идентификатор виджета */
  widgetId: Scalars['ID']['input'];
};

export type WidgetVariationMeta = {
  __typename?: 'WidgetVariationMeta';
  /** Критерий успешного прохождения тренажеров */
  numberOfSuccessfulPasses?: Maybe<Scalars['Int']['output']>;
  /** Количество неудаленных вариантов */
  variantCount?: Maybe<Scalars['Int']['output']>;
  /** Массив вариантов */
  variants: Array<WidgetVariant>;
  /** S3 путь файлика с вариантами виджета. Используется/актуален только в случае если variationMode = BY_WIDGET_BODY */
  variationFilePath?: Maybe<Scalars['String']['output']>;
  /** Режим вариативности */
  variationMode: WidgetVariationModeEnum;
};

export type WidgetVariationMetaInput = {
  /** Критерий успешного прохождения тренажеров */
  numberOfSuccessfulPasses?: InputMaybe<Scalars['Int']['input']>;
  /** Массив вариантов */
  variants: Array<WidgetVariantInput>;
  /** S3 путь файлика с вариантами виджета. Используется/актуален только в случае если variationMode = BY_WIDGET_BODY */
  variationFilePath?: InputMaybe<Scalars['String']['input']>;
  /** Режим вариативности */
  variationMode: WidgetVariationModeEnum;
};

export enum WidgetVariationModeEnum {
  /** Вариативность на уровне тела */
  ByWidgetBody = 'BY_WIDGET_BODY'
}

export type WidgetVideo = {
  __typename?: 'WidgetVideo';
  /** Ссылка на обложку к видео */
  coverLink: Scalars['String']['output'];
  /** Описание видео */
  description: Scalars['String']['output'];
  /** Ссылка на фон к видео в раскрытом состоянии */
  expandedCoverLink: Scalars['String']['output'];
  /** Ссылка на оригинальную обложку, может быть использовано вместо coverLink */
  originalCoverLink: Scalars['String']['output'];
  /** Ссылка на субтитры */
  subtitleLink?: Maybe<Scalars['String']['output']>;
  /** Ссылка на файл субтитров для определенного языка */
  subtitleLinks?: Maybe<Array<SubtitleLinkForLanguage>>;
  /** Заголовок видео */
  title: Scalars['String']['output'];
  /** Признак того что видео загружено с локального диска */
  uploadedFromLocalDevice: Scalars['Boolean']['output'];
  /** ID файла/записи */
  videoId?: Maybe<Scalars['ID']['output']>;
  /** Ссылка на видео */
  videoLink: Scalars['String']['output'];
  /** ссылка/указание на видеосервис */
  videoService?: Maybe<Scalars['String']['output']>;
};

export type WidgetVideoInput = {
  /** Ссылка на обложку к видео */
  coverLink: Scalars['String']['input'];
  /** Описание видео */
  description: Scalars['String']['input'];
  /** Ссылка на фон к видео в раскрытом состоянии */
  expandedCoverLink: Scalars['String']['input'];
  /** Ссылка на оригинальную обложку, может быть использовано вместо coverLink */
  originalCoverLink: Scalars['String']['input'];
  /** Ссылка на субтитры */
  subtitleLink?: InputMaybe<Scalars['String']['input']>;
  /** Ссылка на файл субтитров для определенного языка */
  subtitleLinks?: InputMaybe<Array<SubtitleLinkForLanguageInput>>;
  /** Заголовок видео */
  title: Scalars['String']['input'];
  /** Признак того что видео загружено с локального диска */
  uploadedFromLocalDevice: Scalars['Boolean']['input'];
  /** ID файла/записи */
  videoId?: InputMaybe<Scalars['ID']['input']>;
  /** Ссылка на видео */
  videoLink: Scalars['String']['input'];
  /** ссылка/указание на видеосервис */
  videoService?: InputMaybe<Scalars['String']['input']>;
};

export type WorkWithTasks = {
  __typename?: 'WorkWithTasks';
  answers: Scalars['Int']['output'];
  comments: Scalars['Int']['output'];
  simpleTeachers: Array<WorkWithTasksSimpleTeacher>;
  teachers: Array<WorkWithTasksTeacher>;
  totalTeachers: Scalars['Int']['output'];
};

export type WorkWithTasksSimpleTeacher = {
  __typename?: 'WorkWithTasksSimpleTeacher';
  avatarUrl?: Maybe<Scalars['String']['output']>;
  fullName?: Maybe<Scalars['String']['output']>;
  teacherId: Scalars['UUID']['output'];
};

export type WorkWithTasksSubject = {
  __typename?: 'WorkWithTasksSubject';
  subjectId: Scalars['Int']['output'];
  subjectTitle: Scalars['String']['output'];
};

export type WorkWithTasksTeacher = {
  __typename?: 'WorkWithTasksTeacher';
  answers: Scalars['Int']['output'];
  avatarUrl?: Maybe<Scalars['String']['output']>;
  comments: Scalars['Int']['output'];
  fullName?: Maybe<Scalars['String']['output']>;
  stageGroups: Scalars['Int']['output'];
  students: Scalars['Int']['output'];
  subjects: Array<WorkWithTasksSubject>;
  teacherId: Scalars['UUID']['output'];
};

export type Workload = {
  __typename?: 'Workload';
  answersCount: Scalars['Int']['output'];
  studentsWithAnswersCount: Scalars['Int']['output'];
  tasksCount: Scalars['Int']['output'];
};

export type WorkshopMutations = {
  __typename?: 'WorkshopMutations';
  /** сделать копию задания с кодом taskId (возвращает код нового задания) */
  copyTaskFrom: Task;
  /** сделать копию задания с кодом taskId (возвращает код нового задания) */
  copyTaskFromV2: Task;
  /** универсальная мутация для конструктора заданий экзаменационного теста */
  saveExamTestTask: Task;
  /** универсальная мутация для конструктора заданий */
  saveTask: Task;
  saveTaskV2: Task;
  /** Тэгирует сущность сервиса Контент в сервисе Контент по идентифкатору сущности и по ее типу */
  setContentTags: Array<ContentTag>;
};


export type WorkshopMutationsCopyTaskFromArgs = {
  frontDateTime?: InputMaybe<Scalars['DateTime']['input']>;
  order?: InputMaybe<Scalars['ID']['input']>;
  slotId?: InputMaybe<Scalars['ID']['input']>;
  taskId: Scalars['ID']['input'];
  taskSetType?: InputMaybe<PlaylistType>;
};


export type WorkshopMutationsCopyTaskFromV2Args = {
  frontDateTime?: InputMaybe<Scalars['DateTime']['input']>;
  order?: InputMaybe<Scalars['ID']['input']>;
  slotId?: InputMaybe<Scalars['ID']['input']>;
  taskId: Scalars['ID']['input'];
  taskSetType?: InputMaybe<PlaylistType>;
};


export type WorkshopMutationsSaveExamTestTaskArgs = {
  content?: InputMaybe<ContentInput>;
  isSchool21?: InputMaybe<Scalars['Boolean']['input']>;
  linkModuleAndLevel?: InputMaybe<LinkModuleAndLevelInput>;
  linkSlot?: InputMaybe<LinkSlotInput>;
  taskId?: InputMaybe<Scalars['ID']['input']>;
  taskMeta?: InputMaybe<TaskMetaInput>;
};


export type WorkshopMutationsSaveTaskArgs = {
  content?: InputMaybe<ContentInput>;
  isSchool21?: InputMaybe<Scalars['Boolean']['input']>;
  linkModuleAndLevel?: InputMaybe<LinkModuleAndLevelInput>;
  linkSlot?: InputMaybe<LinkSlotInput>;
  taskId?: InputMaybe<Scalars['ID']['input']>;
  taskMeta?: InputMaybe<TaskMetaInput>;
};


export type WorkshopMutationsSaveTaskV2Args = {
  content?: InputMaybe<ContentInput>;
  isSchool21?: InputMaybe<Scalars['Boolean']['input']>;
  linkModuleAndLevel?: InputMaybe<LinkModuleAndLevelInput>;
  linkSlot?: InputMaybe<LinkSlotInput>;
  taskId?: InputMaybe<Scalars['ID']['input']>;
  taskMeta?: InputMaybe<TaskMetaInput>;
};


export type WorkshopMutationsSetContentTagsArgs = {
  contentTags: Array<ContentTagInput>;
  entityId: Scalars['ID']['input'];
  taggedEntityType: TaggedEntityTypeEnum;
};

/** Рабочая станция студента в кластере S21 */
export type WorkstationModel = {
  __typename?: 'WorkstationModel';
  /** Класс (кабинет, кластер) */
  classroom: ClassRoom;
  /**
   * Идентификатор класса (кластера)
   * @deprecated do not use. Will be deleted in 31.0
   */
  classroomId: Scalars['ID']['output'];
  /** Хостнейм рабочей станции <кластер>-<ряд><место> */
  hostName?: Maybe<Scalars['String']['output']>;
  /** Идентификатор рабочей станции */
  id: Scalars['ID']['output'];
  /**
   * Место
   * @deprecated do not use. Will be deleted in 29.0
   */
  number?: Maybe<Scalars['Int']['output']>;
  /**
   * Ряд
   * @deprecated do not use. Will be deleted in 29.0
   */
  row?: Maybe<Scalars['String']['output']>;
  /**
   * Идентификатор рабочей станции
   * @deprecated do not use. Will be deleted in 29.0
   */
  workstationId: Scalars['Int']['output'];
  /** Место */
  workstationNumber: Scalars['Int']['output'];
  /** Ряд */
  workstationRow: Scalars['String']['output'];
  /** URL рабочей станции <campusId>:<hostName> */
  workstationUrl: Scalars['String']['output'];
};

export type YearFinalMark = {
  __typename?: 'YearFinalMark';
  /** Значение оценки */
  mark: Scalars['String']['output'];
  /** Идентификатор типа итоговой оценки */
  markTypeId: Scalars['ID']['output'];
};

export type YearStatisticsMark = {
  __typename?: 'YearStatisticsMark';
  /** Значение оценки */
  mark: Scalars['String']['output'];
  /** Идентификатор типа итоговой оценки */
  markTypeId: Scalars['ID']['output'];
};

/** Тип описывающий версию миграции flyway для определенной БД */
export type FlywayMigrationVersion = {
  __typename?: 'flywayMigrationVersion';
  /** Название датусурса определенной БД */
  dataSourceName?: Maybe<Scalars['String']['output']>;
  /** Версия последней миграции для данной БД */
  migrationVersion?: Maybe<Scalars['String']['output']>;
};

export type S21InternshipQueries = {
  __typename?: 's21InternshipQueries';
  /**
   * -----------------------------Запросы студента-----------------------------
   *  S21. Получение информации о стажировке
   */
  getInternshipDataById: InternshipStudentInfo;
  /** S21. Получение обратной связи от ментора разбитую по попыткам */
  getInternshipReviewDataInfo: InternshipStudentReviewInfo;
  /** S21. Получить информацию по стажировке студента администратором */
  getInternshipReviewDataInfoByStudent: InternshipStudentReviewInfo;
};


export type S21InternshipQueriesGetInternshipDataByIdArgs = {
  goalId: Scalars['ID']['input'];
};


export type S21InternshipQueriesGetInternshipReviewDataInfoArgs = {
  goalId: Scalars['ID']['input'];
};


export type S21InternshipQueriesGetInternshipReviewDataInfoByStudentArgs = {
  goalId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
};

export type SchoolMarkSet = {
  __typename?: 'schoolMarkSet';
  markType?: Maybe<Scalars['String']['output']>;
  schoolMarks: Array<SchoolMark>;
};

export const GoalCourseFragmentDoc = gql`
    fragment GoalCourse on CourseCoverInformation {
  localCourseId
  courseName
  courseType
  experienceFact
  finalPercentage
  displayedCourseStatus
}
    `;
export const LevelFragmentDoc = gql`
    fragment Level on ExperienceLevelRange {
  id
  level
  levelCode
  leftBorder
  rightBorder
}
    `;
export const DeadlineGoalDataFragmentDoc = gql`
    fragment DeadlineGoalData on DeadlineGoal {
  goalProjects {
    studentGoalId
    project {
      goalName
      goalId
    }
    status
    executionType
    finalPercentage
    finalPoint
    pointTask
  }
  goalCourses {
    ...GoalCourse
  }
  levels {
    ...Level
  }
}
    ${GoalCourseFragmentDoc}
${LevelFragmentDoc}`;
export const DeadlineDataFragmentDoc = gql`
    fragment DeadlineData on Deadline {
  deadlineId
  description
  comment
  deadlineToDaysArray
  deadlineTs
  createTs
  updateTs
  status
  rules {
    logicalOperatorId
    rulesInGroup {
      logicalOperatorId
      value {
        fieldId
        subFieldKey
        operator
        value
      }
    }
  }
}
    `;
export const StudentProjectItemFragmentDoc = gql`
    fragment StudentProjectItem on StudentItem {
  goalId
  name
  description
  experience
  dateTime
  finalPercentage
  laboriousness
  executionType
  goalStatus
  courseType
  displayedCourseStatus
  amountAnswers
  amountMembers
  amountJoinedMembers
  amountReviewedAnswers
  amountCodeReviewMembers
  amountCurrentCodeReviewMembers
  groupName
  localCourseId
}
    `;
export const GlobalSearchCoursesSearchResultFragmentDoc = gql`
    fragment GlobalSearchCoursesSearchResult on CoursesSearchResult {
  count
  courses {
    goalId
    name
    displayedCourseStatus
    executionType
    finalPercentage
    experience
    courseType
    localCourseId
    goalStatus
  }
}
    `;
export const GlobalSearchProjectsSearchResultFragmentDoc = gql`
    fragment GlobalSearchProjectsSearchResult on ProjectsSearchResult {
  count
  projects {
    studentTaskId
    status
    finalPercentage
    finalPoint
    project {
      goalId
      goalName
    }
    executionType
  }
}
    `;
export const GlobalSearchProfilesSearchResultFragmentDoc = gql`
    fragment GlobalSearchProfilesSearchResult on ProfilesSearchResult {
  count
  profiles {
    login
    firstName
    lastName
    level
    avatarUrl
    school {
      shortName
    }
  }
}
    `;
export const RpSaleInfoFragmentDoc = gql`
    fragment RpSaleInfo on RpSaleProgress {
  rpType
  progressPercentage
}
    `;
export const PenaltySlotFragmentDoc = gql`
    fragment PenaltySlot on PenaltySlot {
  id
  startTime
  endTime
  description
  currentStudentsCount
  maxStudentsCount
  duration
}
    `;
export const CurrentUserFragmentDoc = gql`
    fragment CurrentUser on User {
  id
  avatarUrl
  login
  firstName
  middleName
  lastName
  currentSchoolStudentId
}
    `;
export const AsapWidgetFragmentDoc = gql`
    fragment AsapWidget on ASAPMessage {
  smallImageUrl
  smallTitle
  smallUrl
  startDate
  finishDate
  showFinishDate
  fullTitle
  fullText
  fullImageUrl
  adtType
  adtWidgetId
}
    `;
export const CodeReviewProjectFragmentDoc = gql`
    fragment CodeReviewProject on CodeReview {
  goalId
  goalTitle
  studentGoalId
  studentCodeReviewStatus
  goalExecutionType
  studentTaskAdditionalAttributesModel {
    codeReviewCost
    codeReviewDuration
  }
}
    `;
export const SoftSkillFragmentDoc = gql`
    fragment SoftSkill on SoftSkillPoint {
  softSkillName
  softSkillId
  totalPower
  currentUserPower
  maxPower
  teamRole
}
    `;
export const TeamMemberUserFragmentDoc = gql`
    fragment TeamMemberUser on User {
  id
  avatarUrl
  login
  userExperience {
    level {
      id
      levelCode
      range {
        levelCode
      }
    }
    cookiesCount
    codeReviewPoints
  }
  activeSchoolShortName
}
    `;
export const TeamMemberFragmentDoc = gql`
    fragment TeamMember on TeamMember {
  user {
    ...TeamMemberUser
  }
  role
}
    ${TeamMemberUserFragmentDoc}`;
export const CurrentTeamInvitationProjectFragmentDoc = gql`
    fragment CurrentTeamInvitationProject on TeamWithMembers {
  team {
    id
    name
  }
  members {
    ...TeamMember
  }
}
    ${TeamMemberFragmentDoc}`;
export const InvitatingTeamsToProjectFragmentDoc = gql`
    fragment InvitatingTeamsToProject on TeamWithMembers {
  team {
    id
    name
    currentTeamMemberCount
  }
  captains {
    ...TeamMemberUser
  }
}
    ${TeamMemberUserFragmentDoc}`;
export const ProjectWithTeamInvitationsFragmentDoc = gql`
    fragment ProjectWithTeamInvitations on GroupProject {
  module {
    id
    moduleTitle
    openRegistration
    startProgress
    durationFromStageSubjectGroupPlan
    isDeadlineFree
    localCourseId
    studyModule {
      duration
    }
    softSkills {
      ...SoftSkill
    }
    teamSettings {
      minAmountMember
      maxAmountMember
      location
    }
    currentTask {
      id
      task {
        studentTaskAdditionalAttributes {
          pointTask
        }
      }
    }
  }
  currentTeam {
    ...CurrentTeamInvitationProject
  }
  invitingTeams {
    ...InvitatingTeamsToProject
  }
}
    ${SoftSkillFragmentDoc}
${CurrentTeamInvitationProjectFragmentDoc}
${InvitatingTeamsToProjectFragmentDoc}`;
export const TeamLeadGoalPeriodSettingsFragmentDoc = gql`
    fragment TeamLeadGoalPeriodSettings on TeamLeadGoalPeriodSettings {
  signUpDate
  beginDate
  checkDate
  deadlineDate
  isTeamLeadPeriodsEqual
}
    `;
export const InternshipAtemptResultFragmentDoc = gql`
    fragment InternshipAtemptResult on StudentGoalAttempt {
  finalPointProject
  finalPercentageProject
  resultModuleCompletion
  resultDate
}
    `;
export const InternshipEvaluationFeedbackFragmentDoc = gql`
    fragment InternshipEvaluationFeedback on ReviewFeedback {
  id
  comment
  filledChecklist {
    id
  }
  reviewFeedbackCategoryValues {
    feedbackCategory
    feedbackValue
    id
  }
}
    `;
export const InternshipChecklistFragmentDoc = gql`
    fragment InternshipChecklist on FilledChecklist {
  id
  checklistId
  endTimeCheck
  startTimeCheck
  reviewer {
    avatarUrl
    login
    businessAdminRoles {
      id
      school {
        id
        organizationType
      }
    }
  }
  reviewFeedback {
    ...InternshipEvaluationFeedback
  }
  comment
  receivedPoint
  receivedPercentage
  quickAction
  checkType
}
    ${InternshipEvaluationFeedbackFragmentDoc}`;
export const InternshipP2PEvaluationFragmentDoc = gql`
    fragment InternshipP2PEvaluation on P2PEvaluationInfo {
  status
  checklist {
    ...InternshipChecklist
  }
}
    ${InternshipChecklistFragmentDoc}`;
export const InternshipAttemptEvaluationsFragmentDoc = gql`
    fragment InternshipAttemptEvaluations on ProjectAttemptEvaluationsInfo {
  studentAnswerId
  attemptResult {
    ...InternshipAtemptResult
  }
  p2p {
    ...InternshipP2PEvaluation
  }
}
    ${InternshipAtemptResultFragmentDoc}
${InternshipP2PEvaluationFragmentDoc}`;
export const InternshipStudentReviewListFragmentDoc = gql`
    fragment InternshipStudentReviewList on InternshipStudentReviewList {
  reviewModelList {
    reviewOrderNumber
    planTimeMentorReview
    factTimeMentorReview
    percentageMentorReview
    commentMentorReview
    threshold
  }
  numberReview
  studentProgressInternshipId
}
    `;
export const InternshipStudentReviewInfoFragmentDoc = gql`
    fragment InternshipStudentReviewInfo on InternshipStudentReviewInfo {
  internshipStudentReviewList {
    ...InternshipStudentReviewList
  }
}
    ${InternshipStudentReviewListFragmentDoc}`;
export const InternshipApplicantInfoFragmentDoc = gql`
    fragment InternshipApplicantInfo on InternshipStudentInfo {
  link
  internshipStartTime
  internshipCompletionTime
}
    `;
export const ProjectReviewsInfoFragmentDoc = gql`
    fragment ProjectReviewsInfo on ProjectReviewsInfo {
  reviewByStudentCount
  relevantReviewByStudentsCount
  reviewByInspectionStaffCount
  relevantReviewByInspectionStaffCount
}
    `;
export const P2PInfoFragmentDoc = gql`
    fragment P2PInfo on P2PChecksInfo {
  cookiesCount
  periodOfVerification
  projectReviewsInfo {
    ...ProjectReviewsInfo
  }
}
    ${ProjectReviewsInfoFragmentDoc}`;
export const InternshipTimelineItemFragmentDoc = gql`
    fragment InternshipTimelineItem on ProjectTimelineItem {
  type
  status
  start
  end
  order
  children {
    type
    elementType
    status
    start
    end
    order
  }
}
    `;
export const GroupProjectStatisticsFragmentDoc = gql`
    fragment GroupProjectStatistics on GroupProjectStatistics {
  inProgressTeams
  evaluationTeams
  finishedTeams
  acceptedTeams
  failedTeams
}
    `;
export const ProjectStatisticsFragmentDoc = gql`
    fragment ProjectStatistics on ProjectStatistics {
  registeredStudents
  inProgressStudents
  evaluationStudents
  finishedStudents
  acceptedStudents
  failedStudents
  retriedStudentsPercentage
  groupProjectStatistics {
    ...GroupProjectStatistics
  }
}
    ${GroupProjectStatisticsFragmentDoc}`;
export const InternshipModuleCoverInfoFragmentDoc = gql`
    fragment InternshipModuleCoverInfo on ModuleCoverInformation {
  softSkills {
    softSkillId
    softSkillName
    totalPower
    maxPower
    currentUserPower
    achievedUserPower
  }
  timeline {
    ...InternshipTimelineItem
  }
  projectStatistics {
    ...ProjectStatistics
  }
}
    ${InternshipTimelineItemFragmentDoc}
${ProjectStatisticsFragmentDoc}`;
export const RetrySettingsFragmentDoc = gql`
    fragment RetrySettings on ModuleAttemptsSettings {
  maxModuleAttempts
  isUnlimitedAttempts
}
    `;
export const CurrentTaskInfoFragmentDoc = gql`
    fragment CurrentTaskInfo on StudentTask {
  id
  taskId
  task {
    id
    assignmentType
    studentTaskAdditionalAttributes {
      cookiesCount
      maxCodeReviewCount
      codeReviewCost
      ciCdMode
    }
    checkTypes
  }
  lastAnswer {
    id
  }
}
    `;
export const InternshipInfoFragmentDoc = gql`
    fragment InternshipInfo on StudentModule {
  id
  moduleTitle
  finalPercentage
  finalPoint
  goalExecutionType
  displayedGoalStatus
  accessBeforeStartProgress
  resultModuleCompletion
  finishedExecutionDateByScheduler
  durationFromStageSubjectGroupPlan
  currentAttemptNumber
  isDeadlineFree
  isRetryAvailable
  localCourseId
  courseBaseParameters {
    isGradedCourse
  }
  studyModule {
    retrySettings {
      ...RetrySettings
    }
    id
    idea
    duration
    goalPoint
    levels {
      id
      goalElements {
        id
        tasks {
          id
          taskId
        }
      }
    }
  }
  currentTask {
    ...CurrentTaskInfo
  }
}
    ${RetrySettingsFragmentDoc}
${CurrentTaskInfoFragmentDoc}`;
export const CalendarReviewUserFragmentDoc = gql`
    fragment CalendarReviewUser on User {
  id
  login
}
    `;
export const VerifiableStudentItemFragmentDoc = gql`
    fragment VerifiableStudentItem on VerifiableStudent {
  userId
  login
  avatarUrl
  levelCode
  isTeamLead
  cookiesCount
  codeReviewPoints
  school {
    shortName
  }
}
    `;
export const CalendarReviewBookingFragmentDoc = gql`
    fragment CalendarReviewBooking on CalendarBooking {
  id
  answerId
  eventSlotId
  task {
    id
    goalId
    goalName
    studentTaskAdditionalAttributes {
      cookiesCount
    }
    assignmentType
  }
  eventSlot {
    id
    start
    end
    event {
      eventUserRole
    }
    school {
      shortName
    }
  }
  verifierUser {
    ...CalendarReviewUser
  }
  verifiableInfo {
    verifiableStudents {
      ...VerifiableStudentItem
    }
    team {
      name
    }
  }
  bookingStatus
  isOnline
  vcLinkUrl
  additionalChecklist {
    filledChecklistId
    filledChecklistStatusRecordingEnum
  }
}
    ${CalendarReviewUserFragmentDoc}
${VerifiableStudentItemFragmentDoc}`;
export const CalendarEventExamFragmentDoc = gql`
    fragment CalendarEventExam on Exam {
  examId
  eventId
  beginDate
  endDate
  name
  location
  currentStudentsCount
  maxStudentCount
  updateDate
  goalId
  goalName
  isWaitListActive
  isInWaitList
  stopRegisterDate
}
    `;
export const CalendarEventActivityFragmentDoc = gql`
    fragment CalendarEventActivity on ActivityEvent {
  activityEventId
  eventId
  name
  beginDate
  endDate
  isRegistered
  description
  currentStudentsCount
  maxStudentCount
  location
  updateDate
  isWaitListActive
  isInWaitList
  stopRegisterDate
}
    `;
export const PenaltyFragmentDoc = gql`
    fragment Penalty on Penalty {
  comment
  id
  duration
  status
  startTime
  createTime
  penaltySlot {
    currentStudentsCount
    description
    duration
    startTime
    id
    endTime
  }
  reasonId
}
    `;
export const CalendarEventFragmentDoc = gql`
    fragment CalendarEvent on CalendarEvent {
  id
  start
  end
  description
  eventType
  eventCode
  eventSlots {
    id
    type
    start
    end
    event {
      eventUserRole
    }
    school {
      shortName
    }
  }
  bookings {
    ...CalendarReviewBooking
  }
  exam {
    ...CalendarEventExam
  }
  studentCodeReview {
    studentGoalId
  }
  activity {
    ...CalendarEventActivity
    studentFeedback {
      id
      rating
      comment
    }
    status
    activityType
    isMandatory
    isWaitListActive
    isVisible
    comments {
      type
      createTs
      comment
    }
    organizers {
      id
      login
    }
  }
  goals {
    goalId
    goalName
  }
  penalty {
    ...Penalty
  }
}
    ${CalendarReviewBookingFragmentDoc}
${CalendarEventExamFragmentDoc}
${CalendarEventActivityFragmentDoc}
${PenaltyFragmentDoc}`;
export const CalendarExamFragmentDoc = gql`
    fragment CalendarExam on Exam {
  examId
  eventId
  beginDate
  endDate
  name
  location
  maxStudentCount
  currentStudentsCount
  updateDate
  goalId
  goalName
  isWaitListActive
  isInWaitList
  stopRegisterDate
}
    `;
export const CalendarNameLessTimeslotFragmentDoc = gql`
    fragment CalendarNameLessTimeslot on CalendarNamelessTimeSlot {
  start
  end
  validStartTimes
  staffSlot
}
    `;
export const CalendarStudentTaskAdditionalAttributesFragmentDoc = gql`
    fragment CalendarStudentTaskAdditionalAttributes on StudentTaskAdditionalAttributes {
  cookiesCount
}
    `;
export const CalendarStudentTaskFragmentDoc = gql`
    fragment CalendarStudentTask on StudentTask {
  id
  taskId
  task {
    id
    studentTaskAdditionalAttributes {
      ...CalendarStudentTaskAdditionalAttributes
    }
    assignmentType
  }
  lastAnswer {
    id
  }
}
    ${CalendarStudentTaskAdditionalAttributesFragmentDoc}`;
export const UserInBookingFragmentDoc = gql`
    fragment UserInBooking on User {
  id
  login
  avatarUrl
  userExperience {
    level {
      id
      range {
        levelCode
      }
    }
  }
}
    `;
export const ProjectTeamMemberFragmentDoc = gql`
    fragment ProjectTeamMember on User {
  id
  avatarUrl
  login
  userExperience {
    level {
      id
      range {
        levelCode
      }
    }
    cookiesCount
    codeReviewPoints
  }
  activeSchoolShortName
}
    `;
export const ProjectTeamMembersFragmentDoc = gql`
    fragment ProjectTeamMembers on ProjectTeamMembers {
  id
  teamLead {
    ...ProjectTeamMember
  }
  members {
    ...ProjectTeamMember
  }
  invitedUsers {
    ...ProjectTeamMember
  }
  teamName
  teamStatus
  minTeamMemberCount
  maxTeamMemberCount
}
    ${ProjectTeamMemberFragmentDoc}`;
export const ReviewFragmentDoc = gql`
    fragment Review on CalendarBooking {
  id
  answerId
  eventSlot {
    id
    start
    end
  }
  task {
    id
    title
    assignmentType
    goalId
    goalName
    studentTaskAdditionalAttributes {
      cookiesCount
    }
  }
  verifierUser {
    ...UserInBooking
  }
  verifiableStudent {
    id
    user {
      ...UserInBooking
    }
  }
  team {
    ...ProjectTeamMembers
  }
  bookingStatus
  isOnline
  vcLinkUrl
}
    ${UserInBookingFragmentDoc}
${ProjectTeamMembersFragmentDoc}`;
export const CompetitionCurrentCoalitionFragmentDoc = gql`
    fragment CompetitionCurrentCoalition on GameCoalition {
  id
  name
  avatarUrl
  backgroundUrl
  backgroundUrlBig
  memberCount
  color
  masterAvatarImgUrl
  currentTournament {
    points
    tournament {
      name
      timeStart
      timeEnd
    }
  }
  masterUser {
    login
  }
}
    `;
export const CurrentCoalitionTournamentFragmentDoc = gql`
    fragment CurrentCoalitionTournament on CoalitionTournamentRank {
  id
  rank
  coalitionTournament {
    points
    extraPoints
    coalition {
      id
      name
      avatarUrl
      backgroundUrl
      backgroundUrlBig
      memberCount
      color
      masterAvatarImgUrl
      masterUser {
        id
        login
      }
    }
    mvpMember {
      id
      points
      coalitionMemberUser {
        id
        login
        avatarUrl
      }
    }
  }
}
    `;
export const CurrentTournamentFragmentDoc = gql`
    fragment CurrentTournament on GameTournament {
  id
  name
  timeStart
  timeEnd
  tournamentAwardDescription
  coalitionPoints {
    ...CurrentCoalitionTournament
  }
}
    ${CurrentCoalitionTournamentFragmentDoc}`;
export const CompetitioncoalitionUserInfoFragmentDoc = gql`
    fragment CompetitioncoalitionUserInfo on User {
  id
  login
  avatarUrl
  userExperience {
    level {
      id
      levelCode
    }
  }
}
    `;
export const GetTop5AndMeCoalitionTournamentMembersInfoFragmentDoc = gql`
    fragment GetTop5AndMeCoalitionTournamentMembersInfo on CoalitionMemberPowerRank {
  id
  rank
  power {
    id
    points
    coalitionMemberUser {
      ...CompetitioncoalitionUserInfo
    }
  }
}
    ${CompetitioncoalitionUserInfoFragmentDoc}`;
export const LocalCourseFragmentDoc = gql`
    fragment LocalCourse on LocalCourseGoalInformation {
  localCourseGoalId
  goalId
  goalName
  description
  projectHours
  signUpDate
  beginDate
  deadlineDate
  checkDate
  isContentAvailable
  executionType
  finalPoint
  finalPercentage
  status
  periodSettings
  retriesUsed
  statusUpdateDate
  retrySettings {
    ...RetrySettings
  }
}
    ${RetrySettingsFragmentDoc}`;
export const AttemptStatisticResultFragmentDoc = gql`
    fragment AttemptStatisticResult on StudentGoalAttemptStatistic {
  finalPercentage
  pointProject
  resultModuleCompletion
  resultDate
}
    `;
export const MediatekaTagV2ItemFragmentFragmentDoc = gql`
    fragment MediatekaTagV2ItemFragment on TagHierarchyElement {
  tagId
  name
  tagType
  children {
    tagId
    name
    tagType
    children {
      tagId
      name
      tagType
      children {
        tagId
        name
        tagType
      }
    }
  }
}
    `;
export const MediatekaMediaFragmentFragmentDoc = gql`
    fragment MediatekaMediaFragment on ContentItem {
  itemId
  creatorUserId
  tagIds
  tagsV2 {
    ...MediatekaTagV2ItemFragment
  }
  fileName
  contentName
  contentType
  contentUrl
  createDate
  contentAuthor
  previewUrl
  description
  fileSize
  subtitleLink
  subtitleLinks {
    languageCode
    subtitleLink
  }
  itemBookmarked
  stages {
    id
    name
  }
}
    ${MediatekaTagV2ItemFragmentFragmentDoc}`;
export const MediatekaCollectionItemFragmentFragmentDoc = gql`
    fragment MediatekaCollectionItemFragment on Selection {
  selectionId
  name
}
    `;
export const PlatfSolutionInfoFragmentDoc = gql`
    fragment PlatfSolutionInfo on PlatfSolutionInfo {
  comment
  files {
    studyProcessFileId
    link
    status
    statusDetails
    updateDateTime
    creatorLogin
    fileExtension
    fileSize
  }
}
    `;
export const StudentAnswerCommentFragmentDoc = gql`
    fragment StudentAnswerComment on StudentAnswerComment {
  studentAnswerId
  comment
}
    `;
export const StudyProcessFileFragmentDoc = gql`
    fragment StudyProcessFile on StudyProcessFile {
  studyProcessFileId
  link
  status
  statusDetails
  updateDateTime
  creatorLogin
  fileExtension
  fileSize
}
    `;
export const CoinsTransactionInfoFragmentDoc = gql`
    fragment CoinsTransactionInfo on UserCoinsHistoryItemModel {
  id
  itemType
  amount
  date
  badgeName
  badgeAvatar
  externalTransactionId
  giverLogin
  comment
  amountAfter
  tournamentName
}
    `;
export const TimelineItemChildrenFragmentDoc = gql`
    fragment TimelineItemChildren on ProjectTimelineItem {
  type
  elementType
  status
  start
  end
  order
}
    `;
export const TimelineItemFragmentDoc = gql`
    fragment TimelineItem on ProjectTimelineItem {
  type
  status
  start
  end
  children {
    ...TimelineItemChildren
  }
}
    ${TimelineItemChildrenFragmentDoc}`;
export const CourseInfoFragmentDoc = gql`
    fragment CourseInfo on CourseCoverInformation {
  courseName
  courseType
  courseStatus
  displayedCourseStatus
  signUpEndDate
  signUpStartDate
  workStartDate
  workEndDate
  duration
  courseDescription
  finalPercentage
  courseStatusesHistory
  experience
  experienceFact
  currentStudentCount
  retriesOfCurrentStudents
  teamsWaitingEvaluationCount
  displayedCourseStatus
  finishedCount
  retriesCount
  resultCourseCompletion
  softSkills {
    softSkillId
    maxPower
    currentUserPower
    softSkillName
    totalPower
    teamRole
    achievedUserPower
  }
  isRetryAvailable
  isCourseCanBeFinished
  timeline {
    ...TimelineItem
  }
}
    ${TimelineItemFragmentDoc}`;
export const FilledChecklistModuleInfoFragmentDoc = gql`
    fragment FilledChecklistModuleInfo on ModuleInfoP2P {
  moduleName
  executionType
  periodOfVerification
}
    `;
export const FormChecklistQuestionFragmentDoc = gql`
    fragment FormChecklistQuestion on SectionQuestion {
  sectionQuestionId
  name
  description
  taskAssessmentScale {
    criterionScaleId
    type
    description
    scaleWeights {
      key
      value
    }
  }
}
    `;
export const FormChecklistSectionFragmentDoc = gql`
    fragment FormChecklistSection on ChecklistSection {
  checklistSectionId
  name
  description
  kindQuestionId
  questionList {
    ...FormChecklistQuestion
  }
}
    ${FormChecklistQuestionFragmentDoc}`;
export const FormChecklistFragmentDoc = gql`
    fragment FormChecklist on Checklist {
  introduction
  guidelines
  sectionList {
    ...FormChecklistSection
  }
  quickActions
  availableLanguages
  languageCode
}
    ${FormChecklistSectionFragmentDoc}`;
export const ChecklistSolutionInfoFragmentDoc = gql`
    fragment ChecklistSolutionInfo on SolutionInfo {
  solutionType
  gitlabSolutionInfo {
    gitlabLink {
      id
      sshLink
      httpsLink
    }
  }
  platfSolutionInfo {
    comment
    files {
      studyProcessFileId
      link
      creatorLogin
      fileExtension
      fileSize
    }
  }
}
    `;
export const CodeReviewRoundFragmentDoc = gql`
    fragment CodeReviewRound on CodeReviewRound {
  eventId
  codeReviewRoundType
  codeReviewStatus
  startTime
  endTime
  mergeRequestURL
  createTime
}
    `;
export const CodeReviewCurrentTaskInfoFragmentDoc = gql`
    fragment CodeReviewCurrentTaskInfo on StudentTask {
  id
  taskId
  task {
    content {
      body
    }
    assignmentType
    studentTaskAdditionalAttributes {
      codeReviewDuration
      codeReviewCost
    }
    translatedData
  }
}
    `;
export const CodeReviewProjectInfoFragmentDoc = gql`
    fragment CodeReviewProjectInfo on StudentModule {
  id
  moduleTitle
  studyModule {
    duration
    stage {
      name
    }
  }
  currentTask {
    ...CodeReviewCurrentTaskInfo
  }
}
    ${CodeReviewCurrentTaskInfoFragmentDoc}`;
export const StudentsCodeReviewByStudentFragmentDoc = gql`
    fragment StudentsCodeReviewByStudent on StudentCodeReview {
  reviewerStudentId
  user {
    login
    avatarUrl
  }
}
    `;
export const UpcomingEventFragmentDoc = gql`
    fragment UpcomingEvent on CalendarEvent {
  id
  start
  end
  bookings {
    id
    task {
      id
      goalName
    }
  }
  eventSlots {
    id
    eventId
    type
    start
    end
  }
  maxStudentCount
  location
  ipRange
  eventType
  eventCode
  description
  externalId
  currentStudentsCount
  exam {
    examId
    eventId
    beginDate
    endDate
    location
    ip
    maxStudentCount
    isVisible
    name
    goalId
    isWaitListActive
    isInWaitList
    currentStudentsCount
    createDate
    updateDate
    schoolId
    stopRegisterDate
    isRegistered
    goalName
    eventType
    registrationAccessStatus
  }
  studentCodeReview {
    studentGoalId
  }
  activity {
    activityEventId
    eventId
    beginDate
    endDate
    location
    description
    maxStudentCount
    isVisible
    name
    isWaitListActive
    isInWaitList
    currentStudentsCount
    createDate
    updateDate
    schoolId
    stopRegisterDate
    isRegistered
    activityType
    eventType
    isMandatory
    status
    organizers {
      id
      login
    }
  }
  penalty {
    ...Penalty
  }
}
    ${PenaltyFragmentDoc}`;
export const LocalCourseGoalsFragmentDoc = gql`
    fragment LocalCourseGoals on LocalCourseGoals {
  courseType
  displayedCourseStatus
  localCourseGoals {
    finalPercentage
    status
    localCourseGoalId
    goalId
    goalName
    executionType
  }
}
    `;
export const ExecutionConditionValueFragmentDoc = gql`
    fragment ExecutionConditionValue on StudentEvaluationRuleValue {
  fieldId
  fieldName
  fieldType
  subFieldKey
  subFieldName
  operator
  valueWithDescription {
    key
    value
  }
  projectRoutingInfo {
    key
    value
  }
}
    `;
export const ExecutionConditionsFragmentDoc = gql`
    fragment ExecutionConditions on StudentEvaluationRuleGroup {
  logicalOperatorId
  rulesInGroup {
    logicalOperatorId
    value {
      ...ExecutionConditionValue
    }
  }
}
    ${ExecutionConditionValueFragmentDoc}`;
export const AtemptResultFragmentDoc = gql`
    fragment AtemptResult on StudentGoalAttempt {
  finalPointProject
  finalPercentageProject
  resultModuleCompletion
  resultDate
}
    `;
export const AttemptTeamMemberFragmentDoc = gql`
    fragment AttemptTeamMember on User {
  id
  avatarUrl
  login
  userExperience {
    level {
      id
      range {
        levelCode
      }
    }
    cookiesCount
    codeReviewPoints
  }
}
    `;
export const AttemptTeamWithMembersFragmentDoc = gql`
    fragment AttemptTeamWithMembers on TeamWithMembers {
  team {
    id
    name
  }
  members {
    role
    user {
      ...AttemptTeamMember
    }
  }
}
    ${AttemptTeamMemberFragmentDoc}`;
export const EvaluationFeedbackFragmentDoc = gql`
    fragment EvaluationFeedback on ReviewFeedback {
  id
  comment
  filledChecklist {
    id
  }
  reviewFeedbackCategoryValues {
    feedbackCategory
    feedbackValue
    id
  }
}
    `;
export const OnlineReviewInfoFragmentDoc = gql`
    fragment OnlineReviewInfo on OnlineReview {
  isOnline
  videos {
    onlineVideoId
    link
    status
    statusDetails
    updateDateTime
    fileSize
  }
}
    `;
export const ChecklistFragmentDoc = gql`
    fragment Checklist on FilledChecklist {
  id
  checklistId
  endTimeCheck
  startTimeCheck
  reviewer {
    avatarUrl
    login
    businessAdminRoles {
      id
      school {
        id
        organizationType
      }
    }
  }
  reviewFeedback {
    ...EvaluationFeedback
  }
  comment
  receivedPoint
  receivedPercentage
  quickAction
  checkType
  onlineReview {
    ...OnlineReviewInfo
  }
}
    ${EvaluationFeedbackFragmentDoc}
${OnlineReviewInfoFragmentDoc}`;
export const P2PEvaluationFragmentDoc = gql`
    fragment P2PEvaluation on P2PEvaluationInfo {
  status
  checklist {
    ...Checklist
  }
}
    ${ChecklistFragmentDoc}`;
export const ProjectAttemptEvaluations_V1FragmentDoc = gql`
    fragment ProjectAttemptEvaluations_V1 on ProjectAttemptEvaluationsInfo_V1 {
  studentAnswerId
  studentGoalAttemptId
  attemptStatus
  attemptResult {
    ...AtemptResult
  }
  team {
    ...AttemptTeamWithMembers
  }
  p2p {
    ...P2PEvaluation
  }
  auto {
    status
    receivedPercentage
    endTimeCheck
    resultInfo
  }
  codeReview {
    averageMark
    studentCodeReviews {
      user {
        avatarUrl
        login
      }
      finalMark
      markTime
      reviewerCommentsCount
    }
  }
}
    ${AtemptResultFragmentDoc}
${AttemptTeamWithMembersFragmentDoc}
${P2PEvaluationFragmentDoc}`;
export const StudentsCodeReviewFragmentDoc = gql`
    fragment StudentsCodeReview on StudentCodeReviewsWithCountRound {
  countRound1
  countRound2
  codeReviewsInfo {
    maxCodeReviewCount
    codeReviewDuration
    codeReviewCost
  }
}
    `;
export const ModuleCoverInfoFragmentDoc = gql`
    fragment ModuleCoverInfo on ModuleCoverInformation {
  isOwnStudentTimeline
  softSkills {
    softSkillId
    softSkillName
    totalPower
    maxPower
    currentUserPower
    achievedUserPower
    teamRole
  }
  timeline {
    ...TimelineItem
  }
}
    ${TimelineItemFragmentDoc}`;
export const TeamSettingsInfoFragmentDoc = gql`
    fragment teamSettingsInfo on TeamSettings {
  teamCreateOption
  minAmountMember
  maxAmountMember
  enableSurrenderTeam
}
    `;
export const CurrentInternshipTaskInfoFragmentDoc = gql`
    fragment CurrentInternshipTaskInfo on StudentTask {
  id
  taskId
  task {
    id
    assignmentType
    taskSolutionType
    studentTaskAdditionalAttributes {
      cookiesCount
      maxCodeReviewCount
      codeReviewCost
      ciCdMode
    }
    checkTypes
    taskSolutionType
  }
  lastAnswer {
    id
  }
  teamSettings {
    ...teamSettingsInfo
  }
}
    ${TeamSettingsInfoFragmentDoc}`;
export const ProjectInfoFragmentDoc = gql`
    fragment ProjectInfo on StudentModule {
  id
  moduleTitle
  finalPercentage
  finalPoint
  goalExecutionType
  displayedGoalStatus
  accessBeforeStartProgress
  resultModuleCompletion
  finishedExecutionDateByScheduler
  durationFromStageSubjectGroupPlan
  currentAttemptNumber
  isDeadlineFree
  isRetryAvailable
  localCourseId
  courseBaseParameters {
    isGradedCourse
  }
  teamSettings {
    ...teamSettingsInfo
  }
  studyModule {
    id
    idea
    duration
    goalPoint
    retrySettings {
      ...RetrySettings
    }
    levels {
      id
      goalElements {
        id
        tasks {
          id
          taskId
        }
      }
    }
  }
  currentTask {
    ...CurrentInternshipTaskInfo
  }
}
    ${TeamSettingsInfoFragmentDoc}
${RetrySettingsFragmentDoc}
${CurrentInternshipTaskInfoFragmentDoc}`;
export const OnlineReviewVideoInfoFragmentDoc = gql`
    fragment OnlineReviewVideoInfo on OnlineReviewVideo {
  onlineVideoId
  link
  status
  statusDetails
  updateDateTime
  fileSize
}
    `;
export const CourseGoalsTypesFragmentDoc = gql`
    fragment CourseGoalsTypes on LocalCourseGoalInformation {
  executionType
}
    `;
export const StudentGoalRetryInfoFragmentDoc = gql`
    fragment StudentGoalRetryInfo on StudentGoalRetryInfo {
  totalRetryValue
  usedRetryCount
  unlimitedAttempts
}
    `;
export const ModuleExamCoverInfoFragmentDoc = gql`
    fragment ModuleExamCoverInfo on ModuleCoverInformation {
  timeline {
    ...TimelineItem
  }
  projectStatistics {
    ...ProjectStatistics
  }
  softSkills {
    softSkillId
    maxPower
    currentUserPower
    softSkillName
    totalPower
    teamRole
    achievedUserPower
  }
}
    ${TimelineItemFragmentDoc}
${ProjectStatisticsFragmentDoc}`;
export const ExamInfoFragmentDoc = gql`
    fragment ExamInfo on StudentModule {
  id
  moduleTitle
  displayedGoalStatus
  resultModuleCompletion
  localCourseId
  finalPercentage
  finalPoint
  localCourseId
  goalExecutionType
  isRetryAvailable
  durationFromStageSubjectGroupPlan
  isDeadlineFree
  courseBaseParameters {
    isGradedCourse
  }
  studyModule {
    idea
    duration
    goalPoint
  }
}
    `;
export const TeamMemberInProjectPageFragmentDoc = gql`
    fragment TeamMemberInProjectPage on User {
  id
  avatarUrl
  login
  userExperience {
    level {
      id
      range {
        levelCode
      }
    }
    cookiesCount
    codeReviewPoints
  }
  activeSchoolShortName
}
    `;
export const CurrentUserExperienceFragmentDoc = gql`
    fragment CurrentUserExperience on UserExperience {
  id
  cookiesCount
  codeReviewPoints
  coinsCount
  level {
    id
    range {
      id
      levelCode
    }
  }
}
    `;
export const AvailableStudentForTeamFragmentDoc = gql`
    fragment AvailableStudentForTeam on Student {
  id
  user {
    id
    login
    avatarUrl
    userExperience {
      ...CurrentUserExperience
    }
  }
}
    ${CurrentUserExperienceFragmentDoc}`;
export const StudentInvitationInfoFragmentDoc = gql`
    fragment StudentInvitationInfo on StudentInvitationInfo {
  student {
    ...AvailableStudentForTeam
  }
  invitationStatus
  schoolShortName
}
    ${AvailableStudentForTeamFragmentDoc}`;
export const PartialStudyProcessFileFragmentDoc = gql`
    fragment PartialStudyProcessFile on StudyProcessFile {
  studyProcessFileId
  link
  status
}
    `;
export const ProjectAttemptEvaluationsFragmentDoc = gql`
    fragment ProjectAttemptEvaluations on ProjectAttemptEvaluationsInfo {
  studentAnswerId
  attemptResult {
    ...AtemptResult
  }
  team {
    ...AttemptTeamWithMembers
  }
  p2p {
    ...P2PEvaluation
  }
  auto {
    status
    receivedPercentage
    endTimeCheck
    resultInfo
  }
  codeReview {
    averageMark
    studentCodeReviews {
      user {
        avatarUrl
        login
      }
      finalMark
      markTime
      reviewerCommentsCount
    }
  }
}
    ${AtemptResultFragmentDoc}
${AttemptTeamWithMembersFragmentDoc}
${P2PEvaluationFragmentDoc}`;
export const TeamMemberWithRoleFragmentDoc = gql`
    fragment TeamMemberWithRole on TeamMember {
  role
  user {
    ...ProjectTeamMember
  }
}
    ${ProjectTeamMemberFragmentDoc}`;
export const TeamWithMembersFragmentDoc = gql`
    fragment TeamWithMembers on ProjectTeamWithMembers {
  teamWithMembers {
    team {
      id
      name
      status
      minTeamMemberCount
      maxTeamMemberCount
    }
    members {
      ...TeamMemberWithRole
    }
  }
  invitedStudents {
    student {
      user {
        ...ProjectTeamMember
      }
    }
  }
}
    ${TeamMemberWithRoleFragmentDoc}
${ProjectTeamMemberFragmentDoc}`;
export const UserAchievementsFragmentDoc = gql`
    fragment UserAchievements on UserBadgeAward {
  id
  histories {
    id
    rewardDate
    awardPoints
  }
  badge {
    id
    kind {
      id
      name
      order
    }
    name
    description
    avatarUrl
    bigAvatarUrl
  }
  award {
    id
    awardCondition {
      id
      description
    }
    awardBounties {
      awardBountyId
      description
      cookies
      coins
      experienceValue
      coalitionPoints
      softSkillPowers {
        softSkillId
        power
        softSkill {
          id
          name
        }
      }
    }
  }
  points
  isFake
}
    `;
export const GetStudentIsDeadlinesEnabledDocument = gql`
    query getStudentIsDeadlinesEnabled {
  student {
    isDeadlinesEnabled
  }
}
    `;
export const GetUserFeatureFlagsDocument = gql`
    query getUserFeatureFlags($entityId: String!) {
  user {
    getAllBackendConfigurations: getAllBackendConfigurationsV2(entityId: $entityId) {
      propertyCode
      value
    }
  }
}
    `;
export const UserRoleLoaderGetRolesDocument = gql`
    query userRoleLoaderGetRoles {
  user {
    getCurrentUser {
      functionalRoles {
        code
      }
      id
      studentRoles {
        id
        school {
          id
          shortName
          organizationType
        }
        status
      }
      userSchoolPermissions {
        schoolId
        permissions
      }
      systemAdminRole {
        id
      }
      businessAdminRolesV2 {
        id
        school {
          id
          organizationType
        }
        orgUnitId
      }
    }
    getCurrentUserSchoolRoles {
      schoolId
    }
    getCurrentUserRoles {
      orgUnitId
      orgUnitShortName
      roleCode
    }
  }
}
    `;
export const CreateEventFeedbackDocument = gql`
    mutation createEventFeedback($calendarEventId: ID!, $rating: Int!, $comment: String) {
  student {
    createCalendarEventFeedback(
      studentFeedback: {calendarEventId: $calendarEventId, rating: $rating, comment: $comment}
    ) {
      user {
        login
      }
      createDate
      rating
      comment
    }
  }
}
    `;
export const EventsWithoutFeedbackDocument = gql`
    query eventsWithoutFeedback($from: DateTime!, $to: DateTime!) {
  student {
    getCalendarEventsWithoutFeedback(from: $from, to: $to) {
      id
      activity {
        eventId
        name
        endDate
      }
    }
  }
}
    `;
export const GetIsHonorRatingNeededDocument = gql`
    query getIsHonorRatingNeeded {
  honorRating {
    isHonorRatingNeeded
  }
}
    `;
export const GetAllInCompletedStudentFeedbackPopupDocument = gql`
    query getAllInCompletedStudentFeedbackPopup {
  sc21StudentTaskCheck {
    getAllInCompletedStudentFeedbackPopup {
      studentFeedbackId
      goalName
      resultAttemptDate
    }
  }
}
    `;
export const GetStudentFeedbackByIdDocument = gql`
    query getStudentFeedbackById($studentFeedbackId: ID!) {
  sc21StudentTaskCheck {
    getStudentFeedbackById(studentFeedbackId: $studentFeedbackId) {
      id
      studentGoalAttemptId
      goalId
      goalName
      goalExecutionType
      pointPercent
      resultModuleCompletion
      resultAttemptDate
      serialNumber
      feedbackForm {
        id
        feedbackFormEnum
        name
        feedbackFormQuestions {
          id
          serialNumber
          titleEn
          descriptionEn
          feedbackSectionEnum
          typeValue
          quickActionEn
        }
      }
    }
  }
}
    `;
export const SaveStudentFeedbackResultsDocument = gql`
    mutation saveStudentFeedbackResults($studentFeedbackId: ID!, $studentFeedbackResults: [StudentFeedbackResultInput!]!) {
  sc21StudentTaskCheck {
    saveStudentFeedbackResults(
      studentFeedbackId: $studentFeedbackId
      studentFeedbackResults: $studentFeedbackResults
    )
  }
}
    `;
export const DeadlinesGetStudentDataDocument = gql`
    query deadlinesGetStudentData {
  student {
    getStudentProfile {
      user {
        id
        login
        firstName
        middleName
        lastName
      }
    }
    getExperience {
      id
      value
      level {
        id
        range {
          id
          levelCode
          rightBorder
          leftBorder
        }
      }
    }
    getExperienceHistory {
      id
      awardDate
      experienceReceived
    }
  }
}
    `;
export const DeadlineReminderGetClosestDeadlinePopupDocument = gql`
    query deadlineReminderGetClosestDeadlinePopup {
  student {
    getClosestDeadlinePopup {
      deadline {
        ...DeadlineData
      }
      deadlineGoal {
        ...DeadlineGoalData
      }
      shiftCount
    }
  }
}
    ${DeadlineDataFragmentDoc}
${DeadlineGoalDataFragmentDoc}`;
export const GetUserNotificationsDocument = gql`
    query getUserNotifications($paging: PagingInput!) {
  s21Notification {
    getS21Notifications(paging: $paging) {
      notifications {
        id
        relatedObjectType
        relatedObjectId
        message
        time
        wasRead
        groupName
      }
      totalCount
      groupNames
    }
  }
}
    `;
export const GetUserNotificationsCountDocument = gql`
    query getUserNotificationsCount($wasReadIncluded: Boolean) {
  s21Notification {
    getS21NotificationsCount(wasReadIncluded: $wasReadIncluded)
  }
}
    `;
export const ReadUserNotificationsDocument = gql`
    mutation readUserNotifications($notificationIds: [ID!]!) {
  student {
    readNotifications(notificationIds: $notificationIds)
  }
}
    `;
export const LogCentrifugoErrorDocument = gql`
    mutation logCentrifugoError($jsonMessage: String!) {
  school21 {
    logCentrifugoError(jsonMessage: $jsonMessage)
  }
}
    `;
export const GetStudentCurrentProjectsDocument = gql`
    query getStudentCurrentProjects($userId: ID!) {
  student {
    getStudentCurrentProjects(userId: $userId) {
      ...StudentProjectItem
    }
  }
}
    ${StudentProjectItemFragmentDoc}`;
export const SetDefaultRoleDocument = gql`
    mutation SetDefaultRole($role: ROLES!, $orgUnitId: ID) {
  user {
    setUserRoleDefaultContext_v2(role: $role, orgUnitId: $orgUnitId)
  }
}
    `;
export const GetGlobalSearchResultsDocument = gql`
    query getGlobalSearchResults($searchString: String!, $items: [SearchItem]!, $page: PagingInput!) {
  globalSearch {
    searchByText(searchString: $searchString, items: $items, page: $page) {
      profiles {
        ...GlobalSearchProfilesSearchResult
      }
      projects {
        ...GlobalSearchProjectsSearchResult
      }
      studentCourses {
        ...GlobalSearchCoursesSearchResult
      }
    }
  }
}
    ${GlobalSearchProfilesSearchResultFragmentDoc}
${GlobalSearchProjectsSearchResultFragmentDoc}
${GlobalSearchCoursesSearchResultFragmentDoc}`;
export const GetSearchHistoryDocument = gql`
    query getSearchHistory {
  globalSearch {
    getSearchHistoryTooltips {
      tooltipText
      tooltipCategory
    }
  }
}
    `;
export const GetSaleProgressPercentagesDocument = gql`
    query getSaleProgressPercentages {
  school21 {
    getSaleProgressPercentages {
      ...RpSaleInfo
    }
  }
}
    ${RpSaleInfoFragmentDoc}`;
export const DeadlinesGetDeadlinesDocument = gql`
    query deadlinesGetDeadlines($deadlineStatuses: [DeadlineStatus!]!, $page: PagingInput!, $deadlinesFrom: DateTime, $deadlinesTo: DateTime, $sorting: [SortingField]) {
  student {
    getDeadlines(
      deadlineStatuses: $deadlineStatuses
      page: $page
      deadlineFrom: $deadlinesFrom
      deadlineTo: $deadlinesTo
      sorting: $sorting
    ) {
      deadline {
        ...DeadlineData
      }
      shiftRequests {
        deadlineShiftRequestId
        status
        daysToShift
        createTs
      }
      deadlineGoal {
        ...DeadlineGoalData
      }
      shiftCount
    }
  }
}
    ${DeadlineDataFragmentDoc}
${DeadlineGoalDataFragmentDoc}`;
export const BookPenaltySlotDocument = gql`
    mutation bookPenaltySlot($penaltyId: ID!, $slotId: ID!) {
  penalty {
    setPenaltyBooking(penaltyId: $penaltyId, slotId: $slotId)
  }
}
    `;
export const GetPenaltySlotsDocument = gql`
    query getPenaltySlots($duration: Int!, $page: PagingInput!, $sorting: [SortingField]) {
  penalty {
    getPenaltyFreeSlots(duration: $duration, page: $page, sorting: $sorting) {
      ...PenaltySlot
    }
  }
}
    ${PenaltySlotFragmentDoc}`;
export const GetPenaltyListDocument = gql`
    query getPenaltyList($statuses: [String]!, $from: DateTime, $to: DateTime, $sorting: [SortingField], $page: PagingInput!) {
  penalty {
    getMyPenalties(
      statuses: $statuses
      from: $from
      to: $to
      sorting: $sorting
      page: $page
    ) {
      ...Penalty
    }
    getPenaltyReasons {
      id
      name
    }
    countMyPenalties(statuses: $statuses)
  }
}
    ${PenaltyFragmentDoc}`;
export const GetUserRestrictionsInfoDocument = gql`
    query getUserRestrictionsInfo {
  school21 {
    getUserRestrictions {
      restrictionId
      restrictionType
      userId
      schoolId
      isActive
      createdTs
      updatedTs
    }
  }
}
    `;
export const GetCurrentUserDocument = gql`
    query getCurrentUser {
  user {
    getCurrentUser {
      ...CurrentUser
    }
  }
}
    ${CurrentUserFragmentDoc}`;
export const GetCurrentUserExperienceDocument = gql`
    query getCurrentUserExperience {
  student {
    getExperience {
      ...CurrentUserExperience
    }
  }
}
    ${CurrentUserExperienceFragmentDoc}`;
export const GetTokenDocument = gql`
    query getToken {
  school21 {
    generateJwtTokenForCentrifugo
  }
}
    `;
export const GetIsApiDocumentationEnabledDocument = gql`
    query getIsApiDocumentationEnabled {
  sc21StudentTaskCheck {
    isOpenApiAllowed
  }
}
    `;
export const GetTournamentNotificationResultsDocument = gql`
    query getTournamentNotificationResults {
  student {
    getTournamentResults(isShown: false) {
      id
      power
      coalitionRank
      userRank
      firstCoalitionName
      coalitionName
      timeClosed
    }
  }
}
    `;
export const MarkTournamentNotificationShownDocument = gql`
    mutation markTournamentNotificationShown($userTournamentResultId: [UUID!]!) {
  student {
    markTournamentResultAsShown(userTournamentResultIds: $userTournamentResultId) {
      id
      isShown
    }
  }
}
    `;
export const UserGetThemeDocument = gql`
    query userGetTheme($userId: UUID!) {
  user {
    getUserViewSettings(userId: $userId) {
      isDarkThemeEnabled
      schoolViewSettingType
    }
  }
}
    `;
export const SwitchUserThemeDocument = gql`
    mutation switchUserTheme($userId: UUID!, $isDarkThemeEnabled: Boolean!) {
  user {
    switchUserTheme(userId: $userId, isDarkThemeEnabled: $isDarkThemeEnabled)
  }
}
    `;
export const GetAgendaActivityOrExamDocument = gql`
    query getAgendaActivityOrExam($eventId: ID!) {
  student {
    getEnrichedCalendar(eventId: $eventId) {
      start
      end
      description
      exam {
        currentStudentsCount
        maxStudentCount
        isRegistered
        isInWaitList
        isWaitListActive
        stopRegisterDate
        endDate
        registrationAccessStatus
        goalId
        name
        location
      }
      activity {
        eventId
        activityEventId
        currentStudentsCount
        maxStudentCount
        isRegistered
        isInWaitList
        isWaitListActive
        stopRegisterDate
        endDate
        activityType
        location
        isMandatory
        description
        status
        organizers {
          id
          login
        }
      }
    }
  }
}
    `;
export const UnsubscribeFromAgendaEventDocument = gql`
    mutation unsubscribeFromAgendaEvent($eventId: ID!) {
  student {
    unsubscribeFromEvent(eventId: $eventId) {
      id
    }
  }
}
    `;
export const GetAgendaEventsDocument = gql`
    query getAgendaEvents($from: DateTime!, $to: DateTime!, $limit: Int!) {
  calendarEventS21 {
    getMyAgendaEvents(from: $from, to: $to, limit: $limit) {
      agendaItemContext {
        entityId
        entityType
      }
      start
      end
      label
      description
      agendaEventType
      additionalInfo {
        key
        value
      }
    }
  }
}
    `;
export const GetAgendaP2PDocument = gql`
    query getAgendaP2P($bookingId: ID!) {
  student {
    getEnrichedBooking(bookingId: $bookingId) {
      id
      eventSlot {
        start
        school {
          shortName
        }
      }
      task {
        goalId
        goalName
        assignmentType
        studentTaskAdditionalAttributes {
          cookiesCount
        }
      }
      verifierUser {
        id
        login
        avatarUrl
        userExperience {
          level {
            range {
              levelCode
            }
          }
        }
      }
      verifiableInfo {
        verifiableStudents {
          userId
          login
          avatarUrl
          levelCode
          isTeamLead
          school {
            shortName
          }
        }
        team {
          name
        }
      }
      answerId
      bookingStatus
      additionalChecklist {
        filledChecklistId
      }
      isOnline
      vcLinkUrl
    }
  }
}
    `;
export const GetAsapWidgetsDocument = gql`
    query getAsapWidgets {
  ASAP {
    getASAPMessages {
      ...AsapWidget
    }
  }
}
    ${AsapWidgetFragmentDoc}`;
export const DashboardHeaderGetInfoDocument = gql`
    query dashboardHeaderGetInfo {
  user {
    getCurrentUser {
      id
      login
      avatarUrl
      firstName
      middleName
      lastName
      currentSchoolStudentId
      studentRoles {
        id
        status
        school {
          id
          shortName
        }
      }
    }
  }
  student {
    getUserTournamentWidget {
      coalitionMember {
        coalition {
          avatarUrl
          color
          name
          memberCount
        }
        currentTournamentPowerRank {
          rank
        }
      }
      lastTournamentResult {
        userRank
      }
    }
    getExperience {
      id
      value
      level {
        id
        range {
          id
          levelCode
          rightBorder
          leftBorder
        }
      }
      cookiesCount
      coinsCount
      codeReviewPoints
      isReviewPointsConsistent
    }
  }
}
    `;
export const GetStudentStageGroupS21Document = gql`
    query getStudentStageGroupS21($studentId: UUID!) {
  school21 {
    getStageGroupS21PublicProfile(studentId: $studentId) {
      waveId
      waveName
      eduForm
    }
  }
}
    `;
export const GetDashboardBuildingsDocument = gql`
    query getDashboardBuildings {
  student {
    getBuildings {
      id
      classrooms {
        id
        number
      }
    }
  }
}
    `;
export const GetDashboardWorkstationDocument = gql`
    query getDashboardWorkstation($login: String!) {
  student {
    getWorkstationByLogin(login: $login) {
      id
      classroomId
      hostName
      classroom {
        floor
      }
    }
  }
}
    `;
export const WidgetAchievementsGetLastBadgesDocument = gql`
    query widgetAchievementsGetLastBadges($limit: Int) {
  student {
    getLastBadges(limit: $limit) {
      id
      points
      badge {
        name
        avatarUrl
      }
      award {
        awardBounties {
          awardLevelId
        }
      }
    }
  }
}
    `;
export const GetAvailableCodeReviewProjectsDocument = gql`
    query getAvailableCodeReviewProjects($paging: PagingInput!) {
  student {
    getAvailableCodeReviewProjectsV2(paging: $paging) {
      codeReviews {
        ...CodeReviewProject
      }
      limitInfo {
        limitByWeek
        usedByWeek
      }
    }
  }
}
    ${CodeReviewProjectFragmentDoc}`;
export const GetFirstRoundCodeReviewProjectsDocument = gql`
    query getFirstRoundCodeReviewProjects($paging: PagingInput!) {
  student {
    getFirstRoundCodeReviewProjects(paging: $paging) {
      ...CodeReviewProject
    }
  }
}
    ${CodeReviewProjectFragmentDoc}`;
export const GetSecondRoundCodeReviewProjectsDocument = gql`
    query getSecondRoundCodeReviewProjects($paging: PagingInput!) {
  student {
    getSecondRoundCodeReviewProjects(paging: $paging) {
      ...CodeReviewProject
    }
  }
}
    ${CodeReviewProjectFragmentDoc}`;
export const GetStudentFinishedProjectsDocument = gql`
    query getStudentFinishedProjects($userId: ID!) {
  student {
    getStudentFinishedProjects(userId: $userId) {
      ...StudentProjectItem
    }
  }
}
    ${StudentProjectItemFragmentDoc}`;
export const GetInvitationsCountDocument = gql`
    query getInvitationsCount {
  team {
    getCreatedJoinTeamRequestCount
  }
}
    `;
export const GetProjectsWithOpenTeamsDocument = gql`
    query getProjectsWithOpenTeams {
  student {
    getGroupProjectsWithOpenTeams {
      ...ProjectWithTeamInvitations
    }
  }
}
    ${ProjectWithTeamInvitationsFragmentDoc}`;
export const GetTeamLeadPeriodSettingsDocument = gql`
    query getTeamLeadPeriodSettings($goalId: ID!, $currentStudentLocalCourseId: ID!, $location: LocationEnum!, $teamLeadUserId: UUID!) {
  student {
    getTeamLeadPeriodSettings(
      goalId: $goalId
      currentStudentLocalCourseId: $currentStudentLocalCourseId
      location: $location
      teamLeadUserId: $teamLeadUserId
    ) {
      ...TeamLeadGoalPeriodSettings
    }
  }
}
    ${TeamLeadGoalPeriodSettingsFragmentDoc}`;
export const AcceptInvitationToTeamDocument = gql`
    mutation acceptInvitationToTeam($teamId: UUID!) {
  student {
    acceptInvitation(teamId: $teamId)
  }
}
    `;
export const GetProjectTeamMembersByTeamDocument = gql`
    query getProjectTeamMembersByTeam($teamId: UUID!) {
  team {
    getTeamMembersByTeam(teamId: $teamId) {
      teamId
      role
      ...TeamMember
    }
  }
}
    ${TeamMemberFragmentDoc}`;
export const RejectInvitationToTeamDocument = gql`
    mutation rejectInvitationToTeam($teamId: UUID!) {
  student {
    rejectInvitation(teamId: $teamId)
  }
}
    `;
export const GetRecommendedProjectsDocument = gql`
    query getRecommendedProjects($userId: ID!) {
  student {
    getRecommendedProjects(userId: $userId) {
      ...StudentProjectItem
    }
  }
}
    ${StudentProjectItemFragmentDoc}`;
export const GetInternshipAttemptEvaluationsInfoDocument = gql`
    query getInternshipAttemptEvaluationsInfo($goalId: ID!) {
  student {
    getProjectAttemptEvaluationsInfo(goalId: $goalId) {
      ...InternshipAttemptEvaluations
    }
  }
}
    ${InternshipAttemptEvaluationsFragmentDoc}`;
export const GetInternshipInfoDocument = gql`
    query getInternshipInfo($goalId: ID!) {
  student {
    getModuleById(goalId: $goalId) {
      ...InternshipInfo
    }
    getModuleCoverInformation(goalId: $goalId) {
      ...InternshipModuleCoverInfo
    }
    getP2PChecksInfo(goalId: $goalId) {
      ...P2PInfo
    }
  }
  s21Internship {
    getInternshipDataById(goalId: $goalId) {
      ...InternshipApplicantInfo
    }
    getInternshipReviewDataInfo(goalId: $goalId) {
      ...InternshipStudentReviewInfo
    }
  }
}
    ${InternshipInfoFragmentDoc}
${InternshipModuleCoverInfoFragmentDoc}
${P2PInfoFragmentDoc}
${InternshipApplicantInfoFragmentDoc}
${InternshipStudentReviewInfoFragmentDoc}`;
export const RegisterToInternshipDocument = gql`
    mutation registerToInternship($goalId: ID!) {
  sc21ProjectFlow {
    registerForProject(goalId: $goalId)
  }
}
    `;
export const RetryInternshipDocument = gql`
    mutation retryInternship($taskId: ID!) {
  sc21ProjectFlow {
    retryProject(taskId: $taskId)
  }
}
    `;
export const CalendarGetMyBookingsDocument = gql`
    query calendarGetMyBookings($from: DateTime!, $to: DateTime!) {
  student {
    getMyCalendarBookings(from: $from, to: $to) {
      ...CalendarReviewBooking
    }
  }
}
    ${CalendarReviewBookingFragmentDoc}`;
export const CalendarGetCodeReviewDataDocument = gql`
    query calendarGetCodeReviewData($studentGoalId: ID!) {
  student {
    getStudentModuleByStudentGoalId(studentGoalId: $studentGoalId) {
      moduleTitle
      currentTask {
        task {
          studentTaskAdditionalAttributes {
            codeReviewDuration
          }
        }
      }
    }
  }
}
    `;
export const GetProjectTeamMembersDocument = gql`
    query getProjectTeamMembers($studentTaskId: ID!) {
  student {
    getProjectTeamMembers(studentTaskId: $studentTaskId) {
      ...ProjectTeamMembers
    }
  }
}
    ${ProjectTeamMembersFragmentDoc}`;
export const CalendarGetEventsDocument = gql`
    query calendarGetEvents($from: DateTime!, $to: DateTime!) {
  calendarEventS21 {
    getMyCalendarEvents(from: $from, to: $to) {
      ...CalendarEvent
    }
  }
}
    ${CalendarEventFragmentDoc}`;
export const CalendarGetExamsDocument = gql`
    query calendarGetExams($from: DateTime!, $to: DateTime!) {
  student {
    getExams(from: $from, to: $to) {
      ...CalendarExam
    }
  }
}
    ${CalendarExamFragmentDoc}`;
export const CalendarGetNameLessStudentTimeslotsForReviewDocument = gql`
    query calendarGetNameLessStudentTimeslotsForReview($from: DateTime!, $taskId: ID!, $to: DateTime!) {
  student {
    getNameLessStudentTimeslotsForReview(from: $from, taskId: $taskId, to: $to) {
      checkDuration
      projectReviewsInfo {
        ...ProjectReviewsInfo
      }
      timeSlots {
        ...CalendarNameLessTimeslot
      }
    }
  }
}
    ${ProjectReviewsInfoFragmentDoc}
${CalendarNameLessTimeslotFragmentDoc}`;
export const GetPenaltyReasonsDocument = gql`
    query getPenaltyReasons {
  penalty {
    getPenaltyReasons {
      id
      name
    }
  }
}
    `;
export const CalendarGetStudentCodeReviewsDocument = gql`
    query calendarGetStudentCodeReviews($studentGoalId: ID!) {
  student {
    getStudentCodeReviews(studentGoalId: $studentGoalId) {
      secondRoundStartDate
    }
  }
}
    `;
export const GetUsersDocument = gql`
    query getUsers($userIds: [UUID!]!) {
  school21 {
    getUsers(userIds: $userIds) {
      userId
      login
      firstName
      middleName
      lastName
      avatarUrl
      level
    }
  }
}
    `;
export const CreateParticipantEventDocument = gql`
    mutation createParticipantEvent($input: ActivityEventByStudentInputModel!) {
  event {
    createParticipantEvent(input: $input) {
      activityEventId
      eventId
      name
      eventType
    }
  }
}
    `;
export const GetActivityTypesDocument = gql`
    query getActivityTypes {
  school21 {
    getActivityTypes {
      id
      description
      category
    }
  }
}
    `;
export const UpdateParticipantEventDocument = gql`
    mutation updateParticipantEvent($activityEventId: ID!, $input: ActivityEventByStudentInputModel!) {
  event {
    updateParticipantEvent(activityEventId: $activityEventId, input: $input) {
      activityEventId
      eventId
      name
      eventType
    }
  }
}
    `;
export const GetMySuggestedActivitiesDocument = gql`
    query getMySuggestedActivities($page: PagingInput!, $statuses: [ParticipantEventStatus]) {
  event {
    getMySuggestedActivities(page: $page, statuses: $statuses) {
      id
      start
      end
      eventType
      description
      eventCode
      activity {
        organizers {
          id
          login
        }
        eventCreator {
          id
          login
        }
        comments {
          type
          createTs
          comment
        }
        averageFeedbackRating
        isVisible
        activityType
        status
        activityEventId
        eventId
        name
        description
        location
        currentStudentsCount
        maxStudentCount
        isRegistered
        isInWaitList
        isWaitListActive
        stopRegisterDate
        beginDate
        endDate
      }
    }
  }
}
    `;
export const GetStageClassmatesDocument = gql`
    query getStageClassmates($textSearch: String) {
  school21 {
    getStageClassmates(textSearch: $textSearch) {
      id
      login
      firstName
      middleName
      lastName
    }
  }
}
    `;
export const CalendarAddCodeReviewToEventSlotDocument = gql`
    mutation calendarAddCodeReviewToEventSlot($studentGoalId: ID!, $startTime: DateTime!) {
  student {
    addBookingCodeReviewToEventSlot(
      studentGoalId: $studentGoalId
      startTime: $startTime
    ) {
      id
    }
  }
}
    `;
export const CancelParticipantEventDocument = gql`
    mutation cancelParticipantEvent($activityEvent: ID!) {
  event {
    cancelParticipantEvent(activityEvent: $activityEvent) {
      activityEventId
      eventId
      name
    }
  }
}
    `;
export const CreateCalendarEventFeedbackDocument = gql`
    mutation createCalendarEventFeedback($studentFeedback: StudentEventFeedbackInput!) {
  student {
    createCalendarEventFeedback(studentFeedback: $studentFeedback) {
      id
      user {
        id
      }
      rating
      comment
    }
  }
}
    `;
export const CalendarGetUploadedAndNotConfirmedVideosDocument = gql`
    query CalendarGetUploadedAndNotConfirmedVideos($filledChecklistId: ID!) {
  sc21StudentTaskCheck {
    getUploadedAndNotConfirmedVideos(filledChecklistId: $filledChecklistId) {
      onlineVideoId
      link
      status
      statusDetails
      updateDateTime
      fileSize
    }
  }
}
    `;
export const CalendarUpdateFilledChecklistWithOnlineReviewDocument = gql`
    mutation CalendarUpdateFilledChecklistWithOnlineReview($filledChecklistId: ID!) {
  school21 {
    submitFilledChecklistRecording(filledChecklistId: $filledChecklistId) {
      checklistId
    }
  }
}
    `;
export const CalendarGetStudentExperienceDocument = gql`
    query calendarGetStudentExperience {
  student {
    getExperience {
      id
      cookiesCount
    }
  }
}
    `;
export const CalendarAddBookingToEventSlotDocument = gql`
    mutation calendarAddBookingToEventSlot($answerId: ID!, $startTime: DateTime!, $wasStaffSlotChosen: Boolean!, $isOnline: Boolean) {
  student {
    addBookingP2PToEventSlot(
      answerId: $answerId
      startTime: $startTime
      wasStaffSlotChosen: $wasStaffSlotChosen
      isOnline: $isOnline
    ) {
      id
    }
  }
}
    `;
export const CalendarAddEventDocument = gql`
    mutation calendarAddEvent($start: DateTime!, $end: DateTime!) {
  student {
    addEventToTimetable(start: $start, end: $end) {
      ...CalendarEvent
    }
  }
}
    ${CalendarEventFragmentDoc}`;
export const CalendarChangeEventSlotDocument = gql`
    mutation calendarChangeEventSlot($id: ID!, $start: DateTime!, $end: DateTime!) {
  student {
    changeEventSlot(eventSlotId: $id, start: $start, end: $end) {
      ...CalendarEvent
    }
  }
}
    ${CalendarEventFragmentDoc}`;
export const CalendarDeleteEventSlotDocument = gql`
    mutation calendarDeleteEventSlot($eventSlotId: ID!) {
  student {
    deleteEventSlot(eventSlotId: $eventSlotId)
  }
}
    `;
export const EventsGetActivityFeedbackDocument = gql`
    query EventsGetActivityFeedback($activityEventId: ID!, $page: PagingInput!) {
  event {
    getActivityEventFeedback(activityEventId: $activityEventId, page: $page) {
      id
      user {
        id
        login
        email
      }
      comment
      rating
      createDate
    }
    getActivityEventFeedbackCount(activityEventId: $activityEventId)
  }
}
    `;
export const EventsGetStudentsDocument = gql`
    query EventsGetStudents($activityEventId: ID!, $studentType: StudentEventTypeEnum!, $page: PagingInput!) {
  event {
    getEventStudents(
      eventId: $activityEventId
      page: $page
      studentType: $studentType
    ) {
      User {
        id
        login
        email
      }
    }
  }
}
    `;
export const CalendarGetModuleDocument = gql`
    query calendarGetModule($moduleId: ID!) {
  student {
    getModuleById(goalId: $moduleId) {
      id
      moduleTitle
      subjectTitle
      goalExecutionType
      currentTask {
        ...CalendarStudentTask
      }
    }
  }
}
    ${CalendarStudentTaskFragmentDoc}`;
export const CalendarGetMyReviewsDocument = gql`
    query calendarGetMyReviews($to: DateTime, $limit: Int) {
  student {
    getMyUpcomingBookings(to: $to, limit: $limit) {
      ...Review
    }
  }
}
    ${ReviewFragmentDoc}`;
export const CompetitionCoalitionGetMyCoalitionMembersDocument = gql`
    query competitionCoalitionGetMyCoalitionMembers($page: PagingInput) {
  student {
    getMyCoalitionMembers(page: $page) {
      user {
        id
        login
        avatarUrl
        userExperience {
          level {
            id
            levelCode
          }
        }
      }
    }
  }
}
    `;
export const CompetitionCoalitionGetUserTournamentDocument = gql`
    query competitionCoalitionGetUserTournament {
  student {
    getUserTournamentWidget {
      coalitionMember {
        coalition {
          ...CompetitionCurrentCoalition
        }
      }
      lastTournamentResult {
        id
      }
    }
  }
}
    ${CompetitionCurrentCoalitionFragmentDoc}`;
export const CompetitionGetCurrentOrLastTournamentDocument = gql`
    query competitionGetCurrentOrLastTournament {
  student {
    getCurrentOrLastTournament {
      ...CurrentTournament
    }
  }
}
    ${CurrentTournamentFragmentDoc}`;
export const CompetitionGetStudentRankInTournamentDocument = gql`
    query competitionGetStudentRankInTournament($gameTournamentId: Int!) {
  student {
    getStudentRankInTournament(gameTournamentId: $gameTournamentId) {
      id
      rank
      power {
        id
        points
        coalitionTournament {
          id
          coalition {
            id
          }
        }
        coalitionMemberUser {
          ...CompetitioncoalitionUserInfo
        }
      }
    }
  }
}
    ${CompetitioncoalitionUserInfoFragmentDoc}`;
export const GetTop5AndMeCoalitionTournamentMembersDocument = gql`
    query GetTop5AndMeCoalitionTournamentMembers($gameCoalitionId: Int!, $gameTournamentId: Int!) {
  student {
    getTop5AndMeCoalitionTournamentMembers(
      gameCoalitionId: $gameCoalitionId
      gameTournamentId: $gameTournamentId
    ) {
      top5 {
        ...GetTop5AndMeCoalitionTournamentMembersInfo
      }
    }
  }
}
    ${GetTop5AndMeCoalitionTournamentMembersInfoFragmentDoc}`;
export const GetCourseConsistencyInfoDocument = gql`
    query getCourseConsistencyInfo($localCourseId: ID!) {
  school21 {
    loadCourseConsistencyInfo(localCourseId: $localCourseId) {
      courseId
      name
      isConsistent
      isConstructorsValid
    }
  }
}
    `;
export const GetLocalCourseGoalsDocument = gql`
    query getLocalCourseGoals($localCourseId: ID!) {
  course {
    getLocalCourseGoals(localCourseId: $localCourseId) {
      localCourseId
      globalCourseId
      courseName
      courseType
      localCourseGoals {
        ...LocalCourse
      }
    }
  }
}
    ${LocalCourseFragmentDoc}`;
export const GetCourseAttemptStatisticDocument = gql`
    query getCourseAttemptStatistic($localCourseId: ID!) {
  course {
    getCourseAttemptStatistic(localCourseId: $localCourseId) {
      resultDate
      finalPercentage
      pointProject
      completionResultStatus
    }
  }
}
    `;
export const GiveUpExamDocument = gql`
    mutation giveUpExam($goalId: ID!, $examEventId: ID, $taskId: ID, $skillId: ID) {
  sc21ProjectFlow {
    surrenderFromExam(
      goalId: $goalId
      examEventId: $examEventId
      taskId: $taskId
      skillId: $skillId
    )
  }
}
    `;
export const GetGoalAttemptStatisticDocument = gql`
    query getGoalAttemptStatistic($goalId: ID!) {
  student {
    getGoalAttemptStatistic(goalId: $goalId) {
      ...AttemptStatisticResult
    }
  }
}
    ${AttemptStatisticResultFragmentDoc}`;
export const AddToFavouritesDocument = gql`
    mutation addToFavourites($videoId: UUID!) {
  mediateka {
    addBookmark(itemId: $videoId) {
      status
    }
  }
}
    `;
export const RemoveFromFavouritesDocument = gql`
    mutation removeFromFavourites($videoId: UUID!) {
  mediateka {
    removeBookmark(itemId: $videoId) {
      status
    }
  }
}
    `;
export const GetSearchItemsDocument = gql`
    query getSearchItems($filter: MediatekaItemsFilter, $page: PagingInput!) {
  mediateka {
    searchItems(filter: $filter, page: $page) {
      content {
        ...MediatekaMediaFragment
      }
      totalItems
    }
  }
}
    ${MediatekaMediaFragmentFragmentDoc}`;
export const GetChildrenTagsListDocument = gql`
    query getChildrenTagsList($filter: MediatekaTagsWithLinksFilter!) {
  mediateka {
    getTagsRelativesWithFiltering(filter: $filter) {
      children {
        id
        name
      }
    }
  }
}
    `;
export const GetParentTagsListDocument = gql`
    query getParentTagsList($filter: MediatekaTagsFilter!, $page: PagingInput!) {
  mediateka {
    getTagsByFilter(filter: $filter, page: $page) {
      tags {
        id
        name
      }
    }
  }
}
    `;
export const GetCollectionListDocument = gql`
    query getCollectionList($bound: Boolean, $selectionType: SelectionType, $stageIds: [ID!]) {
  selection {
    getSelections(bound: $bound, selectionType: $selectionType, stageIds: $stageIds) {
      ...MediatekaCollectionItemFragment
    }
  }
}
    ${MediatekaCollectionItemFragmentFragmentDoc}`;
export const GetProjectAccessGroupIdByStudentAnswerIdDocument = gql`
    query getProjectAccessGroupIdByStudentAnswerId($answerId: ID!) {
  sc21StudentTaskCheck {
    getProjectAccessGroupIdByStudentAnswerId(answerId: $answerId)
  }
}
    `;
export const GetTaskSolutionTypeDocument = gql`
    query getTaskSolutionType($taskId: ID!) {
  sc21StudentTaskCheck {
    getTaskSolutionType(taskId: $taskId)
  }
}
    `;
export const GetPlatfSolutionInfoDocument = gql`
    query getPlatfSolutionInfo($studentGoalAttemptId: ID!) {
  sc21StudentTaskCheck {
    getPlatfSolutionInfo(studentGoalAttemptId: $studentGoalAttemptId) {
      ...PlatfSolutionInfo
    }
  }
}
    ${PlatfSolutionInfoFragmentDoc}`;
export const SaveSolutionCommentDocument = gql`
    mutation saveSolutionComment($taskId: ID!, $comment: String!) {
  sc21StudentTaskCheck {
    saveSolutionComment(taskId: $taskId, comment: $comment) {
      ...StudentAnswerComment
    }
  }
}
    ${StudentAnswerCommentFragmentDoc}`;
export const MarkFileSolutionPendingDocument = gql`
    mutation markFileSolutionPending($taskId: ID!, $initialFileEvents: [StudyProcessFileInitialInput!]!) {
  sc21StudentTaskCheck {
    markFileSolutionPending(taskId: $taskId, initialFileEvents: $initialFileEvents) {
      ...StudyProcessFile
    }
  }
}
    ${StudyProcessFileFragmentDoc}`;
export const MarkFileSolutionFailedToUploadDocument = gql`
    mutation markFileSolutionFailedToUpload($taskId: ID!, $errorMessage: String!, $studyProcessFileId: ID!) {
  sc21StudentTaskCheck {
    markFileSolutionFailedToUpload(
      taskId: $taskId
      errorMessage: $errorMessage
      studyProcessFileId: $studyProcessFileId
    ) {
      ...StudyProcessFile
    }
  }
}
    ${StudyProcessFileFragmentDoc}`;
export const MarkFileSolutionUploadCancelledDocument = gql`
    mutation markFileSolutionUploadCancelled($taskId: ID!, $studyProcessFileId: ID!) {
  sc21StudentTaskCheck {
    markFileSolutionUploadCancelled(
      taskId: $taskId
      studyProcessFileId: $studyProcessFileId
    ) {
      ...StudyProcessFile
    }
  }
}
    ${StudyProcessFileFragmentDoc}`;
export const MarkFileSolutionUploadedStatusDocument = gql`
    mutation markFileSolutionUploadedStatus($taskId: ID!, $studyProcessFileIds: ID!) {
  sc21StudentTaskCheck {
    markFileSolutionUploadedStatus(
      taskId: $taskId
      studyProcessFileIds: $studyProcessFileIds
    ) {
      ...StudyProcessFile
    }
  }
}
    ${StudyProcessFileFragmentDoc}`;
export const GetPenaltiesCountDocument = gql`
    query getPenaltiesCount($statuses: [String]!) {
  penalty {
    countMyPenalties(statuses: $statuses)
  }
}
    `;
export const GetNotificationUserSettingsDocument = gql`
    query getNotificationUserSettings {
  notificationConfiguration {
    settings: getNotificationUserSettings {
      groupTypeId
      groupTypeName
      typeId
      typeName
      channelId
      channelName
      channelActive
      channelActiveSystem
      channelLockedSystem
      isMutable
    }
  }
}
    `;
export const SaveNotificationUserSettingsDocument = gql`
    mutation saveNotificationUserSettings($settings: [NotificationUserSettingInput!]!) {
  notificationConfiguration {
    saveNotificationUserSettings(settings: $settings)
  }
}
    `;
export const PasswordChangeSetPasswordDocument = gql`
    mutation passwordChangeSetPassword($newPassword: String!, $oldPassword: String!) {
  user {
    setPassword(newPassword: $newPassword, oldPassword: $oldPassword) {
      id
    }
  }
}
    `;
export const GetCoinsHistoryDocument = gql`
    query getCoinsHistory {
  student {
    getUserCoinsHistory {
      ...CoinsTransactionInfo
    }
  }
}
    ${CoinsTransactionInfoFragmentDoc}`;
export const PublicProfileGetProjectsDocument = gql`
    query publicProfileGetProjects($studentId: UUID!, $stageGroupId: ID!) {
  school21 {
    getStudentProjectsForPublicProfileByStageGroup(
      studentId: $studentId
      stageGroupId: $stageGroupId
    ) {
      groupName
      name
      experience
      finalPercentage
      goalId
      goalStatus
      amountAnswers
      amountReviewedAnswers
      executionType
      localCourseId
      courseType
      displayedCourseStatus
    }
  }
}
    `;
export const PublicProfileLoadStageGroupsDocument = gql`
    query publicProfileLoadStageGroups($studentId: UUID!) {
  school21 {
    loadStudentStageGroups(studentId: $studentId) {
      stageGroupStudentId
      studentId
      stageGroupS21 {
        waveId
        waveName
        eduForm
        active
      }
      safeSchool {
        fullName
      }
    }
  }
}
    `;
export const GetDismissInfoByStudentIdDocument = gql`
    query getDismissInfoByStudentId($studentId: UUID!) {
  school21 {
    getDismissInfoByStudentId(studentId: $studentId) {
      dismissTypeId
      dismissTs
      lastStageGroupS21 {
        waveId
        waveName
        eduForm
        active
      }
    }
  }
}
    `;
export const StudentProfileGetUserRestrictionsByUserIdAndSchoolIdDocument = gql`
    query StudentProfileGetUserRestrictionsByUserIdAndSchoolId($userId: UUID!, $schoolId: UUID!) {
  school21 {
    getUserRestrictionsByUserIdAndSchoolId(userId: $userId, schoolId: $schoolId) {
      restrictionId
      restrictionType
      userId
      schoolId
      isActive
      createdTs
      updatedTs
    }
  }
}
    `;
export const GetCourseInfoByStudentDocument = gql`
    query getCourseInfoByStudent($localCourseId: ID!, $studentId: UUID!) {
  course {
    getCourseCoverInformationByStudent(
      localCourseId: $localCourseId
      studentId: $studentId
    ) {
      ...CourseInfo
    }
    getCourseAttemptStatisticByStudent(
      localCourseId: $localCourseId
      studentId: $studentId
    ) {
      completionResultStatus
    }
    getCourseRetryInfoByStudent(
      localCourseId: $localCourseId
      studentId: $studentId
    ) {
      totalRetryValue
      usedRetryCount
      unlimitedAttempts
    }
    getLocalCourseGoalsByStudent(
      localCourseId: $localCourseId
      studentId: $studentId
      sortingFields: {name: "goalName", asc: true}
    ) {
      localCourseGoals {
        executionType
      }
    }
  }
}
    ${CourseInfoFragmentDoc}`;
export const GetCampusUserAvatarDocument = gql`
    query getCampusUserAvatar($userId: UUID!) {
  school21 {
    getAvatarByUserId(userId: $userId)
  }
}
    `;
export const GetCampusUserIdByLoginDocument = gql`
    query getCampusUserIdByLogin($login: String!) {
  school21 {
    getUserIdByLogin(login: $login)
  }
}
    `;
export const GetCampusBuildingsDocument = gql`
    query getCampusBuildings {
  student {
    getBuildings {
      id
      name
      classrooms {
        id
        number
        capacity
        availableCapacity
        floor
        classroomPlan {
          classroomPlanId
          planMeta
        }
        specializations
      }
    }
  }
}
    `;
export const GetCampusPlanOccupiedDocument = gql`
    query getCampusPlanOccupied($clusterId: ID!) {
  student {
    getClusterPlanStudentsByClusterId(clusterId: $clusterId) {
      occupiedPlaces {
        row
        number
        stageGroupName
        stageName
        user {
          id
          login
          avatarUrl
        }
        experience {
          id
          value
          level {
            id
            range {
              id
              levelCode
              leftBorder
              rightBorder
            }
          }
        }
        studentType
      }
    }
  }
}
    `;
export const GetCampusCurrentUserDocument = gql`
    query getCampusCurrentUser {
  user {
    getCurrentUser {
      id
      login
    }
  }
}
    `;
export const GetCampusWorkstationDocument = gql`
    query getCampusWorkstation($login: String!) {
  student {
    getWorkstationByLogin(login: $login) {
      id
      classroomId
      hostName
      workstationRow
      workstationNumber
    }
  }
}
    `;
export const GetFilledChecklistDocument = gql`
    query getFilledChecklist($filledChecklistId: ID!, $languageCodeType: LanguageCodeType) {
  student {
    getP2pInfo(
      filledChecklistId: $filledChecklistId
      languageCodeType: $languageCodeType
    ) {
      id
      solutionInfo {
        ...ChecklistSolutionInfo
      }
      checklist {
        ...FormChecklist
      }
      moduleInfoP2P {
        ...FilledChecklistModuleInfo
      }
      progressCheckInfo {
        reviewUserCount
        reviewUserCountExecuted
      }
      verifiableUsers {
        teamWithMembers {
          team {
            id
            name
          }
          members {
            ...TeamMember
          }
        }
        user {
          ...TeamMemberUser
        }
      }
      onlineReview {
        ...OnlineReviewInfo
      }
    }
  }
}
    ${ChecklistSolutionInfoFragmentDoc}
${FormChecklistFragmentDoc}
${FilledChecklistModuleInfoFragmentDoc}
${TeamMemberFragmentDoc}
${TeamMemberUserFragmentDoc}
${OnlineReviewInfoFragmentDoc}`;
export const SaveFilledChecklistDocument = gql`
    mutation saveFilledChecklist($filledChecklistInput: ChecklistFilledInput!) {
  student {
    completeP2pCheck(checklistFilledInput: $filledChecklistInput)
  }
}
    `;
export const CompleteFirstCodeReviewRoundDocument = gql`
    mutation completeFirstCodeReviewRound($studentGoalId: ID!) {
  student {
    completeFirstCodeReviewRound(studentGoalId: $studentGoalId) {
      codeReviewRoundId
    }
  }
}
    `;
export const EvaluateCodeReviewProjectAndReviewersDocument = gql`
    mutation evaluateCodeReviewProjectAndReviewers($studentGoalId: ID!, $finalMark: Boolean!, $studentMarks: [CodeReviewersMarksInput!]!) {
  student {
    evaluateCodeReviewProjectAndReviewers(
      studentGoalId: $studentGoalId
      finalMark: $finalMark
      studentMarks: $studentMarks
    ) {
      studentCodeReviewId
    }
  }
}
    `;
export const GetCodeReviewMyStudentDocument = gql`
    query getCodeReviewMyStudent($studentGoalId: ID!) {
  student {
    getMyStudentCodeReview(studentGoalId: $studentGoalId) {
      reviewerCommentsCount
      codeReviewRounds {
        ...CodeReviewRound
      }
    }
  }
}
    ${CodeReviewRoundFragmentDoc}`;
export const GetCoreReviewImportedLanguagesForCurrentVersionDocument = gql`
    query getCoreReviewImportedLanguagesForCurrentVersion($studentGoalId: ID!) {
  school21 {
    getImportedLanguagesForCurrentVersionByStudentGoalId(
      studentGoalId: $studentGoalId
    )
  }
}
    `;
export const GetCodeReviewProjectInfoDocument = gql`
    query getCodeReviewProjectInfo($studentGoalId: ID!, $language: String) {
  student {
    getStudentModuleByStudentGoalId(
      studentGoalId: $studentGoalId
      language: $language
    ) {
      ...CodeReviewProjectInfo
    }
  }
}
    ${CodeReviewProjectInfoFragmentDoc}`;
export const GetStudentCodeReviewByStudentGoalIdDocument = gql`
    query getStudentCodeReviewByStudentGoalId($studentGoalId: ID!) {
  student {
    getStudentCodeReviewByStudentGoalId(studentGoalId: $studentGoalId) {
      ...StudentsCodeReviewByStudent
    }
  }
}
    ${StudentsCodeReviewByStudentFragmentDoc}`;
export const RemoveCodeReviewBookingDocument = gql`
    mutation removeCodeReviewBooking($eventId: ID!) {
  student {
    removeBookingToCodeReview(eventId: $eventId) {
      id
    }
  }
}
    `;
export const ProjectMapGetStudentGraphTemplateDocument = gql`
    query ProjectMapGetStudentGraphTemplate($studentId: UUID, $stageGroupId: Int) {
  holyGraph {
    getStudentGraphTemplate(studentId: $studentId, stageGroupId: $stageGroupId) {
      edges {
        id
        source
        target
        sourceHandle
        targetHandle
        data {
          sourceGap
          targetGap
          points {
            x
            y
          }
        }
      }
      nodes {
        id
        label
        handles
        position {
          x
          y
        }
        items {
          id
          code
          handles
          entityType
          entityId
          parentNodeCodes
          childrenNodeCodes
          skills {
            id
            name
            color
            textColor
          }
          goal {
            projectId
            projectName
            projectDescription
            projectPoints
            goalExecutionType
            isMandatory
          }
          course {
            projectId
            projectName
            projectDescription
            projectPoints
            courseType
            isMandatory
          }
        }
      }
    }
  }
}
    `;
export const ProjectMapGetStudentStageGroupsDocument = gql`
    query ProjectMapGetStudentStageGroups($studentId: UUID!) {
  school21 {
    loadStudentStageGroups(studentId: $studentId) {
      stageGroupS21 {
        waveId
        waveName
        eduForm
        active
      }
    }
  }
}
    `;
export const ProjectMapGetStudentStateGraphNodeDocument = gql`
    query ProjectMapGetStudentStateGraphNode($graphNode: JsonNode!, $studentId: UUID, $stageGroupId: Int) {
  holyGraph {
    getStudentStateGraphNode(
      graphNode: $graphNode
      studentId: $studentId
      stageGroupId: $stageGroupId
    ) {
      id
      items {
        id
        goal {
          projectState
          duration
          projectDate
        }
        course {
          projectState
          localCourseId
          duration
          projectDate
        }
      }
    }
  }
}
    `;
export const GetGraphGetCurrentUserDocument = gql`
    query getGraphGetCurrentUser {
  user {
    getCurrentUser {
      id
      currentSchoolStudentId
      login
    }
  }
}
    `;
export const GetGraphGetStudentAvatarDocument = gql`
    query getGraphGetStudentAvatar($userId: UUID!) {
  school21 {
    getAvatarByUserId(userId: $userId)
  }
}
    `;
export const GetGraphStudentIdByLoginDocument = gql`
    query getGraphStudentIdByLogin($login: String!) {
  school21 {
    getStudentIdByLogin(login: $login)
    getUserIdByLogin(login: $login)
  }
}
    `;
export const GetClassmatesDocument = gql`
    query getClassmates($textSearch: String) {
  honorRating {
    getClassmates(textSearch: $textSearch) {
      __typename
      id
      firstName
      lastName
      login
    }
    __typename
  }
}
    `;
export const SaveHonorRatingsDocument = gql`
    mutation saveHonorRatings($studentHonorRatings: [StudentHonorRatingInput!]!) {
  honorRating {
    saveStudentHonorRatings(studentHonorRatings: $studentHonorRatings) {
      studentHonorRatingId
    }
  }
}
    `;
export const GetUpcomingEventsDocument = gql`
    query getUpcomingEvents($eventCodes: [String!]!, $registrationAccessStatusFilter: RegistartionStatusEnum, $page: PagingInput) {
  calendarEventS21 {
    getUpcomingEventsForRegistration(
      eventCodes: $eventCodes
      registrationAccessStatusFilter: $registrationAccessStatusFilter
      page: $page
    ) {
      ...UpcomingEvent
    }
  }
}
    ${UpcomingEventFragmentDoc}`;
export const StartP2pCheckDocument = gql`
    mutation StartP2pCheck($filledChecklistId: ID!) {
  student {
    startP2pCheck(filledChecklistId: $filledChecklistId)
  }
}
    `;
export const UpdateP2POnlineTypeDocument = gql`
    mutation updateP2POnlineType($bookingId: ID!) {
  sc21StudentTaskCheck {
    enableOnlineP2pCheck(bookingId: $bookingId) {
      id
    }
  }
}
    `;
export const MarkAbsenceAtP2PDocument = gql`
    mutation markAbsenceAtP2P($bookingId: ID!) {
  student {
    markAbsenceInProtocol(bookingId: $bookingId)
  }
}
    `;
export const RemoveP2PDocument = gql`
    mutation removeP2P($bookingId: ID!) {
  student {
    removeBookingFromEventSlot(bookingId: $bookingId)
  }
}
    `;
export const SubscribeToEventDocument = gql`
    mutation subscribeToEvent($eventId: ID!) {
  student {
    subscribeToEvent(eventId: $eventId) {
      ...UpcomingEvent
    }
  }
}
    ${UpcomingEventFragmentDoc}`;
export const UnsubscribeFromEventDocument = gql`
    mutation unsubscribeFromEvent($eventId: ID!) {
  student {
    unsubscribeFromEvent(eventId: $eventId) {
      ...UpcomingEvent
    }
  }
}
    ${UpcomingEventFragmentDoc}`;
export const GetImportedLanguagesForCurrentVersionDocument = gql`
    query getImportedLanguagesForCurrentVersion($taskId: ID!) {
  school21 {
    getImportedLanguagesForCurrentVersion(taskId: $taskId)
  }
}
    `;
export const GetTasksByIdDocument = gql`
    query getTasksById($goalId: ID!, $localCourseId: ID, $taskId: ID!, $language: String) {
  school21 {
    getTasksById(
      goalId: $goalId
      localCourseId: $localCourseId
      taskId: $taskId
      language: $language
    ) {
      id
      task {
        id
        content {
          id
          body
        }
        translatedData
      }
    }
  }
}
    `;
export const GetGitlabSettingsTokenDocument = gql`
    query getGitlabSettingsToken($taskId: ID!) {
  student {
    getLinkToPrivateStudentGitlabProjectByTaskId(taskId: $taskId) {
      runnersToken
    }
  }
}
    `;
export const GetTaskContentFilesDocument = gql`
    query getTaskContentFiles($studentAnswerId: ID!) {
  s21StudentTaskFiles {
    getTaskContentFiles(studentAnswerId: $studentAnswerId) {
      fileName
      filePath
      fileSize
      extension
      fileOrder
    }
  }
}
    `;
export const GetProjectConsistencyInfoDocument = gql`
    query getProjectConsistencyInfo($goalId: ID!) {
  school21 {
    loadGoalConsistencyInfo(goalId: $goalId) {
      goalId
      isConsistent
      isConstructorsValid
    }
  }
}
    `;
export const GetLocalCourseGoalsInfoDocument = gql`
    query getLocalCourseGoalsInfo($localCourseId: ID!) {
  course {
    getLocalCourseGoals(localCourseId: $localCourseId) {
      ...LocalCourseGoals
    }
  }
}
    ${LocalCourseGoalsFragmentDoc}`;
export const AttachedFilesWidgetGetProjectsSelectionDocument = gql`
    query AttachedFilesWidgetGetProjectsSelection($entityId: ID!) {
  selection {
    getSelectionByEntity(entityId: $entityId, entityType: MODULE)
  }
}
    `;
export const AttachedFilesWidgetGetSelectionDocument = gql`
    query AttachedFilesWidgetGetSelection($selection: ID!) {
  selection {
    getItems(selectionId: $selection) {
      itemId
      contentType
      contentName
      contentUrl
    }
  }
}
    `;
export const GetExecutionConditionsDocument = gql`
    query getExecutionConditions($goalId: ID!) {
  student {
    loadTaskEvaluationRules(goalId: $goalId) {
      ...ExecutionConditions
    }
  }
}
    ${ExecutionConditionsFragmentDoc}`;
export const GetProjectGitlabInfoDocument = gql`
    query getProjectGitlabInfo($answerId: ID!) {
  student {
    getPrivateGitlabProjectLinkInfoByAnswerId(answerId: $answerId) {
      gitlabProjectId
      sshLink
      httpsLink
      status
      hasOpenedMR
    }
  }
}
    `;
export const GetProjectAttemptEvaluationsInfoDocument = gql`
    query getProjectAttemptEvaluationsInfo($goalId: ID!, $studentId: UUID!) {
  school21 {
    getProjectAttemptEvaluationsInfo_V1(goalId: $goalId, studentId: $studentId) {
      ...ProjectAttemptEvaluations_V1
    }
  }
}
    ${ProjectAttemptEvaluations_V1FragmentDoc}`;
export const CreateFeedbackOnEvaluationDocument = gql`
    mutation createFeedbackOnEvaluation($reviewFeedbackInput: ReviewFeedbackInput!) {
  student {
    createReviewFeedback(reviewFeedbackInput: $reviewFeedbackInput) {
      ...EvaluationFeedback
    }
  }
}
    ${EvaluationFeedbackFragmentDoc}`;
export const GetProjectInfoDocument = gql`
    query getProjectInfo($goalId: ID!) {
  student {
    getModuleById(goalId: $goalId) {
      ...ProjectInfo
    }
    getModuleCoverInformation(goalId: $goalId) {
      ...ModuleCoverInfo
    }
    getP2PChecksInfo(goalId: $goalId) {
      ...P2PInfo
    }
    getStudentCodeReviewByGoalId(goalId: $goalId) {
      ...StudentsCodeReview
    }
  }
}
    ${ProjectInfoFragmentDoc}
${ModuleCoverInfoFragmentDoc}
${P2PInfoFragmentDoc}
${StudentsCodeReviewFragmentDoc}`;
export const MediatekaGetContentItemDocument = gql`
    query MediatekaGetContentItem($itemIds: [ID!]!) {
  mediateka {
    getContentItemsByIds(isActive: true, itemIds: $itemIds) {
      itemId
      contentType
      contentName
      contentAuthor
      contentUrl
      subtitleLink
      subtitleLinks {
        languageCode
        subtitleLink
      }
      description
    }
  }
}
    `;
export const GetStageInfoDocument = gql`
    query getStageInfo {
  user {
    getCurrentUser {
      id
      studentRoles {
        status
        school {
          organizationType
        }
        stageGroup {
          classSubjects {
            stage {
              name
            }
          }
          name
          stage
          isActive
        }
      }
    }
    getAllStagesTenantAware {
      id
      name
    }
  }
}
    `;
export const MarkOnlineReviewVideoUploadedDocument = gql`
    mutation markOnlineReviewVideoUploaded($filledChecklistId: ID!, $onlineReviewId: ID!) {
  school21 {
    markP2pCheckVideoUploaded(
      filledChecklistId: $filledChecklistId
      onlineReviewId: $onlineReviewId
    ) {
      ...OnlineReviewVideoInfo
    }
  }
}
    ${OnlineReviewVideoInfoFragmentDoc}`;
export const MarkFilesPendingDocument = gql`
    mutation markFilesPending($filledChecklistId: ID!, $pendingFiles: [StudyProcessFileInitialInput!]!) {
  school21 {
    markFilesPending(
      filledChecklistId: $filledChecklistId
      pendingFiles: $pendingFiles
    ) {
      ...OnlineReviewVideoInfo
    }
  }
}
    ${OnlineReviewVideoInfoFragmentDoc}`;
export const MarkOnlineReviewVideoFailedToUploadDocument = gql`
    mutation markOnlineReviewVideoFailedToUpload($filledChecklistId: ID!, $onlineReviewId: ID!, $errorMessage: String!) {
  school21 {
    markP2pCheckVideoFailedToUpload(
      filledChecklistId: $filledChecklistId
      onlineReviewId: $onlineReviewId
      errorMessage: $errorMessage
    ) {
      ...OnlineReviewVideoInfo
    }
  }
}
    ${OnlineReviewVideoInfoFragmentDoc}`;
export const MarkOnlineReviewVideoUploadCancelledDocument = gql`
    mutation markOnlineReviewVideoUploadCancelled($filledChecklistId: ID!, $onlineReviewId: ID!) {
  school21 {
    markP2pCheckVideoUploadCancelled(
      filledChecklistId: $filledChecklistId
      onlineReviewId: $onlineReviewId
    ) {
      ...OnlineReviewVideoInfo
    }
  }
}
    ${OnlineReviewVideoInfoFragmentDoc}`;
export const CapitulationFromTheCourseDocument = gql`
    mutation capitulationFromTheCourse($localCourseId: ID!) {
  student {
    capitulationFromTheCourse(localCourseId: $localCourseId) {
      finalPoint
    }
  }
}
    `;
export const FinishCourseDocument = gql`
    mutation finishCourse($localCourseId: ID!) {
  course {
    finishCourse(localCourseId: $localCourseId)
  }
}
    `;
export const RegistrationForTheCourseDocument = gql`
    mutation registrationForTheCourse($localCourseId: ID!) {
  course {
    registrationForTheCourse(localCourseId: $localCourseId) {
      finalPoint
    }
  }
}
    `;
export const RetryCourseDocument = gql`
    mutation retryCourse($localCourseId: ID!) {
  course {
    retryCourse(localCourseId: $localCourseId)
  }
}
    `;
export const GetCourseCoverInformationDocument = gql`
    query getCourseCoverInformation($localCourseId: ID!) {
  course {
    getCourseCoverInformation(localCourseId: $localCourseId) {
      ...CourseInfo
    }
    getCourseRetryInfo(localCourseId: $localCourseId) {
      totalRetryValue
      usedRetryCount
      unlimitedAttempts
    }
    getLocalCourseGoals(localCourseId: $localCourseId) {
      localCourseGoals {
        ...CourseGoalsTypes
      }
    }
  }
}
    ${CourseInfoFragmentDoc}
${CourseGoalsTypesFragmentDoc}`;
export const GetCourseEvaluationRulesDocument = gql`
    query getCourseEvaluationRules($localCourseId: ID!) {
  course {
    loadCourseEvaluationRules(localCourseId: $localCourseId) {
      ...ExecutionConditions
    }
  }
}
    ${ExecutionConditionsFragmentDoc}`;
export const GetExamInfoDocument = gql`
    query getExamInfo($goalId: ID!) {
  student {
    getModuleById(goalId: $goalId) {
      ...ExamInfo
    }
    getModuleCoverInformation(goalId: $goalId) {
      ...ModuleExamCoverInfo
    }
    getGoalRetryInfo(goalId: $goalId) {
      ...StudentGoalRetryInfo
    }
  }
}
    ${ExamInfoFragmentDoc}
${ModuleExamCoverInfoFragmentDoc}
${StudentGoalRetryInfoFragmentDoc}`;
export const RegisterForExamDocument = gql`
    mutation registerForExam($goalId: ID!) {
  sc21ProjectFlow {
    registerForExam(goalId: $goalId)
  }
}
    `;
export const TryAgainExamModuleDocument = gql`
    mutation tryAgainExamModule($goalId: ID!) {
  sc21ProjectFlow {
    retryExam(goalId: $goalId)
  }
}
    `;
export const GetProjectTeamWithMembersDocument = gql`
    query getProjectTeamWithMembers($goalId: ID!) {
  student {
    getProjectTeamWithMembers(goalId: $goalId) {
      teamWithMembers {
        team {
          id
          name
          status
          minTeamMemberCount
          maxTeamMemberCount
        }
        members {
          role
          user {
            ...TeamMemberInProjectPage
          }
        }
      }
      invitedStudents {
        student {
          user {
            ...TeamMemberInProjectPage
          }
        }
      }
    }
  }
}
    ${TeamMemberInProjectPageFragmentDoc}`;
export const GetIsDisbandRequestAlreadySentDocument = gql`
    query getIsDisbandRequestAlreadySent($teamId: UUID!) {
  student {
    isRequestBeenSentToTeamDisband(teamId: $teamId)
  }
}
    `;
export const DisbandAndFailDocument = gql`
    mutation disbandAndFail($taskId: ID!) {
  sc21ProjectFlow {
    surrenderFromProject(taskId: $taskId)
  }
}
    `;
export const SendDisbandRequestDocument = gql`
    mutation sendDisbandRequest($teamId: UUID!, $comment: String!, $urlFileComment: String, $goalId: ID!) {
  student {
    sendTeamDisbandRequest(
      teamId: $teamId
      comment: $comment
      urlFileComment: $urlFileComment
      goalId: $goalId
    )
  }
}
    `;
export const GetAvailableStudentsForTeamsDocument = gql`
    query getAvailableStudentsForTeams($goalId: ID!) {
  student {
    getAvailableStudentsForTeam(goalId: $goalId) {
      ...StudentInvitationInfo
    }
  }
}
    ${StudentInvitationInfoFragmentDoc}`;
export const CancelInvitationDocument = gql`
    mutation cancelInvitation($teamId: UUID!, $userId: ID!) {
  student {
    cancelInvitation(teamId: $teamId, userId: $userId) {
      ...StudentInvitationInfo
    }
  }
}
    ${StudentInvitationInfoFragmentDoc}`;
export const SendInvitationDocument = gql`
    mutation sendInvitation($teamId: UUID!, $userId: ID!) {
  student {
    sendInvitation(teamId: $teamId, userId: $userId) {
      ...StudentInvitationInfo
    }
  }
}
    ${StudentInvitationInfoFragmentDoc}`;
export const ChangeProjectTeamNameDocument = gql`
    mutation changeProjectTeamName($teamId: UUID!, $newName: String!) {
  student {
    changeGroupName(teamId: $teamId, newName: $newName)
  }
}
    `;
export const LeaveAndDisbandTeamDocument = gql`
    mutation leaveAndDisbandTeam($teamId: UUID!) {
  student {
    disbandTeam(teamId: $teamId)
  }
}
    `;
export const LeaveTeamDocument = gql`
    mutation leaveTeam($teamId: UUID!, $exitReasonId: Int, $exitReasonDescription: String) {
  student {
    exitStudentFromTeam(
      teamId: $teamId
      exitReasonId: $exitReasonId
      exitReasonDescription: $exitReasonDescription
    )
  }
}
    `;
export const GetPlatfSolutionDocument = gql`
    query getPlatfSolution($studentGoalAttemptId: ID!) {
  sc21StudentTaskCheck {
    getPlatfSolutionInfo(studentGoalAttemptId: $studentGoalAttemptId) {
      files {
        ...PartialStudyProcessFile
      }
      comment
    }
  }
}
    ${PartialStudyProcessFileFragmentDoc}`;
export const GetLinkToPrivateStudentGitlabProjectByAnswerIdDocument = gql`
    query getLinkToPrivateStudentGitlabProjectByAnswerId($answerId: ID!) {
  student {
    getPrivateGitlabProjectLinkInfoByAnswerId(answerId: $answerId) {
      httpsLink
      sshLink
      status
    }
  }
}
    `;
export const GetProjectStatisticsDocument = gql`
    query getProjectStatistics($goalId: ID!) {
  student {
    getProjectStatistics(goalId: $goalId) {
      ...ProjectStatistics
    }
  }
}
    ${ProjectStatisticsFragmentDoc}`;
export const CheckCodeReviewPointsDocument = gql`
    mutation checkCodeReviewPoints($goalId: ID!) {
  student {
    tryDecreaseCodeReviewPoints(goalId: $goalId)
  }
}
    `;
export const GetCodeReviewPointChargedOffDocument = gql`
    query getCodeReviewPointChargedOff($goalId: ID!) {
  student {
    getCodeReviewPointChargedOff(goalId: $goalId)
  }
}
    `;
export const FinishProjectDocument = gql`
    mutation finishProject($taskId: ID!) {
  sc21ProjectFlow {
    finishProject(taskId: $taskId)
  }
}
    `;
export const RegisterToProjectDocument = gql`
    mutation registerToProject($goalId: ID!) {
  sc21ProjectFlow {
    registerForProject(goalId: $goalId)
  }
}
    `;
export const RetryCreatePrivateGitlabProjectDocument = gql`
    mutation retryCreatePrivateGitlabProject($studentAnswerId: ID!) {
  student {
    retryCreatePrivateGitlabProject(studentAnswerId: $studentAnswerId)
  }
}
    `;
export const RetryProjectDocument = gql`
    mutation retryProject($taskId: ID!) {
  sc21ProjectFlow {
    retryProject(taskId: $taskId)
  }
}
    `;
export const StartProjectDocument = gql`
    mutation startProject($goalId: ID!) {
  sc21ProjectFlow {
    startProject(goalId: $goalId)
  }
}
    `;
export const PublicProfileGetAchievementsDocument = gql`
    query publicProfileGetAchievements($userId: UUID!) {
  school21 {
    getBadgesPublicProfile(userId: $userId) {
      points
      id
      badge {
        id
        name
        avatarUrl
      }
    }
  }
}
    `;
export const PublicProfileLoadAverageLogtimeDocument = gql`
    query publicProfileLoadAverageLogtime($login: String!, $schoolID: UUID!, $date: Date!) {
  school21 {
    loadAverageLogtime(login: $login, schoolID: $schoolID, date: $date) {
      week
      month
      weekPerMonth
    }
  }
}
    `;
export const PublicProfileGetCoalitionDocument = gql`
    query publicProfileGetCoalition($userId: UUID!) {
  student {
    getUserTournamentWidget(userId: $userId) {
      coalitionMember {
        coalition {
          avatarUrl
          color
          name
          memberCount
        }
        currentTournamentPowerRank {
          rank
          power {
            id
            points
          }
        }
      }
      lastTournamentResult {
        userRank
        power
      }
    }
  }
}
    `;
export const PublicProfileGetCredentialsByLoginDocument = gql`
    query publicProfileGetCredentialsByLogin($login: String!) {
  school21 {
    getStudentByLogin(login: $login) {
      studentId
      userId
      schoolId
      isActive
      isGraduate
    }
  }
}
    `;
export const PublicProfileGetStudentTrafficDocument = gql`
    query publicProfileGetStudentTraffic($login: String!, $schoolID: UUID!, $date: Date!) {
  student {
    getStudentTraffic(login: $login, schoolID: $schoolID, date: $date) {
      days {
        date
        periodOnCampus
        periodAuthorizSDP
        periodAuthorizIMac
      }
      endDate
      startDate
    }
  }
}
    `;
export const PublicProfileGetPersonalInfoDocument = gql`
    query publicProfileGetPersonalInfo($userId: UUID!, $studentId: UUID!, $login: String!, $schoolId: UUID!) {
  school21 {
    getAvatarByUserId(userId: $userId)
    getStageGroupS21PublicProfile(studentId: $studentId) {
      waveId
      waveName
      eduForm
    }
    getExperiencePublicProfile(userId: $userId) {
      value
      level {
        levelCode
        range {
          leftBorder
          rightBorder
        }
      }
      cookiesCount
      coinsCount
      codeReviewPoints
      isReviewPointsConsistent
    }
    getEmailbyUserId(userId: $userId)
    getClassRoomByLogin(login: $login) {
      id
      number
      floor
    }
  }
  student {
    getWorkstationByLogin(login: $login) {
      workstationId
      hostName
      row
      number
    }
    getFeedbackStatisticsAverageScore(studentId: $studentId) {
      countFeedback
      feedbackAverageScore {
        categoryCode
        categoryName
        value
      }
    }
  }
  user {
    getSchool(schoolId: $schoolId) {
      id
      fullName
      shortName
      address
    }
  }
}
    `;
export const PublicProfileGetSoftSkillsDocument = gql`
    query publicProfileGetSoftSkills($studentId: UUID!) {
  school21 {
    getSoftSkillsByStudentId(studentId: $studentId) {
      id
      type
      code
      totalPower
      hueSaturationLightness
    }
    getSoftSkillLimitByStudentId(studentId: $studentId) {
      powerLimit
    }
  }
}
    `;
export const PublicProfileGetXpGraphDocument = gql`
    query publicProfileGetXpGraph($userId: UUID!) {
  student {
    getExperienceHistoryDate(userId: $userId) {
      history {
        awardDate
        expValue
      }
    }
  }
}
    `;
export const GetCredentialsByLoginDocument = gql`
    query getCredentialsByLogin($login: String!) {
  school21 {
    getStudentByLogin(login: $login) {
      studentId
      userId
      schoolId
      isActive
      isGraduate
    }
  }
}
    `;
export const GetProfileUserDocument = gql`
    query getProfileUser($userId: UUID!) {
  school21 {
    getBasePublicProfile(userId: $userId) {
      avatarUrl
      firstName
      middleName
      lastName
    }
    getExperiencePublicProfile(userId: $userId) {
      ...CurrentUserExperience
    }
  }
}
    ${CurrentUserExperienceFragmentDoc}`;
export const GetProjectAttemptEvaluationsInfoByStudentDocument = gql`
    query getProjectAttemptEvaluationsInfoByStudent($goalId: ID!, $studentId: UUID!) {
  school21 {
    getProjectAttemptEvaluationsInfo(goalId: $goalId, studentId: $studentId) {
      ...ProjectAttemptEvaluations
    }
  }
}
    ${ProjectAttemptEvaluationsFragmentDoc}`;
export const GetProjectInfoByStudentDocument = gql`
    query getProjectInfoByStudent($goalId: ID!, $studentId: UUID!) {
  school21 {
    getModuleById(goalId: $goalId, studentId: $studentId) {
      ...ProjectInfo
    }
    getModuleCoverInformation(goalId: $goalId, studentId: $studentId) {
      ...ModuleCoverInfo
    }
    getP2PChecksInfo(goalId: $goalId, studentId: $studentId) {
      ...P2PInfo
    }
    getGoalRetryInfo(goalId: $goalId, studentId: $studentId) {
      ...StudentGoalRetryInfo
    }
  }
}
    ${ProjectInfoFragmentDoc}
${ModuleCoverInfoFragmentDoc}
${P2PInfoFragmentDoc}
${StudentGoalRetryInfoFragmentDoc}`;
export const GetProjectTeamWithMembersByStudentDocument = gql`
    query getProjectTeamWithMembersByStudent($goalId: ID!, $studentId: UUID!) {
  school21 {
    getProjectTeamWithMembers(goalId: $goalId, studentId: $studentId) {
      ...TeamWithMembers
    }
  }
}
    ${TeamWithMembersFragmentDoc}`;
export const BonusesGetBadgesWithFakePublicProfileDocument = gql`
    query bonusesGetBadgesWithFakePublicProfile($userId: UUID) {
  school21 {
    getBadgesWithFakePublicProfile(userId: $userId) {
      ...UserAchievements
    }
  }
}
    ${UserAchievementsFragmentDoc}`;
export const BonusesGetUserIdByLoginDocument = gql`
    query bonusesGetUserIdByLogin($login: String!) {
  school21 {
    getUserIdByLogin(login: $login)
  }
}
    `;

export type SdkFunctionWrapper = <T>(action: (requestHeaders?:Record<string, string>) => Promise<T>, operationName: string, operationType?: string, variables?: any) => Promise<T>;


const defaultWrapper: SdkFunctionWrapper = (action, _operationName, _operationType, _variables) => action();

export function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {
  return {
    getStudentIsDeadlinesEnabled(variables?: GetStudentIsDeadlinesEnabledQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetStudentIsDeadlinesEnabledQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetStudentIsDeadlinesEnabledQuery>(GetStudentIsDeadlinesEnabledDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getStudentIsDeadlinesEnabled', 'query', variables);
    },
    getUserFeatureFlags(variables: GetUserFeatureFlagsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetUserFeatureFlagsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetUserFeatureFlagsQuery>(GetUserFeatureFlagsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getUserFeatureFlags', 'query', variables);
    },
    userRoleLoaderGetRoles(variables?: UserRoleLoaderGetRolesQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<UserRoleLoaderGetRolesQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<UserRoleLoaderGetRolesQuery>(UserRoleLoaderGetRolesDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'userRoleLoaderGetRoles', 'query', variables);
    },
    createEventFeedback(variables: CreateEventFeedbackMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CreateEventFeedbackMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<CreateEventFeedbackMutation>(CreateEventFeedbackDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'createEventFeedback', 'mutation', variables);
    },
    eventsWithoutFeedback(variables: EventsWithoutFeedbackQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<EventsWithoutFeedbackQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<EventsWithoutFeedbackQuery>(EventsWithoutFeedbackDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'eventsWithoutFeedback', 'query', variables);
    },
    getIsHonorRatingNeeded(variables?: GetIsHonorRatingNeededQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetIsHonorRatingNeededQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetIsHonorRatingNeededQuery>(GetIsHonorRatingNeededDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getIsHonorRatingNeeded', 'query', variables);
    },
    getAllInCompletedStudentFeedbackPopup(variables?: GetAllInCompletedStudentFeedbackPopupQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetAllInCompletedStudentFeedbackPopupQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetAllInCompletedStudentFeedbackPopupQuery>(GetAllInCompletedStudentFeedbackPopupDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getAllInCompletedStudentFeedbackPopup', 'query', variables);
    },
    getStudentFeedbackById(variables: GetStudentFeedbackByIdQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetStudentFeedbackByIdQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetStudentFeedbackByIdQuery>(GetStudentFeedbackByIdDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getStudentFeedbackById', 'query', variables);
    },
    saveStudentFeedbackResults(variables: SaveStudentFeedbackResultsMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<SaveStudentFeedbackResultsMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<SaveStudentFeedbackResultsMutation>(SaveStudentFeedbackResultsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'saveStudentFeedbackResults', 'mutation', variables);
    },
    deadlinesGetStudentData(variables?: DeadlinesGetStudentDataQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<DeadlinesGetStudentDataQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<DeadlinesGetStudentDataQuery>(DeadlinesGetStudentDataDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'deadlinesGetStudentData', 'query', variables);
    },
    deadlineReminderGetClosestDeadlinePopup(variables?: DeadlineReminderGetClosestDeadlinePopupQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<DeadlineReminderGetClosestDeadlinePopupQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<DeadlineReminderGetClosestDeadlinePopupQuery>(DeadlineReminderGetClosestDeadlinePopupDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'deadlineReminderGetClosestDeadlinePopup', 'query', variables);
    },
    getUserNotifications(variables: GetUserNotificationsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetUserNotificationsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetUserNotificationsQuery>(GetUserNotificationsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getUserNotifications', 'query', variables);
    },
    getUserNotificationsCount(variables?: GetUserNotificationsCountQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetUserNotificationsCountQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetUserNotificationsCountQuery>(GetUserNotificationsCountDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getUserNotificationsCount', 'query', variables);
    },
    readUserNotifications(variables: ReadUserNotificationsMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<ReadUserNotificationsMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<ReadUserNotificationsMutation>(ReadUserNotificationsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'readUserNotifications', 'mutation', variables);
    },
    logCentrifugoError(variables: LogCentrifugoErrorMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<LogCentrifugoErrorMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<LogCentrifugoErrorMutation>(LogCentrifugoErrorDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'logCentrifugoError', 'mutation', variables);
    },
    getStudentCurrentProjects(variables: GetStudentCurrentProjectsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetStudentCurrentProjectsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetStudentCurrentProjectsQuery>(GetStudentCurrentProjectsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getStudentCurrentProjects', 'query', variables);
    },
    SetDefaultRole(variables: SetDefaultRoleMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<SetDefaultRoleMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<SetDefaultRoleMutation>(SetDefaultRoleDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'SetDefaultRole', 'mutation', variables);
    },
    getGlobalSearchResults(variables: GetGlobalSearchResultsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetGlobalSearchResultsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetGlobalSearchResultsQuery>(GetGlobalSearchResultsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getGlobalSearchResults', 'query', variables);
    },
    getSearchHistory(variables?: GetSearchHistoryQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetSearchHistoryQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetSearchHistoryQuery>(GetSearchHistoryDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getSearchHistory', 'query', variables);
    },
    getSaleProgressPercentages(variables?: GetSaleProgressPercentagesQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetSaleProgressPercentagesQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetSaleProgressPercentagesQuery>(GetSaleProgressPercentagesDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getSaleProgressPercentages', 'query', variables);
    },
    deadlinesGetDeadlines(variables: DeadlinesGetDeadlinesQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<DeadlinesGetDeadlinesQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<DeadlinesGetDeadlinesQuery>(DeadlinesGetDeadlinesDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'deadlinesGetDeadlines', 'query', variables);
    },
    bookPenaltySlot(variables: BookPenaltySlotMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<BookPenaltySlotMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<BookPenaltySlotMutation>(BookPenaltySlotDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'bookPenaltySlot', 'mutation', variables);
    },
    getPenaltySlots(variables: GetPenaltySlotsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetPenaltySlotsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetPenaltySlotsQuery>(GetPenaltySlotsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getPenaltySlots', 'query', variables);
    },
    getPenaltyList(variables: GetPenaltyListQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetPenaltyListQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetPenaltyListQuery>(GetPenaltyListDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getPenaltyList', 'query', variables);
    },
    getUserRestrictionsInfo(variables?: GetUserRestrictionsInfoQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetUserRestrictionsInfoQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetUserRestrictionsInfoQuery>(GetUserRestrictionsInfoDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getUserRestrictionsInfo', 'query', variables);
    },
    getCurrentUser(variables?: GetCurrentUserQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetCurrentUserQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetCurrentUserQuery>(GetCurrentUserDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getCurrentUser', 'query', variables);
    },
    getCurrentUserExperience(variables?: GetCurrentUserExperienceQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetCurrentUserExperienceQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetCurrentUserExperienceQuery>(GetCurrentUserExperienceDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getCurrentUserExperience', 'query', variables);
    },
    getToken(variables?: GetTokenQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetTokenQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetTokenQuery>(GetTokenDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getToken', 'query', variables);
    },
    getIsApiDocumentationEnabled(variables?: GetIsApiDocumentationEnabledQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetIsApiDocumentationEnabledQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetIsApiDocumentationEnabledQuery>(GetIsApiDocumentationEnabledDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getIsApiDocumentationEnabled', 'query', variables);
    },
    getTournamentNotificationResults(variables?: GetTournamentNotificationResultsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetTournamentNotificationResultsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetTournamentNotificationResultsQuery>(GetTournamentNotificationResultsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getTournamentNotificationResults', 'query', variables);
    },
    markTournamentNotificationShown(variables: MarkTournamentNotificationShownMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<MarkTournamentNotificationShownMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<MarkTournamentNotificationShownMutation>(MarkTournamentNotificationShownDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'markTournamentNotificationShown', 'mutation', variables);
    },
    userGetTheme(variables: UserGetThemeQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<UserGetThemeQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<UserGetThemeQuery>(UserGetThemeDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'userGetTheme', 'query', variables);
    },
    switchUserTheme(variables: SwitchUserThemeMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<SwitchUserThemeMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<SwitchUserThemeMutation>(SwitchUserThemeDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'switchUserTheme', 'mutation', variables);
    },
    getAgendaActivityOrExam(variables: GetAgendaActivityOrExamQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetAgendaActivityOrExamQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetAgendaActivityOrExamQuery>(GetAgendaActivityOrExamDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getAgendaActivityOrExam', 'query', variables);
    },
    unsubscribeFromAgendaEvent(variables: UnsubscribeFromAgendaEventMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<UnsubscribeFromAgendaEventMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<UnsubscribeFromAgendaEventMutation>(UnsubscribeFromAgendaEventDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'unsubscribeFromAgendaEvent', 'mutation', variables);
    },
    getAgendaEvents(variables: GetAgendaEventsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetAgendaEventsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetAgendaEventsQuery>(GetAgendaEventsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getAgendaEvents', 'query', variables);
    },
    getAgendaP2P(variables: GetAgendaP2PQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetAgendaP2PQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetAgendaP2PQuery>(GetAgendaP2PDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getAgendaP2P', 'query', variables);
    },
    getAsapWidgets(variables?: GetAsapWidgetsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetAsapWidgetsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetAsapWidgetsQuery>(GetAsapWidgetsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getAsapWidgets', 'query', variables);
    },
    dashboardHeaderGetInfo(variables?: DashboardHeaderGetInfoQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<DashboardHeaderGetInfoQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<DashboardHeaderGetInfoQuery>(DashboardHeaderGetInfoDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'dashboardHeaderGetInfo', 'query', variables);
    },
    getStudentStageGroupS21(variables: GetStudentStageGroupS21QueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetStudentStageGroupS21Query> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetStudentStageGroupS21Query>(GetStudentStageGroupS21Document, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getStudentStageGroupS21', 'query', variables);
    },
    getDashboardBuildings(variables?: GetDashboardBuildingsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetDashboardBuildingsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetDashboardBuildingsQuery>(GetDashboardBuildingsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getDashboardBuildings', 'query', variables);
    },
    getDashboardWorkstation(variables: GetDashboardWorkstationQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetDashboardWorkstationQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetDashboardWorkstationQuery>(GetDashboardWorkstationDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getDashboardWorkstation', 'query', variables);
    },
    widgetAchievementsGetLastBadges(variables?: WidgetAchievementsGetLastBadgesQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<WidgetAchievementsGetLastBadgesQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<WidgetAchievementsGetLastBadgesQuery>(WidgetAchievementsGetLastBadgesDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'widgetAchievementsGetLastBadges', 'query', variables);
    },
    getAvailableCodeReviewProjects(variables: GetAvailableCodeReviewProjectsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetAvailableCodeReviewProjectsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetAvailableCodeReviewProjectsQuery>(GetAvailableCodeReviewProjectsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getAvailableCodeReviewProjects', 'query', variables);
    },
    getFirstRoundCodeReviewProjects(variables: GetFirstRoundCodeReviewProjectsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetFirstRoundCodeReviewProjectsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetFirstRoundCodeReviewProjectsQuery>(GetFirstRoundCodeReviewProjectsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getFirstRoundCodeReviewProjects', 'query', variables);
    },
    getSecondRoundCodeReviewProjects(variables: GetSecondRoundCodeReviewProjectsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetSecondRoundCodeReviewProjectsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetSecondRoundCodeReviewProjectsQuery>(GetSecondRoundCodeReviewProjectsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getSecondRoundCodeReviewProjects', 'query', variables);
    },
    getStudentFinishedProjects(variables: GetStudentFinishedProjectsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetStudentFinishedProjectsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetStudentFinishedProjectsQuery>(GetStudentFinishedProjectsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getStudentFinishedProjects', 'query', variables);
    },
    getInvitationsCount(variables?: GetInvitationsCountQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetInvitationsCountQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetInvitationsCountQuery>(GetInvitationsCountDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getInvitationsCount', 'query', variables);
    },
    getProjectsWithOpenTeams(variables?: GetProjectsWithOpenTeamsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetProjectsWithOpenTeamsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetProjectsWithOpenTeamsQuery>(GetProjectsWithOpenTeamsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getProjectsWithOpenTeams', 'query', variables);
    },
    getTeamLeadPeriodSettings(variables: GetTeamLeadPeriodSettingsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetTeamLeadPeriodSettingsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetTeamLeadPeriodSettingsQuery>(GetTeamLeadPeriodSettingsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getTeamLeadPeriodSettings', 'query', variables);
    },
    acceptInvitationToTeam(variables: AcceptInvitationToTeamMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<AcceptInvitationToTeamMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<AcceptInvitationToTeamMutation>(AcceptInvitationToTeamDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'acceptInvitationToTeam', 'mutation', variables);
    },
    getProjectTeamMembersByTeam(variables: GetProjectTeamMembersByTeamQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetProjectTeamMembersByTeamQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetProjectTeamMembersByTeamQuery>(GetProjectTeamMembersByTeamDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getProjectTeamMembersByTeam', 'query', variables);
    },
    rejectInvitationToTeam(variables: RejectInvitationToTeamMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<RejectInvitationToTeamMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<RejectInvitationToTeamMutation>(RejectInvitationToTeamDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'rejectInvitationToTeam', 'mutation', variables);
    },
    getRecommendedProjects(variables: GetRecommendedProjectsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetRecommendedProjectsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetRecommendedProjectsQuery>(GetRecommendedProjectsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getRecommendedProjects', 'query', variables);
    },
    getInternshipAttemptEvaluationsInfo(variables: GetInternshipAttemptEvaluationsInfoQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetInternshipAttemptEvaluationsInfoQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetInternshipAttemptEvaluationsInfoQuery>(GetInternshipAttemptEvaluationsInfoDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getInternshipAttemptEvaluationsInfo', 'query', variables);
    },
    getInternshipInfo(variables: GetInternshipInfoQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetInternshipInfoQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetInternshipInfoQuery>(GetInternshipInfoDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getInternshipInfo', 'query', variables);
    },
    registerToInternship(variables: RegisterToInternshipMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<RegisterToInternshipMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<RegisterToInternshipMutation>(RegisterToInternshipDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'registerToInternship', 'mutation', variables);
    },
    retryInternship(variables: RetryInternshipMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<RetryInternshipMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<RetryInternshipMutation>(RetryInternshipDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'retryInternship', 'mutation', variables);
    },
    calendarGetMyBookings(variables: CalendarGetMyBookingsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CalendarGetMyBookingsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<CalendarGetMyBookingsQuery>(CalendarGetMyBookingsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'calendarGetMyBookings', 'query', variables);
    },
    calendarGetCodeReviewData(variables: CalendarGetCodeReviewDataQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CalendarGetCodeReviewDataQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<CalendarGetCodeReviewDataQuery>(CalendarGetCodeReviewDataDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'calendarGetCodeReviewData', 'query', variables);
    },
    getProjectTeamMembers(variables: GetProjectTeamMembersQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetProjectTeamMembersQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetProjectTeamMembersQuery>(GetProjectTeamMembersDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getProjectTeamMembers', 'query', variables);
    },
    calendarGetEvents(variables: CalendarGetEventsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CalendarGetEventsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<CalendarGetEventsQuery>(CalendarGetEventsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'calendarGetEvents', 'query', variables);
    },
    calendarGetExams(variables: CalendarGetExamsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CalendarGetExamsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<CalendarGetExamsQuery>(CalendarGetExamsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'calendarGetExams', 'query', variables);
    },
    calendarGetNameLessStudentTimeslotsForReview(variables: CalendarGetNameLessStudentTimeslotsForReviewQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CalendarGetNameLessStudentTimeslotsForReviewQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<CalendarGetNameLessStudentTimeslotsForReviewQuery>(CalendarGetNameLessStudentTimeslotsForReviewDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'calendarGetNameLessStudentTimeslotsForReview', 'query', variables);
    },
    getPenaltyReasons(variables?: GetPenaltyReasonsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetPenaltyReasonsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetPenaltyReasonsQuery>(GetPenaltyReasonsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getPenaltyReasons', 'query', variables);
    },
    calendarGetStudentCodeReviews(variables: CalendarGetStudentCodeReviewsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CalendarGetStudentCodeReviewsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<CalendarGetStudentCodeReviewsQuery>(CalendarGetStudentCodeReviewsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'calendarGetStudentCodeReviews', 'query', variables);
    },
    getUsers(variables: GetUsersQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetUsersQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetUsersQuery>(GetUsersDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getUsers', 'query', variables);
    },
    createParticipantEvent(variables: CreateParticipantEventMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CreateParticipantEventMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<CreateParticipantEventMutation>(CreateParticipantEventDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'createParticipantEvent', 'mutation', variables);
    },
    getActivityTypes(variables?: GetActivityTypesQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetActivityTypesQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetActivityTypesQuery>(GetActivityTypesDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getActivityTypes', 'query', variables);
    },
    updateParticipantEvent(variables: UpdateParticipantEventMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<UpdateParticipantEventMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<UpdateParticipantEventMutation>(UpdateParticipantEventDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'updateParticipantEvent', 'mutation', variables);
    },
    getMySuggestedActivities(variables: GetMySuggestedActivitiesQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetMySuggestedActivitiesQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetMySuggestedActivitiesQuery>(GetMySuggestedActivitiesDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getMySuggestedActivities', 'query', variables);
    },
    getStageClassmates(variables?: GetStageClassmatesQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetStageClassmatesQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetStageClassmatesQuery>(GetStageClassmatesDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getStageClassmates', 'query', variables);
    },
    calendarAddCodeReviewToEventSlot(variables: CalendarAddCodeReviewToEventSlotMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CalendarAddCodeReviewToEventSlotMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<CalendarAddCodeReviewToEventSlotMutation>(CalendarAddCodeReviewToEventSlotDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'calendarAddCodeReviewToEventSlot', 'mutation', variables);
    },
    cancelParticipantEvent(variables: CancelParticipantEventMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CancelParticipantEventMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<CancelParticipantEventMutation>(CancelParticipantEventDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'cancelParticipantEvent', 'mutation', variables);
    },
    createCalendarEventFeedback(variables: CreateCalendarEventFeedbackMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CreateCalendarEventFeedbackMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<CreateCalendarEventFeedbackMutation>(CreateCalendarEventFeedbackDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'createCalendarEventFeedback', 'mutation', variables);
    },
    CalendarGetUploadedAndNotConfirmedVideos(variables: CalendarGetUploadedAndNotConfirmedVideosQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CalendarGetUploadedAndNotConfirmedVideosQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<CalendarGetUploadedAndNotConfirmedVideosQuery>(CalendarGetUploadedAndNotConfirmedVideosDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'CalendarGetUploadedAndNotConfirmedVideos', 'query', variables);
    },
    CalendarUpdateFilledChecklistWithOnlineReview(variables: CalendarUpdateFilledChecklistWithOnlineReviewMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CalendarUpdateFilledChecklistWithOnlineReviewMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<CalendarUpdateFilledChecklistWithOnlineReviewMutation>(CalendarUpdateFilledChecklistWithOnlineReviewDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'CalendarUpdateFilledChecklistWithOnlineReview', 'mutation', variables);
    },
    calendarGetStudentExperience(variables?: CalendarGetStudentExperienceQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CalendarGetStudentExperienceQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<CalendarGetStudentExperienceQuery>(CalendarGetStudentExperienceDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'calendarGetStudentExperience', 'query', variables);
    },
    calendarAddBookingToEventSlot(variables: CalendarAddBookingToEventSlotMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CalendarAddBookingToEventSlotMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<CalendarAddBookingToEventSlotMutation>(CalendarAddBookingToEventSlotDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'calendarAddBookingToEventSlot', 'mutation', variables);
    },
    calendarAddEvent(variables: CalendarAddEventMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CalendarAddEventMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<CalendarAddEventMutation>(CalendarAddEventDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'calendarAddEvent', 'mutation', variables);
    },
    calendarChangeEventSlot(variables: CalendarChangeEventSlotMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CalendarChangeEventSlotMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<CalendarChangeEventSlotMutation>(CalendarChangeEventSlotDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'calendarChangeEventSlot', 'mutation', variables);
    },
    calendarDeleteEventSlot(variables: CalendarDeleteEventSlotMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CalendarDeleteEventSlotMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<CalendarDeleteEventSlotMutation>(CalendarDeleteEventSlotDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'calendarDeleteEventSlot', 'mutation', variables);
    },
    EventsGetActivityFeedback(variables: EventsGetActivityFeedbackQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<EventsGetActivityFeedbackQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<EventsGetActivityFeedbackQuery>(EventsGetActivityFeedbackDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'EventsGetActivityFeedback', 'query', variables);
    },
    EventsGetStudents(variables: EventsGetStudentsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<EventsGetStudentsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<EventsGetStudentsQuery>(EventsGetStudentsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'EventsGetStudents', 'query', variables);
    },
    calendarGetModule(variables: CalendarGetModuleQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CalendarGetModuleQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<CalendarGetModuleQuery>(CalendarGetModuleDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'calendarGetModule', 'query', variables);
    },
    calendarGetMyReviews(variables?: CalendarGetMyReviewsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CalendarGetMyReviewsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<CalendarGetMyReviewsQuery>(CalendarGetMyReviewsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'calendarGetMyReviews', 'query', variables);
    },
    competitionCoalitionGetMyCoalitionMembers(variables?: CompetitionCoalitionGetMyCoalitionMembersQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CompetitionCoalitionGetMyCoalitionMembersQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<CompetitionCoalitionGetMyCoalitionMembersQuery>(CompetitionCoalitionGetMyCoalitionMembersDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'competitionCoalitionGetMyCoalitionMembers', 'query', variables);
    },
    competitionCoalitionGetUserTournament(variables?: CompetitionCoalitionGetUserTournamentQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CompetitionCoalitionGetUserTournamentQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<CompetitionCoalitionGetUserTournamentQuery>(CompetitionCoalitionGetUserTournamentDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'competitionCoalitionGetUserTournament', 'query', variables);
    },
    competitionGetCurrentOrLastTournament(variables?: CompetitionGetCurrentOrLastTournamentQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CompetitionGetCurrentOrLastTournamentQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<CompetitionGetCurrentOrLastTournamentQuery>(CompetitionGetCurrentOrLastTournamentDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'competitionGetCurrentOrLastTournament', 'query', variables);
    },
    competitionGetStudentRankInTournament(variables: CompetitionGetStudentRankInTournamentQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CompetitionGetStudentRankInTournamentQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<CompetitionGetStudentRankInTournamentQuery>(CompetitionGetStudentRankInTournamentDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'competitionGetStudentRankInTournament', 'query', variables);
    },
    GetTop5AndMeCoalitionTournamentMembers(variables: GetTop5AndMeCoalitionTournamentMembersQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetTop5AndMeCoalitionTournamentMembersQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetTop5AndMeCoalitionTournamentMembersQuery>(GetTop5AndMeCoalitionTournamentMembersDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'GetTop5AndMeCoalitionTournamentMembers', 'query', variables);
    },
    getCourseConsistencyInfo(variables: GetCourseConsistencyInfoQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetCourseConsistencyInfoQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetCourseConsistencyInfoQuery>(GetCourseConsistencyInfoDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getCourseConsistencyInfo', 'query', variables);
    },
    getLocalCourseGoals(variables: GetLocalCourseGoalsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetLocalCourseGoalsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetLocalCourseGoalsQuery>(GetLocalCourseGoalsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getLocalCourseGoals', 'query', variables);
    },
    getCourseAttemptStatistic(variables: GetCourseAttemptStatisticQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetCourseAttemptStatisticQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetCourseAttemptStatisticQuery>(GetCourseAttemptStatisticDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getCourseAttemptStatistic', 'query', variables);
    },
    giveUpExam(variables: GiveUpExamMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GiveUpExamMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<GiveUpExamMutation>(GiveUpExamDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'giveUpExam', 'mutation', variables);
    },
    getGoalAttemptStatistic(variables: GetGoalAttemptStatisticQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetGoalAttemptStatisticQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetGoalAttemptStatisticQuery>(GetGoalAttemptStatisticDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getGoalAttemptStatistic', 'query', variables);
    },
    addToFavourites(variables: AddToFavouritesMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<AddToFavouritesMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<AddToFavouritesMutation>(AddToFavouritesDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'addToFavourites', 'mutation', variables);
    },
    removeFromFavourites(variables: RemoveFromFavouritesMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<RemoveFromFavouritesMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<RemoveFromFavouritesMutation>(RemoveFromFavouritesDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'removeFromFavourites', 'mutation', variables);
    },
    getSearchItems(variables: GetSearchItemsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetSearchItemsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetSearchItemsQuery>(GetSearchItemsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getSearchItems', 'query', variables);
    },
    getChildrenTagsList(variables: GetChildrenTagsListQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetChildrenTagsListQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetChildrenTagsListQuery>(GetChildrenTagsListDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getChildrenTagsList', 'query', variables);
    },
    getParentTagsList(variables: GetParentTagsListQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetParentTagsListQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetParentTagsListQuery>(GetParentTagsListDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getParentTagsList', 'query', variables);
    },
    getCollectionList(variables?: GetCollectionListQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetCollectionListQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetCollectionListQuery>(GetCollectionListDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getCollectionList', 'query', variables);
    },
    getProjectAccessGroupIdByStudentAnswerId(variables: GetProjectAccessGroupIdByStudentAnswerIdQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetProjectAccessGroupIdByStudentAnswerIdQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetProjectAccessGroupIdByStudentAnswerIdQuery>(GetProjectAccessGroupIdByStudentAnswerIdDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getProjectAccessGroupIdByStudentAnswerId', 'query', variables);
    },
    getTaskSolutionType(variables: GetTaskSolutionTypeQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetTaskSolutionTypeQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetTaskSolutionTypeQuery>(GetTaskSolutionTypeDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getTaskSolutionType', 'query', variables);
    },
    getPlatfSolutionInfo(variables: GetPlatfSolutionInfoQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetPlatfSolutionInfoQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetPlatfSolutionInfoQuery>(GetPlatfSolutionInfoDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getPlatfSolutionInfo', 'query', variables);
    },
    saveSolutionComment(variables: SaveSolutionCommentMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<SaveSolutionCommentMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<SaveSolutionCommentMutation>(SaveSolutionCommentDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'saveSolutionComment', 'mutation', variables);
    },
    markFileSolutionPending(variables: MarkFileSolutionPendingMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<MarkFileSolutionPendingMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<MarkFileSolutionPendingMutation>(MarkFileSolutionPendingDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'markFileSolutionPending', 'mutation', variables);
    },
    markFileSolutionFailedToUpload(variables: MarkFileSolutionFailedToUploadMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<MarkFileSolutionFailedToUploadMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<MarkFileSolutionFailedToUploadMutation>(MarkFileSolutionFailedToUploadDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'markFileSolutionFailedToUpload', 'mutation', variables);
    },
    markFileSolutionUploadCancelled(variables: MarkFileSolutionUploadCancelledMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<MarkFileSolutionUploadCancelledMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<MarkFileSolutionUploadCancelledMutation>(MarkFileSolutionUploadCancelledDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'markFileSolutionUploadCancelled', 'mutation', variables);
    },
    markFileSolutionUploadedStatus(variables: MarkFileSolutionUploadedStatusMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<MarkFileSolutionUploadedStatusMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<MarkFileSolutionUploadedStatusMutation>(MarkFileSolutionUploadedStatusDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'markFileSolutionUploadedStatus', 'mutation', variables);
    },
    getPenaltiesCount(variables: GetPenaltiesCountQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetPenaltiesCountQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetPenaltiesCountQuery>(GetPenaltiesCountDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getPenaltiesCount', 'query', variables);
    },
    getNotificationUserSettings(variables?: GetNotificationUserSettingsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetNotificationUserSettingsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetNotificationUserSettingsQuery>(GetNotificationUserSettingsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getNotificationUserSettings', 'query', variables);
    },
    saveNotificationUserSettings(variables: SaveNotificationUserSettingsMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<SaveNotificationUserSettingsMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<SaveNotificationUserSettingsMutation>(SaveNotificationUserSettingsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'saveNotificationUserSettings', 'mutation', variables);
    },
    passwordChangeSetPassword(variables: PasswordChangeSetPasswordMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<PasswordChangeSetPasswordMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<PasswordChangeSetPasswordMutation>(PasswordChangeSetPasswordDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'passwordChangeSetPassword', 'mutation', variables);
    },
    getCoinsHistory(variables?: GetCoinsHistoryQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetCoinsHistoryQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetCoinsHistoryQuery>(GetCoinsHistoryDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getCoinsHistory', 'query', variables);
    },
    publicProfileGetProjects(variables: PublicProfileGetProjectsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<PublicProfileGetProjectsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<PublicProfileGetProjectsQuery>(PublicProfileGetProjectsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'publicProfileGetProjects', 'query', variables);
    },
    publicProfileLoadStageGroups(variables: PublicProfileLoadStageGroupsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<PublicProfileLoadStageGroupsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<PublicProfileLoadStageGroupsQuery>(PublicProfileLoadStageGroupsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'publicProfileLoadStageGroups', 'query', variables);
    },
    getDismissInfoByStudentId(variables: GetDismissInfoByStudentIdQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetDismissInfoByStudentIdQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetDismissInfoByStudentIdQuery>(GetDismissInfoByStudentIdDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getDismissInfoByStudentId', 'query', variables);
    },
    StudentProfileGetUserRestrictionsByUserIdAndSchoolId(variables: StudentProfileGetUserRestrictionsByUserIdAndSchoolIdQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<StudentProfileGetUserRestrictionsByUserIdAndSchoolIdQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<StudentProfileGetUserRestrictionsByUserIdAndSchoolIdQuery>(StudentProfileGetUserRestrictionsByUserIdAndSchoolIdDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'StudentProfileGetUserRestrictionsByUserIdAndSchoolId', 'query', variables);
    },
    getCourseInfoByStudent(variables: GetCourseInfoByStudentQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetCourseInfoByStudentQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetCourseInfoByStudentQuery>(GetCourseInfoByStudentDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getCourseInfoByStudent', 'query', variables);
    },
    getCampusUserAvatar(variables: GetCampusUserAvatarQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetCampusUserAvatarQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetCampusUserAvatarQuery>(GetCampusUserAvatarDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getCampusUserAvatar', 'query', variables);
    },
    getCampusUserIdByLogin(variables: GetCampusUserIdByLoginQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetCampusUserIdByLoginQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetCampusUserIdByLoginQuery>(GetCampusUserIdByLoginDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getCampusUserIdByLogin', 'query', variables);
    },
    getCampusBuildings(variables?: GetCampusBuildingsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetCampusBuildingsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetCampusBuildingsQuery>(GetCampusBuildingsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getCampusBuildings', 'query', variables);
    },
    getCampusPlanOccupied(variables: GetCampusPlanOccupiedQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetCampusPlanOccupiedQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetCampusPlanOccupiedQuery>(GetCampusPlanOccupiedDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getCampusPlanOccupied', 'query', variables);
    },
    getCampusCurrentUser(variables?: GetCampusCurrentUserQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetCampusCurrentUserQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetCampusCurrentUserQuery>(GetCampusCurrentUserDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getCampusCurrentUser', 'query', variables);
    },
    getCampusWorkstation(variables: GetCampusWorkstationQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetCampusWorkstationQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetCampusWorkstationQuery>(GetCampusWorkstationDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getCampusWorkstation', 'query', variables);
    },
    getFilledChecklist(variables: GetFilledChecklistQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetFilledChecklistQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetFilledChecklistQuery>(GetFilledChecklistDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getFilledChecklist', 'query', variables);
    },
    saveFilledChecklist(variables: SaveFilledChecklistMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<SaveFilledChecklistMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<SaveFilledChecklistMutation>(SaveFilledChecklistDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'saveFilledChecklist', 'mutation', variables);
    },
    completeFirstCodeReviewRound(variables: CompleteFirstCodeReviewRoundMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CompleteFirstCodeReviewRoundMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<CompleteFirstCodeReviewRoundMutation>(CompleteFirstCodeReviewRoundDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'completeFirstCodeReviewRound', 'mutation', variables);
    },
    evaluateCodeReviewProjectAndReviewers(variables: EvaluateCodeReviewProjectAndReviewersMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<EvaluateCodeReviewProjectAndReviewersMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<EvaluateCodeReviewProjectAndReviewersMutation>(EvaluateCodeReviewProjectAndReviewersDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'evaluateCodeReviewProjectAndReviewers', 'mutation', variables);
    },
    getCodeReviewMyStudent(variables: GetCodeReviewMyStudentQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetCodeReviewMyStudentQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetCodeReviewMyStudentQuery>(GetCodeReviewMyStudentDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getCodeReviewMyStudent', 'query', variables);
    },
    getCoreReviewImportedLanguagesForCurrentVersion(variables: GetCoreReviewImportedLanguagesForCurrentVersionQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetCoreReviewImportedLanguagesForCurrentVersionQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetCoreReviewImportedLanguagesForCurrentVersionQuery>(GetCoreReviewImportedLanguagesForCurrentVersionDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getCoreReviewImportedLanguagesForCurrentVersion', 'query', variables);
    },
    getCodeReviewProjectInfo(variables: GetCodeReviewProjectInfoQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetCodeReviewProjectInfoQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetCodeReviewProjectInfoQuery>(GetCodeReviewProjectInfoDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getCodeReviewProjectInfo', 'query', variables);
    },
    getStudentCodeReviewByStudentGoalId(variables: GetStudentCodeReviewByStudentGoalIdQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetStudentCodeReviewByStudentGoalIdQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetStudentCodeReviewByStudentGoalIdQuery>(GetStudentCodeReviewByStudentGoalIdDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getStudentCodeReviewByStudentGoalId', 'query', variables);
    },
    removeCodeReviewBooking(variables: RemoveCodeReviewBookingMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<RemoveCodeReviewBookingMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<RemoveCodeReviewBookingMutation>(RemoveCodeReviewBookingDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'removeCodeReviewBooking', 'mutation', variables);
    },
    ProjectMapGetStudentGraphTemplate(variables?: ProjectMapGetStudentGraphTemplateQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<ProjectMapGetStudentGraphTemplateQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<ProjectMapGetStudentGraphTemplateQuery>(ProjectMapGetStudentGraphTemplateDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'ProjectMapGetStudentGraphTemplate', 'query', variables);
    },
    ProjectMapGetStudentStageGroups(variables: ProjectMapGetStudentStageGroupsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<ProjectMapGetStudentStageGroupsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<ProjectMapGetStudentStageGroupsQuery>(ProjectMapGetStudentStageGroupsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'ProjectMapGetStudentStageGroups', 'query', variables);
    },
    ProjectMapGetStudentStateGraphNode(variables: ProjectMapGetStudentStateGraphNodeQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<ProjectMapGetStudentStateGraphNodeQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<ProjectMapGetStudentStateGraphNodeQuery>(ProjectMapGetStudentStateGraphNodeDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'ProjectMapGetStudentStateGraphNode', 'query', variables);
    },
    getGraphGetCurrentUser(variables?: GetGraphGetCurrentUserQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetGraphGetCurrentUserQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetGraphGetCurrentUserQuery>(GetGraphGetCurrentUserDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getGraphGetCurrentUser', 'query', variables);
    },
    getGraphGetStudentAvatar(variables: GetGraphGetStudentAvatarQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetGraphGetStudentAvatarQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetGraphGetStudentAvatarQuery>(GetGraphGetStudentAvatarDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getGraphGetStudentAvatar', 'query', variables);
    },
    getGraphStudentIdByLogin(variables: GetGraphStudentIdByLoginQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetGraphStudentIdByLoginQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetGraphStudentIdByLoginQuery>(GetGraphStudentIdByLoginDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getGraphStudentIdByLogin', 'query', variables);
    },
    getClassmates(variables?: GetClassmatesQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetClassmatesQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetClassmatesQuery>(GetClassmatesDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getClassmates', 'query', variables);
    },
    saveHonorRatings(variables: SaveHonorRatingsMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<SaveHonorRatingsMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<SaveHonorRatingsMutation>(SaveHonorRatingsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'saveHonorRatings', 'mutation', variables);
    },
    getUpcomingEvents(variables: GetUpcomingEventsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetUpcomingEventsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetUpcomingEventsQuery>(GetUpcomingEventsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getUpcomingEvents', 'query', variables);
    },
    StartP2pCheck(variables: StartP2pCheckMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<StartP2pCheckMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<StartP2pCheckMutation>(StartP2pCheckDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'StartP2pCheck', 'mutation', variables);
    },
    updateP2POnlineType(variables: UpdateP2POnlineTypeMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<UpdateP2POnlineTypeMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<UpdateP2POnlineTypeMutation>(UpdateP2POnlineTypeDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'updateP2POnlineType', 'mutation', variables);
    },
    markAbsenceAtP2P(variables: MarkAbsenceAtP2PMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<MarkAbsenceAtP2PMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<MarkAbsenceAtP2PMutation>(MarkAbsenceAtP2PDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'markAbsenceAtP2P', 'mutation', variables);
    },
    removeP2P(variables: RemoveP2PMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<RemoveP2PMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<RemoveP2PMutation>(RemoveP2PDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'removeP2P', 'mutation', variables);
    },
    subscribeToEvent(variables: SubscribeToEventMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<SubscribeToEventMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<SubscribeToEventMutation>(SubscribeToEventDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'subscribeToEvent', 'mutation', variables);
    },
    unsubscribeFromEvent(variables: UnsubscribeFromEventMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<UnsubscribeFromEventMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<UnsubscribeFromEventMutation>(UnsubscribeFromEventDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'unsubscribeFromEvent', 'mutation', variables);
    },
    getImportedLanguagesForCurrentVersion(variables: GetImportedLanguagesForCurrentVersionQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetImportedLanguagesForCurrentVersionQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetImportedLanguagesForCurrentVersionQuery>(GetImportedLanguagesForCurrentVersionDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getImportedLanguagesForCurrentVersion', 'query', variables);
    },
    getTasksById(variables: GetTasksByIdQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetTasksByIdQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetTasksByIdQuery>(GetTasksByIdDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getTasksById', 'query', variables);
    },
    getGitlabSettingsToken(variables: GetGitlabSettingsTokenQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetGitlabSettingsTokenQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetGitlabSettingsTokenQuery>(GetGitlabSettingsTokenDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getGitlabSettingsToken', 'query', variables);
    },
    getTaskContentFiles(variables: GetTaskContentFilesQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetTaskContentFilesQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetTaskContentFilesQuery>(GetTaskContentFilesDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getTaskContentFiles', 'query', variables);
    },
    getProjectConsistencyInfo(variables: GetProjectConsistencyInfoQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetProjectConsistencyInfoQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetProjectConsistencyInfoQuery>(GetProjectConsistencyInfoDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getProjectConsistencyInfo', 'query', variables);
    },
    getLocalCourseGoalsInfo(variables: GetLocalCourseGoalsInfoQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetLocalCourseGoalsInfoQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetLocalCourseGoalsInfoQuery>(GetLocalCourseGoalsInfoDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getLocalCourseGoalsInfo', 'query', variables);
    },
    AttachedFilesWidgetGetProjectsSelection(variables: AttachedFilesWidgetGetProjectsSelectionQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<AttachedFilesWidgetGetProjectsSelectionQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<AttachedFilesWidgetGetProjectsSelectionQuery>(AttachedFilesWidgetGetProjectsSelectionDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'AttachedFilesWidgetGetProjectsSelection', 'query', variables);
    },
    AttachedFilesWidgetGetSelection(variables: AttachedFilesWidgetGetSelectionQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<AttachedFilesWidgetGetSelectionQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<AttachedFilesWidgetGetSelectionQuery>(AttachedFilesWidgetGetSelectionDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'AttachedFilesWidgetGetSelection', 'query', variables);
    },
    getExecutionConditions(variables: GetExecutionConditionsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetExecutionConditionsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetExecutionConditionsQuery>(GetExecutionConditionsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getExecutionConditions', 'query', variables);
    },
    getProjectGitlabInfo(variables: GetProjectGitlabInfoQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetProjectGitlabInfoQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetProjectGitlabInfoQuery>(GetProjectGitlabInfoDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getProjectGitlabInfo', 'query', variables);
    },
    getProjectAttemptEvaluationsInfo(variables: GetProjectAttemptEvaluationsInfoQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetProjectAttemptEvaluationsInfoQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetProjectAttemptEvaluationsInfoQuery>(GetProjectAttemptEvaluationsInfoDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getProjectAttemptEvaluationsInfo', 'query', variables);
    },
    createFeedbackOnEvaluation(variables: CreateFeedbackOnEvaluationMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CreateFeedbackOnEvaluationMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<CreateFeedbackOnEvaluationMutation>(CreateFeedbackOnEvaluationDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'createFeedbackOnEvaluation', 'mutation', variables);
    },
    getProjectInfo(variables: GetProjectInfoQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetProjectInfoQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetProjectInfoQuery>(GetProjectInfoDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getProjectInfo', 'query', variables);
    },
    MediatekaGetContentItem(variables: MediatekaGetContentItemQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<MediatekaGetContentItemQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<MediatekaGetContentItemQuery>(MediatekaGetContentItemDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'MediatekaGetContentItem', 'query', variables);
    },
    getStageInfo(variables?: GetStageInfoQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetStageInfoQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetStageInfoQuery>(GetStageInfoDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getStageInfo', 'query', variables);
    },
    markOnlineReviewVideoUploaded(variables: MarkOnlineReviewVideoUploadedMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<MarkOnlineReviewVideoUploadedMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<MarkOnlineReviewVideoUploadedMutation>(MarkOnlineReviewVideoUploadedDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'markOnlineReviewVideoUploaded', 'mutation', variables);
    },
    markFilesPending(variables: MarkFilesPendingMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<MarkFilesPendingMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<MarkFilesPendingMutation>(MarkFilesPendingDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'markFilesPending', 'mutation', variables);
    },
    markOnlineReviewVideoFailedToUpload(variables: MarkOnlineReviewVideoFailedToUploadMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<MarkOnlineReviewVideoFailedToUploadMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<MarkOnlineReviewVideoFailedToUploadMutation>(MarkOnlineReviewVideoFailedToUploadDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'markOnlineReviewVideoFailedToUpload', 'mutation', variables);
    },
    markOnlineReviewVideoUploadCancelled(variables: MarkOnlineReviewVideoUploadCancelledMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<MarkOnlineReviewVideoUploadCancelledMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<MarkOnlineReviewVideoUploadCancelledMutation>(MarkOnlineReviewVideoUploadCancelledDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'markOnlineReviewVideoUploadCancelled', 'mutation', variables);
    },
    capitulationFromTheCourse(variables: CapitulationFromTheCourseMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CapitulationFromTheCourseMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<CapitulationFromTheCourseMutation>(CapitulationFromTheCourseDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'capitulationFromTheCourse', 'mutation', variables);
    },
    finishCourse(variables: FinishCourseMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<FinishCourseMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<FinishCourseMutation>(FinishCourseDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'finishCourse', 'mutation', variables);
    },
    registrationForTheCourse(variables: RegistrationForTheCourseMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<RegistrationForTheCourseMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<RegistrationForTheCourseMutation>(RegistrationForTheCourseDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'registrationForTheCourse', 'mutation', variables);
    },
    retryCourse(variables: RetryCourseMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<RetryCourseMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<RetryCourseMutation>(RetryCourseDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'retryCourse', 'mutation', variables);
    },
    getCourseCoverInformation(variables: GetCourseCoverInformationQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetCourseCoverInformationQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetCourseCoverInformationQuery>(GetCourseCoverInformationDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getCourseCoverInformation', 'query', variables);
    },
    getCourseEvaluationRules(variables: GetCourseEvaluationRulesQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetCourseEvaluationRulesQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetCourseEvaluationRulesQuery>(GetCourseEvaluationRulesDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getCourseEvaluationRules', 'query', variables);
    },
    getExamInfo(variables: GetExamInfoQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetExamInfoQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetExamInfoQuery>(GetExamInfoDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getExamInfo', 'query', variables);
    },
    registerForExam(variables: RegisterForExamMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<RegisterForExamMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<RegisterForExamMutation>(RegisterForExamDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'registerForExam', 'mutation', variables);
    },
    tryAgainExamModule(variables: TryAgainExamModuleMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<TryAgainExamModuleMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<TryAgainExamModuleMutation>(TryAgainExamModuleDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'tryAgainExamModule', 'mutation', variables);
    },
    getProjectTeamWithMembers(variables: GetProjectTeamWithMembersQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetProjectTeamWithMembersQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetProjectTeamWithMembersQuery>(GetProjectTeamWithMembersDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getProjectTeamWithMembers', 'query', variables);
    },
    getIsDisbandRequestAlreadySent(variables: GetIsDisbandRequestAlreadySentQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetIsDisbandRequestAlreadySentQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetIsDisbandRequestAlreadySentQuery>(GetIsDisbandRequestAlreadySentDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getIsDisbandRequestAlreadySent', 'query', variables);
    },
    disbandAndFail(variables: DisbandAndFailMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<DisbandAndFailMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<DisbandAndFailMutation>(DisbandAndFailDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'disbandAndFail', 'mutation', variables);
    },
    sendDisbandRequest(variables: SendDisbandRequestMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<SendDisbandRequestMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<SendDisbandRequestMutation>(SendDisbandRequestDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'sendDisbandRequest', 'mutation', variables);
    },
    getAvailableStudentsForTeams(variables: GetAvailableStudentsForTeamsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetAvailableStudentsForTeamsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetAvailableStudentsForTeamsQuery>(GetAvailableStudentsForTeamsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getAvailableStudentsForTeams', 'query', variables);
    },
    cancelInvitation(variables: CancelInvitationMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CancelInvitationMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<CancelInvitationMutation>(CancelInvitationDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'cancelInvitation', 'mutation', variables);
    },
    sendInvitation(variables: SendInvitationMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<SendInvitationMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<SendInvitationMutation>(SendInvitationDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'sendInvitation', 'mutation', variables);
    },
    changeProjectTeamName(variables: ChangeProjectTeamNameMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<ChangeProjectTeamNameMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<ChangeProjectTeamNameMutation>(ChangeProjectTeamNameDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'changeProjectTeamName', 'mutation', variables);
    },
    leaveAndDisbandTeam(variables: LeaveAndDisbandTeamMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<LeaveAndDisbandTeamMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<LeaveAndDisbandTeamMutation>(LeaveAndDisbandTeamDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'leaveAndDisbandTeam', 'mutation', variables);
    },
    leaveTeam(variables: LeaveTeamMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<LeaveTeamMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<LeaveTeamMutation>(LeaveTeamDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'leaveTeam', 'mutation', variables);
    },
    getPlatfSolution(variables: GetPlatfSolutionQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetPlatfSolutionQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetPlatfSolutionQuery>(GetPlatfSolutionDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getPlatfSolution', 'query', variables);
    },
    getLinkToPrivateStudentGitlabProjectByAnswerId(variables: GetLinkToPrivateStudentGitlabProjectByAnswerIdQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetLinkToPrivateStudentGitlabProjectByAnswerIdQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetLinkToPrivateStudentGitlabProjectByAnswerIdQuery>(GetLinkToPrivateStudentGitlabProjectByAnswerIdDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getLinkToPrivateStudentGitlabProjectByAnswerId', 'query', variables);
    },
    getProjectStatistics(variables: GetProjectStatisticsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetProjectStatisticsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetProjectStatisticsQuery>(GetProjectStatisticsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getProjectStatistics', 'query', variables);
    },
    checkCodeReviewPoints(variables: CheckCodeReviewPointsMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<CheckCodeReviewPointsMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<CheckCodeReviewPointsMutation>(CheckCodeReviewPointsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'checkCodeReviewPoints', 'mutation', variables);
    },
    getCodeReviewPointChargedOff(variables: GetCodeReviewPointChargedOffQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetCodeReviewPointChargedOffQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetCodeReviewPointChargedOffQuery>(GetCodeReviewPointChargedOffDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getCodeReviewPointChargedOff', 'query', variables);
    },
    finishProject(variables: FinishProjectMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<FinishProjectMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<FinishProjectMutation>(FinishProjectDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'finishProject', 'mutation', variables);
    },
    registerToProject(variables: RegisterToProjectMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<RegisterToProjectMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<RegisterToProjectMutation>(RegisterToProjectDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'registerToProject', 'mutation', variables);
    },
    retryCreatePrivateGitlabProject(variables: RetryCreatePrivateGitlabProjectMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<RetryCreatePrivateGitlabProjectMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<RetryCreatePrivateGitlabProjectMutation>(RetryCreatePrivateGitlabProjectDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'retryCreatePrivateGitlabProject', 'mutation', variables);
    },
    retryProject(variables: RetryProjectMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<RetryProjectMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<RetryProjectMutation>(RetryProjectDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'retryProject', 'mutation', variables);
    },
    startProject(variables: StartProjectMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<StartProjectMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<StartProjectMutation>(StartProjectDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'startProject', 'mutation', variables);
    },
    publicProfileGetAchievements(variables: PublicProfileGetAchievementsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<PublicProfileGetAchievementsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<PublicProfileGetAchievementsQuery>(PublicProfileGetAchievementsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'publicProfileGetAchievements', 'query', variables);
    },
    publicProfileLoadAverageLogtime(variables: PublicProfileLoadAverageLogtimeQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<PublicProfileLoadAverageLogtimeQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<PublicProfileLoadAverageLogtimeQuery>(PublicProfileLoadAverageLogtimeDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'publicProfileLoadAverageLogtime', 'query', variables);
    },
    publicProfileGetCoalition(variables: PublicProfileGetCoalitionQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<PublicProfileGetCoalitionQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<PublicProfileGetCoalitionQuery>(PublicProfileGetCoalitionDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'publicProfileGetCoalition', 'query', variables);
    },
    publicProfileGetCredentialsByLogin(variables: PublicProfileGetCredentialsByLoginQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<PublicProfileGetCredentialsByLoginQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<PublicProfileGetCredentialsByLoginQuery>(PublicProfileGetCredentialsByLoginDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'publicProfileGetCredentialsByLogin', 'query', variables);
    },
    publicProfileGetStudentTraffic(variables: PublicProfileGetStudentTrafficQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<PublicProfileGetStudentTrafficQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<PublicProfileGetStudentTrafficQuery>(PublicProfileGetStudentTrafficDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'publicProfileGetStudentTraffic', 'query', variables);
    },
    publicProfileGetPersonalInfo(variables: PublicProfileGetPersonalInfoQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<PublicProfileGetPersonalInfoQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<PublicProfileGetPersonalInfoQuery>(PublicProfileGetPersonalInfoDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'publicProfileGetPersonalInfo', 'query', variables);
    },
    publicProfileGetSoftSkills(variables: PublicProfileGetSoftSkillsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<PublicProfileGetSoftSkillsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<PublicProfileGetSoftSkillsQuery>(PublicProfileGetSoftSkillsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'publicProfileGetSoftSkills', 'query', variables);
    },
    publicProfileGetXpGraph(variables: PublicProfileGetXpGraphQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<PublicProfileGetXpGraphQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<PublicProfileGetXpGraphQuery>(PublicProfileGetXpGraphDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'publicProfileGetXpGraph', 'query', variables);
    },
    getCredentialsByLogin(variables: GetCredentialsByLoginQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetCredentialsByLoginQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetCredentialsByLoginQuery>(GetCredentialsByLoginDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getCredentialsByLogin', 'query', variables);
    },
    getProfileUser(variables: GetProfileUserQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetProfileUserQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetProfileUserQuery>(GetProfileUserDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getProfileUser', 'query', variables);
    },
    getProjectAttemptEvaluationsInfoByStudent(variables: GetProjectAttemptEvaluationsInfoByStudentQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetProjectAttemptEvaluationsInfoByStudentQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetProjectAttemptEvaluationsInfoByStudentQuery>(GetProjectAttemptEvaluationsInfoByStudentDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getProjectAttemptEvaluationsInfoByStudent', 'query', variables);
    },
    getProjectInfoByStudent(variables: GetProjectInfoByStudentQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetProjectInfoByStudentQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetProjectInfoByStudentQuery>(GetProjectInfoByStudentDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getProjectInfoByStudent', 'query', variables);
    },
    getProjectTeamWithMembersByStudent(variables: GetProjectTeamWithMembersByStudentQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetProjectTeamWithMembersByStudentQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetProjectTeamWithMembersByStudentQuery>(GetProjectTeamWithMembersByStudentDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getProjectTeamWithMembersByStudent', 'query', variables);
    },
    bonusesGetBadgesWithFakePublicProfile(variables?: BonusesGetBadgesWithFakePublicProfileQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<BonusesGetBadgesWithFakePublicProfileQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<BonusesGetBadgesWithFakePublicProfileQuery>(BonusesGetBadgesWithFakePublicProfileDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'bonusesGetBadgesWithFakePublicProfile', 'query', variables);
    },
    bonusesGetUserIdByLogin(variables: BonusesGetUserIdByLoginQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<BonusesGetUserIdByLoginQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<BonusesGetUserIdByLoginQuery>(BonusesGetUserIdByLoginDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'bonusesGetUserIdByLogin', 'query', variables);
    }
  };
}
export type Sdk = ReturnType<typeof getSdk>;
export type GetStudentIsDeadlinesEnabledQueryVariables = Exact<{ [key: string]: never; }>;


export type GetStudentIsDeadlinesEnabledQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', isDeadlinesEnabled: boolean } | null };

export type GetUserFeatureFlagsQueryVariables = Exact<{
  entityId: Scalars['String']['input'];
}>;


export type GetUserFeatureFlagsQuery = { __typename?: 'Query', user?: { __typename?: 'UserQueries', getAllBackendConfigurations: Array<{ __typename?: 'Configuration', propertyCode: string, value: string }> } | null };

export type UserRoleLoaderGetRolesQueryVariables = Exact<{ [key: string]: never; }>;


export type UserRoleLoaderGetRolesQuery = { __typename?: 'Query', user?: { __typename?: 'UserQueries', getCurrentUser: { __typename?: 'User', id: string, functionalRoles: Array<{ __typename?: 'FunctionalRole', code: string }>, studentRoles?: Array<{ __typename?: 'StudentRole', id: string, status: RoleStatus, school: { __typename?: 'SafeSchool', id: string, shortName: string, organizationType: string } }> | null, userSchoolPermissions: Array<{ __typename?: 'UserSchoolPermission', schoolId?: string | null, permissions: Array<string> }>, systemAdminRole?: { __typename?: 'SystemAdminRole', id: string } | null, businessAdminRolesV2?: Array<{ __typename?: 'BusinessAdminRoleV2', id: string, orgUnitId: string, school?: { __typename?: 'SafeSchool', id: string, organizationType: string } | null }> | null }, getCurrentUserSchoolRoles: Array<{ __typename?: 'UserSchoolRole', schoolId?: string | null }>, getCurrentUserRoles: Array<{ __typename?: 'UserRole', orgUnitId: string, orgUnitShortName: string, roleCode: string }> } | null };

export type CreateEventFeedbackMutationVariables = Exact<{
  calendarEventId: Scalars['ID']['input'];
  rating: Scalars['Int']['input'];
  comment?: InputMaybe<Scalars['String']['input']>;
}>;


export type CreateEventFeedbackMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', createCalendarEventFeedback: { __typename?: 'StudentEventFeedback', createDate: Date, rating: number, comment?: string | null, user: { __typename?: 'User', login?: string | null } } } | null };

export type EventsWithoutFeedbackQueryVariables = Exact<{
  from: Scalars['DateTime']['input'];
  to: Scalars['DateTime']['input'];
}>;


export type EventsWithoutFeedbackQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getCalendarEventsWithoutFeedback: Array<{ __typename?: 'CalendarEvent', id: string, activity?: { __typename?: 'ActivityEvent', eventId: string, name: string, endDate: Date } | null } | null> } | null };

export type GetIsHonorRatingNeededQueryVariables = Exact<{ [key: string]: never; }>;


export type GetIsHonorRatingNeededQuery = { __typename?: 'Query', honorRating?: { __typename?: 'HonorRatingQueries', isHonorRatingNeeded: boolean } | null };

export type GetAllInCompletedStudentFeedbackPopupQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAllInCompletedStudentFeedbackPopupQuery = { __typename?: 'Query', sc21StudentTaskCheck?: { __typename?: 'SC21StudentTaskCheckQueries', getAllInCompletedStudentFeedbackPopup: Array<{ __typename?: 'StudentFeedbackPopup', studentFeedbackId: string, goalName: string, resultAttemptDate: Date }> } | null };

export type GetStudentFeedbackByIdQueryVariables = Exact<{
  studentFeedbackId: Scalars['ID']['input'];
}>;


export type GetStudentFeedbackByIdQuery = { __typename?: 'Query', sc21StudentTaskCheck?: { __typename?: 'SC21StudentTaskCheckQueries', getStudentFeedbackById: { __typename?: 'StudentFeedback', id: string, studentGoalAttemptId: string, goalId: string, goalName: string, goalExecutionType: ModuleExecutionType, pointPercent: number, resultModuleCompletion: ResultModuleCompletion, resultAttemptDate: Date, serialNumber: number, feedbackForm?: { __typename?: 'FeedbackForm', id: string, feedbackFormEnum: FeedbackFormEnum, name: string, feedbackFormQuestions: Array<{ __typename?: 'FeedbackFormQuestion', id: string, serialNumber: number, titleEn: string, descriptionEn?: string | null, feedbackSectionEnum: FeedbackSectionEnum, typeValue: string, quickActionEn?: string | null }> } | null } } | null };

export type SaveStudentFeedbackResultsMutationVariables = Exact<{
  studentFeedbackId: Scalars['ID']['input'];
  studentFeedbackResults: Array<StudentFeedbackResultInput> | StudentFeedbackResultInput;
}>;


export type SaveStudentFeedbackResultsMutation = { __typename?: 'Mutation', sc21StudentTaskCheck?: { __typename?: 'SC21StudentTaskCheckMutations', saveStudentFeedbackResults: boolean } | null };

export type DeadlinesGetStudentDataQueryVariables = Exact<{ [key: string]: never; }>;


export type DeadlinesGetStudentDataQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getStudentProfile: { __typename?: 'Student', user: { __typename?: 'User', id: string, login?: string | null, firstName: string, middleName?: string | null, lastName: string } }, getExperience: { __typename?: 'UserExperience', id: string, value: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', id: string, levelCode: number, rightBorder: number, leftBorder: number } } }, getExperienceHistory: Array<{ __typename?: 'UserExperienceHistory', id: string, awardDate: Date, experienceReceived: number } | null> } | null };

export type LevelFragment = { __typename?: 'ExperienceLevelRange', id: string, level: number, levelCode: number, leftBorder: number, rightBorder: number };

export type GoalCourseFragment = { __typename?: 'CourseCoverInformation', localCourseId?: string | null, courseName: string, courseType: CourseType, experienceFact?: number | null, finalPercentage: number, displayedCourseStatus?: DisplayedCourseStatus | null };

export type DeadlineGoalDataFragment = { __typename?: 'DeadlineGoal', goalProjects?: Array<{ __typename?: 'StudentProjectInfo', studentGoalId?: string | null, status?: DisplayedGoalStatus | null, executionType?: ModuleExecutionType | null, finalPercentage?: number | null, finalPoint?: number | null, pointTask?: number | null, project: { __typename?: 'Goal', goalName: string, goalId: string } } | null> | null, goalCourses?: Array<{ __typename?: 'CourseCoverInformation', localCourseId?: string | null, courseName: string, courseType: CourseType, experienceFact?: number | null, finalPercentage: number, displayedCourseStatus?: DisplayedCourseStatus | null } | null> | null, levels?: Array<{ __typename?: 'ExperienceLevelRange', id: string, level: number, levelCode: number, leftBorder: number, rightBorder: number } | null> | null };

export type DeadlineDataFragment = { __typename?: 'Deadline', deadlineId: string, description: string, comment?: string | null, deadlineToDaysArray: Array<number | null>, deadlineTs: Date, createTs: Date, updateTs?: Date | null, status: DeadlineStatus, rules: Array<{ __typename?: 'EvaluationRuleGroup', logicalOperatorId?: LogicalLinkTypeEnum | null, rulesInGroup: Array<{ __typename?: 'EvaluationRule', logicalOperatorId?: LogicalLinkTypeEnum | null, value: { __typename?: 'EvaluationRuleValue', fieldId: string, subFieldKey?: string | null, operator: string, value: Array<string> } }> } | null> };

export type DeadlineReminderGetClosestDeadlinePopupQueryVariables = Exact<{ [key: string]: never; }>;


export type DeadlineReminderGetClosestDeadlinePopupQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getClosestDeadlinePopup?: { __typename?: 'DeadlineStudentInfo', shiftCount: number, deadline: { __typename?: 'Deadline', deadlineId: string, description: string, comment?: string | null, deadlineToDaysArray: Array<number | null>, deadlineTs: Date, createTs: Date, updateTs?: Date | null, status: DeadlineStatus, rules: Array<{ __typename?: 'EvaluationRuleGroup', logicalOperatorId?: LogicalLinkTypeEnum | null, rulesInGroup: Array<{ __typename?: 'EvaluationRule', logicalOperatorId?: LogicalLinkTypeEnum | null, value: { __typename?: 'EvaluationRuleValue', fieldId: string, subFieldKey?: string | null, operator: string, value: Array<string> } }> } | null> }, deadlineGoal?: { __typename?: 'DeadlineGoal', goalProjects?: Array<{ __typename?: 'StudentProjectInfo', studentGoalId?: string | null, status?: DisplayedGoalStatus | null, executionType?: ModuleExecutionType | null, finalPercentage?: number | null, finalPoint?: number | null, pointTask?: number | null, project: { __typename?: 'Goal', goalName: string, goalId: string } } | null> | null, goalCourses?: Array<{ __typename?: 'CourseCoverInformation', localCourseId?: string | null, courseName: string, courseType: CourseType, experienceFact?: number | null, finalPercentage: number, displayedCourseStatus?: DisplayedCourseStatus | null } | null> | null, levels?: Array<{ __typename?: 'ExperienceLevelRange', id: string, level: number, levelCode: number, leftBorder: number, rightBorder: number } | null> | null } | null } | null } | null };

export type GetUserNotificationsQueryVariables = Exact<{
  paging: PagingInput;
}>;


export type GetUserNotificationsQuery = { __typename?: 'Query', s21Notification?: { __typename?: 'S21NotificationQueries', getS21Notifications: { __typename?: 'S21NotificationReport', totalCount: number, groupNames: Array<string>, notifications: Array<{ __typename?: 'S21Notification', id: string, relatedObjectType: S21RelatedObjectEnum, relatedObjectId: string, message: string, time: Date, wasRead: boolean, groupName?: string | null }> } } | null };

export type GetUserNotificationsCountQueryVariables = Exact<{
  wasReadIncluded?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type GetUserNotificationsCountQuery = { __typename?: 'Query', s21Notification?: { __typename?: 'S21NotificationQueries', getS21NotificationsCount: number } | null };

export type ReadUserNotificationsMutationVariables = Exact<{
  notificationIds: Array<Scalars['ID']['input']> | Scalars['ID']['input'];
}>;


export type ReadUserNotificationsMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', readNotifications: Array<string> } | null };

export type LogCentrifugoErrorMutationVariables = Exact<{
  jsonMessage: Scalars['String']['input'];
}>;


export type LogCentrifugoErrorMutation = { __typename?: 'Mutation', school21?: { __typename?: 'School21Mutations', logCentrifugoError: boolean } | null };

export type StudentProjectItemFragment = { __typename?: 'StudentItem', goalId?: number | null, name: string, description: string, experience: number, dateTime?: Date | null, finalPercentage?: number | null, laboriousness: number, executionType?: ModuleExecutionType | null, goalStatus?: DisplayedGoalStatus | null, courseType?: CourseType | null, displayedCourseStatus?: DisplayedCourseStatus | null, amountAnswers?: number | null, amountMembers?: number | null, amountJoinedMembers?: number | null, amountReviewedAnswers?: number | null, amountCodeReviewMembers?: number | null, amountCurrentCodeReviewMembers?: number | null, groupName: string, localCourseId?: number | null };

export type GetStudentCurrentProjectsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type GetStudentCurrentProjectsQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getStudentCurrentProjects: Array<{ __typename?: 'StudentItem', goalId?: number | null, name: string, description: string, experience: number, dateTime?: Date | null, finalPercentage?: number | null, laboriousness: number, executionType?: ModuleExecutionType | null, goalStatus?: DisplayedGoalStatus | null, courseType?: CourseType | null, displayedCourseStatus?: DisplayedCourseStatus | null, amountAnswers?: number | null, amountMembers?: number | null, amountJoinedMembers?: number | null, amountReviewedAnswers?: number | null, amountCodeReviewMembers?: number | null, amountCurrentCodeReviewMembers?: number | null, groupName: string, localCourseId?: number | null } | null> } | null };

export type SetDefaultRoleMutationVariables = Exact<{
  role: Roles;
  orgUnitId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type SetDefaultRoleMutation = { __typename?: 'Mutation', user?: { __typename?: 'UserMutations', setUserRoleDefaultContext_v2: boolean } | null };

export type GlobalSearchCoursesSearchResultFragment = { __typename?: 'CoursesSearchResult', count?: number | null, courses: Array<{ __typename?: 'StudentItem', goalId?: number | null, name: string, displayedCourseStatus?: DisplayedCourseStatus | null, executionType?: ModuleExecutionType | null, finalPercentage?: number | null, experience: number, courseType?: CourseType | null, localCourseId?: number | null, goalStatus?: DisplayedGoalStatus | null } | null> };

export type GlobalSearchProjectsSearchResultFragment = { __typename?: 'ProjectsSearchResult', count?: number | null, projects: Array<{ __typename?: 'StudentProjectInfo', studentTaskId?: string | null, status?: DisplayedGoalStatus | null, finalPercentage?: number | null, finalPoint?: number | null, executionType?: ModuleExecutionType | null, project: { __typename?: 'Goal', goalId: string, goalName: string } } | null> };

export type GlobalSearchProfilesSearchResultFragment = { __typename?: 'ProfilesSearchResult', count?: number | null, profiles: Array<{ __typename?: 'S21StudentPublicProfileBasicInfo', login: string, firstName?: string | null, lastName?: string | null, level?: number | null, avatarUrl?: string | null, school?: { __typename?: 'School', shortName: string } | null } | null> };

export type GetGlobalSearchResultsQueryVariables = Exact<{
  searchString: Scalars['String']['input'];
  items: Array<InputMaybe<SearchItem>> | InputMaybe<SearchItem>;
  page: PagingInput;
}>;


export type GetGlobalSearchResultsQuery = { __typename?: 'Query', globalSearch?: { __typename?: 'GlobalSearchQueries', searchByText: { __typename?: 'GlobalSearchResult', profiles?: { __typename?: 'ProfilesSearchResult', count?: number | null, profiles: Array<{ __typename?: 'S21StudentPublicProfileBasicInfo', login: string, firstName?: string | null, lastName?: string | null, level?: number | null, avatarUrl?: string | null, school?: { __typename?: 'School', shortName: string } | null } | null> } | null, projects?: { __typename?: 'ProjectsSearchResult', count?: number | null, projects: Array<{ __typename?: 'StudentProjectInfo', studentTaskId?: string | null, status?: DisplayedGoalStatus | null, finalPercentage?: number | null, finalPoint?: number | null, executionType?: ModuleExecutionType | null, project: { __typename?: 'Goal', goalId: string, goalName: string } } | null> } | null, studentCourses?: { __typename?: 'CoursesSearchResult', count?: number | null, courses: Array<{ __typename?: 'StudentItem', goalId?: number | null, name: string, displayedCourseStatus?: DisplayedCourseStatus | null, executionType?: ModuleExecutionType | null, finalPercentage?: number | null, experience: number, courseType?: CourseType | null, localCourseId?: number | null, goalStatus?: DisplayedGoalStatus | null } | null> } | null } } | null };

export type GetSearchHistoryQueryVariables = Exact<{ [key: string]: never; }>;


export type GetSearchHistoryQuery = { __typename?: 'Query', globalSearch?: { __typename?: 'GlobalSearchQueries', getSearchHistoryTooltips: Array<{ __typename?: 'SearchTooltip', tooltipText?: string | null, tooltipCategory?: SearchItem | null } | null> } | null };

export type RpSaleInfoFragment = { __typename?: 'RpSaleProgress', rpType: RpType, progressPercentage: number };

export type GetSaleProgressPercentagesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetSaleProgressPercentagesQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getSaleProgressPercentages: Array<{ __typename?: 'RpSaleProgress', rpType: RpType, progressPercentage: number } | null> } | null };

export type DeadlinesGetDeadlinesQueryVariables = Exact<{
  deadlineStatuses: Array<DeadlineStatus> | DeadlineStatus;
  page: PagingInput;
  deadlinesFrom?: InputMaybe<Scalars['DateTime']['input']>;
  deadlinesTo?: InputMaybe<Scalars['DateTime']['input']>;
  sorting?: InputMaybe<Array<InputMaybe<SortingField>> | InputMaybe<SortingField>>;
}>;


export type DeadlinesGetDeadlinesQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getDeadlines: Array<{ __typename?: 'DeadlineStudentInfo', shiftCount: number, deadline: { __typename?: 'Deadline', deadlineId: string, description: string, comment?: string | null, deadlineToDaysArray: Array<number | null>, deadlineTs: Date, createTs: Date, updateTs?: Date | null, status: DeadlineStatus, rules: Array<{ __typename?: 'EvaluationRuleGroup', logicalOperatorId?: LogicalLinkTypeEnum | null, rulesInGroup: Array<{ __typename?: 'EvaluationRule', logicalOperatorId?: LogicalLinkTypeEnum | null, value: { __typename?: 'EvaluationRuleValue', fieldId: string, subFieldKey?: string | null, operator: string, value: Array<string> } }> } | null> }, shiftRequests: Array<{ __typename?: 'DeadlineShiftRequest', deadlineShiftRequestId: string, status: DeadlineShiftRequestStatus, daysToShift: number, createTs: Date } | null>, deadlineGoal?: { __typename?: 'DeadlineGoal', goalProjects?: Array<{ __typename?: 'StudentProjectInfo', studentGoalId?: string | null, status?: DisplayedGoalStatus | null, executionType?: ModuleExecutionType | null, finalPercentage?: number | null, finalPoint?: number | null, pointTask?: number | null, project: { __typename?: 'Goal', goalName: string, goalId: string } } | null> | null, goalCourses?: Array<{ __typename?: 'CourseCoverInformation', localCourseId?: string | null, courseName: string, courseType: CourseType, experienceFact?: number | null, finalPercentage: number, displayedCourseStatus?: DisplayedCourseStatus | null } | null> | null, levels?: Array<{ __typename?: 'ExperienceLevelRange', id: string, level: number, levelCode: number, leftBorder: number, rightBorder: number } | null> | null } | null } | null> } | null };

export type BookPenaltySlotMutationVariables = Exact<{
  penaltyId: Scalars['ID']['input'];
  slotId: Scalars['ID']['input'];
}>;


export type BookPenaltySlotMutation = { __typename?: 'Mutation', penalty?: { __typename?: 'PenaltyMutations', setPenaltyBooking: string } | null };

export type PenaltySlotFragment = { __typename?: 'PenaltySlot', id: string, startTime?: Date | null, endTime?: Date | null, description?: string | null, currentStudentsCount?: number | null, maxStudentsCount?: number | null, duration?: number | null };

export type GetPenaltySlotsQueryVariables = Exact<{
  duration: Scalars['Int']['input'];
  page: PagingInput;
  sorting?: InputMaybe<Array<InputMaybe<SortingField>> | InputMaybe<SortingField>>;
}>;


export type GetPenaltySlotsQuery = { __typename?: 'Query', penalty?: { __typename?: 'PenaltyQueries', getPenaltyFreeSlots: Array<{ __typename?: 'PenaltySlot', id: string, startTime?: Date | null, endTime?: Date | null, description?: string | null, currentStudentsCount?: number | null, maxStudentsCount?: number | null, duration?: number | null }> } | null };

export type PenaltyFragment = { __typename?: 'Penalty', comment?: string | null, id?: string | null, duration: number, status: string, startTime?: Date | null, createTime: Date, reasonId: string, penaltySlot?: { __typename?: 'PenaltySlot', currentStudentsCount?: number | null, description?: string | null, duration?: number | null, startTime?: Date | null, id: string, endTime?: Date | null } | null };

export type GetPenaltyListQueryVariables = Exact<{
  statuses: Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>;
  from?: InputMaybe<Scalars['DateTime']['input']>;
  to?: InputMaybe<Scalars['DateTime']['input']>;
  sorting?: InputMaybe<Array<InputMaybe<SortingField>> | InputMaybe<SortingField>>;
  page: PagingInput;
}>;


export type GetPenaltyListQuery = { __typename?: 'Query', penalty?: { __typename?: 'PenaltyQueries', countMyPenalties: number, getMyPenalties: Array<{ __typename?: 'Penalty', comment?: string | null, id?: string | null, duration: number, status: string, startTime?: Date | null, createTime: Date, reasonId: string, penaltySlot?: { __typename?: 'PenaltySlot', currentStudentsCount?: number | null, description?: string | null, duration?: number | null, startTime?: Date | null, id: string, endTime?: Date | null } | null }>, getPenaltyReasons: Array<{ __typename?: 'PenaltyReason', id: string, name: string } | null> } | null };

export type GetUserRestrictionsInfoQueryVariables = Exact<{ [key: string]: never; }>;


export type GetUserRestrictionsInfoQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getUserRestrictions: Array<{ __typename?: 'UserRestriction', restrictionId: string, restrictionType: string, userId: string, schoolId: string, isActive: boolean, createdTs: Date, updatedTs?: Date | null } | null> } | null };

export type CurrentUserFragment = { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, firstName: string, middleName?: string | null, lastName: string, currentSchoolStudentId?: string | null };

export type GetCurrentUserQueryVariables = Exact<{ [key: string]: never; }>;


export type GetCurrentUserQuery = { __typename?: 'Query', user?: { __typename?: 'UserQueries', getCurrentUser: { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, firstName: string, middleName?: string | null, lastName: string, currentSchoolStudentId?: string | null } } | null };

export type CurrentUserExperienceFragment = { __typename?: 'UserExperience', id: string, cookiesCount: number, codeReviewPoints: number, coinsCount: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', id: string, levelCode: number } } };

export type GetCurrentUserExperienceQueryVariables = Exact<{ [key: string]: never; }>;


export type GetCurrentUserExperienceQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getExperience: { __typename?: 'UserExperience', id: string, cookiesCount: number, codeReviewPoints: number, coinsCount: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', id: string, levelCode: number } } } } | null };

export type GetTokenQueryVariables = Exact<{ [key: string]: never; }>;


export type GetTokenQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', generateJwtTokenForCentrifugo: string } | null };

export type GetIsApiDocumentationEnabledQueryVariables = Exact<{ [key: string]: never; }>;


export type GetIsApiDocumentationEnabledQuery = { __typename?: 'Query', sc21StudentTaskCheck?: { __typename?: 'SC21StudentTaskCheckQueries', isOpenApiAllowed: boolean } | null };

export type GetTournamentNotificationResultsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetTournamentNotificationResultsQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getTournamentResults: Array<{ __typename?: 'UserTournamentResult', id: string, power: number, coalitionRank: number, userRank: number, firstCoalitionName: string, coalitionName: string, timeClosed: Date }> } | null };

export type MarkTournamentNotificationShownMutationVariables = Exact<{
  userTournamentResultId: Array<Scalars['UUID']['input']> | Scalars['UUID']['input'];
}>;


export type MarkTournamentNotificationShownMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', markTournamentResultAsShown: Array<{ __typename?: 'UserTournamentResult', id: string, isShown: boolean }> } | null };

export type UserGetThemeQueryVariables = Exact<{
  userId: Scalars['UUID']['input'];
}>;


export type UserGetThemeQuery = { __typename?: 'Query', user?: { __typename?: 'UserQueries', getUserViewSettings: { __typename?: 'UserViewSettings', isDarkThemeEnabled: boolean, schoolViewSettingType: S21SchoolViewSettingType } } | null };

export type SwitchUserThemeMutationVariables = Exact<{
  userId: Scalars['UUID']['input'];
  isDarkThemeEnabled: Scalars['Boolean']['input'];
}>;


export type SwitchUserThemeMutation = { __typename?: 'Mutation', user?: { __typename?: 'UserMutations', switchUserTheme: boolean } | null };

export type GetAgendaActivityOrExamQueryVariables = Exact<{
  eventId: Scalars['ID']['input'];
}>;


export type GetAgendaActivityOrExamQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getEnrichedCalendar: { __typename?: 'CalendarEvent', start: Date, end: Date, description: string, exam?: { __typename?: 'Exam', currentStudentsCount: number, maxStudentCount?: number | null, isRegistered?: boolean | null, isInWaitList?: boolean | null, isWaitListActive: boolean, stopRegisterDate?: Date | null, endDate: Date, registrationAccessStatus: ExamEventRegistrationAccessStatus, goalId: string, name: string, location: string } | null, activity?: { __typename?: 'ActivityEvent', eventId: string, activityEventId: string, currentStudentsCount: number, maxStudentCount?: number | null, isRegistered?: boolean | null, isInWaitList?: boolean | null, isWaitListActive: boolean, stopRegisterDate?: Date | null, endDate: Date, activityType: string, location: string, isMandatory: boolean, description?: string | null, status?: ParticipantEventStatus | null, organizers?: Array<{ __typename?: 'User', id: string, login?: string | null }> | null } | null } } | null };

export type UnsubscribeFromAgendaEventMutationVariables = Exact<{
  eventId: Scalars['ID']['input'];
}>;


export type UnsubscribeFromAgendaEventMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', unsubscribeFromEvent: { __typename?: 'CalendarEvent', id: string } } | null };

export type GetAgendaEventsQueryVariables = Exact<{
  from: Scalars['DateTime']['input'];
  to: Scalars['DateTime']['input'];
  limit: Scalars['Int']['input'];
}>;


export type GetAgendaEventsQuery = { __typename?: 'Query', calendarEventS21?: { __typename?: 'CalendarEventS21Queries', getMyAgendaEvents: Array<{ __typename?: 'AgendaEvent', start: Date, end: Date, label: string, description: string, agendaEventType: AgendaEventType, agendaItemContext: { __typename?: 'AgendaItemContext', entityId: string, entityType: AgendaEntityType }, additionalInfo?: Array<{ __typename?: 'AgendaAdditionalInfo', key?: string | null, value?: string | null }> | null }> } | null };

export type GetAgendaP2PQueryVariables = Exact<{
  bookingId: Scalars['ID']['input'];
}>;


export type GetAgendaP2PQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getEnrichedBooking: { __typename?: 'CalendarBooking', id: string, answerId?: string | null, bookingStatus: BookingStatusEnum, isOnline: boolean, vcLinkUrl?: string | null, eventSlot: { __typename?: 'CalendarTimeSlot', start: Date, school?: { __typename?: 'School', shortName: string } | null }, task?: { __typename?: 'Task', goalId?: string | null, goalName: string, assignmentType: TaskAssignmentEnum, studentTaskAdditionalAttributes: { __typename?: 'StudentTaskAdditionalAttributes', cookiesCount: number } } | null, verifierUser?: { __typename?: 'User', id: string, login?: string | null, avatarUrl: string, userExperience?: { __typename?: 'UserExperience', level: { __typename?: 'ExperienceLevel', range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null } | null, verifiableInfo?: { __typename?: 'VerifiableInfo', verifiableStudents: Array<{ __typename?: 'VerifiableStudent', userId: string, login: string, avatarUrl: string, levelCode: number, isTeamLead?: boolean | null, school: { __typename?: 'School', shortName: string } }>, team?: { __typename?: 'Team', name: string } | null } | null, additionalChecklist?: { __typename?: 'AdditionalChecklist', filledChecklistId?: string | null } | null } } | null };

export type AsapWidgetFragment = { __typename?: 'ASAPMessage', smallImageUrl?: string | null, smallTitle: string, smallUrl?: string | null, startDate: Date, finishDate: Date, showFinishDate: boolean, fullTitle?: string | null, fullText?: string | null, fullImageUrl?: string | null, adtType: AsapWidgetTypeEnum, adtWidgetId?: number | null };

export type GetAsapWidgetsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAsapWidgetsQuery = { __typename?: 'Query', ASAP?: { __typename?: 'ASAPQueries', getASAPMessages: Array<{ __typename?: 'ASAPMessage', smallImageUrl?: string | null, smallTitle: string, smallUrl?: string | null, startDate: Date, finishDate: Date, showFinishDate: boolean, fullTitle?: string | null, fullText?: string | null, fullImageUrl?: string | null, adtType: AsapWidgetTypeEnum, adtWidgetId?: number | null }> } | null };

export type DashboardHeaderGetInfoQueryVariables = Exact<{ [key: string]: never; }>;


export type DashboardHeaderGetInfoQuery = { __typename?: 'Query', user?: { __typename?: 'UserQueries', getCurrentUser: { __typename?: 'User', id: string, login?: string | null, avatarUrl: string, firstName: string, middleName?: string | null, lastName: string, currentSchoolStudentId?: string | null, studentRoles?: Array<{ __typename?: 'StudentRole', id: string, status: RoleStatus, school: { __typename?: 'SafeSchool', id: string, shortName: string } }> | null } } | null, student?: { __typename?: 'StudentQueries', getUserTournamentWidget: { __typename?: 'UserTournamentWidget', coalitionMember?: { __typename?: 'CoalitionMember', coalition: { __typename?: 'GameCoalition', avatarUrl: string, color: string, name: string, memberCount: number }, currentTournamentPowerRank?: { __typename?: 'CoalitionMemberPowerRank', rank: number } | null } | null, lastTournamentResult?: { __typename?: 'UserTournamentResult', userRank: number } | null }, getExperience: { __typename?: 'UserExperience', id: string, value: number, cookiesCount: number, coinsCount: number, codeReviewPoints: number, isReviewPointsConsistent?: boolean | null, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', id: string, levelCode: number, rightBorder: number, leftBorder: number } } } } | null };

export type GetStudentStageGroupS21QueryVariables = Exact<{
  studentId: Scalars['UUID']['input'];
}>;


export type GetStudentStageGroupS21Query = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getStageGroupS21PublicProfile?: { __typename?: 'StageGroupS21', waveId: number, waveName: string, eduForm: string } | null } | null };

export type GetDashboardBuildingsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetDashboardBuildingsQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getBuildings: Array<{ __typename?: 'Building', id: string, classrooms: Array<{ __typename?: 'ClassRoom', id: string, number: string }> }> } | null };

export type GetDashboardWorkstationQueryVariables = Exact<{
  login: Scalars['String']['input'];
}>;


export type GetDashboardWorkstationQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getWorkstationByLogin?: { __typename?: 'WorkstationModel', id: string, classroomId: string, hostName?: string | null, classroom: { __typename?: 'ClassRoom', floor: number } } | null } | null };

export type WidgetAchievementsGetLastBadgesQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type WidgetAchievementsGetLastBadgesQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getLastBadges: Array<{ __typename?: 'UserBadgeAward', id: string, points: number, badge: { __typename?: 'Badge', name: string, avatarUrl: string }, award: { __typename?: 'Award', awardBounties: Array<{ __typename?: 'AwardBounty', awardLevelId?: number | null }> } }> } | null };

export type CodeReviewProjectFragment = { __typename?: 'CodeReview', goalId: string, goalTitle: string, studentGoalId: string, studentCodeReviewStatus: StudentCodeReviewStatus, goalExecutionType: ModuleExecutionType, studentTaskAdditionalAttributesModel: { __typename?: 'StudentTaskAdditionalAttributes', codeReviewCost: number, codeReviewDuration: number } };

export type GetAvailableCodeReviewProjectsQueryVariables = Exact<{
  paging: PagingInput;
}>;


export type GetAvailableCodeReviewProjectsQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getAvailableCodeReviewProjectsV2: { __typename?: 'AvailableCodeReviews', codeReviews: Array<{ __typename?: 'CodeReview', goalId: string, goalTitle: string, studentGoalId: string, studentCodeReviewStatus: StudentCodeReviewStatus, goalExecutionType: ModuleExecutionType, studentTaskAdditionalAttributesModel: { __typename?: 'StudentTaskAdditionalAttributes', codeReviewCost: number, codeReviewDuration: number } }>, limitInfo: { __typename?: 'CodeReviewLimitInfo', limitByWeek: number, usedByWeek: number } } } | null };

export type GetFirstRoundCodeReviewProjectsQueryVariables = Exact<{
  paging: PagingInput;
}>;


export type GetFirstRoundCodeReviewProjectsQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getFirstRoundCodeReviewProjects: Array<{ __typename?: 'CodeReview', goalId: string, goalTitle: string, studentGoalId: string, studentCodeReviewStatus: StudentCodeReviewStatus, goalExecutionType: ModuleExecutionType, studentTaskAdditionalAttributesModel: { __typename?: 'StudentTaskAdditionalAttributes', codeReviewCost: number, codeReviewDuration: number } }> } | null };

export type GetSecondRoundCodeReviewProjectsQueryVariables = Exact<{
  paging: PagingInput;
}>;


export type GetSecondRoundCodeReviewProjectsQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getSecondRoundCodeReviewProjects: Array<{ __typename?: 'CodeReview', goalId: string, goalTitle: string, studentGoalId: string, studentCodeReviewStatus: StudentCodeReviewStatus, goalExecutionType: ModuleExecutionType, studentTaskAdditionalAttributesModel: { __typename?: 'StudentTaskAdditionalAttributes', codeReviewCost: number, codeReviewDuration: number } }> } | null };

export type GetStudentFinishedProjectsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type GetStudentFinishedProjectsQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getStudentFinishedProjects: Array<{ __typename?: 'StudentItem', goalId?: number | null, name: string, description: string, experience: number, dateTime?: Date | null, finalPercentage?: number | null, laboriousness: number, executionType?: ModuleExecutionType | null, goalStatus?: DisplayedGoalStatus | null, courseType?: CourseType | null, displayedCourseStatus?: DisplayedCourseStatus | null, amountAnswers?: number | null, amountMembers?: number | null, amountJoinedMembers?: number | null, amountReviewedAnswers?: number | null, amountCodeReviewMembers?: number | null, amountCurrentCodeReviewMembers?: number | null, groupName: string, localCourseId?: number | null } | null> } | null };

export type GetInvitationsCountQueryVariables = Exact<{ [key: string]: never; }>;


export type GetInvitationsCountQuery = { __typename?: 'Query', team?: { __typename?: 'TeamQueries', getCreatedJoinTeamRequestCount: number } | null };

export type TeamMemberUserFragment = { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, levelCode: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null };

export type TeamMemberFragment = { __typename?: 'TeamMember', role: TeamRole, user?: { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, levelCode: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null } | null };

export type InvitatingTeamsToProjectFragment = { __typename?: 'TeamWithMembers', team: { __typename?: 'Team', id: string, name: string, currentTeamMemberCount: number }, captains: Array<{ __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, levelCode: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null }> };

export type CurrentTeamInvitationProjectFragment = { __typename?: 'TeamWithMembers', team: { __typename?: 'Team', id: string, name: string }, members: Array<{ __typename?: 'TeamMember', role: TeamRole, user?: { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, levelCode: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null } | null }> };

export type SoftSkillFragment = { __typename?: 'SoftSkillPoint', softSkillName: string, softSkillId: number, totalPower: number, currentUserPower: number, maxPower: number, teamRole?: TeamRole | null };

export type ProjectWithTeamInvitationsFragment = { __typename?: 'GroupProject', module: { __typename?: 'StudentModule', id: string, moduleTitle: string, openRegistration?: Date | null, startProgress?: Date | null, durationFromStageSubjectGroupPlan?: number | null, isDeadlineFree?: boolean | null, localCourseId?: string | null, studyModule: { __typename?: 'StudyModule', duration: number }, softSkills: Array<{ __typename?: 'SoftSkillPoint', softSkillName: string, softSkillId: number, totalPower: number, currentUserPower: number, maxPower: number, teamRole?: TeamRole | null }>, teamSettings?: { __typename?: 'TeamSettings', minAmountMember: number, maxAmountMember: number, location: LocationEnum } | null, currentTask?: { __typename?: 'StudentTask', id: string, task: { __typename?: 'Task', studentTaskAdditionalAttributes: { __typename?: 'StudentTaskAdditionalAttributes', pointTask?: number | null } } } | null }, currentTeam: { __typename?: 'TeamWithMembers', team: { __typename?: 'Team', id: string, name: string }, members: Array<{ __typename?: 'TeamMember', role: TeamRole, user?: { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, levelCode: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null } | null }> }, invitingTeams: Array<{ __typename?: 'TeamWithMembers', team: { __typename?: 'Team', id: string, name: string, currentTeamMemberCount: number }, captains: Array<{ __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, levelCode: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null }> }> };

export type GetProjectsWithOpenTeamsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetProjectsWithOpenTeamsQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getGroupProjectsWithOpenTeams: Array<{ __typename?: 'GroupProject', module: { __typename?: 'StudentModule', id: string, moduleTitle: string, openRegistration?: Date | null, startProgress?: Date | null, durationFromStageSubjectGroupPlan?: number | null, isDeadlineFree?: boolean | null, localCourseId?: string | null, studyModule: { __typename?: 'StudyModule', duration: number }, softSkills: Array<{ __typename?: 'SoftSkillPoint', softSkillName: string, softSkillId: number, totalPower: number, currentUserPower: number, maxPower: number, teamRole?: TeamRole | null }>, teamSettings?: { __typename?: 'TeamSettings', minAmountMember: number, maxAmountMember: number, location: LocationEnum } | null, currentTask?: { __typename?: 'StudentTask', id: string, task: { __typename?: 'Task', studentTaskAdditionalAttributes: { __typename?: 'StudentTaskAdditionalAttributes', pointTask?: number | null } } } | null }, currentTeam: { __typename?: 'TeamWithMembers', team: { __typename?: 'Team', id: string, name: string }, members: Array<{ __typename?: 'TeamMember', role: TeamRole, user?: { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, levelCode: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null } | null }> }, invitingTeams: Array<{ __typename?: 'TeamWithMembers', team: { __typename?: 'Team', id: string, name: string, currentTeamMemberCount: number }, captains: Array<{ __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, levelCode: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null }> }> }> } | null };

export type TeamLeadGoalPeriodSettingsFragment = { __typename?: 'TeamLeadGoalPeriodSettings', signUpDate: Date, beginDate: Date, checkDate: Date, deadlineDate: Date, isTeamLeadPeriodsEqual?: boolean | null };

export type GetTeamLeadPeriodSettingsQueryVariables = Exact<{
  goalId: Scalars['ID']['input'];
  currentStudentLocalCourseId: Scalars['ID']['input'];
  location: LocationEnum;
  teamLeadUserId: Scalars['UUID']['input'];
}>;


export type GetTeamLeadPeriodSettingsQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getTeamLeadPeriodSettings?: { __typename?: 'TeamLeadGoalPeriodSettings', signUpDate: Date, beginDate: Date, checkDate: Date, deadlineDate: Date, isTeamLeadPeriodsEqual?: boolean | null } | null } | null };

export type AcceptInvitationToTeamMutationVariables = Exact<{
  teamId: Scalars['UUID']['input'];
}>;


export type AcceptInvitationToTeamMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', acceptInvitation: boolean } | null };

export type GetProjectTeamMembersByTeamQueryVariables = Exact<{
  teamId: Scalars['UUID']['input'];
}>;


export type GetProjectTeamMembersByTeamQuery = { __typename?: 'Query', team?: { __typename?: 'TeamQueries', getTeamMembersByTeam: Array<{ __typename?: 'TeamMember', teamId: string, role: TeamRole, user?: { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, levelCode: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null } | null }> } | null };

export type RejectInvitationToTeamMutationVariables = Exact<{
  teamId: Scalars['UUID']['input'];
}>;


export type RejectInvitationToTeamMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', rejectInvitation: boolean } | null };

export type GetRecommendedProjectsQueryVariables = Exact<{
  userId: Scalars['ID']['input'];
}>;


export type GetRecommendedProjectsQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getRecommendedProjects: Array<{ __typename?: 'StudentItem', goalId?: number | null, name: string, description: string, experience: number, dateTime?: Date | null, finalPercentage?: number | null, laboriousness: number, executionType?: ModuleExecutionType | null, goalStatus?: DisplayedGoalStatus | null, courseType?: CourseType | null, displayedCourseStatus?: DisplayedCourseStatus | null, amountAnswers?: number | null, amountMembers?: number | null, amountJoinedMembers?: number | null, amountReviewedAnswers?: number | null, amountCodeReviewMembers?: number | null, amountCurrentCodeReviewMembers?: number | null, groupName: string, localCourseId?: number | null } | null> } | null };

export type InternshipEvaluationFeedbackFragment = { __typename?: 'ReviewFeedback', id: string, comment: string, filledChecklist: { __typename?: 'FilledChecklist', id: string }, reviewFeedbackCategoryValues: Array<{ __typename?: 'ReviewFeedbackCategoryValue', feedbackCategory: FeedbackCategoryEnum, feedbackValue: FeedbackCategoryValueEnum, id: string } | null> };

export type InternshipChecklistFragment = { __typename?: 'FilledChecklist', id: string, checklistId: string, endTimeCheck?: Date | null, startTimeCheck: Date, comment?: string | null, receivedPoint?: number | null, receivedPercentage?: number | null, quickAction?: QuickAction | null, checkType?: FilledChecklistCheckType | null, reviewer: { __typename?: 'User', avatarUrl: string, login?: string | null, businessAdminRoles?: Array<{ __typename?: 'BusinessAdminRole', id: string, school: { __typename?: 'SafeSchool', id: string, organizationType: string } }> | null }, reviewFeedback?: { __typename?: 'ReviewFeedback', id: string, comment: string, filledChecklist: { __typename?: 'FilledChecklist', id: string }, reviewFeedbackCategoryValues: Array<{ __typename?: 'ReviewFeedbackCategoryValue', feedbackCategory: FeedbackCategoryEnum, feedbackValue: FeedbackCategoryValueEnum, id: string } | null> } | null };

export type InternshipP2PEvaluationFragment = { __typename?: 'P2PEvaluationInfo', status: ProjectEvaluationStatus, checklist?: { __typename?: 'FilledChecklist', id: string, checklistId: string, endTimeCheck?: Date | null, startTimeCheck: Date, comment?: string | null, receivedPoint?: number | null, receivedPercentage?: number | null, quickAction?: QuickAction | null, checkType?: FilledChecklistCheckType | null, reviewer: { __typename?: 'User', avatarUrl: string, login?: string | null, businessAdminRoles?: Array<{ __typename?: 'BusinessAdminRole', id: string, school: { __typename?: 'SafeSchool', id: string, organizationType: string } }> | null }, reviewFeedback?: { __typename?: 'ReviewFeedback', id: string, comment: string, filledChecklist: { __typename?: 'FilledChecklist', id: string }, reviewFeedbackCategoryValues: Array<{ __typename?: 'ReviewFeedbackCategoryValue', feedbackCategory: FeedbackCategoryEnum, feedbackValue: FeedbackCategoryValueEnum, id: string } | null> } | null } | null };

export type InternshipAtemptResultFragment = { __typename?: 'StudentGoalAttempt', finalPointProject: number, finalPercentageProject: number, resultModuleCompletion: ResultModuleCompletion, resultDate: Date };

export type InternshipAttemptEvaluationsFragment = { __typename?: 'ProjectAttemptEvaluationsInfo', studentAnswerId: string, attemptResult?: { __typename?: 'StudentGoalAttempt', finalPointProject: number, finalPercentageProject: number, resultModuleCompletion: ResultModuleCompletion, resultDate: Date } | null, p2p: Array<{ __typename?: 'P2PEvaluationInfo', status: ProjectEvaluationStatus, checklist?: { __typename?: 'FilledChecklist', id: string, checklistId: string, endTimeCheck?: Date | null, startTimeCheck: Date, comment?: string | null, receivedPoint?: number | null, receivedPercentage?: number | null, quickAction?: QuickAction | null, checkType?: FilledChecklistCheckType | null, reviewer: { __typename?: 'User', avatarUrl: string, login?: string | null, businessAdminRoles?: Array<{ __typename?: 'BusinessAdminRole', id: string, school: { __typename?: 'SafeSchool', id: string, organizationType: string } }> | null }, reviewFeedback?: { __typename?: 'ReviewFeedback', id: string, comment: string, filledChecklist: { __typename?: 'FilledChecklist', id: string }, reviewFeedbackCategoryValues: Array<{ __typename?: 'ReviewFeedbackCategoryValue', feedbackCategory: FeedbackCategoryEnum, feedbackValue: FeedbackCategoryValueEnum, id: string } | null> } | null } | null }> };

export type GetInternshipAttemptEvaluationsInfoQueryVariables = Exact<{
  goalId: Scalars['ID']['input'];
}>;


export type GetInternshipAttemptEvaluationsInfoQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getProjectAttemptEvaluationsInfo: Array<{ __typename?: 'ProjectAttemptEvaluationsInfo', studentAnswerId: string, attemptResult?: { __typename?: 'StudentGoalAttempt', finalPointProject: number, finalPercentageProject: number, resultModuleCompletion: ResultModuleCompletion, resultDate: Date } | null, p2p: Array<{ __typename?: 'P2PEvaluationInfo', status: ProjectEvaluationStatus, checklist?: { __typename?: 'FilledChecklist', id: string, checklistId: string, endTimeCheck?: Date | null, startTimeCheck: Date, comment?: string | null, receivedPoint?: number | null, receivedPercentage?: number | null, quickAction?: QuickAction | null, checkType?: FilledChecklistCheckType | null, reviewer: { __typename?: 'User', avatarUrl: string, login?: string | null, businessAdminRoles?: Array<{ __typename?: 'BusinessAdminRole', id: string, school: { __typename?: 'SafeSchool', id: string, organizationType: string } }> | null }, reviewFeedback?: { __typename?: 'ReviewFeedback', id: string, comment: string, filledChecklist: { __typename?: 'FilledChecklist', id: string }, reviewFeedbackCategoryValues: Array<{ __typename?: 'ReviewFeedbackCategoryValue', feedbackCategory: FeedbackCategoryEnum, feedbackValue: FeedbackCategoryValueEnum, id: string } | null> } | null } | null }> }> } | null };

export type GroupProjectStatisticsFragment = { __typename?: 'GroupProjectStatistics', inProgressTeams: number, evaluationTeams: number, finishedTeams: number, acceptedTeams: number, failedTeams: number };

export type InternshipStudentReviewListFragment = { __typename?: 'InternshipStudentReviewList', numberReview?: number | null, studentProgressInternshipId?: number | null, reviewModelList?: Array<{ __typename?: 'InternshipStudentReview', reviewOrderNumber?: number | null, planTimeMentorReview?: Date | null, factTimeMentorReview?: Date | null, percentageMentorReview?: number | null, commentMentorReview?: string | null, threshold?: number | null } | null> | null };

export type ProjectReviewsInfoFragment = { __typename?: 'ProjectReviewsInfo', reviewByStudentCount: number, relevantReviewByStudentsCount: number, reviewByInspectionStaffCount: number, relevantReviewByInspectionStaffCount: number };

export type ProjectStatisticsFragment = { __typename?: 'ProjectStatistics', registeredStudents: number, inProgressStudents: number, evaluationStudents: number, finishedStudents: number, acceptedStudents: number, failedStudents: number, retriedStudentsPercentage: number, groupProjectStatistics?: { __typename?: 'GroupProjectStatistics', inProgressTeams: number, evaluationTeams: number, finishedTeams: number, acceptedTeams: number, failedTeams: number } | null };

export type InternshipTimelineItemFragment = { __typename?: 'ProjectTimelineItem', type: TimelineItemType, status: TimelineItemStatus, start?: Date | null, end?: Date | null, order?: number | null, children?: Array<{ __typename?: 'ProjectTimelineItem', type: TimelineItemType, elementType?: TimelineElementEnum | null, status: TimelineItemStatus, start?: Date | null, end?: Date | null, order?: number | null } | null> | null };

export type CurrentTaskInfoFragment = { __typename?: 'StudentTask', id: string, taskId: string, task: { __typename?: 'Task', id: string, assignmentType: TaskAssignmentEnum, checkTypes: Array<TaskCheckEnum>, studentTaskAdditionalAttributes: { __typename?: 'StudentTaskAdditionalAttributes', cookiesCount: number, maxCodeReviewCount: number, codeReviewCost: number, ciCdMode: GitlabCiCdType } }, lastAnswer?: { __typename?: 'StudentAnswer', id: string } | null };

export type RetrySettingsFragment = { __typename?: 'ModuleAttemptsSettings', maxModuleAttempts?: number | null, isUnlimitedAttempts: boolean };

export type InternshipStudentReviewInfoFragment = { __typename?: 'InternshipStudentReviewInfo', internshipStudentReviewList?: Array<{ __typename?: 'InternshipStudentReviewList', numberReview?: number | null, studentProgressInternshipId?: number | null, reviewModelList?: Array<{ __typename?: 'InternshipStudentReview', reviewOrderNumber?: number | null, planTimeMentorReview?: Date | null, factTimeMentorReview?: Date | null, percentageMentorReview?: number | null, commentMentorReview?: string | null, threshold?: number | null } | null> | null } | null> | null };

export type InternshipApplicantInfoFragment = { __typename?: 'InternshipStudentInfo', link?: string | null, internshipStartTime?: Date | null, internshipCompletionTime?: Date | null };

export type P2PInfoFragment = { __typename?: 'P2PChecksInfo', cookiesCount: number, periodOfVerification: number, projectReviewsInfo: { __typename?: 'ProjectReviewsInfo', reviewByStudentCount: number, relevantReviewByStudentsCount: number, reviewByInspectionStaffCount: number, relevantReviewByInspectionStaffCount: number } };

export type InternshipModuleCoverInfoFragment = { __typename?: 'ModuleCoverInformation', softSkills: Array<{ __typename?: 'SoftSkillPoint', softSkillId: number, softSkillName: string, totalPower: number, maxPower: number, currentUserPower: number, achievedUserPower?: number | null }>, timeline: Array<{ __typename?: 'ProjectTimelineItem', type: TimelineItemType, status: TimelineItemStatus, start?: Date | null, end?: Date | null, order?: number | null, children?: Array<{ __typename?: 'ProjectTimelineItem', type: TimelineItemType, elementType?: TimelineElementEnum | null, status: TimelineItemStatus, start?: Date | null, end?: Date | null, order?: number | null } | null> | null }>, projectStatistics?: { __typename?: 'ProjectStatistics', registeredStudents: number, inProgressStudents: number, evaluationStudents: number, finishedStudents: number, acceptedStudents: number, failedStudents: number, retriedStudentsPercentage: number, groupProjectStatistics?: { __typename?: 'GroupProjectStatistics', inProgressTeams: number, evaluationTeams: number, finishedTeams: number, acceptedTeams: number, failedTeams: number } | null } | null };

export type InternshipInfoFragment = { __typename?: 'StudentModule', id: string, moduleTitle: string, finalPercentage?: number | null, finalPoint?: number | null, goalExecutionType?: ModuleExecutionType | null, displayedGoalStatus?: DisplayedGoalStatus | null, accessBeforeStartProgress?: boolean | null, resultModuleCompletion?: ResultModuleCompletion | null, finishedExecutionDateByScheduler?: Date | null, durationFromStageSubjectGroupPlan?: number | null, currentAttemptNumber?: number | null, isDeadlineFree?: boolean | null, isRetryAvailable: boolean, localCourseId?: string | null, courseBaseParameters?: { __typename?: 'CourseBaseParameters', isGradedCourse: boolean } | null, studyModule: { __typename?: 'StudyModule', id: string, idea: string, duration: number, goalPoint?: number | null, retrySettings?: { __typename?: 'ModuleAttemptsSettings', maxModuleAttempts?: number | null, isUnlimitedAttempts: boolean } | null, levels: Array<{ __typename?: 'StudyModuleLevel', id: string, goalElements: Array<{ __typename?: 'StudyModuleGoalElement', id: string, tasks: Array<{ __typename?: 'Task', id: string, taskId: string }> }> }> }, currentTask?: { __typename?: 'StudentTask', id: string, taskId: string, task: { __typename?: 'Task', id: string, assignmentType: TaskAssignmentEnum, checkTypes: Array<TaskCheckEnum>, studentTaskAdditionalAttributes: { __typename?: 'StudentTaskAdditionalAttributes', cookiesCount: number, maxCodeReviewCount: number, codeReviewCost: number, ciCdMode: GitlabCiCdType } }, lastAnswer?: { __typename?: 'StudentAnswer', id: string } | null } | null };

export type GetInternshipInfoQueryVariables = Exact<{
  goalId: Scalars['ID']['input'];
}>;


export type GetInternshipInfoQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getModuleById: { __typename?: 'StudentModule', id: string, moduleTitle: string, finalPercentage?: number | null, finalPoint?: number | null, goalExecutionType?: ModuleExecutionType | null, displayedGoalStatus?: DisplayedGoalStatus | null, accessBeforeStartProgress?: boolean | null, resultModuleCompletion?: ResultModuleCompletion | null, finishedExecutionDateByScheduler?: Date | null, durationFromStageSubjectGroupPlan?: number | null, currentAttemptNumber?: number | null, isDeadlineFree?: boolean | null, isRetryAvailable: boolean, localCourseId?: string | null, courseBaseParameters?: { __typename?: 'CourseBaseParameters', isGradedCourse: boolean } | null, studyModule: { __typename?: 'StudyModule', id: string, idea: string, duration: number, goalPoint?: number | null, retrySettings?: { __typename?: 'ModuleAttemptsSettings', maxModuleAttempts?: number | null, isUnlimitedAttempts: boolean } | null, levels: Array<{ __typename?: 'StudyModuleLevel', id: string, goalElements: Array<{ __typename?: 'StudyModuleGoalElement', id: string, tasks: Array<{ __typename?: 'Task', id: string, taskId: string }> }> }> }, currentTask?: { __typename?: 'StudentTask', id: string, taskId: string, task: { __typename?: 'Task', id: string, assignmentType: TaskAssignmentEnum, checkTypes: Array<TaskCheckEnum>, studentTaskAdditionalAttributes: { __typename?: 'StudentTaskAdditionalAttributes', cookiesCount: number, maxCodeReviewCount: number, codeReviewCost: number, ciCdMode: GitlabCiCdType } }, lastAnswer?: { __typename?: 'StudentAnswer', id: string } | null } | null }, getModuleCoverInformation?: { __typename?: 'ModuleCoverInformation', softSkills: Array<{ __typename?: 'SoftSkillPoint', softSkillId: number, softSkillName: string, totalPower: number, maxPower: number, currentUserPower: number, achievedUserPower?: number | null }>, timeline: Array<{ __typename?: 'ProjectTimelineItem', type: TimelineItemType, status: TimelineItemStatus, start?: Date | null, end?: Date | null, order?: number | null, children?: Array<{ __typename?: 'ProjectTimelineItem', type: TimelineItemType, elementType?: TimelineElementEnum | null, status: TimelineItemStatus, start?: Date | null, end?: Date | null, order?: number | null } | null> | null }>, projectStatistics?: { __typename?: 'ProjectStatistics', registeredStudents: number, inProgressStudents: number, evaluationStudents: number, finishedStudents: number, acceptedStudents: number, failedStudents: number, retriedStudentsPercentage: number, groupProjectStatistics?: { __typename?: 'GroupProjectStatistics', inProgressTeams: number, evaluationTeams: number, finishedTeams: number, acceptedTeams: number, failedTeams: number } | null } | null } | null, getP2PChecksInfo?: { __typename?: 'P2PChecksInfo', cookiesCount: number, periodOfVerification: number, projectReviewsInfo: { __typename?: 'ProjectReviewsInfo', reviewByStudentCount: number, relevantReviewByStudentsCount: number, reviewByInspectionStaffCount: number, relevantReviewByInspectionStaffCount: number } } | null } | null, s21Internship?: { __typename?: 's21InternshipQueries', getInternshipDataById: { __typename?: 'InternshipStudentInfo', link?: string | null, internshipStartTime?: Date | null, internshipCompletionTime?: Date | null }, getInternshipReviewDataInfo: { __typename?: 'InternshipStudentReviewInfo', internshipStudentReviewList?: Array<{ __typename?: 'InternshipStudentReviewList', numberReview?: number | null, studentProgressInternshipId?: number | null, reviewModelList?: Array<{ __typename?: 'InternshipStudentReview', reviewOrderNumber?: number | null, planTimeMentorReview?: Date | null, factTimeMentorReview?: Date | null, percentageMentorReview?: number | null, commentMentorReview?: string | null, threshold?: number | null } | null> | null } | null> | null } } | null };

export type RegisterToInternshipMutationVariables = Exact<{
  goalId: Scalars['ID']['input'];
}>;


export type RegisterToInternshipMutation = { __typename?: 'Mutation', sc21ProjectFlow?: { __typename?: 'SC21ProjectFlowMutations', registerForProject: boolean } | null };

export type RetryInternshipMutationVariables = Exact<{
  taskId: Scalars['ID']['input'];
}>;


export type RetryInternshipMutation = { __typename?: 'Mutation', sc21ProjectFlow?: { __typename?: 'SC21ProjectFlowMutations', retryProject: boolean } | null };

export type VerifiableStudentItemFragment = { __typename?: 'VerifiableStudent', userId: string, login: string, avatarUrl: string, levelCode: number, isTeamLead?: boolean | null, cookiesCount: number, codeReviewPoints: number, school: { __typename?: 'School', shortName: string } };

export type CalendarReviewUserFragment = { __typename?: 'User', id: string, login?: string | null };

export type CalendarReviewBookingFragment = { __typename?: 'CalendarBooking', id: string, answerId?: string | null, eventSlotId: string, bookingStatus: BookingStatusEnum, isOnline: boolean, vcLinkUrl?: string | null, task?: { __typename?: 'Task', id: string, goalId?: string | null, goalName: string, assignmentType: TaskAssignmentEnum, studentTaskAdditionalAttributes: { __typename?: 'StudentTaskAdditionalAttributes', cookiesCount: number } } | null, eventSlot: { __typename?: 'CalendarTimeSlot', id: string, start: Date, end: Date, event: { __typename?: 'CalendarEvent', eventUserRole: CalendarEventUserRole }, school?: { __typename?: 'School', shortName: string } | null }, verifierUser?: { __typename?: 'User', id: string, login?: string | null } | null, verifiableInfo?: { __typename?: 'VerifiableInfo', verifiableStudents: Array<{ __typename?: 'VerifiableStudent', userId: string, login: string, avatarUrl: string, levelCode: number, isTeamLead?: boolean | null, cookiesCount: number, codeReviewPoints: number, school: { __typename?: 'School', shortName: string } }>, team?: { __typename?: 'Team', name: string } | null } | null, additionalChecklist?: { __typename?: 'AdditionalChecklist', filledChecklistId?: string | null, filledChecklistStatusRecordingEnum?: FilledChecklistStatusRecordingEnum | null } | null };

export type CalendarGetMyBookingsQueryVariables = Exact<{
  from: Scalars['DateTime']['input'];
  to: Scalars['DateTime']['input'];
}>;


export type CalendarGetMyBookingsQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getMyCalendarBookings: Array<{ __typename?: 'CalendarBooking', id: string, answerId?: string | null, eventSlotId: string, bookingStatus: BookingStatusEnum, isOnline: boolean, vcLinkUrl?: string | null, task?: { __typename?: 'Task', id: string, goalId?: string | null, goalName: string, assignmentType: TaskAssignmentEnum, studentTaskAdditionalAttributes: { __typename?: 'StudentTaskAdditionalAttributes', cookiesCount: number } } | null, eventSlot: { __typename?: 'CalendarTimeSlot', id: string, start: Date, end: Date, event: { __typename?: 'CalendarEvent', eventUserRole: CalendarEventUserRole }, school?: { __typename?: 'School', shortName: string } | null }, verifierUser?: { __typename?: 'User', id: string, login?: string | null } | null, verifiableInfo?: { __typename?: 'VerifiableInfo', verifiableStudents: Array<{ __typename?: 'VerifiableStudent', userId: string, login: string, avatarUrl: string, levelCode: number, isTeamLead?: boolean | null, cookiesCount: number, codeReviewPoints: number, school: { __typename?: 'School', shortName: string } }>, team?: { __typename?: 'Team', name: string } | null } | null, additionalChecklist?: { __typename?: 'AdditionalChecklist', filledChecklistId?: string | null, filledChecklistStatusRecordingEnum?: FilledChecklistStatusRecordingEnum | null } | null }> } | null };

export type CalendarGetCodeReviewDataQueryVariables = Exact<{
  studentGoalId: Scalars['ID']['input'];
}>;


export type CalendarGetCodeReviewDataQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getStudentModuleByStudentGoalId: { __typename?: 'StudentModule', moduleTitle: string, currentTask?: { __typename?: 'StudentTask', task: { __typename?: 'Task', studentTaskAdditionalAttributes: { __typename?: 'StudentTaskAdditionalAttributes', codeReviewDuration: number } } } | null } } | null };

export type ProjectTeamMemberFragment = { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null };

export type ProjectTeamMembersFragment = { __typename?: 'ProjectTeamMembers', id: string, teamName: string, teamStatus: TeamStatusEnum, minTeamMemberCount: number, maxTeamMemberCount: number, teamLead: { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null }, members: Array<{ __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null }>, invitedUsers: Array<{ __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null }> };

export type GetProjectTeamMembersQueryVariables = Exact<{
  studentTaskId: Scalars['ID']['input'];
}>;


export type GetProjectTeamMembersQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getProjectTeamMembers?: { __typename?: 'ProjectTeamMembers', id: string, teamName: string, teamStatus: TeamStatusEnum, minTeamMemberCount: number, maxTeamMemberCount: number, teamLead: { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null }, members: Array<{ __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null }>, invitedUsers: Array<{ __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null }> } | null } | null };

export type CalendarEventActivityFragment = { __typename?: 'ActivityEvent', activityEventId: string, eventId: string, name: string, beginDate: Date, endDate: Date, isRegistered?: boolean | null, description?: string | null, currentStudentsCount: number, maxStudentCount?: number | null, location: string, updateDate: Date, isWaitListActive: boolean, isInWaitList?: boolean | null, stopRegisterDate?: Date | null };

export type CalendarEventExamFragment = { __typename?: 'Exam', examId: string, eventId: string, beginDate: Date, endDate: Date, name: string, location: string, currentStudentsCount: number, maxStudentCount?: number | null, updateDate: Date, goalId: string, goalName: string, isWaitListActive: boolean, isInWaitList?: boolean | null, stopRegisterDate?: Date | null };

export type CalendarEventFragment = { __typename?: 'CalendarEvent', id: string, start: Date, end: Date, description: string, eventType?: string | null, eventCode?: string | null, eventSlots: Array<{ __typename?: 'CalendarTimeSlot', id: string, type: TimeSlotTypeEnum, start: Date, end: Date, event: { __typename?: 'CalendarEvent', eventUserRole: CalendarEventUserRole }, school?: { __typename?: 'School', shortName: string } | null }>, bookings: Array<{ __typename?: 'CalendarBooking', id: string, answerId?: string | null, eventSlotId: string, bookingStatus: BookingStatusEnum, isOnline: boolean, vcLinkUrl?: string | null, task?: { __typename?: 'Task', id: string, goalId?: string | null, goalName: string, assignmentType: TaskAssignmentEnum, studentTaskAdditionalAttributes: { __typename?: 'StudentTaskAdditionalAttributes', cookiesCount: number } } | null, eventSlot: { __typename?: 'CalendarTimeSlot', id: string, start: Date, end: Date, event: { __typename?: 'CalendarEvent', eventUserRole: CalendarEventUserRole }, school?: { __typename?: 'School', shortName: string } | null }, verifierUser?: { __typename?: 'User', id: string, login?: string | null } | null, verifiableInfo?: { __typename?: 'VerifiableInfo', verifiableStudents: Array<{ __typename?: 'VerifiableStudent', userId: string, login: string, avatarUrl: string, levelCode: number, isTeamLead?: boolean | null, cookiesCount: number, codeReviewPoints: number, school: { __typename?: 'School', shortName: string } }>, team?: { __typename?: 'Team', name: string } | null } | null, additionalChecklist?: { __typename?: 'AdditionalChecklist', filledChecklistId?: string | null, filledChecklistStatusRecordingEnum?: FilledChecklistStatusRecordingEnum | null } | null }>, exam?: { __typename?: 'Exam', examId: string, eventId: string, beginDate: Date, endDate: Date, name: string, location: string, currentStudentsCount: number, maxStudentCount?: number | null, updateDate: Date, goalId: string, goalName: string, isWaitListActive: boolean, isInWaitList?: boolean | null, stopRegisterDate?: Date | null } | null, studentCodeReview?: { __typename?: 'StudentCodeReview', studentGoalId: string } | null, activity?: { __typename?: 'ActivityEvent', status?: ParticipantEventStatus | null, activityType: string, isMandatory: boolean, isWaitListActive: boolean, isVisible: boolean, activityEventId: string, eventId: string, name: string, beginDate: Date, endDate: Date, isRegistered?: boolean | null, description?: string | null, currentStudentsCount: number, maxStudentCount?: number | null, location: string, updateDate: Date, isInWaitList?: boolean | null, stopRegisterDate?: Date | null, studentFeedback?: { __typename?: 'StudentEventFeedback', id: string, rating: number, comment?: string | null } | null, comments?: Array<{ __typename?: 'ParticipantEventComment', type: ParticipantEventCommentType, createTs: Date, comment: string }> | null, organizers?: Array<{ __typename?: 'User', id: string, login?: string | null }> | null } | null, goals: Array<{ __typename?: 'Goal', goalId: string, goalName: string }>, penalty?: { __typename?: 'Penalty', comment?: string | null, id?: string | null, duration: number, status: string, startTime?: Date | null, createTime: Date, reasonId: string, penaltySlot?: { __typename?: 'PenaltySlot', currentStudentsCount?: number | null, description?: string | null, duration?: number | null, startTime?: Date | null, id: string, endTime?: Date | null } | null } | null };

export type CalendarGetEventsQueryVariables = Exact<{
  from: Scalars['DateTime']['input'];
  to: Scalars['DateTime']['input'];
}>;


export type CalendarGetEventsQuery = { __typename?: 'Query', calendarEventS21?: { __typename?: 'CalendarEventS21Queries', getMyCalendarEvents: Array<{ __typename?: 'CalendarEvent', id: string, start: Date, end: Date, description: string, eventType?: string | null, eventCode?: string | null, eventSlots: Array<{ __typename?: 'CalendarTimeSlot', id: string, type: TimeSlotTypeEnum, start: Date, end: Date, event: { __typename?: 'CalendarEvent', eventUserRole: CalendarEventUserRole }, school?: { __typename?: 'School', shortName: string } | null }>, bookings: Array<{ __typename?: 'CalendarBooking', id: string, answerId?: string | null, eventSlotId: string, bookingStatus: BookingStatusEnum, isOnline: boolean, vcLinkUrl?: string | null, task?: { __typename?: 'Task', id: string, goalId?: string | null, goalName: string, assignmentType: TaskAssignmentEnum, studentTaskAdditionalAttributes: { __typename?: 'StudentTaskAdditionalAttributes', cookiesCount: number } } | null, eventSlot: { __typename?: 'CalendarTimeSlot', id: string, start: Date, end: Date, event: { __typename?: 'CalendarEvent', eventUserRole: CalendarEventUserRole }, school?: { __typename?: 'School', shortName: string } | null }, verifierUser?: { __typename?: 'User', id: string, login?: string | null } | null, verifiableInfo?: { __typename?: 'VerifiableInfo', verifiableStudents: Array<{ __typename?: 'VerifiableStudent', userId: string, login: string, avatarUrl: string, levelCode: number, isTeamLead?: boolean | null, cookiesCount: number, codeReviewPoints: number, school: { __typename?: 'School', shortName: string } }>, team?: { __typename?: 'Team', name: string } | null } | null, additionalChecklist?: { __typename?: 'AdditionalChecklist', filledChecklistId?: string | null, filledChecklistStatusRecordingEnum?: FilledChecklistStatusRecordingEnum | null } | null }>, exam?: { __typename?: 'Exam', examId: string, eventId: string, beginDate: Date, endDate: Date, name: string, location: string, currentStudentsCount: number, maxStudentCount?: number | null, updateDate: Date, goalId: string, goalName: string, isWaitListActive: boolean, isInWaitList?: boolean | null, stopRegisterDate?: Date | null } | null, studentCodeReview?: { __typename?: 'StudentCodeReview', studentGoalId: string } | null, activity?: { __typename?: 'ActivityEvent', status?: ParticipantEventStatus | null, activityType: string, isMandatory: boolean, isWaitListActive: boolean, isVisible: boolean, activityEventId: string, eventId: string, name: string, beginDate: Date, endDate: Date, isRegistered?: boolean | null, description?: string | null, currentStudentsCount: number, maxStudentCount?: number | null, location: string, updateDate: Date, isInWaitList?: boolean | null, stopRegisterDate?: Date | null, studentFeedback?: { __typename?: 'StudentEventFeedback', id: string, rating: number, comment?: string | null } | null, comments?: Array<{ __typename?: 'ParticipantEventComment', type: ParticipantEventCommentType, createTs: Date, comment: string }> | null, organizers?: Array<{ __typename?: 'User', id: string, login?: string | null }> | null } | null, goals: Array<{ __typename?: 'Goal', goalId: string, goalName: string }>, penalty?: { __typename?: 'Penalty', comment?: string | null, id?: string | null, duration: number, status: string, startTime?: Date | null, createTime: Date, reasonId: string, penaltySlot?: { __typename?: 'PenaltySlot', currentStudentsCount?: number | null, description?: string | null, duration?: number | null, startTime?: Date | null, id: string, endTime?: Date | null } | null } | null }> } | null };

export type CalendarExamFragment = { __typename?: 'Exam', examId: string, eventId: string, beginDate: Date, endDate: Date, name: string, location: string, maxStudentCount?: number | null, currentStudentsCount: number, updateDate: Date, goalId: string, goalName: string, isWaitListActive: boolean, isInWaitList?: boolean | null, stopRegisterDate?: Date | null };

export type CalendarGetExamsQueryVariables = Exact<{
  from: Scalars['DateTime']['input'];
  to: Scalars['DateTime']['input'];
}>;


export type CalendarGetExamsQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getExams: Array<{ __typename?: 'Exam', examId: string, eventId: string, beginDate: Date, endDate: Date, name: string, location: string, maxStudentCount?: number | null, currentStudentsCount: number, updateDate: Date, goalId: string, goalName: string, isWaitListActive: boolean, isInWaitList?: boolean | null, stopRegisterDate?: Date | null }> } | null };

export type CalendarNameLessTimeslotFragment = { __typename?: 'CalendarNamelessTimeSlot', start: Date, end: Date, validStartTimes: Array<Date>, staffSlot?: boolean | null };

export type CalendarGetNameLessStudentTimeslotsForReviewQueryVariables = Exact<{
  from: Scalars['DateTime']['input'];
  taskId: Scalars['ID']['input'];
  to: Scalars['DateTime']['input'];
}>;


export type CalendarGetNameLessStudentTimeslotsForReviewQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getNameLessStudentTimeslotsForReview: { __typename?: 'CalendarNamelessTimeSlotResponse', checkDuration: number, projectReviewsInfo: { __typename?: 'ProjectReviewsInfo', reviewByStudentCount: number, relevantReviewByStudentsCount: number, reviewByInspectionStaffCount: number, relevantReviewByInspectionStaffCount: number }, timeSlots: Array<{ __typename?: 'CalendarNamelessTimeSlot', start: Date, end: Date, validStartTimes: Array<Date>, staffSlot?: boolean | null }> } } | null };

export type GetPenaltyReasonsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPenaltyReasonsQuery = { __typename?: 'Query', penalty?: { __typename?: 'PenaltyQueries', getPenaltyReasons: Array<{ __typename?: 'PenaltyReason', id: string, name: string } | null> } | null };

export type CalendarGetStudentCodeReviewsQueryVariables = Exact<{
  studentGoalId: Scalars['ID']['input'];
}>;


export type CalendarGetStudentCodeReviewsQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getStudentCodeReviews: { __typename?: 'StudentCodeReviewsWithPlaneSecondRound', secondRoundStartDate: Date } } | null };

export type GetUsersQueryVariables = Exact<{
  userIds: Array<Scalars['UUID']['input']> | Scalars['UUID']['input'];
}>;


export type GetUsersQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getUsers?: Array<{ __typename?: 'S21StudentPublicProfileBasicInfo', userId: string, login: string, firstName?: string | null, middleName?: string | null, lastName?: string | null, avatarUrl?: string | null, level?: number | null }> | null } | null };

export type CreateParticipantEventMutationVariables = Exact<{
  input: ActivityEventByStudentInputModel;
}>;


export type CreateParticipantEventMutation = { __typename?: 'Mutation', event?: { __typename?: 'EventMutations', createParticipantEvent: { __typename?: 'ActivityEvent', activityEventId: string, eventId: string, name: string, eventType: string } } | null };

export type GetActivityTypesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetActivityTypesQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getActivityTypes: Array<{ __typename?: 'ActivityType', id: string, description: string, category: string }> } | null };

export type UpdateParticipantEventMutationVariables = Exact<{
  activityEventId: Scalars['ID']['input'];
  input: ActivityEventByStudentInputModel;
}>;


export type UpdateParticipantEventMutation = { __typename?: 'Mutation', event?: { __typename?: 'EventMutations', updateParticipantEvent: { __typename?: 'ActivityEvent', activityEventId: string, eventId: string, name: string, eventType: string } } | null };

export type GetMySuggestedActivitiesQueryVariables = Exact<{
  page: PagingInput;
  statuses?: InputMaybe<Array<InputMaybe<ParticipantEventStatus>> | InputMaybe<ParticipantEventStatus>>;
}>;


export type GetMySuggestedActivitiesQuery = { __typename?: 'Query', event?: { __typename?: 'EventQueries', getMySuggestedActivities?: Array<{ __typename?: 'CalendarEvent', id: string, start: Date, end: Date, eventType?: string | null, description: string, eventCode?: string | null, activity?: { __typename?: 'ActivityEvent', averageFeedbackRating: number, isVisible: boolean, activityType: string, status?: ParticipantEventStatus | null, activityEventId: string, eventId: string, name: string, description?: string | null, location: string, currentStudentsCount: number, maxStudentCount?: number | null, isRegistered?: boolean | null, isInWaitList?: boolean | null, isWaitListActive: boolean, stopRegisterDate?: Date | null, beginDate: Date, endDate: Date, organizers?: Array<{ __typename?: 'User', id: string, login?: string | null }> | null, eventCreator?: { __typename?: 'User', id: string, login?: string | null } | null, comments?: Array<{ __typename?: 'ParticipantEventComment', type: ParticipantEventCommentType, createTs: Date, comment: string }> | null } | null }> | null } | null };

export type GetStageClassmatesQueryVariables = Exact<{
  textSearch?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetStageClassmatesQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getStageClassmates: Array<{ __typename?: 'User', id: string, login?: string | null, firstName: string, middleName?: string | null, lastName: string }> } | null };

export type CalendarAddCodeReviewToEventSlotMutationVariables = Exact<{
  studentGoalId: Scalars['ID']['input'];
  startTime: Scalars['DateTime']['input'];
}>;


export type CalendarAddCodeReviewToEventSlotMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', addBookingCodeReviewToEventSlot?: { __typename?: 'CalendarBooking', id: string } | null } | null };

export type CancelParticipantEventMutationVariables = Exact<{
  activityEvent: Scalars['ID']['input'];
}>;


export type CancelParticipantEventMutation = { __typename?: 'Mutation', event?: { __typename?: 'EventMutations', cancelParticipantEvent: { __typename?: 'ActivityEvent', activityEventId: string, eventId: string, name: string } } | null };

export type CreateCalendarEventFeedbackMutationVariables = Exact<{
  studentFeedback: StudentEventFeedbackInput;
}>;


export type CreateCalendarEventFeedbackMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', createCalendarEventFeedback: { __typename?: 'StudentEventFeedback', id: string, rating: number, comment?: string | null, user: { __typename?: 'User', id: string } } } | null };

export type CalendarGetUploadedAndNotConfirmedVideosQueryVariables = Exact<{
  filledChecklistId: Scalars['ID']['input'];
}>;


export type CalendarGetUploadedAndNotConfirmedVideosQuery = { __typename?: 'Query', sc21StudentTaskCheck?: { __typename?: 'SC21StudentTaskCheckQueries', getUploadedAndNotConfirmedVideos: Array<{ __typename?: 'OnlineReviewVideo', onlineVideoId: string, link: string, status: StudyProcessFileStatusEnum, statusDetails?: string | null, updateDateTime: Date, fileSize: number }> } | null };

export type CalendarUpdateFilledChecklistWithOnlineReviewMutationVariables = Exact<{
  filledChecklistId: Scalars['ID']['input'];
}>;


export type CalendarUpdateFilledChecklistWithOnlineReviewMutation = { __typename?: 'Mutation', school21?: { __typename?: 'School21Mutations', submitFilledChecklistRecording: { __typename?: 'FilledChecklist', checklistId: string } } | null };

export type CalendarGetStudentExperienceQueryVariables = Exact<{ [key: string]: never; }>;


export type CalendarGetStudentExperienceQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getExperience: { __typename?: 'UserExperience', id: string, cookiesCount: number } } | null };

export type CalendarAddBookingToEventSlotMutationVariables = Exact<{
  answerId: Scalars['ID']['input'];
  startTime: Scalars['DateTime']['input'];
  wasStaffSlotChosen: Scalars['Boolean']['input'];
  isOnline?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type CalendarAddBookingToEventSlotMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', addBookingP2PToEventSlot: { __typename?: 'CalendarBooking', id: string } } | null };

export type CalendarAddEventMutationVariables = Exact<{
  start: Scalars['DateTime']['input'];
  end: Scalars['DateTime']['input'];
}>;


export type CalendarAddEventMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', addEventToTimetable: Array<{ __typename?: 'CalendarEvent', id: string, start: Date, end: Date, description: string, eventType?: string | null, eventCode?: string | null, eventSlots: Array<{ __typename?: 'CalendarTimeSlot', id: string, type: TimeSlotTypeEnum, start: Date, end: Date, event: { __typename?: 'CalendarEvent', eventUserRole: CalendarEventUserRole }, school?: { __typename?: 'School', shortName: string } | null }>, bookings: Array<{ __typename?: 'CalendarBooking', id: string, answerId?: string | null, eventSlotId: string, bookingStatus: BookingStatusEnum, isOnline: boolean, vcLinkUrl?: string | null, task?: { __typename?: 'Task', id: string, goalId?: string | null, goalName: string, assignmentType: TaskAssignmentEnum, studentTaskAdditionalAttributes: { __typename?: 'StudentTaskAdditionalAttributes', cookiesCount: number } } | null, eventSlot: { __typename?: 'CalendarTimeSlot', id: string, start: Date, end: Date, event: { __typename?: 'CalendarEvent', eventUserRole: CalendarEventUserRole }, school?: { __typename?: 'School', shortName: string } | null }, verifierUser?: { __typename?: 'User', id: string, login?: string | null } | null, verifiableInfo?: { __typename?: 'VerifiableInfo', verifiableStudents: Array<{ __typename?: 'VerifiableStudent', userId: string, login: string, avatarUrl: string, levelCode: number, isTeamLead?: boolean | null, cookiesCount: number, codeReviewPoints: number, school: { __typename?: 'School', shortName: string } }>, team?: { __typename?: 'Team', name: string } | null } | null, additionalChecklist?: { __typename?: 'AdditionalChecklist', filledChecklistId?: string | null, filledChecklistStatusRecordingEnum?: FilledChecklistStatusRecordingEnum | null } | null }>, exam?: { __typename?: 'Exam', examId: string, eventId: string, beginDate: Date, endDate: Date, name: string, location: string, currentStudentsCount: number, maxStudentCount?: number | null, updateDate: Date, goalId: string, goalName: string, isWaitListActive: boolean, isInWaitList?: boolean | null, stopRegisterDate?: Date | null } | null, studentCodeReview?: { __typename?: 'StudentCodeReview', studentGoalId: string } | null, activity?: { __typename?: 'ActivityEvent', status?: ParticipantEventStatus | null, activityType: string, isMandatory: boolean, isWaitListActive: boolean, isVisible: boolean, activityEventId: string, eventId: string, name: string, beginDate: Date, endDate: Date, isRegistered?: boolean | null, description?: string | null, currentStudentsCount: number, maxStudentCount?: number | null, location: string, updateDate: Date, isInWaitList?: boolean | null, stopRegisterDate?: Date | null, studentFeedback?: { __typename?: 'StudentEventFeedback', id: string, rating: number, comment?: string | null } | null, comments?: Array<{ __typename?: 'ParticipantEventComment', type: ParticipantEventCommentType, createTs: Date, comment: string }> | null, organizers?: Array<{ __typename?: 'User', id: string, login?: string | null }> | null } | null, goals: Array<{ __typename?: 'Goal', goalId: string, goalName: string }>, penalty?: { __typename?: 'Penalty', comment?: string | null, id?: string | null, duration: number, status: string, startTime?: Date | null, createTime: Date, reasonId: string, penaltySlot?: { __typename?: 'PenaltySlot', currentStudentsCount?: number | null, description?: string | null, duration?: number | null, startTime?: Date | null, id: string, endTime?: Date | null } | null } | null }> } | null };

export type CalendarChangeEventSlotMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  start: Scalars['DateTime']['input'];
  end: Scalars['DateTime']['input'];
}>;


export type CalendarChangeEventSlotMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', changeEventSlot: Array<{ __typename?: 'CalendarEvent', id: string, start: Date, end: Date, description: string, eventType?: string | null, eventCode?: string | null, eventSlots: Array<{ __typename?: 'CalendarTimeSlot', id: string, type: TimeSlotTypeEnum, start: Date, end: Date, event: { __typename?: 'CalendarEvent', eventUserRole: CalendarEventUserRole }, school?: { __typename?: 'School', shortName: string } | null }>, bookings: Array<{ __typename?: 'CalendarBooking', id: string, answerId?: string | null, eventSlotId: string, bookingStatus: BookingStatusEnum, isOnline: boolean, vcLinkUrl?: string | null, task?: { __typename?: 'Task', id: string, goalId?: string | null, goalName: string, assignmentType: TaskAssignmentEnum, studentTaskAdditionalAttributes: { __typename?: 'StudentTaskAdditionalAttributes', cookiesCount: number } } | null, eventSlot: { __typename?: 'CalendarTimeSlot', id: string, start: Date, end: Date, event: { __typename?: 'CalendarEvent', eventUserRole: CalendarEventUserRole }, school?: { __typename?: 'School', shortName: string } | null }, verifierUser?: { __typename?: 'User', id: string, login?: string | null } | null, verifiableInfo?: { __typename?: 'VerifiableInfo', verifiableStudents: Array<{ __typename?: 'VerifiableStudent', userId: string, login: string, avatarUrl: string, levelCode: number, isTeamLead?: boolean | null, cookiesCount: number, codeReviewPoints: number, school: { __typename?: 'School', shortName: string } }>, team?: { __typename?: 'Team', name: string } | null } | null, additionalChecklist?: { __typename?: 'AdditionalChecklist', filledChecklistId?: string | null, filledChecklistStatusRecordingEnum?: FilledChecklistStatusRecordingEnum | null } | null }>, exam?: { __typename?: 'Exam', examId: string, eventId: string, beginDate: Date, endDate: Date, name: string, location: string, currentStudentsCount: number, maxStudentCount?: number | null, updateDate: Date, goalId: string, goalName: string, isWaitListActive: boolean, isInWaitList?: boolean | null, stopRegisterDate?: Date | null } | null, studentCodeReview?: { __typename?: 'StudentCodeReview', studentGoalId: string } | null, activity?: { __typename?: 'ActivityEvent', status?: ParticipantEventStatus | null, activityType: string, isMandatory: boolean, isWaitListActive: boolean, isVisible: boolean, activityEventId: string, eventId: string, name: string, beginDate: Date, endDate: Date, isRegistered?: boolean | null, description?: string | null, currentStudentsCount: number, maxStudentCount?: number | null, location: string, updateDate: Date, isInWaitList?: boolean | null, stopRegisterDate?: Date | null, studentFeedback?: { __typename?: 'StudentEventFeedback', id: string, rating: number, comment?: string | null } | null, comments?: Array<{ __typename?: 'ParticipantEventComment', type: ParticipantEventCommentType, createTs: Date, comment: string }> | null, organizers?: Array<{ __typename?: 'User', id: string, login?: string | null }> | null } | null, goals: Array<{ __typename?: 'Goal', goalId: string, goalName: string }>, penalty?: { __typename?: 'Penalty', comment?: string | null, id?: string | null, duration: number, status: string, startTime?: Date | null, createTime: Date, reasonId: string, penaltySlot?: { __typename?: 'PenaltySlot', currentStudentsCount?: number | null, description?: string | null, duration?: number | null, startTime?: Date | null, id: string, endTime?: Date | null } | null } | null }> } | null };

export type CalendarDeleteEventSlotMutationVariables = Exact<{
  eventSlotId: Scalars['ID']['input'];
}>;


export type CalendarDeleteEventSlotMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', deleteEventSlot: boolean } | null };

export type EventsGetActivityFeedbackQueryVariables = Exact<{
  activityEventId: Scalars['ID']['input'];
  page: PagingInput;
}>;


export type EventsGetActivityFeedbackQuery = { __typename?: 'Query', event?: { __typename?: 'EventQueries', getActivityEventFeedbackCount: number, getActivityEventFeedback: Array<{ __typename?: 'StudentEventFeedback', id: string, comment?: string | null, rating: number, createDate: Date, user: { __typename?: 'User', id: string, login?: string | null, email?: string | null } } | null> } | null };

export type EventsGetStudentsQueryVariables = Exact<{
  activityEventId: Scalars['ID']['input'];
  studentType: StudentEventTypeEnum;
  page: PagingInput;
}>;


export type EventsGetStudentsQuery = { __typename?: 'Query', event?: { __typename?: 'EventQueries', getEventStudents: Array<{ __typename?: 'StudentEvent', User: { __typename?: 'User', id: string, login?: string | null, email?: string | null } }> } | null };

export type CalendarStudentTaskAdditionalAttributesFragment = { __typename?: 'StudentTaskAdditionalAttributes', cookiesCount: number };

export type CalendarStudentTaskFragment = { __typename?: 'StudentTask', id: string, taskId: string, task: { __typename?: 'Task', id: string, assignmentType: TaskAssignmentEnum, studentTaskAdditionalAttributes: { __typename?: 'StudentTaskAdditionalAttributes', cookiesCount: number } }, lastAnswer?: { __typename?: 'StudentAnswer', id: string } | null };

export type CalendarGetModuleQueryVariables = Exact<{
  moduleId: Scalars['ID']['input'];
}>;


export type CalendarGetModuleQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getModuleById: { __typename?: 'StudentModule', id: string, moduleTitle: string, subjectTitle: string, goalExecutionType?: ModuleExecutionType | null, currentTask?: { __typename?: 'StudentTask', id: string, taskId: string, task: { __typename?: 'Task', id: string, assignmentType: TaskAssignmentEnum, studentTaskAdditionalAttributes: { __typename?: 'StudentTaskAdditionalAttributes', cookiesCount: number } }, lastAnswer?: { __typename?: 'StudentAnswer', id: string } | null } | null } } | null };

export type UserInBookingFragment = { __typename?: 'User', id: string, login?: string | null, avatarUrl: string, userExperience?: { __typename?: 'UserExperience', level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null };

export type ReviewFragment = { __typename?: 'CalendarBooking', id: string, answerId?: string | null, bookingStatus: BookingStatusEnum, isOnline: boolean, vcLinkUrl?: string | null, eventSlot: { __typename?: 'CalendarTimeSlot', id: string, start: Date, end: Date }, task?: { __typename?: 'Task', id: string, title: string, assignmentType: TaskAssignmentEnum, goalId?: string | null, goalName: string, studentTaskAdditionalAttributes: { __typename?: 'StudentTaskAdditionalAttributes', cookiesCount: number } } | null, verifierUser?: { __typename?: 'User', id: string, login?: string | null, avatarUrl: string, userExperience?: { __typename?: 'UserExperience', level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null } | null, verifiableStudent?: { __typename?: 'Student', id: string, user: { __typename?: 'User', id: string, login?: string | null, avatarUrl: string, userExperience?: { __typename?: 'UserExperience', level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null } } | null, team?: { __typename?: 'ProjectTeamMembers', id: string, teamName: string, teamStatus: TeamStatusEnum, minTeamMemberCount: number, maxTeamMemberCount: number, teamLead: { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null }, members: Array<{ __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null }>, invitedUsers: Array<{ __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null }> } | null };

export type CalendarGetMyReviewsQueryVariables = Exact<{
  to?: InputMaybe<Scalars['DateTime']['input']>;
  limit?: InputMaybe<Scalars['Int']['input']>;
}>;


export type CalendarGetMyReviewsQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getMyUpcomingBookings: Array<{ __typename?: 'CalendarBooking', id: string, answerId?: string | null, bookingStatus: BookingStatusEnum, isOnline: boolean, vcLinkUrl?: string | null, eventSlot: { __typename?: 'CalendarTimeSlot', id: string, start: Date, end: Date }, task?: { __typename?: 'Task', id: string, title: string, assignmentType: TaskAssignmentEnum, goalId?: string | null, goalName: string, studentTaskAdditionalAttributes: { __typename?: 'StudentTaskAdditionalAttributes', cookiesCount: number } } | null, verifierUser?: { __typename?: 'User', id: string, login?: string | null, avatarUrl: string, userExperience?: { __typename?: 'UserExperience', level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null } | null, verifiableStudent?: { __typename?: 'Student', id: string, user: { __typename?: 'User', id: string, login?: string | null, avatarUrl: string, userExperience?: { __typename?: 'UserExperience', level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null } } | null, team?: { __typename?: 'ProjectTeamMembers', id: string, teamName: string, teamStatus: TeamStatusEnum, minTeamMemberCount: number, maxTeamMemberCount: number, teamLead: { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null }, members: Array<{ __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null }>, invitedUsers: Array<{ __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null }> } | null }> } | null };

export type CompetitionCoalitionGetMyCoalitionMembersQueryVariables = Exact<{
  page?: InputMaybe<PagingInput>;
}>;


export type CompetitionCoalitionGetMyCoalitionMembersQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getMyCoalitionMembers: Array<{ __typename?: 'CoalitionMember', user: { __typename?: 'User', id: string, login?: string | null, avatarUrl: string, userExperience?: { __typename?: 'UserExperience', level: { __typename?: 'ExperienceLevel', id: number, levelCode: number } } | null } }> } | null };

export type CompetitionCurrentCoalitionFragment = { __typename?: 'GameCoalition', id: string, name: string, avatarUrl: string, backgroundUrl: string, backgroundUrlBig: string, memberCount: number, color: string, masterAvatarImgUrl: string, currentTournament?: { __typename?: 'CoalitionTournament', points: number, tournament: { __typename?: 'GameTournament', name: string, timeStart: Date, timeEnd: Date } } | null, masterUser: { __typename?: 'User', login?: string | null } };

export type CompetitionCoalitionGetUserTournamentQueryVariables = Exact<{ [key: string]: never; }>;


export type CompetitionCoalitionGetUserTournamentQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getUserTournamentWidget: { __typename?: 'UserTournamentWidget', coalitionMember?: { __typename?: 'CoalitionMember', coalition: { __typename?: 'GameCoalition', id: string, name: string, avatarUrl: string, backgroundUrl: string, backgroundUrlBig: string, memberCount: number, color: string, masterAvatarImgUrl: string, currentTournament?: { __typename?: 'CoalitionTournament', points: number, tournament: { __typename?: 'GameTournament', name: string, timeStart: Date, timeEnd: Date } } | null, masterUser: { __typename?: 'User', login?: string | null } } } | null, lastTournamentResult?: { __typename?: 'UserTournamentResult', id: string } | null } } | null };

export type CurrentCoalitionTournamentFragment = { __typename?: 'CoalitionTournamentRank', id: string, rank: number, coalitionTournament: { __typename?: 'CoalitionTournament', points: number, extraPoints: number, coalition: { __typename?: 'GameCoalition', id: string, name: string, avatarUrl: string, backgroundUrl: string, backgroundUrlBig: string, memberCount: number, color: string, masterAvatarImgUrl: string, masterUser: { __typename?: 'User', id: string, login?: string | null } }, mvpMember?: { __typename?: 'CoalitionMemberPower', id: string, points: number, coalitionMemberUser: { __typename?: 'User', id: string, login?: string | null, avatarUrl: string } } | null } };

export type CurrentTournamentFragment = { __typename?: 'GameTournament', id: string, name: string, timeStart: Date, timeEnd: Date, tournamentAwardDescription?: string | null, coalitionPoints: Array<{ __typename?: 'CoalitionTournamentRank', id: string, rank: number, coalitionTournament: { __typename?: 'CoalitionTournament', points: number, extraPoints: number, coalition: { __typename?: 'GameCoalition', id: string, name: string, avatarUrl: string, backgroundUrl: string, backgroundUrlBig: string, memberCount: number, color: string, masterAvatarImgUrl: string, masterUser: { __typename?: 'User', id: string, login?: string | null } }, mvpMember?: { __typename?: 'CoalitionMemberPower', id: string, points: number, coalitionMemberUser: { __typename?: 'User', id: string, login?: string | null, avatarUrl: string } } | null } }> };

export type CompetitionGetCurrentOrLastTournamentQueryVariables = Exact<{ [key: string]: never; }>;


export type CompetitionGetCurrentOrLastTournamentQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getCurrentOrLastTournament?: { __typename?: 'GameTournament', id: string, name: string, timeStart: Date, timeEnd: Date, tournamentAwardDescription?: string | null, coalitionPoints: Array<{ __typename?: 'CoalitionTournamentRank', id: string, rank: number, coalitionTournament: { __typename?: 'CoalitionTournament', points: number, extraPoints: number, coalition: { __typename?: 'GameCoalition', id: string, name: string, avatarUrl: string, backgroundUrl: string, backgroundUrlBig: string, memberCount: number, color: string, masterAvatarImgUrl: string, masterUser: { __typename?: 'User', id: string, login?: string | null } }, mvpMember?: { __typename?: 'CoalitionMemberPower', id: string, points: number, coalitionMemberUser: { __typename?: 'User', id: string, login?: string | null, avatarUrl: string } } | null } }> } | null } | null };

export type CompetitioncoalitionUserInfoFragment = { __typename?: 'User', id: string, login?: string | null, avatarUrl: string, userExperience?: { __typename?: 'UserExperience', level: { __typename?: 'ExperienceLevel', id: number, levelCode: number } } | null };

export type CompetitionGetStudentRankInTournamentQueryVariables = Exact<{
  gameTournamentId: Scalars['Int']['input'];
}>;


export type CompetitionGetStudentRankInTournamentQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getStudentRankInTournament?: { __typename?: 'CoalitionMemberPowerRank', id: string, rank: number, power: { __typename?: 'CoalitionMemberPower', id: string, points: number, coalitionTournament: { __typename?: 'CoalitionTournament', id: string, coalition: { __typename?: 'GameCoalition', id: string } }, coalitionMemberUser: { __typename?: 'User', id: string, login?: string | null, avatarUrl: string, userExperience?: { __typename?: 'UserExperience', level: { __typename?: 'ExperienceLevel', id: number, levelCode: number } } | null } } } | null } | null };

export type GetTop5AndMeCoalitionTournamentMembersInfoFragment = { __typename?: 'CoalitionMemberPowerRank', id: string, rank: number, power: { __typename?: 'CoalitionMemberPower', id: string, points: number, coalitionMemberUser: { __typename?: 'User', id: string, login?: string | null, avatarUrl: string, userExperience?: { __typename?: 'UserExperience', level: { __typename?: 'ExperienceLevel', id: number, levelCode: number } } | null } } };

export type GetTop5AndMeCoalitionTournamentMembersQueryVariables = Exact<{
  gameCoalitionId: Scalars['Int']['input'];
  gameTournamentId: Scalars['Int']['input'];
}>;


export type GetTop5AndMeCoalitionTournamentMembersQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getTop5AndMeCoalitionTournamentMembers: { __typename?: 'Top5AndMeCoalitionTournamentMembers', top5: Array<{ __typename?: 'CoalitionMemberPowerRank', id: string, rank: number, power: { __typename?: 'CoalitionMemberPower', id: string, points: number, coalitionMemberUser: { __typename?: 'User', id: string, login?: string | null, avatarUrl: string, userExperience?: { __typename?: 'UserExperience', level: { __typename?: 'ExperienceLevel', id: number, levelCode: number } } | null } } }> } } | null };

export type GetCourseConsistencyInfoQueryVariables = Exact<{
  localCourseId: Scalars['ID']['input'];
}>;


export type GetCourseConsistencyInfoQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', loadCourseConsistencyInfo: { __typename?: 'CourseConsistency', courseId: string, name: string, isConsistent: boolean, isConstructorsValid?: boolean | null } } | null };

export type LocalCourseFragment = { __typename?: 'LocalCourseGoalInformation', localCourseGoalId: string, goalId: string, goalName: string, description: string, projectHours: number, signUpDate?: Date | null, beginDate?: Date | null, deadlineDate?: Date | null, checkDate?: Date | null, isContentAvailable: boolean, executionType: ModuleExecutionType, finalPoint: number, finalPercentage: number, status: DisplayedGoalStatus, periodSettings?: PeriodSettings | null, retriesUsed?: number | null, statusUpdateDate?: Date | null, retrySettings?: { __typename?: 'ModuleAttemptsSettings', maxModuleAttempts?: number | null, isUnlimitedAttempts: boolean } | null };

export type GetLocalCourseGoalsQueryVariables = Exact<{
  localCourseId: Scalars['ID']['input'];
}>;


export type GetLocalCourseGoalsQuery = { __typename?: 'Query', course?: { __typename?: 'CourseQueries', getLocalCourseGoals: { __typename?: 'LocalCourseGoals', localCourseId: string, globalCourseId: string, courseName: string, courseType: CourseType, localCourseGoals?: Array<{ __typename?: 'LocalCourseGoalInformation', localCourseGoalId: string, goalId: string, goalName: string, description: string, projectHours: number, signUpDate?: Date | null, beginDate?: Date | null, deadlineDate?: Date | null, checkDate?: Date | null, isContentAvailable: boolean, executionType: ModuleExecutionType, finalPoint: number, finalPercentage: number, status: DisplayedGoalStatus, periodSettings?: PeriodSettings | null, retriesUsed?: number | null, statusUpdateDate?: Date | null, retrySettings?: { __typename?: 'ModuleAttemptsSettings', maxModuleAttempts?: number | null, isUnlimitedAttempts: boolean } | null }> | null } } | null };

export type GetCourseAttemptStatisticQueryVariables = Exact<{
  localCourseId: Scalars['ID']['input'];
}>;


export type GetCourseAttemptStatisticQuery = { __typename?: 'Query', course?: { __typename?: 'CourseQueries', getCourseAttemptStatistic?: Array<{ __typename?: 'StudentCourseAttemptStatistic', resultDate: Date, finalPercentage: number, pointProject: number, completionResultStatus: CompletionResultStatus } | null> | null } | null };

export type GiveUpExamMutationVariables = Exact<{
  goalId: Scalars['ID']['input'];
  examEventId?: InputMaybe<Scalars['ID']['input']>;
  taskId?: InputMaybe<Scalars['ID']['input']>;
  skillId?: InputMaybe<Scalars['ID']['input']>;
}>;


export type GiveUpExamMutation = { __typename?: 'Mutation', sc21ProjectFlow?: { __typename?: 'SC21ProjectFlowMutations', surrenderFromExam: boolean } | null };

export type AttemptStatisticResultFragment = { __typename?: 'StudentGoalAttemptStatistic', finalPercentage: number, pointProject: number, resultModuleCompletion: ResultModuleCompletion, resultDate: Date };

export type GetGoalAttemptStatisticQueryVariables = Exact<{
  goalId: Scalars['ID']['input'];
}>;


export type GetGoalAttemptStatisticQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getGoalAttemptStatistic?: Array<{ __typename?: 'StudentGoalAttemptStatistic', finalPercentage: number, pointProject: number, resultModuleCompletion: ResultModuleCompletion, resultDate: Date } | null> | null } | null };

export type AddToFavouritesMutationVariables = Exact<{
  videoId: Scalars['UUID']['input'];
}>;


export type AddToFavouritesMutation = { __typename?: 'Mutation', mediateka: { __typename?: 'MediatekaMutations', addBookmark: { __typename?: 'ItemBookmarkStatus', status: boolean } } };

export type RemoveFromFavouritesMutationVariables = Exact<{
  videoId: Scalars['UUID']['input'];
}>;


export type RemoveFromFavouritesMutation = { __typename?: 'Mutation', mediateka: { __typename?: 'MediatekaMutations', removeBookmark: { __typename?: 'ItemBookmarkStatus', status: boolean } } };

export type MediatekaTagV2ItemFragmentFragment = { __typename?: 'TagHierarchyElement', tagId: string, name: string, tagType: MediatekaTagType, children?: Array<{ __typename?: 'TagHierarchyElement', tagId: string, name: string, tagType: MediatekaTagType, children?: Array<{ __typename?: 'TagHierarchyElement', tagId: string, name: string, tagType: MediatekaTagType, children?: Array<{ __typename?: 'TagHierarchyElement', tagId: string, name: string, tagType: MediatekaTagType }> | null }> | null }> | null };

export type MediatekaMediaFragmentFragment = { __typename?: 'ContentItem', itemId: string, creatorUserId: string, tagIds: Array<string>, fileName?: string | null, contentName: string, contentType: AdditionalContentType, contentUrl: string, createDate: Date, contentAuthor?: string | null, previewUrl?: string | null, description?: string | null, fileSize?: number | null, subtitleLink?: string | null, itemBookmarked?: boolean | null, tagsV2: Array<{ __typename?: 'TagHierarchyElement', tagId: string, name: string, tagType: MediatekaTagType, children?: Array<{ __typename?: 'TagHierarchyElement', tagId: string, name: string, tagType: MediatekaTagType, children?: Array<{ __typename?: 'TagHierarchyElement', tagId: string, name: string, tagType: MediatekaTagType, children?: Array<{ __typename?: 'TagHierarchyElement', tagId: string, name: string, tagType: MediatekaTagType }> | null }> | null }> | null }>, subtitleLinks?: Array<{ __typename?: 'SubtitleLinkForLanguage', languageCode: string, subtitleLink: string }> | null, stages: Array<{ __typename?: 'Stage', id: string, name: string }> };

export type GetSearchItemsQueryVariables = Exact<{
  filter?: InputMaybe<MediatekaItemsFilter>;
  page: PagingInput;
}>;


export type GetSearchItemsQuery = { __typename?: 'Query', mediateka: { __typename?: 'MediatekaQueries', searchItems: { __typename?: 'ItemPageModel', totalItems: number, content: Array<{ __typename?: 'ContentItem', itemId: string, creatorUserId: string, tagIds: Array<string>, fileName?: string | null, contentName: string, contentType: AdditionalContentType, contentUrl: string, createDate: Date, contentAuthor?: string | null, previewUrl?: string | null, description?: string | null, fileSize?: number | null, subtitleLink?: string | null, itemBookmarked?: boolean | null, tagsV2: Array<{ __typename?: 'TagHierarchyElement', tagId: string, name: string, tagType: MediatekaTagType, children?: Array<{ __typename?: 'TagHierarchyElement', tagId: string, name: string, tagType: MediatekaTagType, children?: Array<{ __typename?: 'TagHierarchyElement', tagId: string, name: string, tagType: MediatekaTagType, children?: Array<{ __typename?: 'TagHierarchyElement', tagId: string, name: string, tagType: MediatekaTagType }> | null }> | null }> | null }>, subtitleLinks?: Array<{ __typename?: 'SubtitleLinkForLanguage', languageCode: string, subtitleLink: string }> | null, stages: Array<{ __typename?: 'Stage', id: string, name: string }> }> } } };

export type GetChildrenTagsListQueryVariables = Exact<{
  filter: MediatekaTagsWithLinksFilter;
}>;


export type GetChildrenTagsListQuery = { __typename?: 'Query', mediateka: { __typename?: 'MediatekaQueries', getTagsRelativesWithFiltering: Array<{ __typename?: 'MediatekaLinkedTags', children: Array<{ __typename?: 'MediatekaTag', id: string, name: string }> }> } };

export type GetParentTagsListQueryVariables = Exact<{
  filter: MediatekaTagsFilter;
  page: PagingInput;
}>;


export type GetParentTagsListQuery = { __typename?: 'Query', mediateka: { __typename?: 'MediatekaQueries', getTagsByFilter: { __typename?: 'MediatekaFilteredTagsWithCount', tags: Array<{ __typename?: 'MediatekaTag', id: string, name: string }> } } };

export type MediatekaCollectionItemFragmentFragment = { __typename?: 'Selection', selectionId: string, name: string };

export type GetCollectionListQueryVariables = Exact<{
  bound?: InputMaybe<Scalars['Boolean']['input']>;
  selectionType?: InputMaybe<SelectionType>;
  stageIds?: InputMaybe<Array<Scalars['ID']['input']> | Scalars['ID']['input']>;
}>;


export type GetCollectionListQuery = { __typename?: 'Query', selection: { __typename?: 'SelectionQueries', getSelections: Array<{ __typename?: 'Selection', selectionId: string, name: string }> } };

export type GetProjectAccessGroupIdByStudentAnswerIdQueryVariables = Exact<{
  answerId: Scalars['ID']['input'];
}>;


export type GetProjectAccessGroupIdByStudentAnswerIdQuery = { __typename?: 'Query', sc21StudentTaskCheck?: { __typename?: 'SC21StudentTaskCheckQueries', getProjectAccessGroupIdByStudentAnswerId: string } | null };

export type GetTaskSolutionTypeQueryVariables = Exact<{
  taskId: Scalars['ID']['input'];
}>;


export type GetTaskSolutionTypeQuery = { __typename?: 'Query', sc21StudentTaskCheck?: { __typename?: 'SC21StudentTaskCheckQueries', getTaskSolutionType: TaskSolutionTypeEnum } | null };

export type PlatfSolutionInfoFragment = { __typename?: 'PlatfSolutionInfo', comment?: string | null, files: Array<{ __typename?: 'StudyProcessFile', studyProcessFileId: string, link: string, status: StudyProcessFileStatusEnum, statusDetails?: string | null, updateDateTime: Date, creatorLogin: string, fileExtension: string, fileSize?: number | null } | null> };

export type GetPlatfSolutionInfoQueryVariables = Exact<{
  studentGoalAttemptId: Scalars['ID']['input'];
}>;


export type GetPlatfSolutionInfoQuery = { __typename?: 'Query', sc21StudentTaskCheck?: { __typename?: 'SC21StudentTaskCheckQueries', getPlatfSolutionInfo?: { __typename?: 'PlatfSolutionInfo', comment?: string | null, files: Array<{ __typename?: 'StudyProcessFile', studyProcessFileId: string, link: string, status: StudyProcessFileStatusEnum, statusDetails?: string | null, updateDateTime: Date, creatorLogin: string, fileExtension: string, fileSize?: number | null } | null> } | null } | null };

export type StudentAnswerCommentFragment = { __typename?: 'StudentAnswerComment', studentAnswerId: string, comment: string };

export type SaveSolutionCommentMutationVariables = Exact<{
  taskId: Scalars['ID']['input'];
  comment: Scalars['String']['input'];
}>;


export type SaveSolutionCommentMutation = { __typename?: 'Mutation', sc21StudentTaskCheck?: { __typename?: 'SC21StudentTaskCheckMutations', saveSolutionComment: { __typename?: 'StudentAnswerComment', studentAnswerId: string, comment: string } } | null };

export type StudyProcessFileFragment = { __typename?: 'StudyProcessFile', studyProcessFileId: string, link: string, status: StudyProcessFileStatusEnum, statusDetails?: string | null, updateDateTime: Date, creatorLogin: string, fileExtension: string, fileSize?: number | null };

export type MarkFileSolutionPendingMutationVariables = Exact<{
  taskId: Scalars['ID']['input'];
  initialFileEvents: Array<StudyProcessFileInitialInput> | StudyProcessFileInitialInput;
}>;


export type MarkFileSolutionPendingMutation = { __typename?: 'Mutation', sc21StudentTaskCheck?: { __typename?: 'SC21StudentTaskCheckMutations', markFileSolutionPending: Array<{ __typename?: 'StudyProcessFile', studyProcessFileId: string, link: string, status: StudyProcessFileStatusEnum, statusDetails?: string | null, updateDateTime: Date, creatorLogin: string, fileExtension: string, fileSize?: number | null }> } | null };

export type MarkFileSolutionFailedToUploadMutationVariables = Exact<{
  taskId: Scalars['ID']['input'];
  errorMessage: Scalars['String']['input'];
  studyProcessFileId: Scalars['ID']['input'];
}>;


export type MarkFileSolutionFailedToUploadMutation = { __typename?: 'Mutation', sc21StudentTaskCheck?: { __typename?: 'SC21StudentTaskCheckMutations', markFileSolutionFailedToUpload: { __typename?: 'StudyProcessFile', studyProcessFileId: string, link: string, status: StudyProcessFileStatusEnum, statusDetails?: string | null, updateDateTime: Date, creatorLogin: string, fileExtension: string, fileSize?: number | null } } | null };

export type MarkFileSolutionUploadCancelledMutationVariables = Exact<{
  taskId: Scalars['ID']['input'];
  studyProcessFileId: Scalars['ID']['input'];
}>;


export type MarkFileSolutionUploadCancelledMutation = { __typename?: 'Mutation', sc21StudentTaskCheck?: { __typename?: 'SC21StudentTaskCheckMutations', markFileSolutionUploadCancelled: { __typename?: 'StudyProcessFile', studyProcessFileId: string, link: string, status: StudyProcessFileStatusEnum, statusDetails?: string | null, updateDateTime: Date, creatorLogin: string, fileExtension: string, fileSize?: number | null } } | null };

export type MarkFileSolutionUploadedStatusMutationVariables = Exact<{
  taskId: Scalars['ID']['input'];
  studyProcessFileIds: Scalars['ID']['input'];
}>;


export type MarkFileSolutionUploadedStatusMutation = { __typename?: 'Mutation', sc21StudentTaskCheck?: { __typename?: 'SC21StudentTaskCheckMutations', markFileSolutionUploadedStatus: { __typename?: 'StudyProcessFile', studyProcessFileId: string, link: string, status: StudyProcessFileStatusEnum, statusDetails?: string | null, updateDateTime: Date, creatorLogin: string, fileExtension: string, fileSize?: number | null } } | null };

export type GetPenaltiesCountQueryVariables = Exact<{
  statuses: Array<InputMaybe<Scalars['String']['input']>> | InputMaybe<Scalars['String']['input']>;
}>;


export type GetPenaltiesCountQuery = { __typename?: 'Query', penalty?: { __typename?: 'PenaltyQueries', countMyPenalties: number } | null };

export type GetNotificationUserSettingsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetNotificationUserSettingsQuery = { __typename?: 'Query', notificationConfiguration?: { __typename?: 'NotificationConfigurationQueries', settings: Array<{ __typename?: 'NotificationUserSetting', groupTypeId: string, groupTypeName: string, typeId: string, typeName: string, channelId: string, channelName: string, channelActive?: boolean | null, channelActiveSystem: boolean, channelLockedSystem: boolean, isMutable?: boolean | null }> } | null };

export type SaveNotificationUserSettingsMutationVariables = Exact<{
  settings: Array<NotificationUserSettingInput> | NotificationUserSettingInput;
}>;


export type SaveNotificationUserSettingsMutation = { __typename?: 'Mutation', notificationConfiguration?: { __typename?: 'NotificationConfigurationMutations', saveNotificationUserSettings: boolean } | null };

export type PasswordChangeSetPasswordMutationVariables = Exact<{
  newPassword: Scalars['String']['input'];
  oldPassword: Scalars['String']['input'];
}>;


export type PasswordChangeSetPasswordMutation = { __typename?: 'Mutation', user?: { __typename?: 'UserMutations', setPassword?: { __typename?: 'User', id: string } | null } | null };

export type CoinsTransactionInfoFragment = { __typename?: 'UserCoinsHistoryItemModel', id: number, itemType: UserCoinsHistoryItemType, amount: number, date: Date, badgeName?: string | null, badgeAvatar?: string | null, externalTransactionId?: number | null, giverLogin?: string | null, comment?: string | null, amountAfter: number, tournamentName?: string | null };

export type GetCoinsHistoryQueryVariables = Exact<{ [key: string]: never; }>;


export type GetCoinsHistoryQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getUserCoinsHistory?: Array<{ __typename?: 'UserCoinsHistoryItemModel', id: number, itemType: UserCoinsHistoryItemType, amount: number, date: Date, badgeName?: string | null, badgeAvatar?: string | null, externalTransactionId?: number | null, giverLogin?: string | null, comment?: string | null, amountAfter: number, tournamentName?: string | null }> | null } | null };

export type PublicProfileGetProjectsQueryVariables = Exact<{
  studentId: Scalars['UUID']['input'];
  stageGroupId: Scalars['ID']['input'];
}>;


export type PublicProfileGetProjectsQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getStudentProjectsForPublicProfileByStageGroup: Array<{ __typename?: 'StudentItem', groupName: string, name: string, experience: number, finalPercentage?: number | null, goalId?: number | null, goalStatus?: DisplayedGoalStatus | null, amountAnswers?: number | null, amountReviewedAnswers?: number | null, executionType?: ModuleExecutionType | null, localCourseId?: number | null, courseType?: CourseType | null, displayedCourseStatus?: DisplayedCourseStatus | null } | null> } | null };

export type PublicProfileLoadStageGroupsQueryVariables = Exact<{
  studentId: Scalars['UUID']['input'];
}>;


export type PublicProfileLoadStageGroupsQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', loadStudentStageGroups?: Array<{ __typename?: 'StageGroupS21Student', stageGroupStudentId: string, studentId: string, stageGroupS21: { __typename?: 'StageGroupS21', waveId: number, waveName: string, eduForm: string, active?: boolean | null }, safeSchool: { __typename?: 'SafeSchool', fullName: string } } | null> | null } | null };

export type GetDismissInfoByStudentIdQueryVariables = Exact<{
  studentId: Scalars['UUID']['input'];
}>;


export type GetDismissInfoByStudentIdQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getDismissInfoByStudentId?: { __typename?: 'StudentDismissInfo', dismissTypeId: string, dismissTs: Date, lastStageGroupS21?: { __typename?: 'StageGroupS21', waveId: number, waveName: string, eduForm: string, active?: boolean | null } | null } | null } | null };

export type StudentProfileGetUserRestrictionsByUserIdAndSchoolIdQueryVariables = Exact<{
  userId: Scalars['UUID']['input'];
  schoolId: Scalars['UUID']['input'];
}>;


export type StudentProfileGetUserRestrictionsByUserIdAndSchoolIdQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getUserRestrictionsByUserIdAndSchoolId: Array<{ __typename?: 'UserRestriction', restrictionId: string, restrictionType: string, userId: string, schoolId: string, isActive: boolean, createdTs: Date, updatedTs?: Date | null } | null> } | null };

export type TimelineItemChildrenFragment = { __typename?: 'ProjectTimelineItem', type: TimelineItemType, elementType?: TimelineElementEnum | null, status: TimelineItemStatus, start?: Date | null, end?: Date | null, order?: number | null };

export type TimelineItemFragment = { __typename?: 'ProjectTimelineItem', type: TimelineItemType, status: TimelineItemStatus, start?: Date | null, end?: Date | null, children?: Array<{ __typename?: 'ProjectTimelineItem', type: TimelineItemType, elementType?: TimelineElementEnum | null, status: TimelineItemStatus, start?: Date | null, end?: Date | null, order?: number | null } | null> | null };

export type CourseInfoFragment = { __typename?: 'CourseCoverInformation', courseName: string, courseType: CourseType, courseStatus?: CourseStatus | null, displayedCourseStatus?: DisplayedCourseStatus | null, signUpEndDate?: Date | null, signUpStartDate?: Date | null, workStartDate?: Date | null, workEndDate?: Date | null, duration: number, courseDescription: string, finalPercentage: number, courseStatusesHistory: Array<CourseStatus>, experience: number, experienceFact?: number | null, currentStudentCount: number, retriesOfCurrentStudents: number, teamsWaitingEvaluationCount: number, finishedCount: number, retriesCount: number, resultCourseCompletion?: CompletionResultStatus | null, isRetryAvailable?: boolean | null, isCourseCanBeFinished?: boolean | null, softSkills: Array<{ __typename?: 'SoftSkillPoint', softSkillId: number, maxPower: number, currentUserPower: number, softSkillName: string, totalPower: number, teamRole?: TeamRole | null, achievedUserPower?: number | null }>, timeline: Array<{ __typename?: 'ProjectTimelineItem', type: TimelineItemType, status: TimelineItemStatus, start?: Date | null, end?: Date | null, children?: Array<{ __typename?: 'ProjectTimelineItem', type: TimelineItemType, elementType?: TimelineElementEnum | null, status: TimelineItemStatus, start?: Date | null, end?: Date | null, order?: number | null } | null> | null }> };

export type GetCourseInfoByStudentQueryVariables = Exact<{
  localCourseId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
}>;


export type GetCourseInfoByStudentQuery = { __typename?: 'Query', course?: { __typename?: 'CourseQueries', getCourseCoverInformationByStudent: { __typename?: 'CourseCoverInformation', courseName: string, courseType: CourseType, courseStatus?: CourseStatus | null, displayedCourseStatus?: DisplayedCourseStatus | null, signUpEndDate?: Date | null, signUpStartDate?: Date | null, workStartDate?: Date | null, workEndDate?: Date | null, duration: number, courseDescription: string, finalPercentage: number, courseStatusesHistory: Array<CourseStatus>, experience: number, experienceFact?: number | null, currentStudentCount: number, retriesOfCurrentStudents: number, teamsWaitingEvaluationCount: number, finishedCount: number, retriesCount: number, resultCourseCompletion?: CompletionResultStatus | null, isRetryAvailable?: boolean | null, isCourseCanBeFinished?: boolean | null, softSkills: Array<{ __typename?: 'SoftSkillPoint', softSkillId: number, maxPower: number, currentUserPower: number, softSkillName: string, totalPower: number, teamRole?: TeamRole | null, achievedUserPower?: number | null }>, timeline: Array<{ __typename?: 'ProjectTimelineItem', type: TimelineItemType, status: TimelineItemStatus, start?: Date | null, end?: Date | null, children?: Array<{ __typename?: 'ProjectTimelineItem', type: TimelineItemType, elementType?: TimelineElementEnum | null, status: TimelineItemStatus, start?: Date | null, end?: Date | null, order?: number | null } | null> | null }> }, getCourseAttemptStatisticByStudent?: Array<{ __typename?: 'StudentCourseAttemptStatistic', completionResultStatus: CompletionResultStatus } | null> | null, getCourseRetryInfoByStudent: { __typename?: 'StudentGoalRetryInfo', totalRetryValue: number, usedRetryCount: number, unlimitedAttempts: boolean }, getLocalCourseGoalsByStudent: { __typename?: 'LocalCourseGoals', localCourseGoals?: Array<{ __typename?: 'LocalCourseGoalInformation', executionType: ModuleExecutionType }> | null } } | null };

export type GetCampusUserAvatarQueryVariables = Exact<{
  userId: Scalars['UUID']['input'];
}>;


export type GetCampusUserAvatarQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getAvatarByUserId?: string | null } | null };

export type GetCampusUserIdByLoginQueryVariables = Exact<{
  login: Scalars['String']['input'];
}>;


export type GetCampusUserIdByLoginQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getUserIdByLogin?: string | null } | null };

export type GetCampusBuildingsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetCampusBuildingsQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getBuildings: Array<{ __typename?: 'Building', id: string, name: string, classrooms: Array<{ __typename?: 'ClassRoom', id: string, number: string, capacity: number, availableCapacity: number, floor: number, specializations: Array<string>, classroomPlan?: { __typename?: 'ClassroomPlan', classroomPlanId: string, planMeta: string } | null }> }> } | null };

export type GetCampusPlanOccupiedQueryVariables = Exact<{
  clusterId: Scalars['ID']['input'];
}>;


export type GetCampusPlanOccupiedQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getClusterPlanStudentsByClusterId: { __typename?: 'ClusterPlanStudents', occupiedPlaces: Array<{ __typename?: 'CurrentWorkstationUser', row: string, number: number, stageGroupName: string, stageName: string, studentType: StudentPlatformType, user: { __typename?: 'User', id: string, login?: string | null, avatarUrl: string }, experience: { __typename?: 'UserExperience', id: string, value: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', id: string, levelCode: number, leftBorder: number, rightBorder: number } } } }> } } | null };

export type GetCampusCurrentUserQueryVariables = Exact<{ [key: string]: never; }>;


export type GetCampusCurrentUserQuery = { __typename?: 'Query', user?: { __typename?: 'UserQueries', getCurrentUser: { __typename?: 'User', id: string, login?: string | null } } | null };

export type GetCampusWorkstationQueryVariables = Exact<{
  login: Scalars['String']['input'];
}>;


export type GetCampusWorkstationQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getWorkstationByLogin?: { __typename?: 'WorkstationModel', id: string, classroomId: string, hostName?: string | null, workstationRow: string, workstationNumber: number } | null } | null };

export type FormChecklistQuestionFragment = { __typename?: 'SectionQuestion', sectionQuestionId: string, name: string, description: string, taskAssessmentScale: { __typename?: 'CriterionScale', criterionScaleId: string, type: CriterionScaleType, description: string, scaleWeights: Array<{ __typename?: 'KeyValue', key: string, value: string }> } };

export type FormChecklistSectionFragment = { __typename?: 'ChecklistSection', checklistSectionId: string, name: string, description?: string | null, kindQuestionId: string, questionList?: Array<{ __typename?: 'SectionQuestion', sectionQuestionId: string, name: string, description: string, taskAssessmentScale: { __typename?: 'CriterionScale', criterionScaleId: string, type: CriterionScaleType, description: string, scaleWeights: Array<{ __typename?: 'KeyValue', key: string, value: string }> } } | null> | null };

export type OnlineReviewInfoFragment = { __typename?: 'OnlineReview', isOnline: boolean, videos?: Array<{ __typename?: 'OnlineReviewVideo', onlineVideoId: string, link: string, status: StudyProcessFileStatusEnum, statusDetails?: string | null, updateDateTime: Date, fileSize: number }> | null };

export type FilledChecklistModuleInfoFragment = { __typename?: 'ModuleInfoP2P', moduleName: string, executionType?: ModuleExecutionType | null, periodOfVerification: number };

export type FormChecklistFragment = { __typename?: 'Checklist', introduction?: string | null, guidelines: string, quickActions: Array<QuickAction>, availableLanguages?: Array<LanguageCodeType> | null, languageCode: LanguageCodeType, sectionList: Array<{ __typename?: 'ChecklistSection', checklistSectionId: string, name: string, description?: string | null, kindQuestionId: string, questionList?: Array<{ __typename?: 'SectionQuestion', sectionQuestionId: string, name: string, description: string, taskAssessmentScale: { __typename?: 'CriterionScale', criterionScaleId: string, type: CriterionScaleType, description: string, scaleWeights: Array<{ __typename?: 'KeyValue', key: string, value: string }> } } | null> | null }> };

export type ChecklistSolutionInfoFragment = { __typename?: 'SolutionInfo', solutionType: TaskSolutionTypeEnum, gitlabSolutionInfo?: { __typename?: 'GitlabSolutionInfo', gitlabLink: { __typename?: 'GitlabLink', id: number, sshLink: string, httpsLink: string } } | null, platfSolutionInfo?: { __typename?: 'PlatfSolutionInfo', comment?: string | null, files: Array<{ __typename?: 'StudyProcessFile', studyProcessFileId: string, link: string, creatorLogin: string, fileExtension: string, fileSize?: number | null } | null> } | null };

export type GetFilledChecklistQueryVariables = Exact<{
  filledChecklistId: Scalars['ID']['input'];
  languageCodeType?: InputMaybe<LanguageCodeType>;
}>;


export type GetFilledChecklistQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getP2pInfo: { __typename?: 'FilledChecklist', id: string, solutionInfo?: { __typename?: 'SolutionInfo', solutionType: TaskSolutionTypeEnum, gitlabSolutionInfo?: { __typename?: 'GitlabSolutionInfo', gitlabLink: { __typename?: 'GitlabLink', id: number, sshLink: string, httpsLink: string } } | null, platfSolutionInfo?: { __typename?: 'PlatfSolutionInfo', comment?: string | null, files: Array<{ __typename?: 'StudyProcessFile', studyProcessFileId: string, link: string, creatorLogin: string, fileExtension: string, fileSize?: number | null } | null> } | null } | null, checklist: { __typename?: 'Checklist', introduction?: string | null, guidelines: string, quickActions: Array<QuickAction>, availableLanguages?: Array<LanguageCodeType> | null, languageCode: LanguageCodeType, sectionList: Array<{ __typename?: 'ChecklistSection', checklistSectionId: string, name: string, description?: string | null, kindQuestionId: string, questionList?: Array<{ __typename?: 'SectionQuestion', sectionQuestionId: string, name: string, description: string, taskAssessmentScale: { __typename?: 'CriterionScale', criterionScaleId: string, type: CriterionScaleType, description: string, scaleWeights: Array<{ __typename?: 'KeyValue', key: string, value: string }> } } | null> | null }> }, moduleInfoP2P?: { __typename?: 'ModuleInfoP2P', moduleName: string, executionType?: ModuleExecutionType | null, periodOfVerification: number } | null, progressCheckInfo?: { __typename?: 'ProgressCheckInfo', reviewUserCount: number, reviewUserCountExecuted: number } | null, verifiableUsers?: { __typename?: 'VerifiableUsers', teamWithMembers?: { __typename?: 'TeamWithMembers', team: { __typename?: 'Team', id: string, name: string }, members: Array<{ __typename?: 'TeamMember', role: TeamRole, user?: { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, levelCode: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null } | null }> } | null, user?: { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, levelCode: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null } | null } | null, onlineReview?: { __typename?: 'OnlineReview', isOnline: boolean, videos?: Array<{ __typename?: 'OnlineReviewVideo', onlineVideoId: string, link: string, status: StudyProcessFileStatusEnum, statusDetails?: string | null, updateDateTime: Date, fileSize: number }> | null } | null } } | null };

export type SaveFilledChecklistMutationVariables = Exact<{
  filledChecklistInput: ChecklistFilledInput;
}>;


export type SaveFilledChecklistMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', completeP2pCheck: number } | null };

export type CompleteFirstCodeReviewRoundMutationVariables = Exact<{
  studentGoalId: Scalars['ID']['input'];
}>;


export type CompleteFirstCodeReviewRoundMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', completeFirstCodeReviewRound: Array<{ __typename?: 'CodeReviewRound', codeReviewRoundId: string }> } | null };

export type EvaluateCodeReviewProjectAndReviewersMutationVariables = Exact<{
  studentGoalId: Scalars['ID']['input'];
  finalMark: Scalars['Boolean']['input'];
  studentMarks: Array<CodeReviewersMarksInput> | CodeReviewersMarksInput;
}>;


export type EvaluateCodeReviewProjectAndReviewersMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', evaluateCodeReviewProjectAndReviewers?: { __typename?: 'StudentCodeReview', studentCodeReviewId: string } | null } | null };

export type CodeReviewRoundFragment = { __typename?: 'CodeReviewRound', eventId?: string | null, codeReviewRoundType: CodeReviewRoundType, codeReviewStatus: CodeReviewStatus, startTime: Date, endTime: Date, mergeRequestURL: string, createTime: Date };

export type GetCodeReviewMyStudentQueryVariables = Exact<{
  studentGoalId: Scalars['ID']['input'];
}>;


export type GetCodeReviewMyStudentQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getMyStudentCodeReview?: { __typename?: 'StudentCodeReview', reviewerCommentsCount?: number | null, codeReviewRounds: Array<{ __typename?: 'CodeReviewRound', eventId?: string | null, codeReviewRoundType: CodeReviewRoundType, codeReviewStatus: CodeReviewStatus, startTime: Date, endTime: Date, mergeRequestURL: string, createTime: Date }> } | null } | null };

export type GetCoreReviewImportedLanguagesForCurrentVersionQueryVariables = Exact<{
  studentGoalId: Scalars['ID']['input'];
}>;


export type GetCoreReviewImportedLanguagesForCurrentVersionQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getImportedLanguagesForCurrentVersionByStudentGoalId: Array<string | null> } | null };

export type CodeReviewCurrentTaskInfoFragment = { __typename?: 'StudentTask', id: string, taskId: string, task: { __typename?: 'Task', assignmentType: TaskAssignmentEnum, translatedData?: string | null, content?: { __typename?: 'TaskContent', body?: string | null } | null, studentTaskAdditionalAttributes: { __typename?: 'StudentTaskAdditionalAttributes', codeReviewDuration: number, codeReviewCost: number } } };

export type CodeReviewProjectInfoFragment = { __typename?: 'StudentModule', id: string, moduleTitle: string, studyModule: { __typename?: 'StudyModule', duration: number, stage: { __typename?: 'Stage', name: string } }, currentTask?: { __typename?: 'StudentTask', id: string, taskId: string, task: { __typename?: 'Task', assignmentType: TaskAssignmentEnum, translatedData?: string | null, content?: { __typename?: 'TaskContent', body?: string | null } | null, studentTaskAdditionalAttributes: { __typename?: 'StudentTaskAdditionalAttributes', codeReviewDuration: number, codeReviewCost: number } } } | null };

export type GetCodeReviewProjectInfoQueryVariables = Exact<{
  studentGoalId: Scalars['ID']['input'];
  language?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetCodeReviewProjectInfoQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getStudentModuleByStudentGoalId: { __typename?: 'StudentModule', id: string, moduleTitle: string, studyModule: { __typename?: 'StudyModule', duration: number, stage: { __typename?: 'Stage', name: string } }, currentTask?: { __typename?: 'StudentTask', id: string, taskId: string, task: { __typename?: 'Task', assignmentType: TaskAssignmentEnum, translatedData?: string | null, content?: { __typename?: 'TaskContent', body?: string | null } | null, studentTaskAdditionalAttributes: { __typename?: 'StudentTaskAdditionalAttributes', codeReviewDuration: number, codeReviewCost: number } } } | null } } | null };

export type StudentsCodeReviewByStudentFragment = { __typename?: 'StudentCodeReview', reviewerStudentId: string, user: { __typename?: 'User', login?: string | null, avatarUrl: string } };

export type GetStudentCodeReviewByStudentGoalIdQueryVariables = Exact<{
  studentGoalId: Scalars['ID']['input'];
}>;


export type GetStudentCodeReviewByStudentGoalIdQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getStudentCodeReviewByStudentGoalId: Array<{ __typename?: 'StudentCodeReview', reviewerStudentId: string, user: { __typename?: 'User', login?: string | null, avatarUrl: string } }> } | null };

export type RemoveCodeReviewBookingMutationVariables = Exact<{
  eventId: Scalars['ID']['input'];
}>;


export type RemoveCodeReviewBookingMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', removeBookingToCodeReview?: { __typename?: 'CalendarEvent', id: string } | null } | null };

export type ProjectMapGetStudentGraphTemplateQueryVariables = Exact<{
  studentId?: InputMaybe<Scalars['UUID']['input']>;
  stageGroupId?: InputMaybe<Scalars['Int']['input']>;
}>;


export type ProjectMapGetStudentGraphTemplateQuery = { __typename?: 'Query', holyGraph?: { __typename?: 'HolyGraphQueries', getStudentGraphTemplate?: { __typename?: 'HolyGraphJSON', edges: Array<{ __typename?: 'HolyGraphEdge', id: string, source: string, target: string, sourceHandle: string, targetHandle: string, data: { __typename?: 'HolyGraphEdgeData', sourceGap: number, targetGap: number, points: Array<{ __typename?: 'HolyGraphPointPosition', x: number, y: number }> } }>, nodes: Array<{ __typename?: 'HolyGraphNode', id: string, label: string, handles: Array<string>, position: { __typename?: 'HolyGraphNodePosition', x: number, y: number }, items: Array<{ __typename?: 'HolyGraphNodeItem', id: string, code: string, handles: Array<string>, entityType: HolyGraphItemEntityType, entityId: number, parentNodeCodes: Array<string>, childrenNodeCodes: Array<string>, skills: Array<{ __typename?: 'HolyGraphItemSkill', id: string, name: string, color: string, textColor?: string | null }>, goal?: { __typename?: 'HolyGraphItemGoalInfo', projectId: number, projectName: string, projectDescription?: string | null, projectPoints?: number | null, goalExecutionType?: ModuleExecutionType | null, isMandatory?: boolean | null } | null, course?: { __typename?: 'HolyGraphItemCourseInfo', projectId: number, projectName: string, projectDescription?: string | null, projectPoints?: number | null, courseType?: CourseType | null, isMandatory?: boolean | null } | null }> }> } | null } | null };

export type ProjectMapGetStudentStageGroupsQueryVariables = Exact<{
  studentId: Scalars['UUID']['input'];
}>;


export type ProjectMapGetStudentStageGroupsQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', loadStudentStageGroups?: Array<{ __typename?: 'StageGroupS21Student', stageGroupS21: { __typename?: 'StageGroupS21', waveId: number, waveName: string, eduForm: string, active?: boolean | null } } | null> | null } | null };

export type ProjectMapGetStudentStateGraphNodeQueryVariables = Exact<{
  graphNode: Scalars['JsonNode']['input'];
  studentId?: InputMaybe<Scalars['UUID']['input']>;
  stageGroupId?: InputMaybe<Scalars['Int']['input']>;
}>;


export type ProjectMapGetStudentStateGraphNodeQuery = { __typename?: 'Query', holyGraph?: { __typename?: 'HolyGraphQueries', getStudentStateGraphNode?: { __typename?: 'HolyGraphNode', id: string, items: Array<{ __typename?: 'HolyGraphNodeItem', id: string, goal?: { __typename?: 'HolyGraphItemGoalInfo', projectState?: GraphNodeProgressStateEnum | null, duration?: number | null, projectDate?: Date | null } | null, course?: { __typename?: 'HolyGraphItemCourseInfo', projectState?: GraphNodeProgressStateEnum | null, localCourseId?: number | null, duration?: number | null, projectDate?: Date | null } | null }> } | null } | null };

export type GetGraphGetCurrentUserQueryVariables = Exact<{ [key: string]: never; }>;


export type GetGraphGetCurrentUserQuery = { __typename?: 'Query', user?: { __typename?: 'UserQueries', getCurrentUser: { __typename?: 'User', id: string, currentSchoolStudentId?: string | null, login?: string | null } } | null };

export type GetGraphGetStudentAvatarQueryVariables = Exact<{
  userId: Scalars['UUID']['input'];
}>;


export type GetGraphGetStudentAvatarQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getAvatarByUserId?: string | null } | null };

export type GetGraphStudentIdByLoginQueryVariables = Exact<{
  login: Scalars['String']['input'];
}>;


export type GetGraphStudentIdByLoginQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getStudentIdByLogin?: string | null, getUserIdByLogin?: string | null } | null };

export type GetClassmatesQueryVariables = Exact<{
  textSearch?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetClassmatesQuery = { __typename?: 'Query', honorRating?: { __typename: 'HonorRatingQueries', getClassmates: Array<{ __typename: 'User', id: string, firstName: string, lastName: string, login?: string | null }> } | null };

export type SaveHonorRatingsMutationVariables = Exact<{
  studentHonorRatings: Array<StudentHonorRatingInput> | StudentHonorRatingInput;
}>;


export type SaveHonorRatingsMutation = { __typename?: 'Mutation', honorRating?: { __typename?: 'HonorRatingMutations', saveStudentHonorRatings: Array<{ __typename?: 'StudentHonorRatingModel', studentHonorRatingId: string }> } | null };

export type UpcomingEventFragment = { __typename?: 'CalendarEvent', id: string, start: Date, end: Date, maxStudentCount?: number | null, location?: string | null, ipRange?: string | null, eventType?: string | null, eventCode?: string | null, description: string, externalId?: number | null, currentStudentsCount?: number | null, bookings: Array<{ __typename?: 'CalendarBooking', id: string, task?: { __typename?: 'Task', id: string, goalName: string } | null }>, eventSlots: Array<{ __typename?: 'CalendarTimeSlot', id: string, eventId: string, type: TimeSlotTypeEnum, start: Date, end: Date }>, exam?: { __typename?: 'Exam', examId: string, eventId: string, beginDate: Date, endDate: Date, location: string, ip?: string | null, maxStudentCount?: number | null, isVisible: boolean, name: string, goalId: string, isWaitListActive: boolean, isInWaitList?: boolean | null, currentStudentsCount: number, createDate: Date, updateDate: Date, schoolId: string, stopRegisterDate?: Date | null, isRegistered?: boolean | null, goalName: string, eventType?: string | null, registrationAccessStatus: ExamEventRegistrationAccessStatus } | null, studentCodeReview?: { __typename?: 'StudentCodeReview', studentGoalId: string } | null, activity?: { __typename?: 'ActivityEvent', activityEventId: string, eventId: string, beginDate: Date, endDate: Date, location: string, description?: string | null, maxStudentCount?: number | null, isVisible: boolean, name: string, isWaitListActive: boolean, isInWaitList?: boolean | null, currentStudentsCount: number, createDate: Date, updateDate: Date, schoolId: string, stopRegisterDate?: Date | null, isRegistered?: boolean | null, activityType: string, eventType: string, isMandatory: boolean, status?: ParticipantEventStatus | null, organizers?: Array<{ __typename?: 'User', id: string, login?: string | null }> | null } | null, penalty?: { __typename?: 'Penalty', comment?: string | null, id?: string | null, duration: number, status: string, startTime?: Date | null, createTime: Date, reasonId: string, penaltySlot?: { __typename?: 'PenaltySlot', currentStudentsCount?: number | null, description?: string | null, duration?: number | null, startTime?: Date | null, id: string, endTime?: Date | null } | null } | null };

export type GetUpcomingEventsQueryVariables = Exact<{
  eventCodes: Array<Scalars['String']['input']> | Scalars['String']['input'];
  registrationAccessStatusFilter?: InputMaybe<RegistartionStatusEnum>;
  page?: InputMaybe<PagingInput>;
}>;


export type GetUpcomingEventsQuery = { __typename?: 'Query', calendarEventS21?: { __typename?: 'CalendarEventS21Queries', getUpcomingEventsForRegistration: Array<{ __typename?: 'CalendarEvent', id: string, start: Date, end: Date, maxStudentCount?: number | null, location?: string | null, ipRange?: string | null, eventType?: string | null, eventCode?: string | null, description: string, externalId?: number | null, currentStudentsCount?: number | null, bookings: Array<{ __typename?: 'CalendarBooking', id: string, task?: { __typename?: 'Task', id: string, goalName: string } | null }>, eventSlots: Array<{ __typename?: 'CalendarTimeSlot', id: string, eventId: string, type: TimeSlotTypeEnum, start: Date, end: Date }>, exam?: { __typename?: 'Exam', examId: string, eventId: string, beginDate: Date, endDate: Date, location: string, ip?: string | null, maxStudentCount?: number | null, isVisible: boolean, name: string, goalId: string, isWaitListActive: boolean, isInWaitList?: boolean | null, currentStudentsCount: number, createDate: Date, updateDate: Date, schoolId: string, stopRegisterDate?: Date | null, isRegistered?: boolean | null, goalName: string, eventType?: string | null, registrationAccessStatus: ExamEventRegistrationAccessStatus } | null, studentCodeReview?: { __typename?: 'StudentCodeReview', studentGoalId: string } | null, activity?: { __typename?: 'ActivityEvent', activityEventId: string, eventId: string, beginDate: Date, endDate: Date, location: string, description?: string | null, maxStudentCount?: number | null, isVisible: boolean, name: string, isWaitListActive: boolean, isInWaitList?: boolean | null, currentStudentsCount: number, createDate: Date, updateDate: Date, schoolId: string, stopRegisterDate?: Date | null, isRegistered?: boolean | null, activityType: string, eventType: string, isMandatory: boolean, status?: ParticipantEventStatus | null, organizers?: Array<{ __typename?: 'User', id: string, login?: string | null }> | null } | null, penalty?: { __typename?: 'Penalty', comment?: string | null, id?: string | null, duration: number, status: string, startTime?: Date | null, createTime: Date, reasonId: string, penaltySlot?: { __typename?: 'PenaltySlot', currentStudentsCount?: number | null, description?: string | null, duration?: number | null, startTime?: Date | null, id: string, endTime?: Date | null } | null } | null } | null> } | null };

export type StartP2pCheckMutationVariables = Exact<{
  filledChecklistId: Scalars['ID']['input'];
}>;


export type StartP2pCheckMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', startP2pCheck: boolean } | null };

export type UpdateP2POnlineTypeMutationVariables = Exact<{
  bookingId: Scalars['ID']['input'];
}>;


export type UpdateP2POnlineTypeMutation = { __typename?: 'Mutation', sc21StudentTaskCheck?: { __typename?: 'SC21StudentTaskCheckMutations', enableOnlineP2pCheck: { __typename?: 'CalendarBooking', id: string } } | null };

export type MarkAbsenceAtP2PMutationVariables = Exact<{
  bookingId: Scalars['ID']['input'];
}>;


export type MarkAbsenceAtP2PMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', markAbsenceInProtocol: BookingStatusEnum } | null };

export type RemoveP2PMutationVariables = Exact<{
  bookingId: Scalars['ID']['input'];
}>;


export type RemoveP2PMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', removeBookingFromEventSlot: boolean } | null };

export type SubscribeToEventMutationVariables = Exact<{
  eventId: Scalars['ID']['input'];
}>;


export type SubscribeToEventMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', subscribeToEvent: { __typename?: 'CalendarEvent', id: string, start: Date, end: Date, maxStudentCount?: number | null, location?: string | null, ipRange?: string | null, eventType?: string | null, eventCode?: string | null, description: string, externalId?: number | null, currentStudentsCount?: number | null, bookings: Array<{ __typename?: 'CalendarBooking', id: string, task?: { __typename?: 'Task', id: string, goalName: string } | null }>, eventSlots: Array<{ __typename?: 'CalendarTimeSlot', id: string, eventId: string, type: TimeSlotTypeEnum, start: Date, end: Date }>, exam?: { __typename?: 'Exam', examId: string, eventId: string, beginDate: Date, endDate: Date, location: string, ip?: string | null, maxStudentCount?: number | null, isVisible: boolean, name: string, goalId: string, isWaitListActive: boolean, isInWaitList?: boolean | null, currentStudentsCount: number, createDate: Date, updateDate: Date, schoolId: string, stopRegisterDate?: Date | null, isRegistered?: boolean | null, goalName: string, eventType?: string | null, registrationAccessStatus: ExamEventRegistrationAccessStatus } | null, studentCodeReview?: { __typename?: 'StudentCodeReview', studentGoalId: string } | null, activity?: { __typename?: 'ActivityEvent', activityEventId: string, eventId: string, beginDate: Date, endDate: Date, location: string, description?: string | null, maxStudentCount?: number | null, isVisible: boolean, name: string, isWaitListActive: boolean, isInWaitList?: boolean | null, currentStudentsCount: number, createDate: Date, updateDate: Date, schoolId: string, stopRegisterDate?: Date | null, isRegistered?: boolean | null, activityType: string, eventType: string, isMandatory: boolean, status?: ParticipantEventStatus | null, organizers?: Array<{ __typename?: 'User', id: string, login?: string | null }> | null } | null, penalty?: { __typename?: 'Penalty', comment?: string | null, id?: string | null, duration: number, status: string, startTime?: Date | null, createTime: Date, reasonId: string, penaltySlot?: { __typename?: 'PenaltySlot', currentStudentsCount?: number | null, description?: string | null, duration?: number | null, startTime?: Date | null, id: string, endTime?: Date | null } | null } | null } } | null };

export type UnsubscribeFromEventMutationVariables = Exact<{
  eventId: Scalars['ID']['input'];
}>;


export type UnsubscribeFromEventMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', unsubscribeFromEvent: { __typename?: 'CalendarEvent', id: string, start: Date, end: Date, maxStudentCount?: number | null, location?: string | null, ipRange?: string | null, eventType?: string | null, eventCode?: string | null, description: string, externalId?: number | null, currentStudentsCount?: number | null, bookings: Array<{ __typename?: 'CalendarBooking', id: string, task?: { __typename?: 'Task', id: string, goalName: string } | null }>, eventSlots: Array<{ __typename?: 'CalendarTimeSlot', id: string, eventId: string, type: TimeSlotTypeEnum, start: Date, end: Date }>, exam?: { __typename?: 'Exam', examId: string, eventId: string, beginDate: Date, endDate: Date, location: string, ip?: string | null, maxStudentCount?: number | null, isVisible: boolean, name: string, goalId: string, isWaitListActive: boolean, isInWaitList?: boolean | null, currentStudentsCount: number, createDate: Date, updateDate: Date, schoolId: string, stopRegisterDate?: Date | null, isRegistered?: boolean | null, goalName: string, eventType?: string | null, registrationAccessStatus: ExamEventRegistrationAccessStatus } | null, studentCodeReview?: { __typename?: 'StudentCodeReview', studentGoalId: string } | null, activity?: { __typename?: 'ActivityEvent', activityEventId: string, eventId: string, beginDate: Date, endDate: Date, location: string, description?: string | null, maxStudentCount?: number | null, isVisible: boolean, name: string, isWaitListActive: boolean, isInWaitList?: boolean | null, currentStudentsCount: number, createDate: Date, updateDate: Date, schoolId: string, stopRegisterDate?: Date | null, isRegistered?: boolean | null, activityType: string, eventType: string, isMandatory: boolean, status?: ParticipantEventStatus | null, organizers?: Array<{ __typename?: 'User', id: string, login?: string | null }> | null } | null, penalty?: { __typename?: 'Penalty', comment?: string | null, id?: string | null, duration: number, status: string, startTime?: Date | null, createTime: Date, reasonId: string, penaltySlot?: { __typename?: 'PenaltySlot', currentStudentsCount?: number | null, description?: string | null, duration?: number | null, startTime?: Date | null, id: string, endTime?: Date | null } | null } | null } } | null };

export type GetImportedLanguagesForCurrentVersionQueryVariables = Exact<{
  taskId: Scalars['ID']['input'];
}>;


export type GetImportedLanguagesForCurrentVersionQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getImportedLanguagesForCurrentVersion: Array<string | null> } | null };

export type GetTasksByIdQueryVariables = Exact<{
  goalId: Scalars['ID']['input'];
  localCourseId?: InputMaybe<Scalars['ID']['input']>;
  taskId: Scalars['ID']['input'];
  language?: InputMaybe<Scalars['String']['input']>;
}>;


export type GetTasksByIdQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getTasksById: Array<{ __typename?: 'StudentTask', id: string, task: { __typename?: 'Task', id: string, translatedData?: string | null, content?: { __typename?: 'TaskContent', id: string, body?: string | null } | null } }> } | null };

export type GetGitlabSettingsTokenQueryVariables = Exact<{
  taskId: Scalars['ID']['input'];
}>;


export type GetGitlabSettingsTokenQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getLinkToPrivateStudentGitlabProjectByTaskId: { __typename?: 'GitlabLink', runnersToken: string } } | null };

export type GetTaskContentFilesQueryVariables = Exact<{
  studentAnswerId: Scalars['ID']['input'];
}>;


export type GetTaskContentFilesQuery = { __typename?: 'Query', s21StudentTaskFiles?: { __typename?: 'S21StudentTaskFiles', getTaskContentFiles: Array<{ __typename?: 'TaskFile', fileName: string, filePath: string, fileSize: number, extension: FileExtensionEnum, fileOrder: number }> } | null };

export type GetProjectConsistencyInfoQueryVariables = Exact<{
  goalId: Scalars['ID']['input'];
}>;


export type GetProjectConsistencyInfoQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', loadGoalConsistencyInfo: { __typename?: 'GoalConsistency', goalId: string, isConsistent: boolean, isConstructorsValid?: boolean | null } } | null };

export type LocalCourseGoalsFragment = { __typename?: 'LocalCourseGoals', courseType: CourseType, displayedCourseStatus?: DisplayedCourseStatus | null, localCourseGoals?: Array<{ __typename?: 'LocalCourseGoalInformation', finalPercentage: number, status: DisplayedGoalStatus, localCourseGoalId: string, goalId: string, goalName: string, executionType: ModuleExecutionType }> | null };

export type GetLocalCourseGoalsInfoQueryVariables = Exact<{
  localCourseId: Scalars['ID']['input'];
}>;


export type GetLocalCourseGoalsInfoQuery = { __typename?: 'Query', course?: { __typename?: 'CourseQueries', getLocalCourseGoals: { __typename?: 'LocalCourseGoals', courseType: CourseType, displayedCourseStatus?: DisplayedCourseStatus | null, localCourseGoals?: Array<{ __typename?: 'LocalCourseGoalInformation', finalPercentage: number, status: DisplayedGoalStatus, localCourseGoalId: string, goalId: string, goalName: string, executionType: ModuleExecutionType }> | null } } | null };

export type AttachedFilesWidgetGetProjectsSelectionQueryVariables = Exact<{
  entityId: Scalars['ID']['input'];
}>;


export type AttachedFilesWidgetGetProjectsSelectionQuery = { __typename?: 'Query', selection: { __typename?: 'SelectionQueries', getSelectionByEntity: Array<string> } };

export type AttachedFilesWidgetGetSelectionQueryVariables = Exact<{
  selection: Scalars['ID']['input'];
}>;


export type AttachedFilesWidgetGetSelectionQuery = { __typename?: 'Query', selection: { __typename?: 'SelectionQueries', getItems: Array<{ __typename?: 'ContentItem', itemId: string, contentType: AdditionalContentType, contentName: string, contentUrl: string }> } };

export type ExecutionConditionValueFragment = { __typename?: 'StudentEvaluationRuleValue', fieldId: string, fieldName?: string | null, fieldType: EvaluationRuleValueFieldType, subFieldKey?: string | null, subFieldName?: string | null, operator: string, valueWithDescription: Array<{ __typename?: 'KeyValue', key: string, value: string }>, projectRoutingInfo: Array<{ __typename?: 'KeyValue', key: string, value: string }> };

export type ExecutionConditionsFragment = { __typename?: 'StudentEvaluationRuleGroup', logicalOperatorId?: LogicalLinkTypeEnum | null, rulesInGroup: Array<{ __typename?: 'StudentEvaluationRule', logicalOperatorId?: LogicalLinkTypeEnum | null, value: { __typename?: 'StudentEvaluationRuleValue', fieldId: string, fieldName?: string | null, fieldType: EvaluationRuleValueFieldType, subFieldKey?: string | null, subFieldName?: string | null, operator: string, valueWithDescription: Array<{ __typename?: 'KeyValue', key: string, value: string }>, projectRoutingInfo: Array<{ __typename?: 'KeyValue', key: string, value: string }> } }> };

export type GetExecutionConditionsQueryVariables = Exact<{
  goalId: Scalars['ID']['input'];
}>;


export type GetExecutionConditionsQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', loadTaskEvaluationRules: Array<{ __typename?: 'StudentEvaluationRuleGroup', logicalOperatorId?: LogicalLinkTypeEnum | null, rulesInGroup: Array<{ __typename?: 'StudentEvaluationRule', logicalOperatorId?: LogicalLinkTypeEnum | null, value: { __typename?: 'StudentEvaluationRuleValue', fieldId: string, fieldName?: string | null, fieldType: EvaluationRuleValueFieldType, subFieldKey?: string | null, subFieldName?: string | null, operator: string, valueWithDescription: Array<{ __typename?: 'KeyValue', key: string, value: string }>, projectRoutingInfo: Array<{ __typename?: 'KeyValue', key: string, value: string }> } }> }> } | null };

export type GetProjectGitlabInfoQueryVariables = Exact<{
  answerId: Scalars['ID']['input'];
}>;


export type GetProjectGitlabInfoQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getPrivateGitlabProjectLinkInfoByAnswerId: { __typename?: 'GitlabLinksWithReadinessStatus', gitlabProjectId?: number | null, sshLink?: string | null, httpsLink?: string | null, status: GitlabProjectLinksReadyToUseStatus, hasOpenedMR?: boolean | null } } | null };

export type EvaluationFeedbackFragment = { __typename?: 'ReviewFeedback', id: string, comment: string, filledChecklist: { __typename?: 'FilledChecklist', id: string }, reviewFeedbackCategoryValues: Array<{ __typename?: 'ReviewFeedbackCategoryValue', feedbackCategory: FeedbackCategoryEnum, feedbackValue: FeedbackCategoryValueEnum, id: string } | null> };

export type ChecklistFragment = { __typename?: 'FilledChecklist', id: string, checklistId: string, endTimeCheck?: Date | null, startTimeCheck: Date, comment?: string | null, receivedPoint?: number | null, receivedPercentage?: number | null, quickAction?: QuickAction | null, checkType?: FilledChecklistCheckType | null, reviewer: { __typename?: 'User', avatarUrl: string, login?: string | null, businessAdminRoles?: Array<{ __typename?: 'BusinessAdminRole', id: string, school: { __typename?: 'SafeSchool', id: string, organizationType: string } }> | null }, reviewFeedback?: { __typename?: 'ReviewFeedback', id: string, comment: string, filledChecklist: { __typename?: 'FilledChecklist', id: string }, reviewFeedbackCategoryValues: Array<{ __typename?: 'ReviewFeedbackCategoryValue', feedbackCategory: FeedbackCategoryEnum, feedbackValue: FeedbackCategoryValueEnum, id: string } | null> } | null, onlineReview?: { __typename?: 'OnlineReview', isOnline: boolean, videos?: Array<{ __typename?: 'OnlineReviewVideo', onlineVideoId: string, link: string, status: StudyProcessFileStatusEnum, statusDetails?: string | null, updateDateTime: Date, fileSize: number }> | null } | null };

export type AttemptTeamMemberFragment = { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null };

export type P2PEvaluationFragment = { __typename?: 'P2PEvaluationInfo', status: ProjectEvaluationStatus, checklist?: { __typename?: 'FilledChecklist', id: string, checklistId: string, endTimeCheck?: Date | null, startTimeCheck: Date, comment?: string | null, receivedPoint?: number | null, receivedPercentage?: number | null, quickAction?: QuickAction | null, checkType?: FilledChecklistCheckType | null, reviewer: { __typename?: 'User', avatarUrl: string, login?: string | null, businessAdminRoles?: Array<{ __typename?: 'BusinessAdminRole', id: string, school: { __typename?: 'SafeSchool', id: string, organizationType: string } }> | null }, reviewFeedback?: { __typename?: 'ReviewFeedback', id: string, comment: string, filledChecklist: { __typename?: 'FilledChecklist', id: string }, reviewFeedbackCategoryValues: Array<{ __typename?: 'ReviewFeedbackCategoryValue', feedbackCategory: FeedbackCategoryEnum, feedbackValue: FeedbackCategoryValueEnum, id: string } | null> } | null, onlineReview?: { __typename?: 'OnlineReview', isOnline: boolean, videos?: Array<{ __typename?: 'OnlineReviewVideo', onlineVideoId: string, link: string, status: StudyProcessFileStatusEnum, statusDetails?: string | null, updateDateTime: Date, fileSize: number }> | null } | null } | null };

export type AttemptTeamWithMembersFragment = { __typename?: 'TeamWithMembers', team: { __typename?: 'Team', id: string, name: string }, members: Array<{ __typename?: 'TeamMember', role: TeamRole, user?: { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null } | null }> };

export type AtemptResultFragment = { __typename?: 'StudentGoalAttempt', finalPointProject: number, finalPercentageProject: number, resultModuleCompletion: ResultModuleCompletion, resultDate: Date };

export type ProjectAttemptEvaluations_V1Fragment = { __typename?: 'ProjectAttemptEvaluationsInfo_V1', studentAnswerId?: string | null, studentGoalAttemptId?: string | null, attemptStatus?: StudentGoalAttemptStatus | null, attemptResult?: { __typename?: 'StudentGoalAttempt', finalPointProject: number, finalPercentageProject: number, resultModuleCompletion: ResultModuleCompletion, resultDate: Date } | null, team?: { __typename?: 'TeamWithMembers', team: { __typename?: 'Team', id: string, name: string }, members: Array<{ __typename?: 'TeamMember', role: TeamRole, user?: { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null } | null }> } | null, p2p: Array<{ __typename?: 'P2PEvaluationInfo', status: ProjectEvaluationStatus, checklist?: { __typename?: 'FilledChecklist', id: string, checklistId: string, endTimeCheck?: Date | null, startTimeCheck: Date, comment?: string | null, receivedPoint?: number | null, receivedPercentage?: number | null, quickAction?: QuickAction | null, checkType?: FilledChecklistCheckType | null, reviewer: { __typename?: 'User', avatarUrl: string, login?: string | null, businessAdminRoles?: Array<{ __typename?: 'BusinessAdminRole', id: string, school: { __typename?: 'SafeSchool', id: string, organizationType: string } }> | null }, reviewFeedback?: { __typename?: 'ReviewFeedback', id: string, comment: string, filledChecklist: { __typename?: 'FilledChecklist', id: string }, reviewFeedbackCategoryValues: Array<{ __typename?: 'ReviewFeedbackCategoryValue', feedbackCategory: FeedbackCategoryEnum, feedbackValue: FeedbackCategoryValueEnum, id: string } | null> } | null, onlineReview?: { __typename?: 'OnlineReview', isOnline: boolean, videos?: Array<{ __typename?: 'OnlineReviewVideo', onlineVideoId: string, link: string, status: StudyProcessFileStatusEnum, statusDetails?: string | null, updateDateTime: Date, fileSize: number }> | null } | null } | null }>, auto: { __typename?: 'AutoEvaluationInfo', status: ProjectEvaluationStatus, receivedPercentage: number, endTimeCheck?: Date | null, resultInfo?: string | null }, codeReview: { __typename?: 'StudentCodeReviewResult', averageMark?: CodeReviewMark | null, studentCodeReviews: Array<{ __typename?: 'StudentCodeReview', finalMark?: boolean | null, markTime?: Date | null, reviewerCommentsCount?: number | null, user: { __typename?: 'User', avatarUrl: string, login?: string | null } }> } };

export type GetProjectAttemptEvaluationsInfoQueryVariables = Exact<{
  goalId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
}>;


export type GetProjectAttemptEvaluationsInfoQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getProjectAttemptEvaluationsInfo_V1: Array<{ __typename?: 'ProjectAttemptEvaluationsInfo_V1', studentAnswerId?: string | null, studentGoalAttemptId?: string | null, attemptStatus?: StudentGoalAttemptStatus | null, attemptResult?: { __typename?: 'StudentGoalAttempt', finalPointProject: number, finalPercentageProject: number, resultModuleCompletion: ResultModuleCompletion, resultDate: Date } | null, team?: { __typename?: 'TeamWithMembers', team: { __typename?: 'Team', id: string, name: string }, members: Array<{ __typename?: 'TeamMember', role: TeamRole, user?: { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null } | null }> } | null, p2p: Array<{ __typename?: 'P2PEvaluationInfo', status: ProjectEvaluationStatus, checklist?: { __typename?: 'FilledChecklist', id: string, checklistId: string, endTimeCheck?: Date | null, startTimeCheck: Date, comment?: string | null, receivedPoint?: number | null, receivedPercentage?: number | null, quickAction?: QuickAction | null, checkType?: FilledChecklistCheckType | null, reviewer: { __typename?: 'User', avatarUrl: string, login?: string | null, businessAdminRoles?: Array<{ __typename?: 'BusinessAdminRole', id: string, school: { __typename?: 'SafeSchool', id: string, organizationType: string } }> | null }, reviewFeedback?: { __typename?: 'ReviewFeedback', id: string, comment: string, filledChecklist: { __typename?: 'FilledChecklist', id: string }, reviewFeedbackCategoryValues: Array<{ __typename?: 'ReviewFeedbackCategoryValue', feedbackCategory: FeedbackCategoryEnum, feedbackValue: FeedbackCategoryValueEnum, id: string } | null> } | null, onlineReview?: { __typename?: 'OnlineReview', isOnline: boolean, videos?: Array<{ __typename?: 'OnlineReviewVideo', onlineVideoId: string, link: string, status: StudyProcessFileStatusEnum, statusDetails?: string | null, updateDateTime: Date, fileSize: number }> | null } | null } | null }>, auto: { __typename?: 'AutoEvaluationInfo', status: ProjectEvaluationStatus, receivedPercentage: number, endTimeCheck?: Date | null, resultInfo?: string | null }, codeReview: { __typename?: 'StudentCodeReviewResult', averageMark?: CodeReviewMark | null, studentCodeReviews: Array<{ __typename?: 'StudentCodeReview', finalMark?: boolean | null, markTime?: Date | null, reviewerCommentsCount?: number | null, user: { __typename?: 'User', avatarUrl: string, login?: string | null } }> } }> } | null };

export type CreateFeedbackOnEvaluationMutationVariables = Exact<{
  reviewFeedbackInput: ReviewFeedbackInput;
}>;


export type CreateFeedbackOnEvaluationMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', createReviewFeedback: { __typename?: 'ReviewFeedback', id: string, comment: string, filledChecklist: { __typename?: 'FilledChecklist', id: string }, reviewFeedbackCategoryValues: Array<{ __typename?: 'ReviewFeedbackCategoryValue', feedbackCategory: FeedbackCategoryEnum, feedbackValue: FeedbackCategoryValueEnum, id: string } | null> } } | null };

export type CurrentInternshipTaskInfoFragment = { __typename?: 'StudentTask', id: string, taskId: string, task: { __typename?: 'Task', id: string, assignmentType: TaskAssignmentEnum, taskSolutionType?: TaskSolutionTypeEnum | null, checkTypes: Array<TaskCheckEnum>, studentTaskAdditionalAttributes: { __typename?: 'StudentTaskAdditionalAttributes', cookiesCount: number, maxCodeReviewCount: number, codeReviewCost: number, ciCdMode: GitlabCiCdType } }, lastAnswer?: { __typename?: 'StudentAnswer', id: string } | null, teamSettings?: { __typename?: 'TeamSettings', teamCreateOption: TeamCreateOptionEnum, minAmountMember: number, maxAmountMember: number, enableSurrenderTeam?: boolean | null } | null };

export type TeamSettingsInfoFragment = { __typename?: 'TeamSettings', teamCreateOption: TeamCreateOptionEnum, minAmountMember: number, maxAmountMember: number, enableSurrenderTeam?: boolean | null };

export type StudentsCodeReviewFragment = { __typename?: 'StudentCodeReviewsWithCountRound', countRound1: number, countRound2: number, codeReviewsInfo?: { __typename?: 'CodeReviewChecksInfo', maxCodeReviewCount: number, codeReviewDuration: number, codeReviewCost: number } | null };

export type ModuleCoverInfoFragment = { __typename?: 'ModuleCoverInformation', isOwnStudentTimeline?: boolean | null, softSkills: Array<{ __typename?: 'SoftSkillPoint', softSkillId: number, softSkillName: string, totalPower: number, maxPower: number, currentUserPower: number, achievedUserPower?: number | null, teamRole?: TeamRole | null }>, timeline: Array<{ __typename?: 'ProjectTimelineItem', type: TimelineItemType, status: TimelineItemStatus, start?: Date | null, end?: Date | null, children?: Array<{ __typename?: 'ProjectTimelineItem', type: TimelineItemType, elementType?: TimelineElementEnum | null, status: TimelineItemStatus, start?: Date | null, end?: Date | null, order?: number | null } | null> | null }> };

export type ProjectInfoFragment = { __typename?: 'StudentModule', id: string, moduleTitle: string, finalPercentage?: number | null, finalPoint?: number | null, goalExecutionType?: ModuleExecutionType | null, displayedGoalStatus?: DisplayedGoalStatus | null, accessBeforeStartProgress?: boolean | null, resultModuleCompletion?: ResultModuleCompletion | null, finishedExecutionDateByScheduler?: Date | null, durationFromStageSubjectGroupPlan?: number | null, currentAttemptNumber?: number | null, isDeadlineFree?: boolean | null, isRetryAvailable: boolean, localCourseId?: string | null, courseBaseParameters?: { __typename?: 'CourseBaseParameters', isGradedCourse: boolean } | null, teamSettings?: { __typename?: 'TeamSettings', teamCreateOption: TeamCreateOptionEnum, minAmountMember: number, maxAmountMember: number, enableSurrenderTeam?: boolean | null } | null, studyModule: { __typename?: 'StudyModule', id: string, idea: string, duration: number, goalPoint?: number | null, retrySettings?: { __typename?: 'ModuleAttemptsSettings', maxModuleAttempts?: number | null, isUnlimitedAttempts: boolean } | null, levels: Array<{ __typename?: 'StudyModuleLevel', id: string, goalElements: Array<{ __typename?: 'StudyModuleGoalElement', id: string, tasks: Array<{ __typename?: 'Task', id: string, taskId: string }> }> }> }, currentTask?: { __typename?: 'StudentTask', id: string, taskId: string, task: { __typename?: 'Task', id: string, assignmentType: TaskAssignmentEnum, taskSolutionType?: TaskSolutionTypeEnum | null, checkTypes: Array<TaskCheckEnum>, studentTaskAdditionalAttributes: { __typename?: 'StudentTaskAdditionalAttributes', cookiesCount: number, maxCodeReviewCount: number, codeReviewCost: number, ciCdMode: GitlabCiCdType } }, lastAnswer?: { __typename?: 'StudentAnswer', id: string } | null, teamSettings?: { __typename?: 'TeamSettings', teamCreateOption: TeamCreateOptionEnum, minAmountMember: number, maxAmountMember: number, enableSurrenderTeam?: boolean | null } | null } | null };

export type GetProjectInfoQueryVariables = Exact<{
  goalId: Scalars['ID']['input'];
}>;


export type GetProjectInfoQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getModuleById: { __typename?: 'StudentModule', id: string, moduleTitle: string, finalPercentage?: number | null, finalPoint?: number | null, goalExecutionType?: ModuleExecutionType | null, displayedGoalStatus?: DisplayedGoalStatus | null, accessBeforeStartProgress?: boolean | null, resultModuleCompletion?: ResultModuleCompletion | null, finishedExecutionDateByScheduler?: Date | null, durationFromStageSubjectGroupPlan?: number | null, currentAttemptNumber?: number | null, isDeadlineFree?: boolean | null, isRetryAvailable: boolean, localCourseId?: string | null, courseBaseParameters?: { __typename?: 'CourseBaseParameters', isGradedCourse: boolean } | null, teamSettings?: { __typename?: 'TeamSettings', teamCreateOption: TeamCreateOptionEnum, minAmountMember: number, maxAmountMember: number, enableSurrenderTeam?: boolean | null } | null, studyModule: { __typename?: 'StudyModule', id: string, idea: string, duration: number, goalPoint?: number | null, retrySettings?: { __typename?: 'ModuleAttemptsSettings', maxModuleAttempts?: number | null, isUnlimitedAttempts: boolean } | null, levels: Array<{ __typename?: 'StudyModuleLevel', id: string, goalElements: Array<{ __typename?: 'StudyModuleGoalElement', id: string, tasks: Array<{ __typename?: 'Task', id: string, taskId: string }> }> }> }, currentTask?: { __typename?: 'StudentTask', id: string, taskId: string, task: { __typename?: 'Task', id: string, assignmentType: TaskAssignmentEnum, taskSolutionType?: TaskSolutionTypeEnum | null, checkTypes: Array<TaskCheckEnum>, studentTaskAdditionalAttributes: { __typename?: 'StudentTaskAdditionalAttributes', cookiesCount: number, maxCodeReviewCount: number, codeReviewCost: number, ciCdMode: GitlabCiCdType } }, lastAnswer?: { __typename?: 'StudentAnswer', id: string } | null, teamSettings?: { __typename?: 'TeamSettings', teamCreateOption: TeamCreateOptionEnum, minAmountMember: number, maxAmountMember: number, enableSurrenderTeam?: boolean | null } | null } | null }, getModuleCoverInformation?: { __typename?: 'ModuleCoverInformation', isOwnStudentTimeline?: boolean | null, softSkills: Array<{ __typename?: 'SoftSkillPoint', softSkillId: number, softSkillName: string, totalPower: number, maxPower: number, currentUserPower: number, achievedUserPower?: number | null, teamRole?: TeamRole | null }>, timeline: Array<{ __typename?: 'ProjectTimelineItem', type: TimelineItemType, status: TimelineItemStatus, start?: Date | null, end?: Date | null, children?: Array<{ __typename?: 'ProjectTimelineItem', type: TimelineItemType, elementType?: TimelineElementEnum | null, status: TimelineItemStatus, start?: Date | null, end?: Date | null, order?: number | null } | null> | null }> } | null, getP2PChecksInfo?: { __typename?: 'P2PChecksInfo', cookiesCount: number, periodOfVerification: number, projectReviewsInfo: { __typename?: 'ProjectReviewsInfo', reviewByStudentCount: number, relevantReviewByStudentsCount: number, reviewByInspectionStaffCount: number, relevantReviewByInspectionStaffCount: number } } | null, getStudentCodeReviewByGoalId: { __typename?: 'StudentCodeReviewsWithCountRound', countRound1: number, countRound2: number, codeReviewsInfo?: { __typename?: 'CodeReviewChecksInfo', maxCodeReviewCount: number, codeReviewDuration: number, codeReviewCost: number } | null } } | null };

export type MediatekaGetContentItemQueryVariables = Exact<{
  itemIds: Array<Scalars['ID']['input']> | Scalars['ID']['input'];
}>;


export type MediatekaGetContentItemQuery = { __typename?: 'Query', mediateka: { __typename?: 'MediatekaQueries', getContentItemsByIds: Array<{ __typename?: 'ContentItem', itemId: string, contentType: AdditionalContentType, contentName: string, contentAuthor?: string | null, contentUrl: string, subtitleLink?: string | null, description?: string | null, subtitleLinks?: Array<{ __typename?: 'SubtitleLinkForLanguage', languageCode: string, subtitleLink: string }> | null }> } };

export type GetStageInfoQueryVariables = Exact<{ [key: string]: never; }>;


export type GetStageInfoQuery = { __typename?: 'Query', user?: { __typename?: 'UserQueries', getCurrentUser: { __typename?: 'User', id: string, studentRoles?: Array<{ __typename?: 'StudentRole', status: RoleStatus, school: { __typename?: 'SafeSchool', organizationType: string }, stageGroup?: { __typename?: 'StageGroup', name: string, stage: number, isActive: boolean, classSubjects?: Array<{ __typename?: 'ClassSubject', stage: { __typename?: 'Stage', name: string } }> | null } | null }> | null }, getAllStagesTenantAware: Array<{ __typename?: 'Stage', id: string, name: string }> } | null };

export type OnlineReviewVideoInfoFragment = { __typename?: 'OnlineReviewVideo', onlineVideoId: string, link: string, status: StudyProcessFileStatusEnum, statusDetails?: string | null, updateDateTime: Date, fileSize: number };

export type MarkOnlineReviewVideoUploadedMutationVariables = Exact<{
  filledChecklistId: Scalars['ID']['input'];
  onlineReviewId: Scalars['ID']['input'];
}>;


export type MarkOnlineReviewVideoUploadedMutation = { __typename?: 'Mutation', school21?: { __typename?: 'School21Mutations', markP2pCheckVideoUploaded: { __typename?: 'OnlineReviewVideo', onlineVideoId: string, link: string, status: StudyProcessFileStatusEnum, statusDetails?: string | null, updateDateTime: Date, fileSize: number } } | null };

export type MarkFilesPendingMutationVariables = Exact<{
  filledChecklistId: Scalars['ID']['input'];
  pendingFiles: Array<StudyProcessFileInitialInput> | StudyProcessFileInitialInput;
}>;


export type MarkFilesPendingMutation = { __typename?: 'Mutation', school21?: { __typename?: 'School21Mutations', markFilesPending: Array<{ __typename?: 'OnlineReviewVideo', onlineVideoId: string, link: string, status: StudyProcessFileStatusEnum, statusDetails?: string | null, updateDateTime: Date, fileSize: number }> } | null };

export type MarkOnlineReviewVideoFailedToUploadMutationVariables = Exact<{
  filledChecklistId: Scalars['ID']['input'];
  onlineReviewId: Scalars['ID']['input'];
  errorMessage: Scalars['String']['input'];
}>;


export type MarkOnlineReviewVideoFailedToUploadMutation = { __typename?: 'Mutation', school21?: { __typename?: 'School21Mutations', markP2pCheckVideoFailedToUpload: { __typename?: 'OnlineReviewVideo', onlineVideoId: string, link: string, status: StudyProcessFileStatusEnum, statusDetails?: string | null, updateDateTime: Date, fileSize: number } } | null };

export type MarkOnlineReviewVideoUploadCancelledMutationVariables = Exact<{
  filledChecklistId: Scalars['ID']['input'];
  onlineReviewId: Scalars['ID']['input'];
}>;


export type MarkOnlineReviewVideoUploadCancelledMutation = { __typename?: 'Mutation', school21?: { __typename?: 'School21Mutations', markP2pCheckVideoUploadCancelled: { __typename?: 'OnlineReviewVideo', onlineVideoId: string, link: string, status: StudyProcessFileStatusEnum, statusDetails?: string | null, updateDateTime: Date, fileSize: number } } | null };

export type CapitulationFromTheCourseMutationVariables = Exact<{
  localCourseId: Scalars['ID']['input'];
}>;


export type CapitulationFromTheCourseMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', capitulationFromTheCourse: { __typename?: 'StudentCourseModel', finalPoint?: number | null } } | null };

export type FinishCourseMutationVariables = Exact<{
  localCourseId: Scalars['ID']['input'];
}>;


export type FinishCourseMutation = { __typename?: 'Mutation', course?: { __typename?: 'CourseMutations', finishCourse: boolean } | null };

export type RegistrationForTheCourseMutationVariables = Exact<{
  localCourseId: Scalars['ID']['input'];
}>;


export type RegistrationForTheCourseMutation = { __typename?: 'Mutation', course?: { __typename?: 'CourseMutations', registrationForTheCourse: { __typename?: 'StudentCourseModel', finalPoint?: number | null } } | null };

export type RetryCourseMutationVariables = Exact<{
  localCourseId: Scalars['ID']['input'];
}>;


export type RetryCourseMutation = { __typename?: 'Mutation', course?: { __typename?: 'CourseMutations', retryCourse?: boolean | null } | null };

export type CourseGoalsTypesFragment = { __typename?: 'LocalCourseGoalInformation', executionType: ModuleExecutionType };

export type GetCourseCoverInformationQueryVariables = Exact<{
  localCourseId: Scalars['ID']['input'];
}>;


export type GetCourseCoverInformationQuery = { __typename?: 'Query', course?: { __typename?: 'CourseQueries', getCourseCoverInformation: { __typename?: 'CourseCoverInformation', courseName: string, courseType: CourseType, courseStatus?: CourseStatus | null, displayedCourseStatus?: DisplayedCourseStatus | null, signUpEndDate?: Date | null, signUpStartDate?: Date | null, workStartDate?: Date | null, workEndDate?: Date | null, duration: number, courseDescription: string, finalPercentage: number, courseStatusesHistory: Array<CourseStatus>, experience: number, experienceFact?: number | null, currentStudentCount: number, retriesOfCurrentStudents: number, teamsWaitingEvaluationCount: number, finishedCount: number, retriesCount: number, resultCourseCompletion?: CompletionResultStatus | null, isRetryAvailable?: boolean | null, isCourseCanBeFinished?: boolean | null, softSkills: Array<{ __typename?: 'SoftSkillPoint', softSkillId: number, maxPower: number, currentUserPower: number, softSkillName: string, totalPower: number, teamRole?: TeamRole | null, achievedUserPower?: number | null }>, timeline: Array<{ __typename?: 'ProjectTimelineItem', type: TimelineItemType, status: TimelineItemStatus, start?: Date | null, end?: Date | null, children?: Array<{ __typename?: 'ProjectTimelineItem', type: TimelineItemType, elementType?: TimelineElementEnum | null, status: TimelineItemStatus, start?: Date | null, end?: Date | null, order?: number | null } | null> | null }> }, getCourseRetryInfo: { __typename?: 'StudentGoalRetryInfo', totalRetryValue: number, usedRetryCount: number, unlimitedAttempts: boolean }, getLocalCourseGoals: { __typename?: 'LocalCourseGoals', localCourseGoals?: Array<{ __typename?: 'LocalCourseGoalInformation', executionType: ModuleExecutionType }> | null } } | null };

export type GetCourseEvaluationRulesQueryVariables = Exact<{
  localCourseId: Scalars['ID']['input'];
}>;


export type GetCourseEvaluationRulesQuery = { __typename?: 'Query', course?: { __typename?: 'CourseQueries', loadCourseEvaluationRules: Array<{ __typename?: 'StudentEvaluationRuleGroup', logicalOperatorId?: LogicalLinkTypeEnum | null, rulesInGroup: Array<{ __typename?: 'StudentEvaluationRule', logicalOperatorId?: LogicalLinkTypeEnum | null, value: { __typename?: 'StudentEvaluationRuleValue', fieldId: string, fieldName?: string | null, fieldType: EvaluationRuleValueFieldType, subFieldKey?: string | null, subFieldName?: string | null, operator: string, valueWithDescription: Array<{ __typename?: 'KeyValue', key: string, value: string }>, projectRoutingInfo: Array<{ __typename?: 'KeyValue', key: string, value: string }> } }> }> } | null };

export type StudentGoalRetryInfoFragment = { __typename?: 'StudentGoalRetryInfo', totalRetryValue: number, usedRetryCount: number, unlimitedAttempts: boolean };

export type ModuleExamCoverInfoFragment = { __typename?: 'ModuleCoverInformation', timeline: Array<{ __typename?: 'ProjectTimelineItem', type: TimelineItemType, status: TimelineItemStatus, start?: Date | null, end?: Date | null, children?: Array<{ __typename?: 'ProjectTimelineItem', type: TimelineItemType, elementType?: TimelineElementEnum | null, status: TimelineItemStatus, start?: Date | null, end?: Date | null, order?: number | null } | null> | null }>, projectStatistics?: { __typename?: 'ProjectStatistics', registeredStudents: number, inProgressStudents: number, evaluationStudents: number, finishedStudents: number, acceptedStudents: number, failedStudents: number, retriedStudentsPercentage: number, groupProjectStatistics?: { __typename?: 'GroupProjectStatistics', inProgressTeams: number, evaluationTeams: number, finishedTeams: number, acceptedTeams: number, failedTeams: number } | null } | null, softSkills: Array<{ __typename?: 'SoftSkillPoint', softSkillId: number, maxPower: number, currentUserPower: number, softSkillName: string, totalPower: number, teamRole?: TeamRole | null, achievedUserPower?: number | null }> };

export type ExamInfoFragment = { __typename?: 'StudentModule', id: string, moduleTitle: string, displayedGoalStatus?: DisplayedGoalStatus | null, resultModuleCompletion?: ResultModuleCompletion | null, localCourseId?: string | null, finalPercentage?: number | null, finalPoint?: number | null, goalExecutionType?: ModuleExecutionType | null, isRetryAvailable: boolean, durationFromStageSubjectGroupPlan?: number | null, isDeadlineFree?: boolean | null, courseBaseParameters?: { __typename?: 'CourseBaseParameters', isGradedCourse: boolean } | null, studyModule: { __typename?: 'StudyModule', idea: string, duration: number, goalPoint?: number | null } };

export type GetExamInfoQueryVariables = Exact<{
  goalId: Scalars['ID']['input'];
}>;


export type GetExamInfoQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getModuleById: { __typename?: 'StudentModule', id: string, moduleTitle: string, displayedGoalStatus?: DisplayedGoalStatus | null, resultModuleCompletion?: ResultModuleCompletion | null, localCourseId?: string | null, finalPercentage?: number | null, finalPoint?: number | null, goalExecutionType?: ModuleExecutionType | null, isRetryAvailable: boolean, durationFromStageSubjectGroupPlan?: number | null, isDeadlineFree?: boolean | null, courseBaseParameters?: { __typename?: 'CourseBaseParameters', isGradedCourse: boolean } | null, studyModule: { __typename?: 'StudyModule', idea: string, duration: number, goalPoint?: number | null } }, getModuleCoverInformation?: { __typename?: 'ModuleCoverInformation', timeline: Array<{ __typename?: 'ProjectTimelineItem', type: TimelineItemType, status: TimelineItemStatus, start?: Date | null, end?: Date | null, children?: Array<{ __typename?: 'ProjectTimelineItem', type: TimelineItemType, elementType?: TimelineElementEnum | null, status: TimelineItemStatus, start?: Date | null, end?: Date | null, order?: number | null } | null> | null }>, projectStatistics?: { __typename?: 'ProjectStatistics', registeredStudents: number, inProgressStudents: number, evaluationStudents: number, finishedStudents: number, acceptedStudents: number, failedStudents: number, retriedStudentsPercentage: number, groupProjectStatistics?: { __typename?: 'GroupProjectStatistics', inProgressTeams: number, evaluationTeams: number, finishedTeams: number, acceptedTeams: number, failedTeams: number } | null } | null, softSkills: Array<{ __typename?: 'SoftSkillPoint', softSkillId: number, maxPower: number, currentUserPower: number, softSkillName: string, totalPower: number, teamRole?: TeamRole | null, achievedUserPower?: number | null }> } | null, getGoalRetryInfo: { __typename?: 'StudentGoalRetryInfo', totalRetryValue: number, usedRetryCount: number, unlimitedAttempts: boolean } } | null };

export type RegisterForExamMutationVariables = Exact<{
  goalId: Scalars['ID']['input'];
}>;


export type RegisterForExamMutation = { __typename?: 'Mutation', sc21ProjectFlow?: { __typename?: 'SC21ProjectFlowMutations', registerForExam: boolean } | null };

export type TryAgainExamModuleMutationVariables = Exact<{
  goalId: Scalars['ID']['input'];
}>;


export type TryAgainExamModuleMutation = { __typename?: 'Mutation', sc21ProjectFlow?: { __typename?: 'SC21ProjectFlowMutations', retryExam: boolean } | null };

export type TeamMemberInProjectPageFragment = { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null };

export type GetProjectTeamWithMembersQueryVariables = Exact<{
  goalId: Scalars['ID']['input'];
}>;


export type GetProjectTeamWithMembersQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getProjectTeamWithMembers?: { __typename?: 'ProjectTeamWithMembers', teamWithMembers: { __typename?: 'TeamWithMembers', team: { __typename?: 'Team', id: string, name: string, status: TeamStatusEnum, minTeamMemberCount: number, maxTeamMemberCount: number }, members: Array<{ __typename?: 'TeamMember', role: TeamRole, user?: { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null } | null }> }, invitedStudents: Array<{ __typename?: 'StudentInvitationInfo', student: { __typename?: 'Student', user: { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null } } }> } | null } | null };

export type GetIsDisbandRequestAlreadySentQueryVariables = Exact<{
  teamId: Scalars['UUID']['input'];
}>;


export type GetIsDisbandRequestAlreadySentQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', isRequestBeenSentToTeamDisband: boolean } | null };

export type DisbandAndFailMutationVariables = Exact<{
  taskId: Scalars['ID']['input'];
}>;


export type DisbandAndFailMutation = { __typename?: 'Mutation', sc21ProjectFlow?: { __typename?: 'SC21ProjectFlowMutations', surrenderFromProject: boolean } | null };

export type SendDisbandRequestMutationVariables = Exact<{
  teamId: Scalars['UUID']['input'];
  comment: Scalars['String']['input'];
  urlFileComment?: InputMaybe<Scalars['String']['input']>;
  goalId: Scalars['ID']['input'];
}>;


export type SendDisbandRequestMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', sendTeamDisbandRequest: UserDisbandRequestStatus } | null };

export type AvailableStudentForTeamFragment = { __typename?: 'Student', id: string, user: { __typename?: 'User', id: string, login?: string | null, avatarUrl: string, userExperience?: { __typename?: 'UserExperience', id: string, cookiesCount: number, codeReviewPoints: number, coinsCount: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', id: string, levelCode: number } } } | null } };

export type StudentInvitationInfoFragment = { __typename?: 'StudentInvitationInfo', invitationStatus: InvitationStatusEnum, schoolShortName?: string | null, student: { __typename?: 'Student', id: string, user: { __typename?: 'User', id: string, login?: string | null, avatarUrl: string, userExperience?: { __typename?: 'UserExperience', id: string, cookiesCount: number, codeReviewPoints: number, coinsCount: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', id: string, levelCode: number } } } | null } } };

export type GetAvailableStudentsForTeamsQueryVariables = Exact<{
  goalId: Scalars['ID']['input'];
}>;


export type GetAvailableStudentsForTeamsQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getAvailableStudentsForTeam: Array<{ __typename?: 'StudentInvitationInfo', invitationStatus: InvitationStatusEnum, schoolShortName?: string | null, student: { __typename?: 'Student', id: string, user: { __typename?: 'User', id: string, login?: string | null, avatarUrl: string, userExperience?: { __typename?: 'UserExperience', id: string, cookiesCount: number, codeReviewPoints: number, coinsCount: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', id: string, levelCode: number } } } | null } } }> } | null };

export type CancelInvitationMutationVariables = Exact<{
  teamId: Scalars['UUID']['input'];
  userId: Scalars['ID']['input'];
}>;


export type CancelInvitationMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', cancelInvitation: { __typename?: 'StudentInvitationInfo', invitationStatus: InvitationStatusEnum, schoolShortName?: string | null, student: { __typename?: 'Student', id: string, user: { __typename?: 'User', id: string, login?: string | null, avatarUrl: string, userExperience?: { __typename?: 'UserExperience', id: string, cookiesCount: number, codeReviewPoints: number, coinsCount: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', id: string, levelCode: number } } } | null } } } } | null };

export type SendInvitationMutationVariables = Exact<{
  teamId: Scalars['UUID']['input'];
  userId: Scalars['ID']['input'];
}>;


export type SendInvitationMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', sendInvitation: { __typename?: 'StudentInvitationInfo', invitationStatus: InvitationStatusEnum, schoolShortName?: string | null, student: { __typename?: 'Student', id: string, user: { __typename?: 'User', id: string, login?: string | null, avatarUrl: string, userExperience?: { __typename?: 'UserExperience', id: string, cookiesCount: number, codeReviewPoints: number, coinsCount: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', id: string, levelCode: number } } } | null } } } } | null };

export type ChangeProjectTeamNameMutationVariables = Exact<{
  teamId: Scalars['UUID']['input'];
  newName: Scalars['String']['input'];
}>;


export type ChangeProjectTeamNameMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', changeGroupName: string } | null };

export type LeaveAndDisbandTeamMutationVariables = Exact<{
  teamId: Scalars['UUID']['input'];
}>;


export type LeaveAndDisbandTeamMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', disbandTeam: boolean } | null };

export type LeaveTeamMutationVariables = Exact<{
  teamId: Scalars['UUID']['input'];
  exitReasonId?: InputMaybe<Scalars['Int']['input']>;
  exitReasonDescription?: InputMaybe<Scalars['String']['input']>;
}>;


export type LeaveTeamMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', exitStudentFromTeam: boolean } | null };

export type PartialStudyProcessFileFragment = { __typename?: 'StudyProcessFile', studyProcessFileId: string, link: string, status: StudyProcessFileStatusEnum };

export type GetPlatfSolutionQueryVariables = Exact<{
  studentGoalAttemptId: Scalars['ID']['input'];
}>;


export type GetPlatfSolutionQuery = { __typename?: 'Query', sc21StudentTaskCheck?: { __typename?: 'SC21StudentTaskCheckQueries', getPlatfSolutionInfo?: { __typename?: 'PlatfSolutionInfo', comment?: string | null, files: Array<{ __typename?: 'StudyProcessFile', studyProcessFileId: string, link: string, status: StudyProcessFileStatusEnum } | null> } | null } | null };

export type GetLinkToPrivateStudentGitlabProjectByAnswerIdQueryVariables = Exact<{
  answerId: Scalars['ID']['input'];
}>;


export type GetLinkToPrivateStudentGitlabProjectByAnswerIdQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getPrivateGitlabProjectLinkInfoByAnswerId: { __typename?: 'GitlabLinksWithReadinessStatus', httpsLink?: string | null, sshLink?: string | null, status: GitlabProjectLinksReadyToUseStatus } } | null };

export type GetProjectStatisticsQueryVariables = Exact<{
  goalId: Scalars['ID']['input'];
}>;


export type GetProjectStatisticsQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getProjectStatistics?: { __typename?: 'ProjectStatistics', registeredStudents: number, inProgressStudents: number, evaluationStudents: number, finishedStudents: number, acceptedStudents: number, failedStudents: number, retriedStudentsPercentage: number, groupProjectStatistics?: { __typename?: 'GroupProjectStatistics', inProgressTeams: number, evaluationTeams: number, finishedTeams: number, acceptedTeams: number, failedTeams: number } | null } | null } | null };

export type CheckCodeReviewPointsMutationVariables = Exact<{
  goalId: Scalars['ID']['input'];
}>;


export type CheckCodeReviewPointsMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', tryDecreaseCodeReviewPoints?: number | null } | null };

export type GetCodeReviewPointChargedOffQueryVariables = Exact<{
  goalId: Scalars['ID']['input'];
}>;


export type GetCodeReviewPointChargedOffQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getCodeReviewPointChargedOff: boolean } | null };

export type FinishProjectMutationVariables = Exact<{
  taskId: Scalars['ID']['input'];
}>;


export type FinishProjectMutation = { __typename?: 'Mutation', sc21ProjectFlow?: { __typename?: 'SC21ProjectFlowMutations', finishProject: Date } | null };

export type RegisterToProjectMutationVariables = Exact<{
  goalId: Scalars['ID']['input'];
}>;


export type RegisterToProjectMutation = { __typename?: 'Mutation', sc21ProjectFlow?: { __typename?: 'SC21ProjectFlowMutations', registerForProject: boolean } | null };

export type RetryCreatePrivateGitlabProjectMutationVariables = Exact<{
  studentAnswerId: Scalars['ID']['input'];
}>;


export type RetryCreatePrivateGitlabProjectMutation = { __typename?: 'Mutation', student?: { __typename?: 'StudentMutations', retryCreatePrivateGitlabProject: boolean } | null };

export type RetryProjectMutationVariables = Exact<{
  taskId: Scalars['ID']['input'];
}>;


export type RetryProjectMutation = { __typename?: 'Mutation', sc21ProjectFlow?: { __typename?: 'SC21ProjectFlowMutations', retryProject: boolean } | null };

export type StartProjectMutationVariables = Exact<{
  goalId: Scalars['ID']['input'];
}>;


export type StartProjectMutation = { __typename?: 'Mutation', sc21ProjectFlow?: { __typename?: 'SC21ProjectFlowMutations', startProject: boolean } | null };

export type PublicProfileGetAchievementsQueryVariables = Exact<{
  userId: Scalars['UUID']['input'];
}>;


export type PublicProfileGetAchievementsQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getBadgesPublicProfile: Array<{ __typename?: 'UserBadgeAward', points: number, id: string, badge: { __typename?: 'Badge', id: string, name: string, avatarUrl: string } }> } | null };

export type PublicProfileLoadAverageLogtimeQueryVariables = Exact<{
  login: Scalars['String']['input'];
  schoolID: Scalars['UUID']['input'];
  date: Scalars['Date']['input'];
}>;


export type PublicProfileLoadAverageLogtimeQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', loadAverageLogtime: { __typename?: 'AverageLogtime', week: number, month: number, weekPerMonth: number } } | null };

export type PublicProfileGetCoalitionQueryVariables = Exact<{
  userId: Scalars['UUID']['input'];
}>;


export type PublicProfileGetCoalitionQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getUserTournamentWidget: { __typename?: 'UserTournamentWidget', coalitionMember?: { __typename?: 'CoalitionMember', coalition: { __typename?: 'GameCoalition', avatarUrl: string, color: string, name: string, memberCount: number }, currentTournamentPowerRank?: { __typename?: 'CoalitionMemberPowerRank', rank: number, power: { __typename?: 'CoalitionMemberPower', id: string, points: number } } | null } | null, lastTournamentResult?: { __typename?: 'UserTournamentResult', userRank: number, power: number } | null } } | null };

export type PublicProfileGetCredentialsByLoginQueryVariables = Exact<{
  login: Scalars['String']['input'];
}>;


export type PublicProfileGetCredentialsByLoginQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getStudentByLogin?: { __typename?: 'StudentAttributes', studentId: string, userId: string, schoolId: string, isActive: boolean, isGraduate: boolean } | null } | null };

export type PublicProfileGetStudentTrafficQueryVariables = Exact<{
  login: Scalars['String']['input'];
  schoolID: Scalars['UUID']['input'];
  date: Scalars['Date']['input'];
}>;


export type PublicProfileGetStudentTrafficQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getStudentTraffic: { __typename?: 'StudentTraffic', endDate: Date, startDate: Date, days: Array<{ __typename?: 'DailyTraffic', date: Date, periodOnCampus: string, periodAuthorizSDP: string, periodAuthorizIMac: string }> } } | null };

export type PublicProfileGetPersonalInfoQueryVariables = Exact<{
  userId: Scalars['UUID']['input'];
  studentId: Scalars['UUID']['input'];
  login: Scalars['String']['input'];
  schoolId: Scalars['UUID']['input'];
}>;


export type PublicProfileGetPersonalInfoQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getAvatarByUserId?: string | null, getEmailbyUserId?: string | null, getStageGroupS21PublicProfile?: { __typename?: 'StageGroupS21', waveId: number, waveName: string, eduForm: string } | null, getExperiencePublicProfile?: { __typename?: 'UserExperience', value: number, cookiesCount: number, coinsCount: number, codeReviewPoints: number, isReviewPointsConsistent?: boolean | null, level: { __typename?: 'ExperienceLevel', levelCode: number, range: { __typename?: 'ExperienceLevelRange', leftBorder: number, rightBorder: number } } } | null, getClassRoomByLogin?: { __typename?: 'ClassRoom', id: string, number: string, floor: number } | null } | null, student?: { __typename?: 'StudentQueries', getWorkstationByLogin?: { __typename?: 'WorkstationModel', workstationId: number, hostName?: string | null, row?: string | null, number?: number | null } | null, getFeedbackStatisticsAverageScore: { __typename?: 'FeedbackStatisticsAverageScore', countFeedback: number, feedbackAverageScore?: Array<{ __typename?: 'FeedbackAverageScore', categoryCode?: string | null, categoryName?: string | null, value?: string | null } | null> | null } } | null, user?: { __typename?: 'UserQueries', getSchool: { __typename?: 'SafeSchool', id: string, fullName: string, shortName: string, address: string } } | null };

export type PublicProfileGetSoftSkillsQueryVariables = Exact<{
  studentId: Scalars['UUID']['input'];
}>;


export type PublicProfileGetSoftSkillsQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getSoftSkillsByStudentId: Array<{ __typename?: 'SoftSkillPower', id: string, type: string, code: string, totalPower: number, hueSaturationLightness: string }>, getSoftSkillLimitByStudentId: { __typename?: 'SoftSkillLimit', powerLimit?: number | null } } | null };

export type PublicProfileGetXpGraphQueryVariables = Exact<{
  userId: Scalars['UUID']['input'];
}>;


export type PublicProfileGetXpGraphQuery = { __typename?: 'Query', student?: { __typename?: 'StudentQueries', getExperienceHistoryDate: { __typename?: 'UserExperienceHistoryDate', history?: Array<{ __typename?: 'ExperienceHistoryDate', awardDate: Date, expValue: number } | null> | null } } | null };

export type GetCredentialsByLoginQueryVariables = Exact<{
  login: Scalars['String']['input'];
}>;


export type GetCredentialsByLoginQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getStudentByLogin?: { __typename?: 'StudentAttributes', studentId: string, userId: string, schoolId: string, isActive: boolean, isGraduate: boolean } | null } | null };

export type GetProfileUserQueryVariables = Exact<{
  userId: Scalars['UUID']['input'];
}>;


export type GetProfileUserQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getBasePublicProfile: { __typename?: 'BasePublicProfile', avatarUrl?: string | null, firstName: string, middleName?: string | null, lastName: string }, getExperiencePublicProfile?: { __typename?: 'UserExperience', id: string, cookiesCount: number, codeReviewPoints: number, coinsCount: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', id: string, levelCode: number } } } | null } | null };

export type ProjectAttemptEvaluationsFragment = { __typename?: 'ProjectAttemptEvaluationsInfo', studentAnswerId: string, attemptResult?: { __typename?: 'StudentGoalAttempt', finalPointProject: number, finalPercentageProject: number, resultModuleCompletion: ResultModuleCompletion, resultDate: Date } | null, team?: { __typename?: 'TeamWithMembers', team: { __typename?: 'Team', id: string, name: string }, members: Array<{ __typename?: 'TeamMember', role: TeamRole, user?: { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null } | null }> } | null, p2p: Array<{ __typename?: 'P2PEvaluationInfo', status: ProjectEvaluationStatus, checklist?: { __typename?: 'FilledChecklist', id: string, checklistId: string, endTimeCheck?: Date | null, startTimeCheck: Date, comment?: string | null, receivedPoint?: number | null, receivedPercentage?: number | null, quickAction?: QuickAction | null, checkType?: FilledChecklistCheckType | null, reviewer: { __typename?: 'User', avatarUrl: string, login?: string | null, businessAdminRoles?: Array<{ __typename?: 'BusinessAdminRole', id: string, school: { __typename?: 'SafeSchool', id: string, organizationType: string } }> | null }, reviewFeedback?: { __typename?: 'ReviewFeedback', id: string, comment: string, filledChecklist: { __typename?: 'FilledChecklist', id: string }, reviewFeedbackCategoryValues: Array<{ __typename?: 'ReviewFeedbackCategoryValue', feedbackCategory: FeedbackCategoryEnum, feedbackValue: FeedbackCategoryValueEnum, id: string } | null> } | null, onlineReview?: { __typename?: 'OnlineReview', isOnline: boolean, videos?: Array<{ __typename?: 'OnlineReviewVideo', onlineVideoId: string, link: string, status: StudyProcessFileStatusEnum, statusDetails?: string | null, updateDateTime: Date, fileSize: number }> | null } | null } | null }>, auto: { __typename?: 'AutoEvaluationInfo', status: ProjectEvaluationStatus, receivedPercentage: number, endTimeCheck?: Date | null, resultInfo?: string | null }, codeReview: { __typename?: 'StudentCodeReviewResult', averageMark?: CodeReviewMark | null, studentCodeReviews: Array<{ __typename?: 'StudentCodeReview', finalMark?: boolean | null, markTime?: Date | null, reviewerCommentsCount?: number | null, user: { __typename?: 'User', avatarUrl: string, login?: string | null } }> } };

export type GetProjectAttemptEvaluationsInfoByStudentQueryVariables = Exact<{
  goalId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
}>;


export type GetProjectAttemptEvaluationsInfoByStudentQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getProjectAttemptEvaluationsInfo: Array<{ __typename?: 'ProjectAttemptEvaluationsInfo', studentAnswerId: string, attemptResult?: { __typename?: 'StudentGoalAttempt', finalPointProject: number, finalPercentageProject: number, resultModuleCompletion: ResultModuleCompletion, resultDate: Date } | null, team?: { __typename?: 'TeamWithMembers', team: { __typename?: 'Team', id: string, name: string }, members: Array<{ __typename?: 'TeamMember', role: TeamRole, user?: { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null } | null }> } | null, p2p: Array<{ __typename?: 'P2PEvaluationInfo', status: ProjectEvaluationStatus, checklist?: { __typename?: 'FilledChecklist', id: string, checklistId: string, endTimeCheck?: Date | null, startTimeCheck: Date, comment?: string | null, receivedPoint?: number | null, receivedPercentage?: number | null, quickAction?: QuickAction | null, checkType?: FilledChecklistCheckType | null, reviewer: { __typename?: 'User', avatarUrl: string, login?: string | null, businessAdminRoles?: Array<{ __typename?: 'BusinessAdminRole', id: string, school: { __typename?: 'SafeSchool', id: string, organizationType: string } }> | null }, reviewFeedback?: { __typename?: 'ReviewFeedback', id: string, comment: string, filledChecklist: { __typename?: 'FilledChecklist', id: string }, reviewFeedbackCategoryValues: Array<{ __typename?: 'ReviewFeedbackCategoryValue', feedbackCategory: FeedbackCategoryEnum, feedbackValue: FeedbackCategoryValueEnum, id: string } | null> } | null, onlineReview?: { __typename?: 'OnlineReview', isOnline: boolean, videos?: Array<{ __typename?: 'OnlineReviewVideo', onlineVideoId: string, link: string, status: StudyProcessFileStatusEnum, statusDetails?: string | null, updateDateTime: Date, fileSize: number }> | null } | null } | null }>, auto: { __typename?: 'AutoEvaluationInfo', status: ProjectEvaluationStatus, receivedPercentage: number, endTimeCheck?: Date | null, resultInfo?: string | null }, codeReview: { __typename?: 'StudentCodeReviewResult', averageMark?: CodeReviewMark | null, studentCodeReviews: Array<{ __typename?: 'StudentCodeReview', finalMark?: boolean | null, markTime?: Date | null, reviewerCommentsCount?: number | null, user: { __typename?: 'User', avatarUrl: string, login?: string | null } }> } }> } | null };

export type GetProjectInfoByStudentQueryVariables = Exact<{
  goalId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
}>;


export type GetProjectInfoByStudentQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getModuleById: { __typename?: 'StudentModule', id: string, moduleTitle: string, finalPercentage?: number | null, finalPoint?: number | null, goalExecutionType?: ModuleExecutionType | null, displayedGoalStatus?: DisplayedGoalStatus | null, accessBeforeStartProgress?: boolean | null, resultModuleCompletion?: ResultModuleCompletion | null, finishedExecutionDateByScheduler?: Date | null, durationFromStageSubjectGroupPlan?: number | null, currentAttemptNumber?: number | null, isDeadlineFree?: boolean | null, isRetryAvailable: boolean, localCourseId?: string | null, courseBaseParameters?: { __typename?: 'CourseBaseParameters', isGradedCourse: boolean } | null, teamSettings?: { __typename?: 'TeamSettings', teamCreateOption: TeamCreateOptionEnum, minAmountMember: number, maxAmountMember: number, enableSurrenderTeam?: boolean | null } | null, studyModule: { __typename?: 'StudyModule', id: string, idea: string, duration: number, goalPoint?: number | null, retrySettings?: { __typename?: 'ModuleAttemptsSettings', maxModuleAttempts?: number | null, isUnlimitedAttempts: boolean } | null, levels: Array<{ __typename?: 'StudyModuleLevel', id: string, goalElements: Array<{ __typename?: 'StudyModuleGoalElement', id: string, tasks: Array<{ __typename?: 'Task', id: string, taskId: string }> }> }> }, currentTask?: { __typename?: 'StudentTask', id: string, taskId: string, task: { __typename?: 'Task', id: string, assignmentType: TaskAssignmentEnum, taskSolutionType?: TaskSolutionTypeEnum | null, checkTypes: Array<TaskCheckEnum>, studentTaskAdditionalAttributes: { __typename?: 'StudentTaskAdditionalAttributes', cookiesCount: number, maxCodeReviewCount: number, codeReviewCost: number, ciCdMode: GitlabCiCdType } }, lastAnswer?: { __typename?: 'StudentAnswer', id: string } | null, teamSettings?: { __typename?: 'TeamSettings', teamCreateOption: TeamCreateOptionEnum, minAmountMember: number, maxAmountMember: number, enableSurrenderTeam?: boolean | null } | null } | null }, getModuleCoverInformation?: { __typename?: 'ModuleCoverInformation', isOwnStudentTimeline?: boolean | null, softSkills: Array<{ __typename?: 'SoftSkillPoint', softSkillId: number, softSkillName: string, totalPower: number, maxPower: number, currentUserPower: number, achievedUserPower?: number | null, teamRole?: TeamRole | null }>, timeline: Array<{ __typename?: 'ProjectTimelineItem', type: TimelineItemType, status: TimelineItemStatus, start?: Date | null, end?: Date | null, children?: Array<{ __typename?: 'ProjectTimelineItem', type: TimelineItemType, elementType?: TimelineElementEnum | null, status: TimelineItemStatus, start?: Date | null, end?: Date | null, order?: number | null } | null> | null }> } | null, getP2PChecksInfo?: { __typename?: 'P2PChecksInfo', cookiesCount: number, periodOfVerification: number, projectReviewsInfo: { __typename?: 'ProjectReviewsInfo', reviewByStudentCount: number, relevantReviewByStudentsCount: number, reviewByInspectionStaffCount: number, relevantReviewByInspectionStaffCount: number } } | null, getGoalRetryInfo: { __typename?: 'StudentGoalRetryInfo', totalRetryValue: number, usedRetryCount: number, unlimitedAttempts: boolean } } | null };

export type TeamMemberWithRoleFragment = { __typename?: 'TeamMember', role: TeamRole, user?: { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null } | null };

export type TeamWithMembersFragment = { __typename?: 'ProjectTeamWithMembers', teamWithMembers: { __typename?: 'TeamWithMembers', team: { __typename?: 'Team', id: string, name: string, status: TeamStatusEnum, minTeamMemberCount: number, maxTeamMemberCount: number }, members: Array<{ __typename?: 'TeamMember', role: TeamRole, user?: { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null } | null }> }, invitedStudents: Array<{ __typename?: 'StudentInvitationInfo', student: { __typename?: 'Student', user: { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null } } }> };

export type GetProjectTeamWithMembersByStudentQueryVariables = Exact<{
  goalId: Scalars['ID']['input'];
  studentId: Scalars['UUID']['input'];
}>;


export type GetProjectTeamWithMembersByStudentQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getProjectTeamWithMembers?: { __typename?: 'ProjectTeamWithMembers', teamWithMembers: { __typename?: 'TeamWithMembers', team: { __typename?: 'Team', id: string, name: string, status: TeamStatusEnum, minTeamMemberCount: number, maxTeamMemberCount: number }, members: Array<{ __typename?: 'TeamMember', role: TeamRole, user?: { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null } | null }> }, invitedStudents: Array<{ __typename?: 'StudentInvitationInfo', student: { __typename?: 'Student', user: { __typename?: 'User', id: string, avatarUrl: string, login?: string | null, activeSchoolShortName?: string | null, userExperience?: { __typename?: 'UserExperience', cookiesCount: number, codeReviewPoints: number, level: { __typename?: 'ExperienceLevel', id: number, range: { __typename?: 'ExperienceLevelRange', levelCode: number } } } | null } } }> } | null } | null };

export type UserAchievementsFragment = { __typename?: 'UserBadgeAward', id: string, points: number, isFake: boolean, histories: Array<{ __typename?: 'UserAwardHistory', id: string, rewardDate: Date, awardPoints: number }>, badge: { __typename?: 'Badge', id: string, name: string, description: string, avatarUrl: string, bigAvatarUrl: string, kind: { __typename?: 'BadgeKind', id: number, name: string, order?: number | null } }, award: { __typename?: 'Award', id: string, awardCondition: { __typename?: 'AwardCondition', id: number, description: string }, awardBounties: Array<{ __typename?: 'AwardBounty', awardBountyId: string, description?: string | null, cookies: number, coins: number, experienceValue: number, coalitionPoints: number, softSkillPowers: Array<{ __typename?: 'AwardBountySoftSkillPower', softSkillId: number, power: number, softSkill: { __typename?: 'SoftSkillType', id: string, name: string } }> }> } };

export type BonusesGetBadgesWithFakePublicProfileQueryVariables = Exact<{
  userId?: InputMaybe<Scalars['UUID']['input']>;
}>;


export type BonusesGetBadgesWithFakePublicProfileQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getBadgesWithFakePublicProfile: Array<{ __typename?: 'UserBadgeAward', id: string, points: number, isFake: boolean, histories: Array<{ __typename?: 'UserAwardHistory', id: string, rewardDate: Date, awardPoints: number }>, badge: { __typename?: 'Badge', id: string, name: string, description: string, avatarUrl: string, bigAvatarUrl: string, kind: { __typename?: 'BadgeKind', id: number, name: string, order?: number | null } }, award: { __typename?: 'Award', id: string, awardCondition: { __typename?: 'AwardCondition', id: number, description: string }, awardBounties: Array<{ __typename?: 'AwardBounty', awardBountyId: string, description?: string | null, cookies: number, coins: number, experienceValue: number, coalitionPoints: number, softSkillPowers: Array<{ __typename?: 'AwardBountySoftSkillPower', softSkillId: number, power: number, softSkill: { __typename?: 'SoftSkillType', id: string, name: string } }> }> } }> } | null };

export type BonusesGetUserIdByLoginQueryVariables = Exact<{
  login: Scalars['String']['input'];
}>;


export type BonusesGetUserIdByLoginQuery = { __typename?: 'Query', school21?: { __typename?: 'School21Queries', getUserIdByLogin?: string | null } | null };
